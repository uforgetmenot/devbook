<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>blivet 存储管理学习笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="blivet-存储管理学习笔记"><a class="header" href="#blivet-存储管理学习笔记">blivet 存储管理学习笔记</a></h1>
<h2 id="学习定位与目标"><a class="header" href="#学习定位与目标">学习定位与目标</a></h2>
<ul>
<li><strong>学习者画像</strong>：拥有0-5年Linux系统或虚拟化平台经验，希望掌握Red Hat/CentOS/Fedora生态中blivet存储配置框架的系统运维、自动化部署与故障排查能力的工程师或DevOps。</li>
<li><strong>学习目标</strong>：理解blivet的架构与数据模型，熟练使用命令行与API完成磁盘配置、LVM/RAID管理、文件系统部署，并能在Anaconda/Kickstart安装场景中编写可靠的存储脚本。</li>
<li><strong>成果预期</strong>：能够独立规划复杂存储拓扑，产出可复用的Kickstart片段、Python自动化脚本、监控与校验清单，确保生产环境的可维护与可扩展。</li>
</ul>
<h2 id="知识结构总览"><a class="header" href="#知识结构总览">知识结构总览</a></h2>
<div class="table-wrapper"><table><thead><tr><th>模块</th><th>核心主题</th><th>典型输出</th><th>场景示例</th></tr></thead><tbody>
<tr><td>模块1 基础认知与架构</td><td>blivet项目背景、设计理念、组件关系</td><td>架构图、术语表</td><td>新人培训、系统规划</td></tr>
<tr><td>模块2 设备建模与生命周期</td><td>StorageData、DeviceTree、Device对象生命周期管理</td><td>设备拓扑文档、对象关系图</td><td>Anaconda安装流程分析</td></tr>
<tr><td>模块3 存储操作实践</td><td>物理卷/分区/LVM/RAID/VDO/文件系统等操作流程</td><td>CLI/脚本示例、操作手册</td><td>数据中心部署、虚拟化主机准备</td></tr>
<tr><td>模块4 自动化集成与API</td><td>blivet-python库、Kickstart语法、Anaconda插件</td><td>自动化脚本、CI校验流程</td><td>Auto install、裸金属配置</td></tr>
<tr><td>模块5 监控与故障排查</td><td>日志定位、状态校验、常见错误处理</td><td>故障分析流程、排错脚本</td><td>试产/量产部署异常</td></tr>
<tr><td>模块6 优化与最佳实践</td><td>性能调优、安全策略、与其他工具协同</td><td>调优清单、安全基线、集成方案</td><td>高可用/云平台运维</td></tr>
</tbody></table>
</div>
<blockquote>
<p>学习提示：建议结合虚拟机或裸机实验环境实践，每完成一个模块记录操作日志与脚本清单，逐步构建个人的存储模板库。</p>
</blockquote>
<h2 id="学习路径设计"><a class="header" href="#学习路径设计">学习路径设计</a></h2>
<h3 id="阶段1基础认知与环境准备1周"><a class="header" href="#阶段1基础认知与环境准备1周">阶段1：基础认知与环境准备（1周）</a></h3>
<ul>
<li><strong>目标</strong>：理解blivet的定位，准备实验环境与工具链。</li>
<li><strong>关键任务</strong>：
<ul>
<li>阅读blivet官方文档、Fedora与RHEL安装指南中的存储章节。</li>
<li>搭建实验环境：准备2台虚拟机（管理节点+目标节点）或使用KVM创建多磁盘虚拟机。</li>
<li>安装必要工具：<code>dnf install blivet-gui blivet-devtools pyparted</code>。</li>
<li>熟悉<code>blivet-gui</code>与<code>blivet-install</code>的基本界面和命令。</li>
</ul>
</li>
<li><strong>实践交付</strong>：完成基础环境搭建报告，列出实验磁盘信息与操作清单。</li>
</ul>
<h3 id="阶段2设备建模与核心数据结构1-2周"><a class="header" href="#阶段2设备建模与核心数据结构1-2周">阶段2：设备建模与核心数据结构（1-2周）</a></h3>
<ul>
<li><strong>目标</strong>：掌握blivet如何抽象磁盘、分区、卷组等对象。</li>
<li><strong>关键任务</strong>：
<ul>
<li>理解<code>DeviceTree</code>构建流程，分析<code>blivet/devices</code>模块的类层次。</li>
<li>使用Python交互式Shell加载blivet，遍历设备树，输出JSON。</li>
<li>掌握持久化标识（UUID、WWID、序列号）与udev规则的关联。</li>
</ul>
</li>
<li><strong>实践交付</strong>：产出设备拓扑图与对象说明笔记。</li>
</ul>
<h3 id="阶段3存储操作实战2-3周"><a class="header" href="#阶段3存储操作实战2-3周">阶段3：存储操作实战（2-3周）</a></h3>
<ul>
<li><strong>目标</strong>：运用blivet完成常见存储配置与变更。</li>
<li><strong>关键任务</strong>：
<ul>
<li>使用blivet创建GPT分区、LVM卷组与逻辑卷，格式化为XFS/ext4。</li>
<li>演练RAID、VDO、加密卷（LUKS）等高级功能。</li>
<li>编写可重复执行的Python脚本，将配置写入Kickstart片段。</li>
</ul>
</li>
<li><strong>实践交付</strong>：操作手册、脚本仓库（含执行日志与回滚步骤）。</li>
</ul>
<h3 id="阶段4自动化集成与安装定制2周"><a class="header" href="#阶段4自动化集成与安装定制2周">阶段4：自动化集成与安装定制（2周）</a></h3>
<ul>
<li><strong>目标</strong>：在自动化安装流程中稳健使用blivet。</li>
<li><strong>关键任务</strong>：
<ul>
<li>设计Kickstart <code>clearpart</code>, <code>part</code>, <code>logvol</code>, <code>raid</code>等语句组合。</li>
<li>利用<code>blivet</code> Python API对自定义设备执行预/后处理。</li>
<li>集成配置校验流程，使用CI对Kickstart脚本进行语法与逻辑检查。</li>
</ul>
</li>
<li><strong>实践交付</strong>：可用于批量部署的Kickstart模板与验证脚本。</li>
</ul>
<h3 id="阶段5运维监控与故障排查持续"><a class="header" href="#阶段5运维监控与故障排查持续">阶段5：运维监控与故障排查（持续）</a></h3>
<ul>
<li><strong>目标</strong>：建立监控、故障处理机制，确保生产稳定。</li>
<li><strong>关键任务</strong>：
<ul>
<li>解析Anaconda日志（<code>/tmp/anaconda.log</code>, <code>/tmp/storage.log</code>），建立故障知识库。</li>
<li>构建<code>blivet</code>状态检查脚本，定期验证存储器件与挂载状态。</li>
<li>总结常见错误（如<code>DeviceCreationError</code>, <code>FormatCreateError</code>）并制定应对策略。</li>
</ul>
</li>
<li><strong>实践交付</strong>：运维排错手册、巡检脚本、告警策略文档。</li>
</ul>
<h2 id="模块1基础认知与架构"><a class="header" href="#模块1基础认知与架构">模块1：基础认知与架构</a></h2>
<h3 id="11-blivet-项目概览"><a class="header" href="#11-blivet-项目概览">1.1 blivet 项目概览</a></h3>
<ul>
<li><strong>来源与发展</strong>：blivet是Red Hat工程团队为Anaconda安装器设计的Python存储抽象库，承载磁盘、卷、文件系统等对象的创建与管理。自RHEL 7起成为默认存储后端，取代了旧版<code>pykickstart</code>中零散的逻辑。</li>
<li><strong>应用场景</strong>：
<ul>
<li>Anaconda图形/文本安装过程中的自动磁盘分配。</li>
<li><code>blivet-gui</code>独立图形工具，用于安装后磁盘管理。</li>
<li>Kickstart自动化安装脚本的<code>%pre</code>/<code>%post</code>阶段。</li>
<li>第三方运维脚本在RHEL/CentOS中进行存储变更。</li>
</ul>
</li>
<li><strong>核心特性</strong>：
<ul>
<li>清晰的设备模型：支持磁盘、MD RAID、LVM、LUKS、Btrfs、VDO、Stratis等。</li>
<li>事务式操作：通过<code>StorageAction</code>封装待执行动作，可执行回滚与依赖解析。</li>
<li>与系统工具集成：基于<code>libblockdev</code>、<code>udev</code>、<code>parted</code>、<code>lvm2</code>、<code>mdadm</code>、<code>cryptsetup</code>等。</li>
</ul>
</li>
</ul>
<h3 id="12-架构组件"><a class="header" href="#12-架构组件">1.2 架构组件</a></h3>
<ul>
<li><strong>DeviceTree</strong>：存储拓扑的核心数据结构，解析系统现有设备并维护计划操作。</li>
<li><strong>Device</strong>类层次：<code>StorageDevice</code> → <code>DiskDevice</code> → <code>PartitionDevice</code> → <code>LVMVolumeGroup</code>/<code>LogicalVolume</code>等。</li>
<li><strong>Formats</strong>：文件系统与格式化操作抽象，如<code>Ext4FS</code>, <code>XFS</code>, <code>SwapSpace</code>, <code>LUKSFormat</code>。</li>
<li><strong>Actions</strong>：<code>CreateDeviceAction</code>, <code>FormatDeviceAction</code>, <code>ResizeDeviceAction</code>等具体执行步骤。</li>
<li><strong>blivet-gui</strong>：基于GTK的图形前端，可视化调用blivet API。</li>
</ul>
<h3 id="13-关键术语"><a class="header" href="#13-关键术语">1.3 关键术语</a></h3>
<div class="table-wrapper"><table><thead><tr><th>术语</th><th>含义</th><th>备注</th></tr></thead><tbody>
<tr><td>Device Tree</td><td>blivet内部表示的设备拓扑树</td><td>与系统真实设备同步，支持模拟操作</td></tr>
<tr><td>Action Queue</td><td>待执行操作队列，按依赖关系排序</td><td>支持预览与回滚</td></tr>
<tr><td>Target Devices</td><td>在Anaconda中规划安装的目标设备集合</td><td>由用户/脚本指定</td></tr>
<tr><td>Storage Configuration</td><td>配置集合，包含分区方案、格式、挂载点</td><td>Kickstart与UI共享</td></tr>
</tbody></table>
</div>
<h3 id="14-基础练习"><a class="header" href="#14-基础练习">1.4 基础练习</a></h3>
<ol>
<li>使用<code>python3 -m blivet.tests.print_config</code>输出当前设备树并分析各节点类型。</li>
<li>运行<code>blivet-gui</code>，观察新增、删除、格式化动作在动作队列中的表现。</li>
<li>对比<code>lsblk</code>, <code>lvs</code>, <code>mdadm --detail</code>等命令与blivet输出的一致性。</li>
</ol>
<h2 id="模块2设备建模与生命周期"><a class="header" href="#模块2设备建模与生命周期">模块2：设备建模与生命周期</a></h2>
<h3 id="21-devicetree-构建流程"><a class="header" href="#21-devicetree-构建流程">2.1 DeviceTree 构建流程</a></h3>
<ol>
<li><strong>探测阶段</strong>：调用<code>udev</code>与<code>libblockdev</code>枚举块设备，建立<code>DeviceTree</code>根节点。</li>
<li><strong>格式识别</strong>：读取分区表、LVM元数据、文件系统超级块，创建对应的<code>Device</code>实例。</li>
<li><strong>关系建立</strong>：为父子设备建立链接，如逻辑卷指向卷组，RAID阵列指向成员磁盘。</li>
<li><strong>动作注册</strong>：当用户规划新设备时，创建Action并添加到队列。</li>
</ol>
<h3 id="22-设备类型层次"><a class="header" href="#22-设备类型层次">2.2 设备类型层次</a></h3>
<pre><code class="language-text">Device (基类)
├── StorageDevice
│   ├── DiskDevice
│   │   ├── PartitionDevice
│   │   └── DMDevice (设备映射)
│   ├── LVMVolumeGroup
│   │   └── LogicalVolume
│   ├── MDRaidArrayDevice
│   ├── BTRFSVolumeDevice
│   ├── NFSDevice / FCoEDevice
│   └── LoopDevice
</code></pre>
<ul>
<li><strong>DiskDevice</strong>：表示物理或虚拟磁盘，支持<code>gpt</code>/<code>msdos</code>分区表。</li>
<li><strong>PartitionDevice</strong>：基于磁盘的分区对象，维护起止扇区、对齐、安全边界。</li>
<li><strong>LVMVolumeGroup</strong>：封装PV、VG属性，关联多个<code>LogicalVolume</code>。</li>
<li><strong>MDRaidArrayDevice</strong>：抽象软件RAID，支持级别0/1/4/5/6/10。</li>
<li><strong>DMDevice</strong>：设备映射层，包括LUKS、VDO、Multipath等。</li>
</ul>
<h3 id="23-设备生命周期"><a class="header" href="#23-设备生命周期">2.3 设备生命周期</a></h3>
<div class="table-wrapper"><table><thead><tr><th>阶段</th><th>说明</th><th>关键方法</th></tr></thead><tbody>
<tr><td>探测（Probing）</td><td>读取系统状态构建Device对象</td><td><code>Blivet.reset</code>, <code>DeviceTree.populate</code></td></tr>
<tr><td>规划（Planning）</td><td>添加/修改设备，生成Action</td><td><code>DeviceTree.newPartition</code>, <code>ActionQueue.addAction</code></td></tr>
<tr><td>执行（Execution）</td><td>调用系统工具执行</td><td><code>DeviceTree.apply</code></td></tr>
<tr><td>验证（Verification）</td><td>校验执行结果，刷新状态</td><td><code>DeviceTree.refresh</code>, <code>ActionQueue.clear</code></td></tr>
</tbody></table>
</div>
<h3 id="24-持久化标识与引用"><a class="header" href="#24-持久化标识与引用">2.4 持久化标识与引用</a></h3>
<ul>
<li>使用<code>udev</code>属性（<code>ID_SERIAL</code>, <code>ID_WWN</code>, <code>DM_UUID</code>）确保设备映射稳定。</li>
<li>Kickstart中可通过<code>--drives=sdX</code>或<code>--label</code>, <code>--uuid</code>指定目标设备。</li>
<li>推荐创建自定义规则文件 <code>/etc/udev/rules.d/99-storage.rules</code> 绑定别名。</li>
</ul>
<h3 id="25-实战案例枚举与过滤设备"><a class="header" href="#25-实战案例枚举与过滤设备">2.5 实战案例：枚举与过滤设备</a></h3>
<pre><code class="language-python">#!/usr/bin/python3
from blivet import Blivet
from blivet import util

b = Blivet()
b.reset()  # 探测系统
b.devicetree.populate()

# 输出所有可用磁盘
for disk in b.devicetree.disks:
    print(f"Disk: {disk.name}, Size: {disk.size.human_readable}, Serial: {disk.serial}")

# 过滤去除安装介质
install_device_paths = util.get_install_device_paths()
usable_disks = [d for d in b.devicetree.disks if d.path not in install_device_paths]

print("可用于部署的磁盘:")
for disk in usable_disks:
    print(f" - {disk.path}")
</code></pre>
<blockquote>
<p>练习：扩展脚本输出已有卷组、逻辑卷，并生成JSON供后续自动化使用。</p>
</blockquote>
<h2 id="模块3存储操作实践"><a class="header" href="#模块3存储操作实践">模块3：存储操作实践</a></h2>
<h3 id="31-分区与物理卷创建"><a class="header" href="#31-分区与物理卷创建">3.1 分区与物理卷创建</a></h3>
<h4 id="步骤"><a class="header" href="#步骤">步骤</a></h4>
<ol>
<li>识别目标磁盘：<code>/dev/sdb</code>。</li>
<li>创建GPT分区表：使用<code>blivet</code>的<code>PartitionDevice</code>接口。</li>
<li>创建两个分区：系统分区与数据分区。</li>
<li>对数据分区初始化LVM PV。</li>
</ol>
<h4 id="python脚本示例"><a class="header" href="#python脚本示例">Python脚本示例</a></h4>
<pre><code class="language-python">from blivet import Blivet
from blivet.size import Size
from blivet.devices import PartitionDevice
from blivet.formats import get_format

b = Blivet()
b.reset()
b.devicetree.populate()

disk = b.devicetree.get_device_by_name("sdb")
req1 = b.new_partition(size=Size("1 GiB"), parents=[disk])
req2 = b.new_partition(size=Size("50 GiB"), parents=[disk])

format_boot = get_format("xfs", mountpoint="/boot")
format_data = get_format("lvm2")

req1.format = format_boot
req2.format = format_data

b.create_device(req1)
b.create_device(req2)

# 应用操作
b.do_it()
</code></pre>
<blockquote>
<p>脚本执行后需通过<code>lsblk</code>验证分区，并将日志写入文件便于回溯。</p>
</blockquote>
<h3 id="32-lvm-管理"><a class="header" href="#32-lvm-管理">3.2 LVM 管理</a></h3>
<ul>
<li><strong>创建VG与LV</strong>：</li>
</ul>
<pre><code class="language-python">from blivet import Blivet
from blivet.size import Size

b = Blivet()
b.reset()
b.devicetree.populate()

pv = b.devicetree.get_device_by_name("sdb2")
vg = b.new_vg(name="vg_data", parents=[pv])

lv_root = b.new_lv(name="lv_root", parents=[vg], size=Size("20 GiB"))
lv_log = b.new_lv(name="lv_log", parents=[vg], size=Size("10 GiB"))

lv_root.format = b.get_format("xfs", mountpoint="/")
lv_log.format = b.get_format("xfs", mountpoint="/var/log")

b.create_device(vg)
b.create_device(lv_root)
b.create_device(lv_log)

b.do_it()
</code></pre>
<ul>
<li><strong>扩容流程</strong>：
<ol>
<li>新增物理磁盘并创建PV。</li>
<li>使用<code>vg.extend()</code>将新PV加入VG。</li>
<li>使用<code>lv.resize()</code>调整LV，随后<code>xfs_growfs</code>或<code>resize2fs</code>扩容文件系统。</li>
</ol>
</li>
</ul>
<h3 id="33-软件raid"><a class="header" href="#33-软件raid">3.3 软件RAID</a></h3>
<ul>
<li>在blivet中使用<code>b.new_mdarray()</code>创建RAID。</li>
<li>示例：创建RAID1镜像用于<code>/boot</code>。</li>
</ul>
<pre><code class="language-python">md = b.new_mdarray(name="md_boot", parents=[disk1_part, disk2_part],
                   level="raid1", size=Size("1 GiB"))
md.format = b.get_format("xfs", mountpoint="/boot")
</code></pre>
<ul>
<li>关键参数：<code>spares</code>, <code>chunk_size</code>，需与业务IO特性匹配。</li>
</ul>
<h3 id="34-高级功能"><a class="header" href="#34-高级功能">3.4 高级功能</a></h3>
<ul>
<li><strong>加密（LUKS）</strong>：
<ul>
<li>使用<code>LUKSFormat</code>对象，指定<code>passphrase</code>或<code>luks_version</code>。</li>
<li>支持与Anaconda <code>%pre</code>脚本结合，动态注入密钥文件。</li>
</ul>
</li>
<li><strong>VDO（压缩与去重）</strong>：
<ul>
<li>通过<code>DMDevice</code>类型<code>VDODevice</code>创建。</li>
<li>需要安装<code>vdo</code>软件包并启用内核模块。</li>
</ul>
</li>
<li><strong>Btrfs 子卷</strong>：
<ul>
<li><code>BTRFSVolumeDevice</code>支持多子卷、挂载选项设置。</li>
<li>Kickstart语法示例：
<pre><code class="language-kickstart">part btrfs.01 --fstype="btrfs" --size=10240
btrfs none --label=fedora-root btrfs.01
btrfs / --subvol --name=root LABEL=fedora-root
btrfs /home --subvol --name=home LABEL=fedora-root
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="35-操作复盘与日志"><a class="header" href="#35-操作复盘与日志">3.5 操作复盘与日志</a></h3>
<ul>
<li>每次执行<code>b.do_it()</code>后检查<code>/var/log/anaconda/storage.log</code>或自定义日志路径。</li>
<li>建议封装日志记录器：</li>
</ul>
<pre><code class="language-python">import logging
logging.basicConfig(filename="/var/log/blivet-ops.log", level=logging.INFO)
logging.info("Create LV: %s", lv_root.name)
</code></pre>
<ul>
<li>将日志与CMDB对接，保障运维审计。</li>
</ul>
<h2 id="模块4自动化集成与api"><a class="header" href="#模块4自动化集成与api">模块4：自动化集成与API</a></h2>
<h3 id="41-kickstart-存储语法回顾"><a class="header" href="#41-kickstart-存储语法回顾">4.1 Kickstart 存储语法回顾</a></h3>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>功能</th><th>核心参数</th></tr></thead><tbody>
<tr><td><code>clearpart</code></td><td>清理磁盘/分区</td><td><code>--all</code>, <code>--drives=</code>, <code>--initlabel</code>, <code>--list=</code></td></tr>
<tr><td><code>ignoredisk</code></td><td>忽略指定磁盘</td><td><code>--drives=</code>, <code>--only-use=</code></td></tr>
<tr><td><code>part</code></td><td>创建基础分区</td><td><code>--fstype=</code>, <code>--size=</code>, <code>--ondisk=</code>, <code>--grow</code></td></tr>
<tr><td><code>logvol</code></td><td>创建LVM逻辑卷</td><td><code>--vgname=</code>, <code>--size=</code>, <code>--name=</code>, <code>--percent=</code></td></tr>
<tr><td><code>raid</code></td><td>创建软件RAID</td><td><code>--level=</code>, <code>--device=</code>, <code>--spares=</code></td></tr>
<tr><td><code>volgroup</code></td><td>创建卷组</td><td><code>--pesize=</code></td></tr>
<tr><td><code>btrfs</code></td><td>创建Btrfs卷与子卷</td><td><code>--label=</code>, <code>--data=</code>, <code>--metadata=</code></td></tr>
</tbody></table>
</div>
<h3 id="42-kickstart-示例混合部署"><a class="header" href="#42-kickstart-示例混合部署">4.2 Kickstart 示例：混合部署</a></h3>
<pre><code class="language-kickstart"># 清理并初始化目标磁盘
ingenignoredisk --only-use=sda,sdb
clearpart --drives=sda,sdb --all --initlabel

# 基础分区
part /boot --fstype="xfs" --ondisk=sda --size=1024
part pv.01 --ondisk=sda --size=20480
part pv.02 --ondisk=sdb --size=20480

# 卷组与逻辑卷
volgroup vg_root pv.01 pv.02
logvol / --vgname=vg_root --size=16384 --name=lv_root --fstype=xfs
logvol /var --vgname=vg_root --size=8192 --name=lv_var --fstype=xfs
logvol swap --vgname=vg_root --size=2048 --name=lv_swap --fstype=swap

# RAID1 镜像用于重要日志
part raid.01 --ondisk=sda --size=8192
part raid.02 --ondisk=sdb --size=8192
raid /var/log --level=1 --device=md0 raid.01 raid.02 --fstype=xfs
</code></pre>
<blockquote>
<p>练习：扩展脚本添加VDO层或加密，编写<code>%pre</code>脚本根据磁盘容量自动调整尺寸。</p>
</blockquote>
<h3 id="43-python-api-自动化"><a class="header" href="#43-python-api-自动化">4.3 Python API 自动化</a></h3>
<ul>
<li>使用<code>blivet.autopart</code>包提供的分区方案模板。</li>
<li>示例：动态根据磁盘容量选择分区策略。</li>
</ul>
<pre><code class="language-python">from blivet import Blivet
from blivet.autopart import autopartition
from pykickstart.constants import CLEARPART_TYPE_ALL

b = Blivet()
b.reset()
b.devicetree.populate()

scheme = autopartition.AutoPartition(b)
opts = autopartition.AutoPartOptions()
opts.clearPartType = CLEARPART_TYPE_ALL
opts.mountpoints = ["/", "/var", "/home"]
opts.encrypted = True
opts.passphrase = "Sup3rSecret"

scheme.options = opts
scheme.execute()

b.do_it()
</code></pre>
<ul>
<li>将脚本嵌入到Kickstart <code>%pre --interpreter=/usr/bin/python3</code> 中，实现动态配置。</li>
</ul>
<h3 id="44-与ansibleforeman-集成"><a class="header" href="#44-与ansibleforeman-集成">4.4 与Ansible/Foreman 集成</a></h3>
<ul>
<li>Ansible模块：需自定义模块调用<code>blivet</code> API，或使用<code>community.general.lvol</code>等模块再结合blivet校验。</li>
<li>Foreman/Katello：通过Provisioning Template管理Kickstart片段，将blivet脚本作为<code>snippet</code>维护。</li>
<li>CI校验：使用<code>ksvalidator</code>保证语法正确，结合自建模拟环境执行<code>anaconda --kickstart</code> dry-run。</li>
</ul>
<h3 id="45-安装流程定制"><a class="header" href="#45-安装流程定制">4.5 安装流程定制</a></h3>
<ul>
<li>在<code>%pre</code>阶段检测磁盘并输出Kickstart变量：</li>
</ul>
<pre><code class="language-bash">%pre
lsblk -dn -o NAME,SIZE &gt; /tmp/disk.info
if [ $(awk '$2+0 &gt;= 200' /tmp/disk.info | wc -l) -lt 2 ]; then
  echo "缺少大于200G的磁盘，退出安装" &gt; /dev/tty3
  exit 1
fi
%end
</code></pre>
<ul>
<li>在<code>%post</code>阶段使用blivet刷新状态并写入CMDB。</li>
</ul>
<h2 id="模块5监控与故障排查"><a class="header" href="#模块5监控与故障排查">模块5：监控与故障排查</a></h2>
<h3 id="51-日志分析"><a class="header" href="#51-日志分析">5.1 日志分析</a></h3>
<ul>
<li>关注文件：
<ul>
<li><code>/tmp/anaconda.log</code>：安装器总体日志，含blivet调用栈。</li>
<li><code>/tmp/storage.log</code>：存储操作的详细日志与错误。</li>
<li><code>/tmp/program.log</code>：外部命令执行情况。</li>
</ul>
</li>
<li>常见错误：
<ul>
<li><code>DeviceTreeError</code>: 探测设备失败，检查udev/驱动。</li>
<li><code>StorageError</code>: 操作冲突或非法参数。</li>
<li><code>ActionCreateError</code>: 创建设备动作时前提未满足。</li>
</ul>
</li>
</ul>
<h3 id="52-状态校验脚本"><a class="header" href="#52-状态校验脚本">5.2 状态校验脚本</a></h3>
<pre><code class="language-python">#!/usr/bin/python3
from blivet import Blivet
from blivet.errors import StorageError

b = Blivet()
try:
    b.reset()
    b.devicetree.populate()
except StorageError as e:
    print(f"Storage initialisation failed: {e}")
    exit(1)

issues = []
for lv in b.devicetree.lvs:
    if lv.exists and not lv.status:
        issues.append(f"LV {lv.name} inactive")

for fs in b.devicetree.filesystems:
    if fs.mountable and not fs.is_mounted:
        issues.append(f"FS {fs.uuid} not mounted")

if issues:
    print("Detect issues:")
    for item in issues:
        print(" -", item)
else:
    print("All blivet devices healthy")
</code></pre>
<h3 id="53-故障排查流程"><a class="header" href="#53-故障排查流程">5.3 故障排查流程</a></h3>
<ol>
<li><strong>确认环境</strong>：检查驱动加载、磁盘识别，使用<code>udevadm info</code>确认属性。</li>
<li><strong>复现场景</strong>：重现安装步骤，收集日志与Kickstart。</li>
<li><strong>解析Action Queue</strong>：查看<code>storage.log</code>中Action队列顺序与依赖。</li>
<li><strong>验证系统状态</strong>：使用<code>lsblk</code>, <code>vgdisplay</code>, <code>cryptsetup status</code>等命令。</li>
<li><strong>制定修复计划</strong>：基于错误类型执行回滚或重建。</li>
</ol>
<h3 id="54-常见问题案例"><a class="header" href="#54-常见问题案例">5.4 常见问题案例</a></h3>
<ul>
<li><strong>案例A</strong>：LUKS卷创建失败
<ul>
<li>症状：<code>FormatCreateError: luksFormat failed</code>。</li>
<li>排查：确认<code>cryptsetup</code>版本、内核模块、密码复杂度，检查<code>entropy</code>不足。</li>
<li>解决：在Kickstart <code>%post</code>中安装<code>rng-tools</code>或在脚本中等待熵。</li>
</ul>
</li>
<li><strong>案例B</strong>：RAID同步后设备名称变化
<ul>
<li>排查：multipath/udev规则影响名称，引入<code>--device=</code>固定设备。</li>
<li>解决：自定义<code>/etc/udev/rules.d/</code>保持名称一致。</li>
</ul>
</li>
<li><strong>案例C</strong>：<code>b.do_it()</code>执行失败但部分设备已创建
<ul>
<li>处理：分析Action队列，手动移除/清理半成品设备，再重新运行脚本。</li>
<li>建议：启用blivet的<code>rollback</code>机制或先在虚拟机模拟。</li>
</ul>
</li>
</ul>
<h3 id="55-监控告警"><a class="header" href="#55-监控告警">5.5 监控告警</a></h3>
<ul>
<li>集成Prometheus：编写Exporter调用blivet API输出VG空闲空间、RAID状态。</li>
<li>设置告警阈值：VG 空闲 &lt; 10%，RAID 降级，LUKS未开启。</li>
<li>日志集中：将<code>/var/log/blivet-ops.log</code>发送至ELK/Graylog。</li>
</ul>
<h2 id="模块6优化与最佳实践"><a class="header" href="#模块6优化与最佳实践">模块6：优化与最佳实践</a></h2>
<h3 id="61-性能优化"><a class="header" href="#61-性能优化">6.1 性能优化</a></h3>
<ul>
<li><strong>IO模式匹配</strong>：
<ul>
<li>SSD与NVMe：充分利用LVM条带化、优化RAID chunk size。</li>
<li>HDD：避免过度分区，考虑使用RAID10提升随机IO。</li>
</ul>
</li>
<li><strong>文件系统选型</strong>：
<ul>
<li>XFS：适合大文件与日志，注意<code>reflink</code>, <code>crc</code>选项。</li>
<li>ext4：中小型系统，注意<code>lazyinit</code>, <code>64bit</code>参数。</li>
<li>Btrfs：需评估内核版本与稳定性。</li>
</ul>
</li>
<li><strong>缓存与分层</strong>：
<ul>
<li>结合<code>bcache</code>, <code>lvmcache</code>实现冷热数据分层。</li>
<li>使用blivet脚本自动化部署缓存设备。</li>
</ul>
</li>
</ul>
<h3 id="62-安全策略"><a class="header" href="#62-安全策略">6.2 安全策略</a></h3>
<ul>
<li>强制启用磁盘加密（LUKS），管理密钥：
<ul>
<li>使用TPM与Clevis绑定，Kickstart <code>--luks-options="tpm2"</code>。</li>
<li>管理密钥备份与轮换策略，定期审计。</li>
</ul>
</li>
<li>容量与权限管理：
<ul>
<li>建立<code>/var</code>, <code>/home</code>等目录的quota策略。</li>
<li>使用SELinux与auditd监控敏感操作。</li>
</ul>
</li>
</ul>
<h3 id="63-高可用与云环境"><a class="header" href="#63-高可用与云环境">6.3 高可用与云环境</a></h3>
<ul>
<li>与Pacemaker/Corosync集成：确保存储挂载脚本在Failover时调用blivet刷新。</li>
<li>KVM/虚拟化：
<ul>
<li>在OpenStack、oVirt中作为宿主机配置工具，结合<code>virt-install</code>使用Kickstart。</li>
<li>制定大规模部署模板，确保标准化。</li>
</ul>
</li>
<li>云平台：
<ul>
<li>在混合云中使用blivet脚本快速初始化裸金属节点，与Metal-as-a-Service (MAAS) 等系统对接。</li>
</ul>
</li>
</ul>
<h3 id="64-文档与版本管理"><a class="header" href="#64-文档与版本管理">6.4 文档与版本管理</a></h3>
<ul>
<li>所有Kickstart与Python脚本存入Git，按环境（dev/staging/prod）分支维护。</li>
<li>使用<code>pre-commit</code>钩子运行<code>ksvalidator</code>、<code>flake8</code>等检查。</li>
<li>建立变更评审流程，确保存储拓扑更新可追溯。</li>
</ul>
<h2 id="综合实战案例为虚拟化集群节点设计存储"><a class="header" href="#综合实战案例为虚拟化集群节点设计存储">综合实战案例：为虚拟化集群节点设计存储</a></h2>
<h3 id="背景"><a class="header" href="#背景">背景</a></h3>
<ul>
<li>场景：KVM虚拟化集群，节点需支持本地存储（Ceph缓存）、镜像仓库与日志分离。</li>
<li>环境：每台节点提供3块SSD（960G）与2块HDD（4T）。</li>
<li>目标：
<ul>
<li>SSD1：系统盘 + /var/log</li>
<li>SSD2 &amp; SSD3：组成RAID1作为Ceph OSD缓存</li>
<li>HDD1 &amp; HDD2：RAID1存放虚拟机镜像，部分LV用于备份</li>
</ul>
</li>
</ul>
<h3 id="设计步骤"><a class="header" href="#设计步骤">设计步骤</a></h3>
<ol>
<li><strong>初步规划</strong>：绘制架构图，确定每个分区与挂载点。</li>
<li><strong>Kickstart 编写</strong>：分区、卷组、RAID定义，使用变量控制大小。</li>
<li><strong>blivet Python 脚本</strong>：
<ul>
<li><code>%pre</code>阶段识别磁盘并排序。</li>
<li><code>%post</code>阶段创建监控脚本并写入crontab。</li>
</ul>
</li>
<li><strong>验证与回滚</strong>：
<ul>
<li>在虚拟机模拟执行，验证RAID同步与Ceph准备脚本。</li>
<li>提供回滚流程（停服务、卸载、清除元数据）。</li>
</ul>
</li>
</ol>
<h3 id="关键代码片段"><a class="header" href="#关键代码片段">关键代码片段</a></h3>
<pre><code class="language-python"># %pre 脚本片段
import json
from blivet import Blivet

b = Blivet()
b.reset(); b.devicetree.populate()

ssds = sorted([d for d in b.devicetree.disks if d.model.startswith("SSD")], key=lambda d: d.serial)
hdds = sorted([d for d in b.devicetree.disks if d.model.startswith("HDD")], key=lambda d: d.serial)

with open('/tmp/disk_map.json', 'w') as fp:
    json.dump({
        'ssd': [d.name for d in ssds],
        'hdd': [d.name for d in hdds]
    }, fp)
</code></pre>
<pre><code class="language-kickstart">%include /tmp/dynamic-storage.ks
</code></pre>
<ul>
<li>根据<code>disk_map.json</code>生成<code>dynamic-storage.ks</code>，实现自动映射。</li>
</ul>
<h2 id="常见错误与预防"><a class="header" href="#常见错误与预防">常见错误与预防</a></h2>
<div class="table-wrapper"><table><thead><tr><th>问题</th><th>触发场景</th><th>预防措施</th><th>解决步骤</th></tr></thead><tbody>
<tr><td>清盘导致误删数据</td><td><code>clearpart --all</code> 忽略了USB安装盘</td><td>使用<code>ignoredisk</code>排除安装介质</td><td>在<code>%pre</code>校验目标磁盘，记录日志</td></tr>
<tr><td>VG 名称冲突</td><td>Kickstart重复执行，旧VG未清理</td><td>执行<code>clearpart</code>并确保<code>--initlabel</code></td><td>手动清理VG <code>vgremove</code> 后重试</td></tr>
<tr><td>LVM 扩容失败</td><td>忘记执行<code>pvresize</code></td><td>执行扩容前校验PV空间</td><td>顺序：<code>pvresize</code> -&gt; <code>lvextend</code> -&gt; <code>xfs_growfs</code></td></tr>
<tr><td>RAID 重建慢</td><td>chunk size 不合理</td><td>根据磁盘类型选择合适chunk</td><td>使用<code>mdadm --grow --chunk</code>调整</td></tr>
<tr><td>VDO 性能下降</td><td>超出物理缓存</td><td>监控压缩比、使用<code>vdostats</code></td><td>扩展物理空间或调优逻辑卷</td></tr>
</tbody></table>
</div>
<h2 id="学习效果验证标准"><a class="header" href="#学习效果验证标准">学习效果验证标准</a></h2>
<ol>
<li><strong>配置交付准确率</strong>：在3次以内完成指定拓扑的Kickstart部署，存储布局与设计一致率≥98%。</li>
<li><strong>自动化脚本质量</strong>：Python脚本通过CI检查（flake8、pytest），并成功在至少两种硬件环境运行。</li>
<li><strong>故障排查能力</strong>：针对4种典型故障（LUKS失败、RAID降级、VG冲突、挂载失败）能在2小时内给出解决方案。</li>
<li><strong>性能优化落地</strong>：根据业务场景完成一次性能测试与调优，IO性能提升≥15%。</li>
<li><strong>文档与版本管理</strong>：所有存储变更有对应Git记录和评审记录，漏记率&lt;5%。</li>
</ol>
<h2 id="扩展资源与进阶建议"><a class="header" href="#扩展资源与进阶建议">扩展资源与进阶建议</a></h2>
<ul>
<li><strong>官方文档</strong>：
<ul>
<li><a href="https://github.com/storaged-project/blivet">blivet GitHub</a></li>
<li>RHEL 9 Storage Administration Guide</li>
<li>Fedora Installation Guide Storage Chapter</li>
</ul>
</li>
<li><strong>工具与库</strong>：
<ul>
<li><code>blivet-gui</code>, <code>storaged</code>/<code>udisks2</code>, <code>libblockdev</code></li>
<li><code>ksvalidator</code>, <code>pyparted</code></li>
</ul>
</li>
<li><strong>社区与培训</strong>：
<ul>
<li>Red Hat Training：RHCSA/RHCE存储章节</li>
<li>Fedora devel 邮件列表、Bugzilla存储组件</li>
<li>Linux storage 论坛与Slack社区</li>
</ul>
</li>
<li><strong>进阶方向</strong>：
<ul>
<li>探索<code>stratisd</code>与blivet集成</li>
<li>在RHEL CoreOS/Installer中自定义存储流程</li>
<li>开发blivet插件，扩展新硬件功能</li>
</ul>
</li>
</ul>
<h2 id="学习日志模板"><a class="header" href="#学习日志模板">学习日志模板</a></h2>
<pre><code class="language-markdown"># blivet 学习日志
日期：2024-03-12
阶段：模块3 存储操作

## 今日目标
- 使用blivet脚本创建LUKS+LVM结构。
- 验证Kickstart自动化片段。

## 进展记录
- 成功生成`dynamic-storage.ks`并在虚拟机测试通过。
- 遇到`DeviceTreeError`，原因是USB盘被识别为目标磁盘。

## 问题与解决
- 在`%pre`脚本中加入`ignoredisk`逻辑并记录日志，问题解决。

## 明日计划
- 完善日志采集脚本，接入Prometheus exporter。
</code></pre>
<h2 id="后续行动建议"><a class="header" href="#后续行动建议">后续行动建议</a></h2>
<ol>
<li>构建多场景实验（裸机/虚拟机/云平台），验证脚本兼容性。</li>
<li>结合企业CMDB，设计存储模板管理流程及审批制度。</li>
<li>对接监控系统，自动识别RAID降级、VG空间告警与异常。</li>
<li>关注blivet最新版本更新，评估新特性（如新文件系统支持）的引入路径。</li>
</ol>
<h2 id="模块3补充cli指令对照与流程详解"><a class="header" href="#模块3补充cli指令对照与流程详解">模块3补充：CLI指令对照与流程详解</a></h2>
<h3 id="3a-常用系统指令与blivet-api映射"><a class="header" href="#3a-常用系统指令与blivet-api映射">3.A 常用系统指令与blivet API映射</a></h3>
<div class="table-wrapper"><table><thead><tr><th>操作目标</th><th>系统命令</th><th>blivet API</th><th>备注</th></tr></thead><tbody>
<tr><td>查看磁盘与分区</td><td><code>lsblk -f</code>, <code>parted -l</code></td><td><code>b.devicetree.disks</code>, <code>b.devicetree.partitions</code></td><td>API返回<code>Device</code>对象，可访问<code>size</code>, <code>format</code>属性</td></tr>
<tr><td>创建分区表</td><td><code>parted /dev/sdb mklabel gpt</code></td><td><code>b.initializeDisk(disk, "gpt")</code></td><td>API会自动调用<code>parted</code>，并更新DeviceTree</td></tr>
<tr><td>创建LVM PV</td><td><code>pvcreate /dev/sdb2</code></td><td><code>b.new_partition(...).format = get_format("lvm2")</code></td><td>需在<code>b.do_it()</code>前设置格式</td></tr>
<tr><td>创建VG</td><td><code>vgcreate vg_data /dev/sdb2</code></td><td><code>b.new_vg(name, parents)</code></td><td><code>parents</code>列表引用PV设备</td></tr>
<tr><td>创建LV</td><td><code>lvcreate -L 20G -n lv_root vg_data</code></td><td><code>b.new_lv(name, parents, size)</code></td><td>支持<code>percent</code>参数</td></tr>
<tr><td>格式化文件系统</td><td><code>mkfs.xfs /dev/vg_data/lv_root</code></td><td><code>lv_root.format = get_format("xfs", mountpoint="/")</code></td><td><code>b.do_it()</code>时统一执行</td></tr>
<tr><td>调整LV大小</td><td><code>lvextend -L +10G /dev/vg_data/lv_root</code></td><td><code>b.resize_device(lv_root, Size("30 GiB"))</code></td><td>需要搭配文件系统扩容</td></tr>
<tr><td>删除分区</td><td><code>parted /dev/sdb rm 2</code></td><td><code>b.destroy_device(partition)</code></td><td>会加入Action队列</td></tr>
</tbody></table>
</div>
<blockquote>
<p>建议在学习过程中同时执行系统命令和blivet脚本，确认两者结果一致，帮助理解API与底层命令的对应关系。</p>
</blockquote>
<h3 id="3b-标准化操作流程"><a class="header" href="#3b-标准化操作流程">3.B 标准化操作流程</a></h3>
<ol>
<li><strong>需求分析</strong>：明确目标挂载点、容量、冗余等级、加密需求。</li>
<li><strong>环境检查</strong>：
<ul>
<li><code>lsblk -o NAME,TYPE,SIZE,MOUNTPOINT</code>确认磁盘状态。</li>
<li><code>vgs</code>, <code>lvs</code>, <code>mdadm --detail --scan</code>检查现有逻辑卷与RAID。</li>
</ul>
</li>
<li><strong>安全快照</strong>：必要时利用快照或备份，防止操作失误。</li>
<li><strong>规划脚本</strong>：在Python脚本或Kickstart中按块编写操作，加入<code>try/except</code>错误处理。</li>
<li><strong>模拟执行</strong>：在<code>b.do_it()</code>前调用<code>b.actions</code>预览队列，确保顺序正确。</li>
<li><strong>正式执行</strong>：<code>b.do_it()</code>执行后，记录日志并核对结果。</li>
<li><strong>验证与回滚准备</strong>：
<ul>
<li>验证挂载：<code>mount | grep target</code>。</li>
<li>校验文件系统：<code>xfs_repair -n</code>, <code>e2fsck -f</code> (谨慎使用)。</li>
<li>预留回滚脚本：逆向操作或<code>vgremove</code>, <code>mdadm --stop</code>等。</li>
</ul>
</li>
</ol>
<h3 id="3c-操作模板库"><a class="header" href="#3c-操作模板库">3.C 操作模板库</a></h3>
<ul>
<li><strong>模板1：系统盘与数据盘分离</strong></li>
</ul>
<pre><code class="language-python">from blivet import Blivet
from blivet.size import Size
b = Blivet()
b.reset(); b.devicetree.populate()

disk_sys = b.devicetree.get_device_by_path("/dev/sda")
disk_data = b.devicetree.get_device_by_path("/dev/sdb")

root_part = b.new_partition(size=Size("2 GiB"), parents=[disk_sys])
root_part.format = b.get_format("xfs", mountpoint="/boot")

pv_sys = b.new_partition(size=Size("100 GiB"), parents=[disk_sys])
pv_sys.format = b.get_format("lvm2")

vg_sys = b.new_vg(name="vg_sys", parents=[pv_sys])
root_lv = b.new_lv(name="lv_root", parents=[vg_sys], size=Size("80 GiB"))
root_lv.format = b.get_format("xfs", mountpoint="/")

pv_data = b.new_partition(size=Size("500 GiB"), parents=[disk_data])
pv_data.format = b.get_format("lvm2")
vg_data = b.new_vg(name="vg_data", parents=[pv_data])
log_lv = b.new_lv(name="lv_log", parents=[vg_data], size=Size("200 GiB"))
log_lv.format = b.get_format("xfs", mountpoint="/var/log")

for req in [root_part, pv_sys, root_lv, pv_data, log_lv]:
    b.create_device(req)

b.do_it()
</code></pre>
<ul>
<li><strong>模板2：LUKS + RAID + LVM 复合结构</strong>，用于高安全场景。可根据需求调整RAID等级与加密参数。</li>
</ul>
<h3 id="3d-常见错误情境演练"><a class="header" href="#3d-常见错误情境演练">3.D 常见错误情境演练</a></h3>
<div class="table-wrapper"><table><thead><tr><th>场景</th><th>预期行为</th><th>实际错误</th><th>原因分析</th><th>修复措施</th></tr></thead><tbody>
<tr><td>运行<code>b.new_partition</code>后未执行<code>b.create_device</code></td><td>生成Action并在<code>b.do_it</code>生效</td><td>分区未创建</td><td>忘记调用<code>create_device</code></td><td>在循环中统一<code>create_device</code>；或直接使用<code>b.create_device(b.new_partition(...))</code></td></tr>
<tr><td><code>FormatCreateError: mkfs.xfs</code>失败</td><td>格式化完成</td><td>命令返回非零</td><td>缺少<code>xfsprogs</code>或目标设备已挂载</td><td>安装依赖或先卸载设备后重试</td></tr>
<tr><td><code>DeviceRemovalError</code></td><td>删除指定分区</td><td>抛出异常</td><td>设备被占用（挂载、LVM引用）</td><td>先卸载并清理依赖，调用<code>b.destroy_device</code>时确保顺序</td></tr>
<tr><td><code>StorageError: disk contains partitions</code></td><td>初始化磁盘</td><td><code>initializeDisk</code>失败</td><td>尚有活动分区</td><td>先调用<code>clearpart</code>逻辑或逐个删除分区</td></tr>
</tbody></table>
</div>
<h3 id="3e-自动化回滚策略"><a class="header" href="#3e-自动化回滚策略">3.E 自动化回滚策略</a></h3>
<ul>
<li>在执行前导出当前设备树：</li>
</ul>
<pre><code class="language-python">with open('/var/tmp/devicetree-before.json', 'w') as fh:
    fh.write(b.devicetree.to_json())
</code></pre>
<ul>
<li>若执行失败，可根据导出的JSON恢复：
<ol>
<li>解析JSON，找到新增的逻辑卷或分区。</li>
<li>使用<code>blivet</code>或命令行逐个删除。</li>
<li>重新<code>b.reset()</code>并检查状态。</li>
</ol>
</li>
<li>对于LVM扩容操作，可先使用<code>--test</code>模式模拟：<code>lvextend --test</code>，确认无误后执行实际扩容。</li>
</ul>
<h2 id="模块4补充自动化与集成细节"><a class="header" href="#模块4补充自动化与集成细节">模块4补充：自动化与集成细节</a></h2>
<h3 id="4a-kickstart参数速查"><a class="header" href="#4a-kickstart参数速查">4.A Kickstart参数速查</a></h3>
<div class="table-wrapper"><table><thead><tr><th>指令</th><th>常用组合</th><th>注意事项</th></tr></thead><tbody>
<tr><td><code>clearpart</code></td><td><code>clearpart --all --initlabel</code></td><td>强制清除所有分区，务必在<code>ignoredisk</code>之后使用</td></tr>
<tr><td><code>ignoredisk</code></td><td><code>ignoredisk --only-use=sda,sdb</code></td><td>在多磁盘环境排除USB或SD卡</td></tr>
<tr><td><code>part</code></td><td><code>part /boot --fstype=xfs --size=1024 --ondisk=sda</code></td><td><code>--size</code>单位为MiB，<code>--grow</code>允许自动扩张</td></tr>
<tr><td><code>volgroup</code></td><td><code>volgroup vg_data pv.01 pv.02 --pesize=4096</code></td><td><code>--pesize</code>默认4096KiB，根据阵列类型调整</td></tr>
<tr><td><code>logvol</code></td><td><code>logvol /var --vgname=vg_data --size=8192 --name=lv_var --fstype=xfs</code></td><td>可搭配<code>--percent=50</code>占用VG百分比</td></tr>
<tr><td><code>raid</code></td><td><code>raid /srv --fstype=xfs --device=md0 --level=10 raid.01 raid.02 raid.03 raid.04</code></td><td>RAID10至少4个成员，可添加<code>--spares=</code></td></tr>
<tr><td><code>btrfs</code></td><td><code>btrfs / --subvol --name=root LABEL=system</code></td><td>子卷必须先定义主卷</td></tr>
<tr><td><code>autopart</code></td><td><code>autopart --type=lvm --fstype=xfs --encrypted</code></td><td>系统根据预设策略生成布局</td></tr>
</tbody></table>
</div>
<h3 id="4b-kickstart-片段化管理"><a class="header" href="#4b-kickstart-片段化管理">4.B Kickstart 片段化管理</a></h3>
<pre><code class="language-kickstart">%include /kickstarts/common/ignoredisk.ks
%include /kickstarts/common/clearpart.ks
%include /kickstarts/roles/compute/storage.ks
</code></pre>
<ul>
<li>将通用片段（ignoredisk、clearpart、logging）与角色特定片段分离，有助于版本控制。</li>
<li>片段中可使用变量，例如在<code>%pre</code>生成：</li>
</ul>
<pre><code class="language-bash">%pre --interpreter=/bin/bash
TOTAL_DISK=$(lsblk -dn -o SIZE /dev/sda | awk '{print $1}')
if (( ${TOTAL_DISK%%.*} &lt; 400 )); then
  echo "part pv.01 --ondisk=sda --size=102400" &gt; /tmp/storage.ks
else
  echo "part pv.01 --ondisk=sda --size=204800" &gt; /tmp/storage.ks
fi
%end
%include /tmp/storage.ks
</code></pre>
<h3 id="4c-python-api-深度实践"><a class="header" href="#4c-python-api-深度实践">4.C Python API 深度实践</a></h3>
<h4 id="4c1-action-队列检查"><a class="header" href="#4c1-action-队列检查">4.C.1 Action 队列检查</a></h4>
<pre><code class="language-python">for action in b.actions:
    print(action)
</code></pre>
<ul>
<li><code>CreateDeviceAction</code>, <code>CreateFormatAction</code>, <code>ResizeDeviceAction</code>等均有<code>requires</code>属性，表示依赖关系。</li>
<li>在自动化脚本中，可对<code>action.is_ready()</code>进行检测，确保所有前置条件满足。</li>
</ul>
<h4 id="4c2-自定义过滤器"><a class="header" href="#4c2-自定义过滤器">4.C.2 自定义过滤器</a></h4>
<pre><code class="language-python">def filter_disks(dev):
    return dev.size &gt;= Size("100 GiB") and dev.serial not in blacklist

usable = list(filter(filter_disks, b.devicetree.disks))
</code></pre>
<ul>
<li>通过函数过滤可用磁盘，结合<code>blacklist</code>或<code>whitelist</code>实现精细控制。</li>
</ul>
<h4 id="4c3-与libblockdev交互"><a class="header" href="#4c3-与libblockdev交互">4.C.3 与libblockdev交互</a></h4>
<pre><code class="language-python">from blivet import Blivet
from blivet import util

util.run_program(['udevadm', 'settle'])
</code></pre>
<ul>
<li>在执行流程中加入<code>udevadm settle</code>确保设备节点稳定。</li>
<li><code>util.run_program</code>提供统一的命令执行接口，返回值及stderr可用于日志记录。</li>
</ul>
<h3 id="4d-cicd-流程示例"><a class="header" href="#4d-cicd-流程示例">4.D CI/CD 流程示例</a></h3>
<ol>
<li><strong>仓库结构</strong>：</li>
</ol>
<pre><code>storage/
├── kickstarts/
│   ├── common/
│   └── roles/
├── scripts/
│   ├── blivet/
│   └── tests/
└── ci/
    └── pipeline.yml
</code></pre>
<ol start="2">
<li><strong>CI步骤</strong>：
<ul>
<li><code>lint</code>: 运行<code>ksvalidator</code>, <code>yamllint</code>, <code>flake8</code>。</li>
<li><code>unit-test</code>: 使用<code>pytest</code>模拟<code>blivet</code>脚本逻辑（通过<code>unittest.mock</code>模拟设备树）。</li>
<li><code>integration-test</code>: 在CI中启动虚拟机（libvirt/KVM），通过<code>virt-install --location=... --extra-args="inst.ks=..."</code>进行无人值守安装，验证Kickstart。</li>
<li><code>report</code>: 输出存储布局截图（<code>lsblk</code>结果）与日志归档。</li>
</ul>
</li>
</ol>
<h3 id="4e-与ansible集成手册"><a class="header" href="#4e-与ansible集成手册">4.E 与Ansible集成手册</a></h3>
<ul>
<li><strong>方案一：调用blivet脚本</strong></li>
</ul>
<pre><code class="language-yaml">- name: Deploy storage layout
  ansible.builtin.copy:
    src: scripts/blivet/setup.py
    dest: /usr/local/bin/setup-storage.py
    mode: '0755'
- name: Execute storage plan
  ansible.builtin.command: /usr/local/bin/setup-storage.py
  register: storage_result
  failed_when: storage_result.rc != 0
</code></pre>
<ul>
<li><strong>方案二：使用现有模块</strong>
<ul>
<li><code>community.general.parted</code></li>
<li><code>community.general.lvol</code></li>
<li><code>community.general.lvg</code></li>
<li><code>ansible.builtin.command</code>结合<code>blivet</code>校验脚本</li>
</ul>
</li>
<li><strong>校验步骤</strong>：</li>
</ul>
<pre><code class="language-yaml">- name: Validate storage layout
  ansible.builtin.command: /usr/local/bin/check-storage.py
  register: check_result
- name: Fail when validation failed
  ansible.builtin.fail:
    msg: "Storage validation failed: {{ check_result.stderr }}"
  when: check_result.rc != 0
</code></pre>
<h2 id="模块5补充日志样本与故障剧本"><a class="header" href="#模块5补充日志样本与故障剧本">模块5补充：日志样本与故障剧本</a></h2>
<h3 id="5a-日志解析案例"><a class="header" href="#5a-日志解析案例">5.A 日志解析案例</a></h3>
<pre><code class="language-text">07:11:12,829 INFO blivet: adding device sdb of type DiskDevice
07:11:12,833 INFO blivet: formatting device sdb1 as xfs
07:11:12,910 ERROR blivet: device sdb1 is mounted, cannot format
Traceback (most recent call last):
  File "/usr/lib/python3.11/site-packages/blivet/formats/fs.py", line 251, in create
    util.run_program(self.create_command)
  File "/usr/lib/python3.11/site-packages/blivet/util.py", line 297, in run_program
    raise errors.RunProgramError(command=command, return_code=rc)
blivet.errors.RunProgramError: xfsprogs returned 32
</code></pre>
<ul>
<li><strong>诊断</strong>：<code>/var/log/messages</code>中可查到<code>mount</code>记录。执行<code>umount /dev/sdb1</code>并重新运行。</li>
</ul>
<h3 id="5b-故障剧本设计"><a class="header" href="#5b-故障剧本设计">5.B 故障剧本设计</a></h3>
<div class="table-wrapper"><table><thead><tr><th>剧本编号</th><th>故障描述</th><th>触发方式</th><th>期望输出</th><th>练习目标</th></tr></thead><tbody>
<tr><td>P1</td><td>Kickstart 忽略了安装盘导致清盘失败</td><td>在<code>ignoredisk</code>中遗漏<code>vda</code></td><td>安装失败，日志提示目标磁盘忙</td><td>训练磁盘筛选与日志定位</td></tr>
<tr><td>P2</td><td>RAID 创建后同步速率过低</td><td>设置<code>/proc/sys/dev/raid/speed_limit_min</code>过小</td><td><code>storage.log</code>显示同步耗时过长</td><td>调整RAID参数并验证</td></tr>
<tr><td>P3</td><td>LVM 扩容后文件系统未扩展</td><td>脚本未调用<code>xfs_growfs</code></td><td>系统启动正常但<code>df -h</code>容量未变化</td><td>完善扩容流程与验证脚本</td></tr>
<tr><td>P4</td><td>LUKS passphrase 遗失</td><td>故意清除keyfile备份</td><td>无法解密卷</td><td>建立密钥备份策略</td></tr>
<tr><td>P5</td><td>VDO 压缩比异常</td><td>压入不可压缩数据</td><td><code>vdostats</code>显示压缩比≈1</td><td>调整使用场景并记录性能数据</td></tr>
</tbody></table>
</div>
<h3 id="5c-快速诊断清单"><a class="header" href="#5c-快速诊断清单">5.C 快速诊断清单</a></h3>
<ul>
<li><code>udevadm info --query=all /dev/sdx</code></li>
<li><code>blkid -o list</code></li>
<li><code>grep -i error /tmp/storage.log</code></li>
<li><code>mdadm --detail /dev/md*</code></li>
<li><code>lvs -o +devices,seg_monitor</code></li>
<li><code>vdostats --human-readable</code></li>
<li><code>journalctl -u systemd-udevd</code></li>
<li><code>cat /proc/mdstat</code></li>
<li><code>semanage fcontext -l | grep /var/lib/libvirt/images</code>（检查SELinux上下文）</li>
</ul>
<h3 id="5d-故障复盘模板"><a class="header" href="#5d-故障复盘模板">5.D 故障复盘模板</a></h3>
<pre><code class="language-markdown"># blivet 故障复盘报告
- 日期：2024-03-15
- 场景：RHEL 9 KVM 宿主机自动化安装
- 故障摘要：`b.do_it()`执行过程中创建RAID5失败

## 关键时间线
- 10:20 开始执行Kickstart安装
- 10:26 `storage.log`出现`mdadm: cannot open /dev/sdd`错误
- 10:27 安装终止，进入救援模式

## 根因分析
- 预期使用的sdd磁盘因BIOS设置未启用热插拔，boot阶段未识别
- `ignoredisk --only-use`未校验磁盘数量，导致脚本继续执行

## 纠正措施
1. 在`%pre`阶段检查可用磁盘数，小于3则退出安装
2. 更新BIOS配置，将SATA口设置为AHCI
3. 增加安装前的硬件巡检任务

## 预防措施
- 在CI环境模拟磁盘缺失场景
- 维护硬件检测清单并定期审计
</code></pre>
<h2 id="模块6补充高阶实践指南"><a class="header" href="#模块6补充高阶实践指南">模块6补充：高阶实践指南</a></h2>
<h3 id="6a-多站点同步策略"><a class="header" href="#6a-多站点同步策略">6.A 多站点同步策略</a></h3>
<ul>
<li>将blivet脚本与<code>drbd</code>, <code>ceph-volume</code>结合，管理跨机房数据同步。</li>
<li>在灾备切换脚本中，引入blivet重新扫描设备：</li>
</ul>
<pre><code class="language-python">b = Blivet()
b.reset()
b.devicetree.populate()
b.devicetree.refresh()
</code></pre>
<ul>
<li>针对<code>drbd</code>卷，需在脚本中等待同步完成再解锁文件系统。</li>
</ul>
<h3 id="6b-容器化与不可变基础设施"><a class="header" href="#6b-容器化与不可变基础设施">6.B 容器化与不可变基础设施</a></h3>
<ul>
<li>RHEL CoreOS及OpenShift安装使用Ignition，无法直接运行Kickstart，但可借助安装前自定义脚本调用blivet完成磁盘准备。</li>
<li>在不可变操作系统中，建议：
<ol>
<li>使用blivet脚本生成目标系统需要的分区结构。</li>
<li>在Ignition或<code>machine-config-operator</code>中引用分区信息。</li>
<li>制定更新策略，避免在运行节点上频繁调整分区。</li>
</ol>
</li>
</ul>
<h3 id="6c-合规与审计"><a class="header" href="#6c-合规与审计">6.C 合规与审计</a></h3>
<ul>
<li>针对安全要求高的场景（如金融、政企）：
<ul>
<li>对LUKS卷启用<code>--pbkdf</code>强化口令派生。</li>
<li>定期执行<code>cryptsetup luksDump</code>检查keyslot使用情况。</li>
<li>在blivet脚本中加入审计日志：
<pre><code class="language-python">logging.info("[AUDIT] Created encrypted LV %s with TPM binding", lv_root.name)
</code></pre>
</li>
</ul>
</li>
<li>审计指标：
<ul>
<li>所有自动化操作必须在日志中包含<code>操作者/时间/目标设备</code>。</li>
<li>变更需要Ticket号并入Git提交信息。</li>
</ul>
</li>
</ul>
<h3 id="6d-组织协作最佳实践"><a class="header" href="#6d-组织协作最佳实践">6.D 组织协作最佳实践</a></h3>
<ul>
<li>建立跨团队例会：硬件、操作系统、平台运维共享最新脚本与问题清单。</li>
<li>使用知识库（Confluence/Notion）同步：
<ul>
<li>存储模板、故障案例、性能测试报告。</li>
<li>标记脚本适用的硬件型号与BIOS版本。</li>
</ul>
</li>
<li>推行“蓝绿部署”或“金丝雀”策略测试新存储方案。</li>
</ul>
<h2 id="真实案例库不断扩充"><a class="header" href="#真实案例库不断扩充">真实案例库（不断扩充）</a></h2>
<h3 id="案例1金融行业双活数据中心部署"><a class="header" href="#案例1金融行业双活数据中心部署">案例1：金融行业双活数据中心部署</a></h3>
<ul>
<li><strong>背景</strong>：两地三中心架构，RHEL 8+Pacemaker集群，要求数据实时复制。</li>
<li><strong>设计要点</strong>：
<ul>
<li>使用blivet脚本在两个站点创建一致的LVM结构。</li>
<li>结合<code>lvcreate --type raid1</code>实现多镜像，网络层使用<code>multipath</code>。</li>
<li>Kickstart在<code>%post</code>阶段生成Pacemaker资源配置文件。</li>
</ul>
</li>
<li><strong>挑战</strong>：长距离链路时延导致同步延迟。</li>
<li><strong>解决方案</strong>：调整RAID写策略，增加缓存监控，记录IOPS指标。</li>
</ul>
<h3 id="案例2云平台裸金属快速交付"><a class="header" href="#案例2云平台裸金属快速交付">案例2：云平台裸金属快速交付</a></h3>
<ul>
<li><strong>背景</strong>：云服务商需要短时间内初始化上百台计算节点，存储配置复杂。</li>
<li><strong>方案</strong>：
<ul>
<li>采用Foreman+Katello管理Kickstart，blivet脚本根据硬件Profile生成布局。</li>
<li><code>check-storage.py</code>脚本在安装后自动运行，验证挂载点与容量。</li>
<li>通过Prometheus监控RAID状态并触发告警。</li>
</ul>
</li>
<li><strong>结果</strong>：部署效率提升60%，回滚时间缩短至15分钟。</li>
</ul>
<h3 id="案例3科研机构高性能计算集群"><a class="header" href="#案例3科研机构高性能计算集群">案例3：科研机构高性能计算集群</a></h3>
<ul>
<li><strong>需求</strong>：节点需要高速Scratch区、持久化存储与日志隔离。</li>
<li><strong>实现</strong>：
<ul>
<li>NVMe磁盘使用<code>lvmcache</code>加速SAS盘RAID。</li>
<li>配置<code>xfs</code>文件系统带<code>inode64</code>、<code>noatime</code>参数。</li>
<li>使用blivet脚本生成自动化配置，并结合Slurm Job提交钩子检测磁盘状态。</li>
</ul>
</li>
<li><strong>性能数据</strong>：IOPS提升20%，RAID恢复时间减少30%。</li>
</ul>
<h3 id="案例4边缘计算设备离线批量安装"><a class="header" href="#案例4边缘计算设备离线批量安装">案例4：边缘计算设备离线批量安装</a></h3>
<ul>
<li><strong>特点</strong>：设备无网络，需要通过USB启动介质进行全自动安装。</li>
<li><strong>处理</strong>：
<ul>
<li>在Kickstart中嵌入完整blivet脚本，确保在无网络环境下执行。</li>
<li><code>%post</code>阶段将装机结果写入本地日志，待设备上线后同步。</li>
<li>处理闪存寿命问题，使用<code>tmpfs</code>承载易写路径。</li>
</ul>
</li>
</ul>
<h2 id="性能与容量测试指南"><a class="header" href="#性能与容量测试指南">性能与容量测试指南</a></h2>
<ol>
<li><strong>基准测试工具</strong>：<code>fio</code>, <code>bonnie++</code>, <code>vdbench</code>。</li>
<li><strong>测试维度</strong>：顺序读写、随机 IO、延迟、压缩比（针对VDO）。</li>
<li><strong>示例脚本</strong>：</li>
</ol>
<pre><code class="language-bash">fio --name=randread --filename=/mnt/data/testfile --size=10G --bs=4k --rw=randread \
    --iodepth=64 --numjobs=4 --runtime=300 --group_reporting --output=/var/log/fio-randread.log
</code></pre>
<ol start="4">
<li><strong>数据记录</strong>：
<ul>
<li>记录测试前后<code>lsblk</code>, <code>lvs -a -o +seg_monitor</code>输出。</li>
<li>保存<code>/proc/diskstats</code>、<code>/sys/block/*/queue/*</code>关键信息。</li>
<li>分析<code>iostat</code>, <code>sar -d</code>数据，形成趋势图。</li>
</ul>
</li>
<li><strong>调优策略示例</strong>：
<ul>
<li>增加RAID的<code>stripe_cache_size</code>以提升写性能。</li>
<li>调整<code>/sys/block/&lt;dev&gt;/queue/scheduler</code>在<code>mq-deadline</code>、<code>none</code>之间切换。</li>
<li>对VDO卷设置合适的<code>logical block per physical block ratio</code>。</li>
</ul>
</li>
</ol>
<h2 id="日志与数据样例库"><a class="header" href="#日志与数据样例库">日志与数据样例库</a></h2>
<ul>
<li><code>samples/storage.log</code>: 收集不同错误类型的日志片段，标注时间戳与上下文。</li>
<li><code>samples/kickstart/compute-node.ks</code>: 完整Kickstart示例，包含注释。</li>
<li><code>samples/scripts/rollback.py</code>: 回滚脚本示例，演示如何根据保存的JSON恢复。</li>
<li><code>samples/prometheus/storage_exporter.py</code>: 输出VG容量、RAID状态的Exporter示例。</li>
</ul>
<h2 id="学习与实践进度追踪表"><a class="header" href="#学习与实践进度追踪表">学习与实践进度追踪表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>周次</th><th>学习重点</th><th>实验任务</th><th>产出物</th><th>是否完成</th></tr></thead><tbody>
<tr><td>第1周</td><td>blivet基础、环境搭建</td><td>安装blivet-gui、导出设备树</td><td>环境搭建报告</td><td></td></tr>
<tr><td>第2周</td><td>DeviceTree深入</td><td>编写设备枚举脚本</td><td><code>devicetree-report.md</code></td><td></td></tr>
<tr><td>第3周</td><td>分区与LVM练习</td><td>创建脚本模板库</td><td><code>scripts/partition.py</code></td><td></td></tr>
<tr><td>第4周</td><td>Kickstart自动化</td><td>设计批量部署模板</td><td><code>kickstarts/auto.ks</code></td><td></td></tr>
<tr><td>第5周</td><td>故障注入与排查</td><td>执行P1-P5故障剧本</td><td>复盘报告</td><td></td></tr>
<tr><td>第6周</td><td>性能测试与优化</td><td>运行fio测试并调优</td><td>性能对比表</td><td></td></tr>
<tr><td>第7周</td><td>安全与合规</td><td>配置LUKS+TPM绑定</td><td>安全基线文档</td><td></td></tr>
<tr><td>第8周</td><td>综合项目</td><td>部署真实案例</td><td>项目总结报告</td><td></td></tr>
</tbody></table>
</div>
<h2 id="下一阶段扩展方向"><a class="header" href="#下一阶段扩展方向">下一阶段扩展方向</a></h2>
<ul>
<li>收集不同RHEL/Fedora版本中blivet差异，整理升级注意事项。</li>
<li>结合<code>storaged</code>/<code>cockpit</code>界面操作，分析与blivet接口的互动方式。</li>
<li>研究<code>blivet</code>在容器存储、Stratis等新技术中的应用边界。</li>
<li>编写多语言版本（英文/日文）以支持海外团队。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/video/WebRTC.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/云计算/cloud-init.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/video/WebRTC.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/云计算/cloud-init.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

