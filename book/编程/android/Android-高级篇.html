<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Android开发学习笔记 - 高级篇 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="android开发学习笔记---高级篇"><a class="header" href="#android开发学习笔记---高级篇">Android开发学习笔记 - 高级篇</a></h1>
<blockquote>
<p>适用人群：有1-2年Android开发经验，希望提升架构设计和性能优化能力
学习目标：掌握性能优化、架构设计模式、测试和应用发布</p>
</blockquote>
<h2 id="一性能优化"><a class="header" href="#一性能优化">一、性能优化</a></h2>
<h3 id="11-内存优化"><a class="header" href="#11-内存优化">1.1 内存优化</a></h3>
<h4 id="111-内存泄漏检测"><a class="header" href="#111-内存泄漏检测">1.1.1 内存泄漏检测</a></h4>
<p><strong>使用LeakCanary：</strong></p>
<pre><code class="language-kotlin">// build.gradle.kts
dependencies {
    debugImplementation("com.squareup.leakcanary:leakcanary-android:2.12")
}

// Application类
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        // LeakCanary会自动初始化
    }
}
</code></pre>
<p><strong>常见内存泄漏场景及解决方案：</strong></p>
<pre><code class="language-kotlin">// 1. 非静态内部类持有外部类引用
// ❌ 错误示例
class MainActivity : AppCompatActivity() {
    inner class MyHandler : Handler() {
        override fun handleMessage(msg: Message) {
            // 持有Activity引用，可能泄漏
        }
    }
}

// ✅ 正确示例
class MainActivity : AppCompatActivity() {
    private lateinit var handler: MyHandler

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        handler = MyHandler(this)
    }

    // 静态内部类 + 弱引用
    private class MyHandler(activity: MainActivity) : Handler(Looper.getMainLooper()) {
        private val activityRef = WeakReference(activity)

        override fun handleMessage(msg: Message) {
            val activity = activityRef.get()
            if (activity != null &amp;&amp; !activity.isFinishing) {
                // 安全处理
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        handler.removeCallbacksAndMessages(null)
    }
}

// 2. 单例持有Context
// ❌ 错误示例
object MySingleton {
    private lateinit var context: Context

    fun init(context: Context) {
        this.context = context // 如果传入Activity会泄漏
    }
}

// ✅ 正确示例
object MySingleton {
    private lateinit var context: Context

    fun init(context: Context) {
        this.context = context.applicationContext // 使用Application Context
    }
}

// 3. 未注销监听器
class MainActivity : AppCompatActivity() {

    private val locationListener = object : LocationListener {
        override fun onLocationChanged(location: Location) {
            // 处理位置更新
        }
        // 其他方法...
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
        locationManager.requestLocationUpdates(
            LocationManager.GPS_PROVIDER,
            1000,
            0f,
            locationListener
        )
    }

    override fun onDestroy() {
        super.onDestroy()
        // ✅ 必须注销监听器
        val locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
        locationManager.removeUpdates(locationListener)
    }
}

// 4. 集合类泄漏
class UserManager {
    private val userList = mutableListOf&lt;User&gt;()

    fun addUser(user: User) {
        userList.add(user)
        // 问题：如果不清理，对象会一直累积
    }

    fun clearUsers() {
        userList.clear() // ✅ 提供清理方法
    }
}
</code></pre>
<h4 id="112-图片内存优化"><a class="header" href="#112-图片内存优化">1.1.2 图片内存优化</a></h4>
<pre><code class="language-kotlin">class ImageOptimization {

    // 1. 压缩加载大图
    fun loadBitmap(path: String, reqWidth: Int, reqHeight: Int): Bitmap {
        val options = BitmapFactory.Options().apply {
            inJustDecodeBounds = true // 只解析尺寸
        }
        BitmapFactory.decodeFile(path, options)

        // 计算采样率
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight)
        options.inJustDecodeBounds = false

        return BitmapFactory.decodeFile(path, options)
    }

    private fun calculateInSampleSize(
        options: BitmapFactory.Options,
        reqWidth: Int,
        reqHeight: Int
    ): Int {
        val height = options.outHeight
        val width = options.outWidth
        var inSampleSize = 1

        if (height &gt; reqHeight || width &gt; reqWidth) {
            val halfHeight = height / 2
            val halfWidth = width / 2

            while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp;
                (halfWidth / inSampleSize) &gt;= reqWidth) {
                inSampleSize *= 2
            }
        }

        return inSampleSize
    }

    // 2. Bitmap复用
    fun loadBitmapWithReuse(path: String, reusableBitmap: Bitmap?): Bitmap {
        val options = BitmapFactory.Options().apply {
            inMutable = true // 设置为可变
            inBitmap = reusableBitmap // 复用Bitmap
        }

        return try {
            BitmapFactory.decodeFile(path, options)
        } catch (e: IllegalArgumentException) {
            // 复用失败，重新加载
            BitmapFactory.decodeFile(path)
        }
    }

    // 3. 使用LruCache缓存
    private val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
    private val cacheSize = maxMemory / 8

    private val memoryCache = object : LruCache&lt;String, Bitmap&gt;(cacheSize) {
        override fun sizeOf(key: String, bitmap: Bitmap): Int {
            return bitmap.byteCount / 1024
        }
    }

    fun addBitmapToCache(key: String, bitmap: Bitmap) {
        if (getBitmapFromCache(key) == null) {
            memoryCache.put(key, bitmap)
        }
    }

    fun getBitmapFromCache(key: String): Bitmap? {
        return memoryCache.get(key)
    }
}
</code></pre>
<h3 id="12-布局优化"><a class="header" href="#12-布局优化">1.2 布局优化</a></h3>
<h4 id="121-减少布局层级"><a class="header" href="#121-减少布局层级">1.2.1 减少布局层级</a></h4>
<pre><code class="language-xml">&lt;!-- ❌ 过度嵌套 --&gt;
&lt;LinearLayout&gt;
    &lt;RelativeLayout&gt;
        &lt;LinearLayout&gt;
            &lt;TextView /&gt;
            &lt;Button /&gt;
        &lt;/LinearLayout&gt;
    &lt;/RelativeLayout&gt;
&lt;/LinearLayout&gt;

&lt;!-- ✅ 使用ConstraintLayout扁平化 --&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
    &lt;TextView
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" /&gt;

    &lt;Button
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/textView" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<h4 id="122-viewstub延迟加载"><a class="header" href="#122-viewstub延迟加载">1.2.2 ViewStub延迟加载</a></h4>
<pre><code class="language-xml">&lt;!-- activity_main.xml --&gt;
&lt;LinearLayout&gt;
    &lt;TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="常驻内容" /&gt;

    &lt;!-- 延迟加载的复杂布局 --&gt;
    &lt;ViewStub
        android:id="@+id/viewStub"
        android:layout="@layout/complex_layout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 需要时才加载
        findViewById&lt;Button&gt;(R.id.btnShow).setOnClickListener {
            val viewStub = findViewById&lt;ViewStub&gt;(R.id.viewStub)
            val inflatedView = viewStub.inflate()
            // 使用inflatedView
        }
    }
}
</code></pre>
<h4 id="123-include和merge标签"><a class="header" href="#123-include和merge标签">1.2.3 include和merge标签</a></h4>
<pre><code class="language-xml">&lt;!-- common_toolbar.xml --&gt;
&lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;TextView
        android:id="@+id/tvTitle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;

    &lt;ImageButton
        android:id="@+id/btnBack"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;
&lt;/merge&gt;

&lt;!-- activity_main.xml --&gt;
&lt;LinearLayout&gt;
    &lt;include layout="@layout/common_toolbar" /&gt;
    &lt;!-- 其他内容 --&gt;
&lt;/LinearLayout&gt;
</code></pre>
<h3 id="13-启动优化"><a class="header" href="#13-启动优化">1.3 启动优化</a></h3>
<h4 id="131-冷启动优化"><a class="header" href="#131-冷启动优化">1.3.1 冷启动优化</a></h4>
<pre><code class="language-kotlin">class MyApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        // ❌ 不要在Application onCreate中执行耗时操作
        // heavyInitialization()

        // ✅ 异步初始化
        Thread {
            initThirdPartySDKs()
        }.start()

        // ✅ 懒加载
        // 在需要时才初始化
    }

    private fun initThirdPartySDKs() {
        // 初始化第三方SDK
    }
}

// 懒加载单例
object DatabaseManager {
    val database: MyDatabase by lazy {
        Room.databaseBuilder(
            context,
            MyDatabase::class.java,
            "database"
        ).build()
    }
}

// 启动页优化
class SplashActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // ✅ 使用主题背景作为启动页，避免白屏
        // 在styles.xml中定义：
        // &lt;style name="SplashTheme" parent="Theme.AppCompat.NoActionBar"&gt;
        //     &lt;item name="android:windowBackground"&gt;@drawable/splash_background&lt;/item&gt;
        // &lt;/style&gt;

        // 直接跳转主页，不设置布局
        startActivity(Intent(this, MainActivity::class.java))
        finish()
    }
}
</code></pre>
<h3 id="14-网络优化"><a class="header" href="#14-网络优化">1.4 网络优化</a></h3>
<pre><code class="language-kotlin">class NetworkOptimization {

    // 1. 使用GZIP压缩
    private val client = OkHttpClient.Builder()
        .addInterceptor { chain -&gt;
            val request = chain.request().newBuilder()
                .addHeader("Accept-Encoding", "gzip")
                .build()
            chain.proceed(request)
        }
        .build()

    // 2. 请求合并
    suspend fun loadUserData(userId: Int): UserData = coroutineScope {
        val userDeferred = async { fetchUser(userId) }
        val postsDeferred = async { fetchUserPosts(userId) }
        val friendsDeferred = async { fetchUserFriends(userId) }

        UserData(
            user = userDeferred.await(),
            posts = postsDeferred.await(),
            friends = friendsDeferred.await()
        )
    }

    // 3. 分页加载
    class UserRepository {
        suspend fun loadUsers(page: Int, pageSize: Int): List&lt;User&gt; {
            return apiService.getUsers(page, pageSize)
        }
    }

    // 4. 缓存策略
    private val cacheClient = OkHttpClient.Builder()
        .cache(Cache(context.cacheDir, 10 * 1024 * 1024)) // 10MB缓存
        .build()
}

data class UserData(
    val user: User,
    val posts: List&lt;Post&gt;,
    val friends: List&lt;User&gt;
)

data class Post(val id: Int, val content: String)
</code></pre>
<h2 id="二架构设计"><a class="header" href="#二架构设计">二、架构设计</a></h2>
<h3 id="21-mvvm架构"><a class="header" href="#21-mvvm架构">2.1 MVVM架构</a></h3>
<h4 id="211-完整mvvm示例"><a class="header" href="#211-完整mvvm示例">2.1.1 完整MVVM示例</a></h4>
<pre><code class="language-kotlin">// 1. Model层 - 数据模型
@Entity(tableName = "todos")
data class Todo(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val title: String,
    val content: String,
    val isCompleted: Boolean = false,
    val createdAt: Long = System.currentTimeMillis()
)

// 2. DAO
@Dao
interface TodoDao {
    @Query("SELECT * FROM todos ORDER BY createdAt DESC")
    fun getAllTodos(): Flow&lt;List&lt;Todo&gt;&gt;

    @Insert
    suspend fun insert(todo: Todo)

    @Update
    suspend fun update(todo: Todo)

    @Delete
    suspend fun delete(todo: Todo)

    @Query("SELECT * FROM todos WHERE isCompleted = :completed")
    fun getTodosByStatus(completed: Boolean): Flow&lt;List&lt;Todo&gt;&gt;
}

// 3. Database
@Database(entities = [Todo::class], version = 1)
abstract class TodoDatabase : RoomDatabase() {
    abstract fun todoDao(): TodoDao

    companion object {
        @Volatile
        private var INSTANCE: TodoDatabase? = null

        fun getDatabase(context: Context): TodoDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    TodoDatabase::class.java,
                    "todo_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}

// 4. Repository层
class TodoRepository(private val todoDao: TodoDao) {

    val allTodos: Flow&lt;List&lt;Todo&gt;&gt; = todoDao.getAllTodos()

    suspend fun insert(todo: Todo) {
        todoDao.insert(todo)
    }

    suspend fun update(todo: Todo) {
        todoDao.update(todo)
    }

    suspend fun delete(todo: Todo) {
        todoDao.delete(todo)
    }

    fun getCompletedTodos(): Flow&lt;List&lt;Todo&gt;&gt; {
        return todoDao.getTodosByStatus(true)
    }

    fun getPendingTodos(): Flow&lt;List&lt;Todo&gt;&gt; {
        return todoDao.getTodosByStatus(false)
    }
}

// 5. ViewModel层
class TodoViewModel(application: Application) : AndroidViewModel(application) {

    private val repository: TodoRepository
    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt;

    private val _filterType = MutableLiveData&lt;FilterType&gt;(FilterType.ALL)
    val filterType: LiveData&lt;FilterType&gt; = _filterType

    init {
        val todoDao = TodoDatabase.getDatabase(application).todoDao()
        repository = TodoRepository(todoDao)
        allTodos = repository.allTodos.asLiveData()
    }

    // 当前显示的Todo列表
    val displayTodos: LiveData&lt;List&lt;Todo&gt;&gt; = allTodos.map { todos -&gt;
        when (_filterType.value) {
            FilterType.ALL -&gt; todos
            FilterType.COMPLETED -&gt; todos.filter { it.isCompleted }
            FilterType.PENDING -&gt; todos.filter { !it.isCompleted }
            null -&gt; todos
        }
    }

    fun insert(title: String, content: String) = viewModelScope.launch {
        val todo = Todo(title = title, content = content)
        repository.insert(todo)
    }

    fun update(todo: Todo) = viewModelScope.launch {
        repository.update(todo)
    }

    fun delete(todo: Todo) = viewModelScope.launch {
        repository.delete(todo)
    }

    fun toggleComplete(todo: Todo) = viewModelScope.launch {
        val updatedTodo = todo.copy(isCompleted = !todo.isCompleted)
        repository.update(updatedTodo)
    }

    fun setFilter(type: FilterType) {
        _filterType.value = type
    }
}

enum class FilterType {
    ALL, COMPLETED, PENDING
}

// 6. View层 - Activity
class TodoListActivity : AppCompatActivity() {

    private val viewModel: TodoViewModel by viewModels()
    private lateinit var adapter: TodoAdapter

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_todo_list)

        setupRecyclerView()
        observeViewModel()

        // 添加Todo
        findViewById&lt;FloatingActionButton&gt;(R.id.fabAdd).setOnClickListener {
            showAddTodoDialog()
        }

        // 过滤器
        findViewById&lt;Chip&gt;(R.id.chipAll).setOnClickListener {
            viewModel.setFilter(FilterType.ALL)
        }
        findViewById&lt;Chip&gt;(R.id.chipCompleted).setOnClickListener {
            viewModel.setFilter(FilterType.COMPLETED)
        }
        findViewById&lt;Chip&gt;(R.id.chipPending).setOnClickListener {
            viewModel.setFilter(FilterType.PENDING)
        }
    }

    private fun setupRecyclerView() {
        adapter = TodoAdapter(
            onItemClick = { todo -&gt;
                // 查看详情
                showTodoDetail(todo)
            },
            onCheckClick = { todo -&gt;
                viewModel.toggleComplete(todo)
            },
            onDeleteClick = { todo -&gt;
                viewModel.delete(todo)
            }
        )

        findViewById&lt;RecyclerView&gt;(R.id.recyclerView).apply {
            layoutManager = LinearLayoutManager(this@TodoListActivity)
            adapter = this@TodoListActivity.adapter
        }
    }

    private fun observeViewModel() {
        // 观察Todo列表
        viewModel.displayTodos.observe(this) { todos -&gt;
            adapter.submitList(todos)
        }

        // 观察过滤类型
        viewModel.filterType.observe(this) { type -&gt;
            // 更新UI状态
        }
    }

    private fun showAddTodoDialog() {
        val dialogView = layoutInflater.inflate(R.layout.dialog_add_todo, null)
        val etTitle = dialogView.findViewById&lt;EditText&gt;(R.id.etTitle)
        val etContent = dialogView.findViewById&lt;EditText&gt;(R.id.etContent)

        AlertDialog.Builder(this)
            .setTitle("添加待办事项")
            .setView(dialogView)
            .setPositiveButton("添加") { _, _ -&gt;
                val title = etTitle.text.toString()
                val content = etContent.text.toString()
                if (title.isNotEmpty()) {
                    viewModel.insert(title, content)
                }
            }
            .setNegativeButton("取消", null)
            .show()
    }

    private fun showTodoDetail(todo: Todo) {
        // 跳转到详情页
    }
}

// 7. Adapter
class TodoAdapter(
    private val onItemClick: (Todo) -&gt; Unit,
    private val onCheckClick: (Todo) -&gt; Unit,
    private val onDeleteClick: (Todo) -&gt; Unit
) : ListAdapter&lt;Todo, TodoAdapter.TodoViewHolder&gt;(TodoDiffCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TodoViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_todo, parent, false)
        return TodoViewHolder(view)
    }

    override fun onBindViewHolder(holder: TodoViewHolder, position: Int) {
        holder.bind(getItem(position))
    }

    inner class TodoViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val tvTitle: TextView = itemView.findViewById(R.id.tvTitle)
        private val tvContent: TextView = itemView.findViewById(R.id.tvContent)
        private val checkbox: CheckBox = itemView.findViewById(R.id.checkbox)
        private val btnDelete: ImageButton = itemView.findViewById(R.id.btnDelete)

        fun bind(todo: Todo) {
            tvTitle.text = todo.title
            tvContent.text = todo.content
            checkbox.isChecked = todo.isCompleted

            // 完成状态的样式
            if (todo.isCompleted) {
                tvTitle.paintFlags = tvTitle.paintFlags or Paint.STRIKE_THRU_TEXT_FLAG
                tvTitle.setTextColor(Color.GRAY)
            } else {
                tvTitle.paintFlags = tvTitle.paintFlags and Paint.STRIKE_THRU_TEXT_FLAG.inv()
                tvTitle.setTextColor(Color.BLACK)
            }

            itemView.setOnClickListener { onItemClick(todo) }
            checkbox.setOnClickListener { onCheckClick(todo) }
            btnDelete.setOnClickListener { onDeleteClick(todo) }
        }
    }

    class TodoDiffCallback : DiffUtil.ItemCallback&lt;Todo&gt;() {
        override fun areItemsTheSame(oldItem: Todo, newItem: Todo): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: Todo, newItem: Todo): Boolean {
            return oldItem == newItem
        }
    }
}
</code></pre>
<h3 id="22-依赖注入---hilt"><a class="header" href="#22-依赖注入---hilt">2.2 依赖注入 - Hilt</a></h3>
<p><strong>添加依赖：</strong></p>
<pre><code class="language-kotlin">// build.gradle.kts (项目级)
plugins {
    id("com.google.dagger.hilt.android") version "2.48" apply false
}

// build.gradle.kts (模块级)
plugins {
    id("com.google.dagger.hilt.android")
    id("kotlin-kapt")
}

dependencies {
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-android-compiler:2.48")
    implementation("androidx.hilt:hilt-navigation-compose:1.1.0")
}
</code></pre>
<p><strong>使用Hilt：</strong></p>
<pre><code class="language-kotlin">// 1. Application类
@HiltAndroidApp
class MyApplication : Application()

// 2. 提供依赖
@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): TodoDatabase {
        return TodoDatabase.getDatabase(context)
    }

    @Provides
    fun provideTodoDao(database: TodoDatabase): TodoDao {
        return database.todoDao()
    }

    @Provides
    @Singleton
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://api.example.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }

    @Provides
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}

// 3. Repository注入
class TodoRepository @Inject constructor(
    private val todoDao: TodoDao
) {
    val allTodos: Flow&lt;List&lt;Todo&gt;&gt; = todoDao.getAllTodos()

    suspend fun insert(todo: Todo) = todoDao.insert(todo)
}

// 4. ViewModel注入
@HiltViewModel
class TodoViewModel @Inject constructor(
    private val repository: TodoRepository
) : ViewModel() {

    val allTodos: LiveData&lt;List&lt;Todo&gt;&gt; = repository.allTodos.asLiveData()

    fun insert(title: String, content: String) = viewModelScope.launch {
        val todo = Todo(title = title, content = content)
        repository.insert(todo)
    }
}

// 5. Activity注入
@AndroidEntryPoint
class TodoListActivity : AppCompatActivity() {

    private val viewModel: TodoViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_todo_list)

        viewModel.allTodos.observe(this) { todos -&gt;
            // 更新UI
        }
    }
}
</code></pre>
<h2 id="三测试"><a class="header" href="#三测试">三、测试</a></h2>
<h3 id="31-单元测试"><a class="header" href="#31-单元测试">3.1 单元测试</a></h3>
<pre><code class="language-kotlin">// 添加依赖
dependencies {
    testImplementation("junit:junit:4.13.2")
    testImplementation("org.mockito:mockito-core:5.7.0")
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.2.1")
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
    testImplementation("androidx.arch.core:core-testing:2.2.0")
}

// 测试ViewModel
class TodoViewModelTest {

    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    @OptIn(ExperimentalCoroutinesApi::class)
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()

    private lateinit var viewModel: TodoViewModel
    private lateinit var repository: TodoRepository

    @Before
    fun setup() {
        repository = mock()
        viewModel = TodoViewModel(repository)
    }

    @Test
    fun `insert todo should call repository insert`() = runTest {
        // Given
        val title = "测试标题"
        val content = "测试内容"

        // When
        viewModel.insert(title, content)

        // Then
        verify(repository).insert(any())
    }

    @Test
    fun `toggle complete should update todo status`() = runTest {
        // Given
        val todo = Todo(id = 1, title = "Test", content = "Content", isCompleted = false)

        // When
        viewModel.toggleComplete(todo)

        // Then
        verify(repository).update(argThat {
            it.id == todo.id &amp;&amp; it.isCompleted == true
        })
    }
}

// MainDispatcherRule.kt
@ExperimentalCoroutinesApi
class MainDispatcherRule(
    private val testDispatcher: TestDispatcher = UnconfinedTestDispatcher()
) : TestWatcher() {
    override fun starting(description: Description) {
        Dispatchers.setMain(testDispatcher)
    }

    override fun finished(description: Description) {
        Dispatchers.resetMain()
    }
}
</code></pre>
<h3 id="32-ui测试"><a class="header" href="#32-ui测试">3.2 UI测试</a></h3>
<pre><code class="language-kotlin">// 添加依赖
dependencies {
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation("androidx.test:runner:1.5.2")
    androidTestImplementation("androidx.test:rules:1.5.0")
}

// UI测试
@RunWith(AndroidJUnit4::class)
class TodoListActivityTest {

    @get:Rule
    val activityRule = ActivityScenarioRule(TodoListActivity::class.java)

    @Test
    fun testAddTodo() {
        // 点击添加按钮
        onView(withId(R.id.fabAdd)).perform(click())

        // 输入标题和内容
        onView(withId(R.id.etTitle)).perform(typeText("测试标题"))
        onView(withId(R.id.etContent)).perform(typeText("测试内容"))

        // 点击确定
        onView(withText("添加")).perform(click())

        // 验证列表中显示新添加的todo
        onView(withText("测试标题")).check(matches(isDisplayed()))
    }

    @Test
    fun testToggleTodoComplete() {
        // 点击checkbox
        onView(withId(R.id.checkbox)).perform(click())

        // 验证标题有删除线
        onView(withId(R.id.tvTitle)).check(matches(hasStrikethrough()))
    }

    private fun hasStrikethrough(): Matcher&lt;View&gt; {
        return object : BoundedMatcher&lt;View, TextView&gt;(TextView::class.java) {
            override fun describeTo(description: Description) {
                description.appendText("has strikethrough")
            }

            override fun matchesSafely(textView: TextView): Boolean {
                return textView.paintFlags and Paint.STRIKE_THRU_TEXT_FLAG != 0
            }
        }
    }
}
</code></pre>
<h2 id="四应用发布"><a class="header" href="#四应用发布">四、应用发布</a></h2>
<h3 id="41-签名配置"><a class="header" href="#41-签名配置">4.1 签名配置</a></h3>
<pre><code class="language-kotlin">// build.gradle.kts
android {
    signingConfigs {
        create("release") {
            storeFile = file("../keystore/release.jks")
            storePassword = "your_store_password"
            keyAlias = "your_key_alias"
            keyPassword = "your_key_password"
        }
    }

    buildTypes {
        release {
            signingConfig = signingConfigs.getByName("release")
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
}
</code></pre>
<p><strong>生成签名文件：</strong></p>
<pre><code class="language-bash">keytool -genkey -v -keystore release.jks -keyalg RSA -keysize 2048 -validity 10000 -alias my_key_alias
</code></pre>
<h3 id="42-混淆配置"><a class="header" href="#42-混淆配置">4.2 混淆配置</a></h3>
<pre><code class="language-proguard"># proguard-rules.pro

# 保留行号
-keepattributes SourceFile,LineNumberTable

# 保留注解
-keepattributes *Annotation*

# 保留泛型
-keepattributes Signature

# 保留异常
-keepattributes Exceptions

# 保留自定义View
-keep public class * extends android.view.View {
    public &lt;init&gt;(android.content.Context);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
    public void set*(...);
}

# 保留Parcelable
-keep class * implements android.os.Parcelable {
    public static final android.os.Parcelable$Creator *;
}

# 保留Serializable
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

# Retrofit
-keepattributes Signature, InnerClasses, EnclosingMethod
-keepclassmembers,allowshrinking,allowobfuscation interface * {
    @retrofit2.http.* &lt;methods&gt;;
}

# Gson
-keepattributes Signature
-keep class com.google.gson.reflect.TypeToken { *; }
-keep class * extends com.google.gson.reflect.TypeToken

# 保留数据模型
-keep class com.example.myapp.model.** { *; }
</code></pre>
<h3 id="43-多渠道打包"><a class="header" href="#43-多渠道打包">4.3 多渠道打包</a></h3>
<pre><code class="language-kotlin">android {
    flavorDimensions += "version"

    productFlavors {
        create("free") {
            dimension = "version"
            applicationIdSuffix = ".free"
            versionNameSuffix = "-free"
        }

        create("paid") {
            dimension = "version"
            applicationIdSuffix = ".paid"
            versionNameSuffix = "-paid"
        }
    }
}
</code></pre>
<h3 id="44-发布检查清单"><a class="header" href="#44-发布检查清单">4.4 发布检查清单</a></h3>
<pre><code>□ 版本号更新（versionCode和versionName）
□ 签名配置正确
□ 混淆规则完善
□ 移除所有调试代码和日志
□ 测试所有主要功能
□ 检查权限声明
□ 准备应用图标和截图
□ 编写更新日志
□ 检查第三方SDK密钥
□ 测试安装包大小
□ 在不同设备上测试
□ 准备隐私政策
</code></pre>
<h2 id="五jetpack组件"><a class="header" href="#五jetpack组件">五、Jetpack组件</a></h2>
<h3 id="51-navigation"><a class="header" href="#51-navigation">5.1 Navigation</a></h3>
<pre><code class="language-kotlin">// 添加依赖
dependencies {
    implementation("androidx.navigation:navigation-fragment-ktx:2.7.6")
    implementation("androidx.navigation:navigation-ui-ktx:2.7.6")
}

// 创建导航图 res/navigation/nav_graph.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/nav_graph"
    app:startDestination="@id/homeFragment"&gt;

    &lt;fragment
        android:id="@+id/homeFragment"
        android:name="com.example.HomeFragment"
        android:label="首页"&gt;
        &lt;action
            android:id="@+id/action_home_to_detail"
            app:destination="@id/detailFragment" /&gt;
    &lt;/fragment&gt;

    &lt;fragment
        android:id="@+id/detailFragment"
        android:name="com.example.DetailFragment"
        android:label="详情"&gt;
        &lt;argument
            android:name="itemId"
            app:argType="integer" /&gt;
    &lt;/fragment&gt;
&lt;/navigation&gt;

// Activity中配置NavHost
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val navController = findNavController(R.id.nav_host_fragment)
        setupActionBarWithNavController(navController)
    }

    override fun onSupportNavigateUp(): Boolean {
        val navController = findNavController(R.id.nav_host_fragment)
        return navController.navigateUp() || super.onSupportNavigateUp()
    }
}

// Fragment中导航
class HomeFragment : Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        view.findViewById&lt;Button&gt;(R.id.btnDetail).setOnClickListener {
            val action = HomeFragmentDirections.actionHomeToDetail(itemId = 123)
            findNavController().navigate(action)
        }
    }
}
</code></pre>
<h3 id="52-databinding"><a class="header" href="#52-databinding">5.2 DataBinding</a></h3>
<pre><code class="language-kotlin">// 启用DataBinding
android {
    buildFeatures {
        dataBinding = true
    }
}

// 布局文件
&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;data&gt;
        &lt;variable
            name="user"
            type="com.example.User" /&gt;

        &lt;variable
            name="viewModel"
            type="com.example.UserViewModel" /&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"&gt;

        &lt;TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@{user.name}" /&gt;

        &lt;Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="点击"
            android:onClick="@{() -&gt; viewModel.onButtonClick()}" /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;

// Activity中使用
class UserActivity : AppCompatActivity() {
    private lateinit var binding: ActivityUserBinding
    private val viewModel: UserViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = DataBindingUtil.setContentView(this, R.layout.activity_user)
        binding.lifecycleOwner = this
        binding.viewModel = viewModel

        viewModel.user.observe(this) { user -&gt;
            binding.user = user
        }
    }
}
</code></pre>
<h2 id="六学习验证标准"><a class="header" href="#六学习验证标准">六、学习验证标准</a></h2>
<p>完成高级篇学习后，你应该能够：</p>
<ol>
<li><strong>性能优化</strong>：能够检测和解决内存泄漏，优化布局和启动性能</li>
<li><strong>架构设计</strong>：熟练使用MVVM架构，掌握Hilt依赖注入</li>
<li><strong>测试</strong>：能够编写单元测试和UI测试</li>
<li><strong>发布</strong>：掌握应用签名、混淆和发布流程</li>
<li><strong>Jetpack组件</strong>：熟练使用Navigation、DataBinding等Jetpack组件</li>
</ol>
<h2 id="七进阶学习方向"><a class="header" href="#七进阶学习方向">七、进阶学习方向</a></h2>
<ol>
<li><strong>Jetpack Compose</strong>：现代化声明式UI框架</li>
<li><strong>Kotlin多平台</strong>：KMM跨平台开发</li>
<li><strong>模块化架构</strong>：大型项目的模块化设计</li>
<li><strong>性能监控</strong>：APM性能监控系统</li>
<li><strong>自动化测试</strong>：CI/CD集成</li>
</ol>
<h2 id="八推荐资源"><a class="header" href="#八推荐资源">八、推荐资源</a></h2>
<ol>
<li><strong>官方文档</strong>：https://developer.android.com</li>
<li><strong>代码实验室</strong>：https://codelabs.developers.google.com</li>
<li><strong>开源项目</strong>：
<ul>
<li>Now in Android（官方示例）</li>
<li>Tivi（Jetpack Compose）</li>
<li>Architecture Components Samples</li>
</ul>
</li>
</ol>
<hr />
<p><strong>恭喜你完成Android开发学习笔记全系列！</strong> 继续实践，构建更优秀的Android应用！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/android/Android-进阶篇.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/android/Android.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/android/Android-进阶篇.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/android/Android.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

