<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LibCurl 技术笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="libcurl-技术笔记"><a class="header" href="#libcurl-技术笔记">LibCurl 技术笔记</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>LibCurl是一个免费开源的客户端URL传输库，支持多种网络协议的数据传输。它是一个功能强大、高度可移植的C/C++库，被广泛应用于需要进行网络通信的应用程序中。LibCurl提供了简单易用的API接口，支持HTTP(S)、FTP(S)、SMTP、POP3、IMAP等多种协议。</p>
<h3 id="核心特性"><a class="header" href="#核心特性">核心特性</a></h3>
<ul>
<li>支持多种网络协议（HTTP/HTTPS、FTP/FTPS、SMTP、POP3、IMAP等）</li>
<li>跨平台支持（Windows、Linux、macOS、Unix等）</li>
<li>线程安全的设计</li>
<li>支持各种认证方式</li>
<li>丰富的SSL/TLS支持</li>
<li>代理服务器支持</li>
<li>断点续传功能</li>
<li>Cookie管理</li>
<li>自定义请求头</li>
<li>多种数据传输方式</li>
</ul>
<h2 id="系统架构"><a class="header" href="#系统架构">系统架构</a></h2>
<h3 id="核心组件架构"><a class="header" href="#核心组件架构">核心组件架构</a></h3>
<pre><code>应用程序层
    |
LibCurl API 层
    |
+-------------------+
|   Easy Interface  |  简单接口（单一传输）
+-------------------+
|   Multi Interface |  多重接口（并发传输）
+-------------------+
|   Share Interface |  共享接口（资源共享）
+-------------------+
    |
协议处理层
    |
+-------------------+
| HTTP | FTP | SMTP |  各种协议实现
+-------------------+
    |
传输层
    |
+-------------------+
|  SSL/TLS | Socket |  安全传输和网络接口
+-------------------+
</code></pre>
<h3 id="主要接口类型"><a class="header" href="#主要接口类型">主要接口类型</a></h3>
<ol>
<li>
<p><strong>Easy Interface</strong></p>
<ul>
<li>同步、阻塞式API</li>
<li>一次处理一个传输</li>
<li>简单易用，适合基本应用</li>
</ul>
</li>
<li>
<p><strong>Multi Interface</strong></p>
<ul>
<li>异步、非阻塞式API</li>
<li>同时处理多个传输</li>
<li>高性能，适合复杂应用</li>
</ul>
</li>
<li>
<p><strong>Share Interface</strong></p>
<ul>
<li>在多个Easy句柄间共享数据</li>
<li>共享DNS缓存、Cookie等</li>
</ul>
</li>
</ol>
<h2 id="关键组件详解"><a class="header" href="#关键组件详解">关键组件详解</a></h2>
<h3 id="1-easy-interface-基础使用"><a class="header" href="#1-easy-interface-基础使用">1. Easy Interface 基础使用</a></h3>
<pre><code class="language-cpp">#include &lt;curl/curl.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

// 回调函数：处理接收的数据
size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* data) {
    size_t totalSize = size * nmemb;
    data-&gt;append((char*)contents, totalSize);
    return totalSize;
}

class CurlEasyClient {
private:
    CURL* curl;
    std::string response_data;

public:
    CurlEasyClient() : curl(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
    }

    ~CurlEasyClient() {
        if (curl) {
            curl_easy_cleanup(curl);
        }
        curl_global_cleanup();
    }

    bool get(const std::string&amp; url) {
        if (!curl) return false;

        response_data.clear();

        // 设置URL
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

        // 设置回调函数
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;response_data);

        // 执行请求
        CURLcode res = curl_easy_perform(curl);

        return (res == CURLE_OK);
    }

    const std::string&amp; getResponse() const {
        return response_data;
    }

    long getResponseCode() {
        long response_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
        return response_code;
    }
};
</code></pre>
<h3 id="2-http-post-请求"><a class="header" href="#2-http-post-请求">2. HTTP POST 请求</a></h3>
<pre><code class="language-cpp">class CurlPostClient {
private:
    CURL* curl;
    struct curl_slist* headers;

public:
    CurlPostClient() : curl(nullptr), headers(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
    }

    ~CurlPostClient() {
        if (headers) curl_slist_free_all(headers);
        if (curl) curl_easy_cleanup(curl);
        curl_global_cleanup();
    }

    bool postJson(const std::string&amp; url, const std::string&amp; json_data) {
        if (!curl) return false;

        // 设置请求头
        headers = curl_slist_append(headers, "Content-Type: application/json");
        headers = curl_slist_append(headers, "Accept: application/json");

        // 配置POST请求
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, json_data.length());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        // 执行请求
        CURLcode res = curl_easy_perform(curl);
        return (res == CURLE_OK);
    }

    bool postFormData(const std::string&amp; url, const std::map&lt;std::string, std::string&gt;&amp; form_data) {
        if (!curl) return false;

        curl_mime* mime = curl_mime_init(curl);

        // 添加表单字段
        for (const auto&amp; field : form_data) {
            curl_mimepart* part = curl_mime_addpart(mime);
            curl_mime_name(part, field.first.c_str());
            curl_mime_data(part, field.second.c_str(), CURL_ZERO_TERMINATED);
        }

        // 配置请求
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);

        CURLcode res = curl_easy_perform(curl);

        curl_mime_free(mime);
        return (res == CURLE_OK);
    }
};
</code></pre>
<h3 id="3-文件上传和下载"><a class="header" href="#3-文件上传和下载">3. 文件上传和下载</a></h3>
<pre><code class="language-cpp">class CurlFileTransfer {
private:
    CURL* curl;

    // 文件上传回调
    static size_t ReadCallback(void* ptr, size_t size, size_t nmemb, FILE* stream) {
        return fread(ptr, size, nmemb, stream);
    }

    // 文件下载回调
    static size_t WriteFileCallback(void* ptr, size_t size, size_t nmemb, FILE* stream) {
        return fwrite(ptr, size, nmemb, stream);
    }

public:
    CurlFileTransfer() : curl(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
    }

    ~CurlFileTransfer() {
        if (curl) curl_easy_cleanup(curl);
        curl_global_cleanup();
    }

    bool uploadFile(const std::string&amp; url, const std::string&amp; file_path, const std::string&amp; field_name = "file") {
        if (!curl) return false;

        FILE* file = fopen(file_path.c_str(), "rb");
        if (!file) return false;

        // 获取文件大小
        fseek(file, 0, SEEK_END);
        long file_size = ftell(file);
        fseek(file, 0, SEEK_SET);

        curl_mime* mime = curl_mime_init(curl);
        curl_mimepart* part = curl_mime_addpart(mime);

        curl_mime_name(part, field_name.c_str());
        curl_mime_filedata(part, file_path.c_str());

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);

        CURLcode res = curl_easy_perform(curl);

        curl_mime_free(mime);
        fclose(file);

        return (res == CURLE_OK);
    }

    bool downloadFile(const std::string&amp; url, const std::string&amp; local_path) {
        if (!curl) return false;

        FILE* file = fopen(local_path.c_str(), "wb");
        if (!file) return false;

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteFileCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);

        CURLcode res = curl_easy_perform(curl);

        fclose(file);
        return (res == CURLE_OK);
    }

    bool downloadWithProgress(const std::string&amp; url, const std::string&amp; local_path) {
        if (!curl) return false;

        FILE* file = fopen(local_path.c_str(), "wb");
        if (!file) return false;

        // 进度回调函数
        auto progress_callback = [](void* clientp, curl_off_t dltotal, curl_off_t dlnow,
                                   curl_off_t ultotal, curl_off_t ulnow) -&gt; int {
            if (dltotal &gt; 0) {
                double progress = (double)dlnow / (double)dltotal * 100.0;
                printf("\rDownload progress: %.2f%%", progress);
                fflush(stdout);
            }
            return 0;
        };

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteFileCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, file);
        curl_easy_setopt(curl, CURLOPT_XFERINFOFUNCTION, progress_callback);
        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);

        CURLcode res = curl_easy_perform(curl);

        fclose(file);
        printf("\n");
        return (res == CURLE_OK);
    }
};
</code></pre>
<h3 id="4-multi-interface-并发处理"><a class="header" href="#4-multi-interface-并发处理">4. Multi Interface 并发处理</a></h3>
<pre><code class="language-cpp">class CurlMultiClient {
private:
    CURLM* multi_handle;
    std::vector&lt;CURL*&gt; easy_handles;
    std::vector&lt;std::string&gt; responses;

public:
    CurlMultiClient() : multi_handle(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        multi_handle = curl_multi_init();
    }

    ~CurlMultiClient() {
        for (CURL* handle : easy_handles) {
            curl_multi_remove_handle(multi_handle, handle);
            curl_easy_cleanup(handle);
        }
        if (multi_handle) curl_multi_cleanup(multi_handle);
        curl_global_cleanup();
    }

    void addRequest(const std::string&amp; url) {
        CURL* easy_handle = curl_easy_init();
        if (!easy_handle) return;

        responses.push_back("");
        std::string* response_data = &amp;responses.back();

        curl_easy_setopt(easy_handle, CURLOPT_URL, url.c_str());
        curl_easy_setopt(easy_handle, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(easy_handle, CURLOPT_WRITEDATA, response_data);

        curl_multi_add_handle(multi_handle, easy_handle);
        easy_handles.push_back(easy_handle);
    }

    bool performAll() {
        if (!multi_handle) return false;

        int running_handles;
        CURLMcode mc = curl_multi_perform(multi_handle, &amp;running_handles);

        if (mc != CURLM_OK) return false;

        while (running_handles &gt; 0) {
            // 等待活动
            mc = curl_multi_wait(multi_handle, nullptr, 0, 1000, nullptr);
            if (mc != CURLM_OK) break;

            // 继续传输
            mc = curl_multi_perform(multi_handle, &amp;running_handles);
            if (mc != CURLM_OK) break;
        }

        // 检查消息
        int messages_left;
        CURLMsg* msg;
        while ((msg = curl_multi_info_read(multi_handle, &amp;messages_left))) {
            if (msg-&gt;msg == CURLMSG_DONE) {
                CURL* easy_handle = msg-&gt;easy_handle;
                CURLcode result = msg-&gt;data.result;

                if (result != CURLE_OK) {
                    std::cerr &lt;&lt; "Transfer failed: " &lt;&lt; curl_easy_strerror(result) &lt;&lt; std::endl;
                }
            }
        }

        return true;
    }

    const std::vector&lt;std::string&gt;&amp; getResponses() const {
        return responses;
    }
};
</code></pre>
<h2 id="高级功能配置"><a class="header" href="#高级功能配置">高级功能配置</a></h2>
<h3 id="1-ssltls-配置"><a class="header" href="#1-ssltls-配置">1. SSL/TLS 配置</a></h3>
<pre><code class="language-cpp">class CurlSSLClient {
private:
    CURL* curl;

public:
    CurlSSLClient() : curl(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
    }

    void configureSSL() {
        if (!curl) return;

        // SSL版本设置
        curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);

        // 证书验证
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);

        // 自定义CA证书路径
        // curl_easy_setopt(curl, CURLOPT_CAINFO, "/path/to/ca-cert.pem");

        // 客户端证书
        // curl_easy_setopt(curl, CURLOPT_SSLCERT, "/path/to/client-cert.pem");
        // curl_easy_setopt(curl, CURLOPT_SSLKEY, "/path/to/client-key.pem");

        // 禁用SSL验证（仅用于测试）
        // curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
        // curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);
    }

    void configureProxy() {
        if (!curl) return;

        // HTTP代理
        curl_easy_setopt(curl, CURLOPT_PROXY, "http://proxy.example.com:8080");
        curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_HTTP);

        // 代理认证
        curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, "username:password");

        // SOCKS5代理
        // curl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5);
    }
};
</code></pre>
<h3 id="2-认证机制"><a class="header" href="#2-认证机制">2. 认证机制</a></h3>
<pre><code class="language-cpp">class CurlAuthClient {
private:
    CURL* curl;

public:
    CurlAuthClient() : curl(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
    }

    // HTTP基本认证
    void setBasicAuth(const std::string&amp; username, const std::string&amp; password) {
        if (!curl) return;

        std::string userpwd = username + ":" + password;
        curl_easy_setopt(curl, CURLOPT_USERPWD, userpwd.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
    }

    // Bearer Token认证
    void setBearerToken(const std::string&amp; token) {
        if (!curl) return;

        std::string auth_header = "Authorization: Bearer " + token;
        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers, auth_header.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    }

    // OAuth 2.0认证
    void setOAuth2Token(const std::string&amp; token) {
        if (!curl) return;

        curl_easy_setopt(curl, CURLOPT_XOAUTH2_BEARER, token.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BEARER);
    }

    // 摘要认证
    void setDigestAuth(const std::string&amp; username, const std::string&amp; password) {
        if (!curl) return;

        std::string userpwd = username + ":" + password;
        curl_easy_setopt(curl, CURLOPT_USERPWD, userpwd.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);
    }
};
</code></pre>
<h3 id="3-cookie-管理"><a class="header" href="#3-cookie-管理">3. Cookie 管理</a></h3>
<pre><code class="language-cpp">class CurlCookieManager {
private:
    CURL* curl;
    std::string cookie_file;

public:
    CurlCookieManager(const std::string&amp; cookie_file_path = "cookies.txt")
        : curl(nullptr), cookie_file(cookie_file_path) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();
        setupCookies();
    }

    void setupCookies() {
        if (!curl) return;

        // 从文件读取Cookie
        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, cookie_file.c_str());

        // 将Cookie写入文件
        curl_easy_setopt(curl, CURLOPT_COOKIEJAR, cookie_file.c_str());

        // 启用Cookie引擎
        curl_easy_setopt(curl, CURLOPT_COOKIESESSION, 1L);
    }

    void addCustomCookie(const std::string&amp; cookie) {
        if (!curl) return;

        curl_easy_setopt(curl, CURLOPT_COOKIE, cookie.c_str());
    }

    void clearCookies() {
        if (!curl) return;

        // 清除所有Cookie
        curl_easy_setopt(curl, CURLOPT_COOKIELIST, "ALL");
    }

    ~CurlCookieManager() {
        if (curl) {
            // 刷新Cookie到文件
            curl_easy_setopt(curl, CURLOPT_COOKIELIST, "FLUSH");
            curl_easy_cleanup(curl);
        }
        curl_global_cleanup();
    }
};
</code></pre>
<h2 id="错误处理和调试"><a class="header" href="#错误处理和调试">错误处理和调试</a></h2>
<h3 id="1-错误处理机制"><a class="header" href="#1-错误处理机制">1. 错误处理机制</a></h3>
<pre><code class="language-cpp">class CurlErrorHandler {
private:
    CURL* curl;
    char error_buffer[CURL_ERROR_SIZE];

public:
    CurlErrorHandler() : curl(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();

        if (curl) {
            // 设置错误缓冲区
            curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, error_buffer);
        }
    }

    bool performWithErrorHandling(const std::string&amp; url) {
        if (!curl) return false;

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

        CURLcode res = curl_easy_perform(curl);

        if (res != CURLE_OK) {
            std::cerr &lt;&lt; "curl_easy_perform() failed: " &lt;&lt; curl_easy_strerror(res) &lt;&lt; std::endl;

            // 详细错误信息
            if (strlen(error_buffer)) {
                std::cerr &lt;&lt; "Error details: " &lt;&lt; error_buffer &lt;&lt; std::endl;
            }

            return false;
        }

        return true;
    }

    void getDetailedInfo() {
        if (!curl) return;

        long response_code;
        double total_time;
        double download_speed;
        char* effective_url = nullptr;

        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;response_code);
        curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &amp;total_time);
        curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD, &amp;download_speed);
        curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &amp;effective_url);

        std::cout &lt;&lt; "Response Code: " &lt;&lt; response_code &lt;&lt; std::endl;
        std::cout &lt;&lt; "Total Time: " &lt;&lt; total_time &lt;&lt; " seconds" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Download Speed: " &lt;&lt; download_speed &lt;&lt; " bytes/sec" &lt;&lt; std::endl;
        if (effective_url) {
            std::cout &lt;&lt; "Effective URL: " &lt;&lt; effective_url &lt;&lt; std::endl;
        }
    }
};
</code></pre>
<h3 id="2-调试和日志"><a class="header" href="#2-调试和日志">2. 调试和日志</a></h3>
<pre><code class="language-cpp">class CurlDebugger {
private:
    CURL* curl;

    // 调试回调函数
    static int DebugCallback(CURL* handle, curl_infotype type, char* data, size_t size, void* userptr) {
        std::string prefix;

        switch (type) {
            case CURLINFO_TEXT:
                prefix = "* Info: ";
                break;
            case CURLINFO_HEADER_OUT:
                prefix = "&gt; Header: ";
                break;
            case CURLINFO_DATA_OUT:
                prefix = "&gt; Data: ";
                break;
            case CURLINFO_SSL_DATA_OUT:
                prefix = "&gt; SSL Data: ";
                break;
            case CURLINFO_HEADER_IN:
                prefix = "&lt; Header: ";
                break;
            case CURLINFO_DATA_IN:
                prefix = "&lt; Data: ";
                break;
            case CURLINFO_SSL_DATA_IN:
                prefix = "&lt; SSL Data: ";
                break;
            default:
                return 0;
        }

        std::string debug_data(data, size);
        std::cout &lt;&lt; prefix &lt;&lt; debug_data;

        return 0;
    }

public:
    CurlDebugger() : curl(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();

        if (curl) {
            // 启用详细调试
            curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);
            curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, DebugCallback);
            curl_easy_setopt(curl, CURLOPT_DEBUGDATA, this);
        }
    }
};
</code></pre>
<h2 id="性能优化策略"><a class="header" href="#性能优化策略">性能优化策略</a></h2>
<h3 id="1-连接复用"><a class="header" href="#1-连接复用">1. 连接复用</a></h3>
<pre><code class="language-cpp">class CurlConnectionPool {
private:
    CURLSH* share_handle;
    std::vector&lt;CURL*&gt; easy_handles;

public:
    CurlConnectionPool() : share_handle(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);

        // 创建共享句柄
        share_handle = curl_share_init();

        // 共享DNS缓存
        curl_share_setopt(share_handle, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);

        // 共享SSL会话
        curl_share_setopt(share_handle, CURLSHOPT_SHARE, CURL_LOCK_DATA_SSL_SESSION);

        // 共享连接缓存
        curl_share_setopt(share_handle, CURLSHOPT_SHARE, CURL_LOCK_DATA_CONNECT);
    }

    CURL* getEasyHandle() {
        CURL* easy_handle = curl_easy_init();
        if (easy_handle) {
            // 设置共享句柄
            curl_easy_setopt(easy_handle, CURLOPT_SHARE, share_handle);

            // 启用连接复用
            curl_easy_setopt(easy_handle, CURLOPT_TCP_KEEPALIVE, 1L);
            curl_easy_setopt(easy_handle, CURLOPT_TCP_KEEPIDLE, 120L);
            curl_easy_setopt(easy_handle, CURLOPT_TCP_KEEPINTVL, 60L);

            easy_handles.push_back(easy_handle);
        }
        return easy_handle;
    }

    ~CurlConnectionPool() {
        for (CURL* handle : easy_handles) {
            curl_easy_cleanup(handle);
        }
        if (share_handle) curl_share_cleanup(share_handle);
        curl_global_cleanup();
    }
};
</code></pre>
<h3 id="2-内存优化"><a class="header" href="#2-内存优化">2. 内存优化</a></h3>
<pre><code class="language-cpp">class CurlMemoryOptimizer {
private:
    CURL* curl;

public:
    CurlMemoryOptimizer() : curl(nullptr) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
        curl = curl_easy_init();

        if (curl) {
            // 设置缓冲区大小
            curl_easy_setopt(curl, CURLOPT_BUFFERSIZE, 32768L);

            // 限制重定向次数
            curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 10L);

            // 设置超时
            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
            curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 10L);

            // 禁用信号处理
            curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);
        }
    }
};
</code></pre>
<h2 id="编译和部署"><a class="header" href="#编译和部署">编译和部署</a></h2>
<h3 id="1-cmake配置"><a class="header" href="#1-cmake配置">1. CMake配置</a></h3>
<pre><code class="language-cmake"># 查找libcurl
find_package(CURL REQUIRED)

# 或者使用pkg-config
find_package(PkgConfig REQUIRED)
pkg_check_modules(CURL REQUIRED libcurl)

# 链接库
target_link_libraries(${PROJECT_NAME}
    ${CURL_LIBRARIES}
)

# 包含头文件目录
target_include_directories(${PROJECT_NAME} PRIVATE
    ${CURL_INCLUDE_DIRS}
)

# 编译器定义
target_compile_definitions(${PROJECT_NAME} PRIVATE
    ${CURL_CFLAGS_OTHER}
)
</code></pre>
<h3 id="2-依赖安装"><a class="header" href="#2-依赖安装">2. 依赖安装</a></h3>
<pre><code class="language-bash"># Ubuntu/Debian系统
sudo apt-get install libcurl4-openssl-dev

# CentOS/RHEL系统
sudo yum install libcurl-devel

# 或者使用curl开发版本
sudo yum install curl-devel

# macOS系统
brew install curl

# Windows系统
# 下载预编译的libcurl库或使用vcpkg
vcpkg install curl
</code></pre>
<h2 id="实际应用场景"><a class="header" href="#实际应用场景">实际应用场景</a></h2>
<h3 id="1-rest-api客户端"><a class="header" href="#1-rest-api客户端">1. REST API客户端</a></h3>
<pre><code class="language-cpp">class RestApiClient {
private:
    CurlEasyClient client;
    std::string base_url;
    std::map&lt;std::string, std::string&gt; default_headers;

public:
    RestApiClient(const std::string&amp; base_url) : base_url(base_url) {
        default_headers["Content-Type"] = "application/json";
        default_headers["Accept"] = "application/json";
    }

    bool get(const std::string&amp; endpoint, std::string&amp; response) {
        std::string url = base_url + endpoint;
        return client.get(url) &amp;&amp; (response = client.getResponse(), true);
    }

    bool post(const std::string&amp; endpoint, const std::string&amp; data, std::string&amp; response) {
        // 实现POST请求逻辑
        return true;
    }

    bool put(const std::string&amp; endpoint, const std::string&amp; data, std::string&amp; response) {
        // 实现PUT请求逻辑
        return true;
    }

    bool delete_resource(const std::string&amp; endpoint, std::string&amp; response) {
        // 实现DELETE请求逻辑
        return true;
    }
};
</code></pre>
<h3 id="2-文件下载管理器"><a class="header" href="#2-文件下载管理器">2. 文件下载管理器</a></h3>
<pre><code class="language-cpp">class DownloadManager {
private:
    CurlMultiClient multi_client;
    std::vector&lt;std::string&gt; urls;
    std::string download_dir;

public:
    DownloadManager(const std::string&amp; dir) : download_dir(dir) {}

    void addDownload(const std::string&amp; url) {
        urls.push_back(url);
        multi_client.addRequest(url);
    }

    bool downloadAll() {
        return multi_client.performAll();
    }

    void getProgress() {
        // 实现下载进度监控
    }
};
</code></pre>
<h3 id="3-网络监控工具"><a class="header" href="#3-网络监控工具">3. 网络监控工具</a></h3>
<pre><code class="language-cpp">class NetworkMonitor {
private:
    std::vector&lt;std::string&gt; monitor_urls;
    std::chrono::milliseconds check_interval;

public:
    NetworkMonitor(std::chrono::milliseconds interval) : check_interval(interval) {}

    void addMonitorUrl(const std::string&amp; url) {
        monitor_urls.push_back(url);
    }

    void startMonitoring() {
        while (true) {
            for (const auto&amp; url : monitor_urls) {
                checkUrl(url);
            }
            std::this_thread::sleep_for(check_interval);
        }
    }

private:
    void checkUrl(const std::string&amp; url) {
        CurlEasyClient client;
        auto start = std::chrono::high_resolution_clock::now();

        bool success = client.get(url);

        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);

        if (success) {
            std::cout &lt;&lt; "URL: " &lt;&lt; url &lt;&lt; " - OK (" &lt;&lt; duration.count() &lt;&lt; "ms)" &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "URL: " &lt;&lt; url &lt;&lt; " - FAILED" &lt;&lt; std::endl;
        }
    }
};
</code></pre>
<h2 id="技术要点总结"><a class="header" href="#技术要点总结">技术要点总结</a></h2>
<ol>
<li><strong>简单易用</strong>：Easy Interface提供了直观的API设计</li>
<li><strong>高性能</strong>：Multi Interface支持高并发网络操作</li>
<li><strong>安全可靠</strong>：完善的SSL/TLS支持和多种认证机制</li>
<li><strong>跨平台</strong>：优秀的平台兼容性和移植性</li>
<li><strong>功能丰富</strong>：支持多种网络协议和传输方式</li>
<li><strong>资源管理</strong>：良好的内存管理和连接复用机制</li>
</ol>
<p>LibCurl是C++网络编程的重要工具，其强大的功能和稳定的性能使其成为开发网络应用程序的首选库。无论是简单的HTTP请求还是复杂的多协议通信，LibCurl都能提供可靠的解决方案。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/c++/gstreamer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/c++/live555.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/c++/gstreamer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/c++/live555.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

