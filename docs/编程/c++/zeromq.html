<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZeroMQ (Ã˜MQ) å®Œæ•´å­¦ä¹ æŒ‡å— - å¼€å‘</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">å¼€å‘</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="æœç´¢æœ¬ä¹¦å†…å®¹..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="zeromq-Ã˜mq-å®Œæ•´å­¦ä¹ æŒ‡å—"><a class="header" href="#zeromq-Ã˜mq-å®Œæ•´å­¦ä¹ æŒ‡å—">ZeroMQ (Ã˜MQ) å®Œæ•´å­¦ä¹ æŒ‡å—</a></h1>
<h2 id="-è¯¾ç¨‹æ¦‚è¿°"><a class="header" href="#-è¯¾ç¨‹æ¦‚è¿°">ğŸ“š è¯¾ç¨‹æ¦‚è¿°</a></h2>
<h3 id="æŠ€æœ¯å®šä½"><a class="header" href="#æŠ€æœ¯å®šä½">æŠ€æœ¯å®šä½</a></h3>
<p>ZeroMQï¼ˆÃ˜MQï¼‰æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½å¼‚æ­¥æ¶ˆæ¯åº“ï¼Œä¸“ä¸ºåˆ†å¸ƒå¼å’Œå¹¶å‘åº”ç”¨ç¨‹åºè®¾è®¡ã€‚å®ƒæä¾›äº†ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ï¼Œä½†ä¸ä¼ ç»Ÿçš„é¢å‘æ¶ˆæ¯ä¸­é—´ä»¶ï¼ˆå¦‚RabbitMQã€Kafkaï¼‰ä¸åŒï¼ŒZeroMQçš„è¿è¡Œ<strong>ä¸éœ€è¦ä¸“é—¨çš„æ¶ˆæ¯ä»£ç†ï¼ˆbrokerï¼‰</strong>ï¼Œå…·æœ‰<strong>å»ä¸­å¿ƒåŒ–ã€ä½å»¶è¿Ÿã€é«˜åå</strong>çš„ç‰¹ç‚¹ã€‚</p>
<h3 id="æ ¸å¿ƒç‰¹æ€§"><a class="header" href="#æ ¸å¿ƒç‰¹æ€§">æ ¸å¿ƒç‰¹æ€§</a></h3>
<ul>
<li><strong>æ— ä»£ç†æ¶æ„ï¼ˆBrokerlessï¼‰</strong>ï¼šç‚¹å¯¹ç‚¹é€šä¿¡ï¼Œæ— éœ€ä¸­é—´ä»¶</li>
<li><strong>å¤šç§æ¶ˆæ¯æ¨¡å¼</strong>ï¼šæ”¯æŒè¯·æ±‚-åº”ç­”ã€å‘å¸ƒ-è®¢é˜…ã€æ¨æ‹‰ã€è·¯ç”±ç­‰æ¨¡å¼</li>
<li><strong>å¼‚æ­¥I/Oå¤„ç†</strong>ï¼šåŸºäºäº‹ä»¶é©±åŠ¨çš„é«˜æ€§èƒ½ç½‘ç»œå¼•æ“</li>
<li><strong>å¤šè¯­è¨€ç»‘å®š</strong>ï¼šæ”¯æŒ40+ç§ç¼–ç¨‹è¯­è¨€</li>
<li><strong>é«˜æ€§èƒ½å’Œä½å»¶è¿Ÿ</strong>ï¼šå¾®ç§’çº§å»¶è¿Ÿï¼Œç™¾ä¸‡çº§æ¶ˆæ¯/ç§’</li>
<li><strong>å†…ç½®è´Ÿè½½å‡è¡¡</strong>ï¼šè‡ªåŠ¨åˆ†å‘æ¶ˆæ¯åˆ°å¤šä¸ªå·¥ä½œè€…</li>
<li><strong>è‡ªåŠ¨é‡è¿æœºåˆ¶</strong>ï¼šç½‘ç»œä¸­æ–­åè‡ªåŠ¨æ¢å¤è¿æ¥</li>
<li><strong>é›¶æ‹·è´æŠ€æœ¯</strong>ï¼šæœ€å°åŒ–å†…å­˜æ‹·è´ï¼Œæå‡æ€§èƒ½</li>
</ul>
<h3 id="å­¦ä¹ ç›®æ ‡"><a class="header" href="#å­¦ä¹ ç›®æ ‡">å­¦ä¹ ç›®æ ‡</a></h3>
<p><strong>åˆçº§ç›®æ ‡ï¼ˆ0-1ä¸ªæœˆï¼‰</strong></p>
<ul>
<li>ç†è§£ZeroMQçš„æ¶æ„å’Œè®¾è®¡ç†å¿µ</li>
<li>æŒæ¡5ç§åŸºæœ¬æ¶ˆæ¯æ¨¡å¼</li>
<li>èƒ½å¤Ÿæ­å»ºç®€å•çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨åº”ç”¨</li>
<li>ç†è§£socketç±»å‹å’Œé€šä¿¡æ¨¡å¼</li>
</ul>
<p><strong>ä¸­çº§ç›®æ ‡ï¼ˆ1-3ä¸ªæœˆï¼‰</strong></p>
<ul>
<li>æŒæ¡é«˜çº§ç‰¹æ€§ï¼ˆå¤šéƒ¨åˆ†æ¶ˆæ¯ã€è½®è¯¢ã€ä»£ç†ï¼‰</li>
<li>å®ç°å¯é çš„é”™è¯¯å¤„ç†å’Œé‡è¿æœºåˆ¶</li>
<li>æ€§èƒ½ä¼˜åŒ–å’Œå‚æ•°è°ƒä¼˜</li>
<li>æ„å»ºåˆ†å¸ƒå¼ä»»åŠ¡å¤„ç†ç³»ç»Ÿ</li>
</ul>
<p><strong>é«˜çº§ç›®æ ‡ï¼ˆ3-6ä¸ªæœˆï¼‰</strong></p>
<ul>
<li>è®¾è®¡é«˜å¯ç”¨çš„æ¶ˆæ¯æ¶æ„</li>
<li>å®ç°å¤æ‚çš„è·¯ç”±å’Œè´Ÿè½½å‡è¡¡</li>
<li>ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œç›‘æ§</li>
<li>ä¸å…¶ä»–ç³»ç»Ÿé›†æˆï¼ˆå¦‚å¾®æœåŠ¡æ¶æ„ï¼‰</li>
</ul>
<h3 id="é€‚ç”¨åœºæ™¯"><a class="header" href="#é€‚ç”¨åœºæ™¯">é€‚ç”¨åœºæ™¯</a></h3>
<p>âœ… <strong>é€‚åˆä½¿ç”¨ZeroMQçš„åœºæ™¯ï¼š</strong></p>
<ul>
<li>å¾®æœåŠ¡ä¹‹é—´çš„é€šä¿¡</li>
<li>å®æ—¶æ•°æ®æµå¤„ç†</li>
<li>åˆ†å¸ƒå¼ä»»åŠ¡é˜Ÿåˆ—</li>
<li>æ¸¸æˆæœåŠ¡å™¨æ¶ˆæ¯ä¼ é€’</li>
<li>é‡‘èäº¤æ˜“ç³»ç»Ÿ</li>
<li>IoTè®¾å¤‡é€šä¿¡</li>
<li>æ—¥å¿—æ”¶é›†å’Œèšåˆ</li>
</ul>
<p>âŒ <strong>ä¸é€‚åˆä½¿ç”¨ZeroMQçš„åœºæ™¯ï¼š</strong></p>
<ul>
<li>éœ€è¦æ¶ˆæ¯æŒä¹…åŒ–å’Œäº‹åŠ¡æ”¯æŒ</li>
<li>éœ€è¦å¤æ‚çš„æ¶ˆæ¯è·¯ç”±è§„åˆ™</li>
<li>éœ€è¦Webç®¡ç†ç•Œé¢</li>
<li>å›¢é˜Ÿç¼ºä¹åˆ†å¸ƒå¼ç³»ç»Ÿç»éªŒ</li>
</ul>
<hr />
<h2 id="-ç¯å¢ƒæ­å»º"><a class="header" href="#-ç¯å¢ƒæ­å»º">ğŸ”§ ç¯å¢ƒæ­å»º</a></h2>
<h3 id="ç¬¬ä¸€æ­¥å®‰è£…zeromqåº“"><a class="header" href="#ç¬¬ä¸€æ­¥å®‰è£…zeromqåº“">ç¬¬ä¸€æ­¥ï¼šå®‰è£…ZeroMQåº“</a></h3>
<h4 id="ubuntudebian"><a class="header" href="#ubuntudebian">Ubuntu/Debian</a></h4>
<pre><code class="language-bash"># æ›´æ–°åŒ…ç®¡ç†å™¨
sudo apt-get update

# å®‰è£…ZeroMQå¼€å‘åº“
sudo apt-get install -y libzmq3-dev

# éªŒè¯å®‰è£…
dpkg -l | grep libzmq
</code></pre>
<h4 id="centosrhel"><a class="header" href="#centosrhel">CentOS/RHEL</a></h4>
<pre><code class="language-bash"># å®‰è£…EPELä»“åº“
sudo yum install -y epel-release

# å®‰è£…ZeroMQ
sudo yum install -y zeromq-devel

# éªŒè¯å®‰è£…
rpm -qa | grep zeromq
</code></pre>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<pre><code class="language-bash"># ä½¿ç”¨Homebrewå®‰è£…
brew install zeromq

# éªŒè¯å®‰è£…
brew info zeromq
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<pre><code class="language-powershell"># ä½¿ç”¨vcpkgå®‰è£…
vcpkg install zeromq
vcpkg install cppzmq

# æˆ–è€…ä¸‹è½½é¢„ç¼–è¯‘äºŒè¿›åˆ¶åŒ…
# https://github.com/zeromq/libzmq/releases
</code></pre>
<h3 id="ç¬¬äºŒæ­¥å®‰è£…cç»‘å®šcppzmq"><a class="header" href="#ç¬¬äºŒæ­¥å®‰è£…cç»‘å®šcppzmq">ç¬¬äºŒæ­¥ï¼šå®‰è£…C++ç»‘å®šï¼ˆcppzmqï¼‰</a></h3>
<pre><code class="language-bash"># å…‹éš†cppzmqä»“åº“
git clone https://github.com/zeromq/cppzmq.git
cd cppzmq

# å®‰è£…ï¼ˆä»…å¤´æ–‡ä»¶åº“ï¼‰
sudo cp *.hpp /usr/local/include/

# æˆ–ä½¿ç”¨CMakeå®‰è£…
mkdir build &amp;&amp; cd build
cmake ..
sudo make install
</code></pre>
<h3 id="ç¬¬ä¸‰æ­¥éªŒè¯ç¯å¢ƒ"><a class="header" href="#ç¬¬ä¸‰æ­¥éªŒè¯ç¯å¢ƒ">ç¬¬ä¸‰æ­¥ï¼šéªŒè¯ç¯å¢ƒ</a></h3>
<p>åˆ›å»ºæµ‹è¯•æ–‡ä»¶ <code>test_zmq.cpp</code>ï¼š</p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;

int main() {
    zmq::context_t context(1);
    zmq::socket_t socket(context, zmq::socket_type::rep);

    std::cout &lt;&lt; "ZeroMQ version: "
              &lt;&lt; ZMQ_VERSION_MAJOR &lt;&lt; "."
              &lt;&lt; ZMQ_VERSION_MINOR &lt;&lt; "."
              &lt;&lt; ZMQ_VERSION_PATCH &lt;&lt; std::endl;

    std::cout &lt;&lt; "ZeroMQ C++ binding installed successfully!" &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>ç¼–è¯‘è¿è¡Œï¼š</p>
<pre><code class="language-bash"># ç¼–è¯‘
g++ -std=c++17 test_zmq.cpp -o test_zmq -lzmq

# è¿è¡Œ
./test_zmq
</code></pre>
<p>é¢„æœŸè¾“å‡ºï¼š</p>
<pre><code>ZeroMQ version: 4.3.4
ZeroMQ C++ binding installed successfully!
</code></pre>
<hr />
<h2 id="-æ ¸å¿ƒæ¦‚å¿µ"><a class="header" href="#-æ ¸å¿ƒæ¦‚å¿µ">ğŸ“– æ ¸å¿ƒæ¦‚å¿µ</a></h2>
<h3 id="1-contextä¸Šä¸‹æ–‡"><a class="header" href="#1-contextä¸Šä¸‹æ–‡">1. Contextï¼ˆä¸Šä¸‹æ–‡ï¼‰</a></h3>
<p>Contextæ˜¯ZeroMQçš„æ ¸å¿ƒå¯¹è±¡ï¼Œç®¡ç†æ‰€æœ‰socketå’ŒI/Oçº¿ç¨‹ã€‚</p>
<pre><code class="language-cpp">// åˆ›å»ºä¸Šä¸‹æ–‡ï¼ˆå‚æ•°ä¸ºI/Oçº¿ç¨‹æ•°ï¼‰
zmq::context_t context(1);  // å•çº¿ç¨‹
zmq::context_t context(4);  // 4ä¸ªI/Oçº¿ç¨‹ï¼ˆé€‚åˆå¤šæ ¸CPUï¼‰
</code></pre>
<p><strong>æœ€ä½³å®è·µï¼š</strong></p>
<ul>
<li>ä¸€ä¸ªè¿›ç¨‹é€šå¸¸åªéœ€è¦ä¸€ä¸ªcontext</li>
<li>I/Oçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° - 1</li>
<li>ç¨‹åºé€€å‡ºå‰ç¡®ä¿é”€æ¯æ‰€æœ‰socketåå†é”€æ¯context</li>
</ul>
<h3 id="2-socketå¥—æ¥å­—"><a class="header" href="#2-socketå¥—æ¥å­—">2. Socketï¼ˆå¥—æ¥å­—ï¼‰</a></h3>
<p>ZeroMQæä¾›å¤šç§socketç±»å‹ï¼Œæ¯ç§ç±»å‹é€‚ç”¨äºä¸åŒçš„é€šä¿¡æ¨¡å¼ã€‚</p>
<h4 id="socketç±»å‹å¯¹ç…§è¡¨"><a class="header" href="#socketç±»å‹å¯¹ç…§è¡¨">Socketç±»å‹å¯¹ç…§è¡¨</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Socketç±»å‹</th><th>æ¨¡å¼</th><th>ç‰¹ç‚¹</th><th>å…¸å‹åº”ç”¨</th></tr></thead><tbody>
<tr><td>ZMQ_REQ</td><td>è¯·æ±‚è€…</td><td>å¿…é¡»å…ˆsendå†recv</td><td>å®¢æˆ·ç«¯</td></tr>
<tr><td>ZMQ_REP</td><td>åº”ç­”è€…</td><td>å¿…é¡»å…ˆrecvå†send</td><td>æœåŠ¡å™¨</td></tr>
<tr><td>ZMQ_PUB</td><td>å‘å¸ƒè€…</td><td>åªå‘é€ï¼Œä¸æ¥æ”¶</td><td>å¹¿æ’­æ¶ˆæ¯</td></tr>
<tr><td>ZMQ_SUB</td><td>è®¢é˜…è€…</td><td>åªæ¥æ”¶ï¼Œéœ€è®¾ç½®è¿‡æ»¤å™¨</td><td>æ¥æ”¶å¹¿æ’­</td></tr>
<tr><td>ZMQ_PUSH</td><td>æ¨é€è€…</td><td>è´Ÿè½½å‡è¡¡æ¨é€</td><td>ä»»åŠ¡åˆ†å‘</td></tr>
<tr><td>ZMQ_PULL</td><td>æ‹‰å–è€…</td><td>å…¬å¹³é˜Ÿåˆ—æ¥æ”¶</td><td>ä»»åŠ¡å¤„ç†</td></tr>
<tr><td>ZMQ_ROUTER</td><td>è·¯ç”±å™¨</td><td>å¼‚æ­¥è·¯ç”±ï¼Œå¯å¯»å€</td><td>é«˜çº§è·¯ç”±</td></tr>
<tr><td>ZMQ_DEALER</td><td>åˆ†å‘å™¨</td><td>å¼‚æ­¥è´Ÿè½½å‡è¡¡</td><td>å¹¶å‘å¤„ç†</td></tr>
<tr><td>ZMQ_PAIR</td><td>é…å¯¹</td><td>ä¸€å¯¹ä¸€ä¸“ç”¨é€šé“</td><td>è¿›ç¨‹å†…é€šä¿¡</td></tr>
</tbody></table>
</div>
<h3 id="3-transportä¼ è¾“åè®®"><a class="header" href="#3-transportä¼ è¾“åè®®">3. Transportï¼ˆä¼ è¾“åè®®ï¼‰</a></h3>
<p>ZeroMQæ”¯æŒå¤šç§ä¼ è¾“åè®®ï¼š</p>
<pre><code class="language-cpp">// TCPåè®®ï¼ˆè·¨ç½‘ç»œï¼‰
socket.bind("tcp://*:5555");
socket.connect("tcp://192.168.1.100:5555");

// IPCåè®®ï¼ˆåŒæœºè¿›ç¨‹é—´ï¼‰
socket.bind("ipc:///tmp/feeds/0");
socket.connect("ipc:///tmp/feeds/0");

// inprocåè®®ï¼ˆè¿›ç¨‹å†…çº¿ç¨‹é—´ï¼‰
socket.bind("inproc://my-endpoint");
socket.connect("inproc://my-endpoint");

// PGM/EPGMåè®®ï¼ˆå¤šæ’­ï¼‰
socket.bind("epgm://eth0;239.192.1.1:5555");
</code></pre>
<p><strong>åè®®é€‰æ‹©å»ºè®®ï¼š</strong></p>
<ul>
<li><strong>tcp://</strong> - è·¨æœºå™¨é€šä¿¡ï¼Œæœ€å¸¸ç”¨</li>
<li><strong>ipc://</strong> - åŒæœºå™¨ä¸åŒè¿›ç¨‹ï¼Œæ€§èƒ½å¥½</li>
<li><strong>inproc://</strong> - åŒè¿›ç¨‹ä¸åŒçº¿ç¨‹ï¼Œæ€§èƒ½æœ€ä½³</li>
<li><strong>pgm://</strong> - éœ€è¦å¤šæ’­åœºæ™¯ï¼ˆä¸å¯é ï¼‰</li>
</ul>
<hr />
<h2 id="-äº”å¤§æ¶ˆæ¯æ¨¡å¼è¯¦è§£"><a class="header" href="#-äº”å¤§æ¶ˆæ¯æ¨¡å¼è¯¦è§£">ğŸ¯ äº”å¤§æ¶ˆæ¯æ¨¡å¼è¯¦è§£</a></h2>
<h3 id="æ¨¡å¼1è¯·æ±‚-åº”ç­”æ¨¡å¼req-rep"><a class="header" href="#æ¨¡å¼1è¯·æ±‚-åº”ç­”æ¨¡å¼req-rep">æ¨¡å¼1ï¼šè¯·æ±‚-åº”ç­”æ¨¡å¼ï¼ˆREQ-REPï¼‰</a></h3>
<p><strong>ä½¿ç”¨åœºæ™¯ï¼š</strong> å®¢æˆ·ç«¯-æœåŠ¡å™¨åŒæ­¥é€šä¿¡ï¼ŒRPCè°ƒç”¨</p>
<h4 id="å®Œæ•´å®ç°ç¤ºä¾‹"><a class="header" href="#å®Œæ•´å®ç°ç¤ºä¾‹">å®Œæ•´å®ç°ç¤ºä¾‹</a></h4>
<p><strong>æœåŠ¡å™¨ç«¯ï¼ˆserver.cppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

class ZMQServer {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    bool running;

public:
    ZMQServer() : context(1), socket(context, ZMQ_REP), running(false) {
        socket.bind("tcp://*:5555");
        std::cout &lt;&lt; "Server listening on port 5555..." &lt;&lt; std::endl;
    }

    void run() {
        running = true;
        while (running) {
            try {
                zmq::message_t request;

                // æ¥æ”¶è¯·æ±‚ï¼ˆé˜»å¡ï¼‰
                auto result = socket.recv(request, zmq::recv_flags::none);
                if (!result) continue;

                std::string req_str = std::string(
                    static_cast&lt;char*&gt;(request.data()),
                    request.size()
                );
                std::cout &lt;&lt; "Received: " &lt;&lt; req_str &lt;&lt; std::endl;

                // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
                std::this_thread::sleep_for(std::chrono::milliseconds(100));

                // å‘é€åº”ç­”
                std::string reply = "Echo: " + req_str;
                zmq::message_t response(reply.length());
                memcpy(response.data(), reply.c_str(), reply.length());
                socket.send(response, zmq::send_flags::none);

            } catch (const zmq::error_t&amp; e) {
                std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
            }
        }
    }

    void stop() {
        running = false;
    }
};

int main() {
    ZMQServer server;
    server.run();
    return 0;
}
</code></pre>
<p><strong>å®¢æˆ·ç«¯ï¼ˆclient.cppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class ZMQClient {
private:
    zmq::context_t context;
    zmq::socket_t socket;

public:
    ZMQClient() : context(1), socket(context, ZMQ_REQ) {
        std::cout &lt;&lt; "Connecting to server..." &lt;&lt; std::endl;
        socket.connect("tcp://localhost:5555");
    }

    std::string sendRequest(const std::string&amp; message) {
        // å‘é€è¯·æ±‚
        zmq::message_t request(message.length());
        memcpy(request.data(), message.c_str(), message.length());
        socket.send(request, zmq::send_flags::none);

        // æ¥æ”¶åº”ç­”
        zmq::message_t reply;
        socket.recv(reply, zmq::recv_flags::none);

        return std::string(static_cast&lt;char*&gt;(reply.data()), reply.size());
    }
};

int main() {
    ZMQClient client;

    for (int i = 0; i &lt; 10; ++i) {
        std::string request = "Hello " + std::to_string(i);
        std::cout &lt;&lt; "Sending: " &lt;&lt; request &lt;&lt; std::endl;

        std::string reply = client.sendRequest(request);
        std::cout &lt;&lt; "Received: " &lt;&lt; reply &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p><strong>æ³¨æ„äº‹é¡¹ï¼š</strong></p>
<ul>
<li>REQå¿…é¡»ä¸¥æ ¼éµå¾ª send â†’ recv â†’ send â†’ recv çš„é¡ºåº</li>
<li>REPå¿…é¡»ä¸¥æ ¼éµå¾ª recv â†’ send â†’ recv â†’ send çš„é¡ºåº</li>
<li>è¿åé¡ºåºä¼šå¯¼è‡´çŠ¶æ€æœºé”™è¯¯</li>
</ul>
<hr />
<h3 id="æ¨¡å¼2å‘å¸ƒ-è®¢é˜…æ¨¡å¼pub-sub"><a class="header" href="#æ¨¡å¼2å‘å¸ƒ-è®¢é˜…æ¨¡å¼pub-sub">æ¨¡å¼2ï¼šå‘å¸ƒ-è®¢é˜…æ¨¡å¼ï¼ˆPUB-SUBï¼‰</a></h3>
<p><strong>ä½¿ç”¨åœºæ™¯ï¼š</strong> ä¸€å¯¹å¤šå¹¿æ’­ï¼Œäº‹ä»¶é€šçŸ¥ï¼Œæ•°æ®åˆ†å‘</p>
<h4 id="å®Œæ•´å®ç°ç¤ºä¾‹-1"><a class="header" href="#å®Œæ•´å®ç°ç¤ºä¾‹-1">å®Œæ•´å®ç°ç¤ºä¾‹</a></h4>
<p><strong>å‘å¸ƒè€…ï¼ˆpublisher.cppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;

class ZMQPublisher {
private:
    zmq::context_t context;
    zmq::socket_t socket;

public:
    ZMQPublisher() : context(1), socket(context, ZMQ_PUB) {
        socket.bind("tcp://*:5556");
        // é‡è¦ï¼šç»™è®¢é˜…è€…æ—¶é—´è¿æ¥ï¼ˆæ…¢è¿æ¥é—®é¢˜ï¼‰
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        std::cout &lt;&lt; "Publisher started on port 5556" &lt;&lt; std::endl;
    }

    void publish(const std::string&amp; topic, const std::string&amp; message) {
        std::string full_message = topic + " " + message;
        zmq::message_t zmq_message(full_message.length());
        memcpy(zmq_message.data(), full_message.c_str(), full_message.length());
        socket.send(zmq_message, zmq::send_flags::none);

        std::cout &lt;&lt; "Published: " &lt;&lt; full_message &lt;&lt; std::endl;
    }

    void run() {
        int message_count = 0;
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution&lt;&gt; dis(15, 30);

        while (true) {
            // å‘å¸ƒå¤©æ°”ä¿¡æ¯
            int temperature = dis(gen);
            publish("weather", "Temperature: " + std::to_string(temperature) + "Â°C");

            // å‘å¸ƒæ–°é—»
            publish("news", "Breaking news #" + std::to_string(message_count));

            // å‘å¸ƒä½“è‚²ä¿¡æ¯
            publish("sports", "Score update: " + std::to_string(message_count));

            message_count++;
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
};

int main() {
    ZMQPublisher publisher;
    publisher.run();
    return 0;
}
</code></pre>
<p><strong>è®¢é˜…è€…ï¼ˆsubscriber.cppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

class ZMQSubscriber {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    std::vector&lt;std::string&gt; topics;

public:
    ZMQSubscriber(const std::vector&lt;std::string&gt;&amp; filter_topics = {""})
        : context(1), socket(context, ZMQ_SUB), topics(filter_topics) {

        socket.connect("tcp://localhost:5556");

        // è®¾ç½®è®¢é˜…è¿‡æ»¤å™¨ï¼ˆå¯ä»¥è®¾ç½®å¤šä¸ªï¼‰
        for (const auto&amp; topic : topics) {
            socket.setsockopt(ZMQ_SUBSCRIBE, topic.c_str(), topic.length());
            std::cout &lt;&lt; "Subscribed to: " &lt;&lt; (topic.empty() ? "ALL" : topic) &lt;&lt; std::endl;
        }
    }

    void run() {
        while (true) {
            zmq::message_t message;
            auto result = socket.recv(message, zmq::recv_flags::none);

            if (result) {
                std::string msg_str = std::string(
                    static_cast&lt;char*&gt;(message.data()),
                    message.size()
                );
                std::cout &lt;&lt; "[Received] " &lt;&lt; msg_str &lt;&lt; std::endl;
            }
        }
    }
};

int main(int argc, char* argv[]) {
    std::vector&lt;std::string&gt; topics;

    if (argc &gt; 1) {
        // ä»å‘½ä»¤è¡Œå‚æ•°è·å–è®¢é˜…ä¸»é¢˜
        for (int i = 1; i &lt; argc; ++i) {
            topics.push_back(argv[i]);
        }
    } else {
        // é»˜è®¤è®¢é˜…weatherä¸»é¢˜
        topics.push_back("weather");
    }

    ZMQSubscriber subscriber(topics);
    subscriber.run();

    return 0;
}
</code></pre>
<p><strong>è¿è¡Œç¤ºä¾‹ï¼š</strong></p>
<pre><code class="language-bash"># ç»ˆç«¯1ï¼šå¯åŠ¨å‘å¸ƒè€…
./publisher

# ç»ˆç«¯2ï¼šè®¢é˜…weatherä¸»é¢˜
./subscriber weather

# ç»ˆç«¯3ï¼šè®¢é˜…newsä¸»é¢˜
./subscriber news

# ç»ˆç«¯4ï¼šè®¢é˜…æ‰€æœ‰ä¸»é¢˜
./subscriber
</code></pre>
<p><strong>å…³é”®çŸ¥è¯†ç‚¹ï¼š</strong></p>
<ol>
<li>
<p><strong>æ…¢è¿æ¥é—®é¢˜ï¼ˆSlow Joinerï¼‰</strong>ï¼šè®¢é˜…è€…è¿æ¥æ—¶å¯èƒ½é”™è¿‡å‰å‡ æ¡æ¶ˆæ¯</p>
<ul>
<li>è§£å†³æ–¹æ¡ˆï¼šå‘å¸ƒè€…å¯åŠ¨åå»¶è¿Ÿ500mså†å‘é€</li>
</ul>
</li>
<li>
<p><strong>ä¸»é¢˜è¿‡æ»¤</strong>ï¼šä½¿ç”¨å‰ç¼€åŒ¹é…</p>
<pre><code class="language-cpp">socket.setsockopt(ZMQ_SUBSCRIBE, "weather", 7);  // è®¢é˜…"weather"å¼€å¤´çš„æ¶ˆæ¯
socket.setsockopt(ZMQ_SUBSCRIBE, "", 0);         // è®¢é˜…æ‰€æœ‰æ¶ˆæ¯
</code></pre>
</li>
<li>
<p><strong>æ€§èƒ½ç‰¹æ€§</strong>ï¼š</p>
<ul>
<li>å‘å¸ƒè€…ä¸å…³å¿ƒè®¢é˜…è€…æ•°é‡</li>
<li>æ— è®¢é˜…è€…æ—¶æ¶ˆæ¯ä¼šè¢«ä¸¢å¼ƒ</li>
<li>å•ä¸ªå‘å¸ƒè€…å¯æ”¯æŒæ•°åƒè®¢é˜…è€…</li>
</ul>
</li>
</ol>
<hr />
<h3 id="æ¨¡å¼3æ¨æ‹‰æ¨¡å¼push-pull"><a class="header" href="#æ¨¡å¼3æ¨æ‹‰æ¨¡å¼push-pull">æ¨¡å¼3ï¼šæ¨æ‹‰æ¨¡å¼ï¼ˆPUSH-PULLï¼‰</a></h3>
<p><strong>ä½¿ç”¨åœºæ™¯ï¼š</strong> ä»»åŠ¡åˆ†å‘ï¼Œè´Ÿè½½å‡è¡¡ï¼Œå¹¶è¡Œå¤„ç†ç®¡é“</p>
<h4 id="å¹¶è¡Œä»»åŠ¡å¤„ç†ç³»ç»Ÿ"><a class="header" href="#å¹¶è¡Œä»»åŠ¡å¤„ç†ç³»ç»Ÿ">å¹¶è¡Œä»»åŠ¡å¤„ç†ç³»ç»Ÿ</a></h4>
<p><strong>ä»»åŠ¡åˆ†å‘å™¨ï¼ˆventilator.cppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

class TaskVentilator {
private:
    zmq::context_t context;
    zmq::socket_t sender;    // PUSH socket
    zmq::socket_t sink;      // PUSH socket to sink

public:
    TaskVentilator() : context(1),
                       sender(context, ZMQ_PUSH),
                       sink(context, ZMQ_PUSH) {
        sender.bind("tcp://*:5557");
        sink.connect("tcp://localhost:5558");
        std::cout &lt;&lt; "Task ventilator ready" &lt;&lt; std::endl;
    }

    void distributeWork(int num_tasks = 100) {
        std::cout &lt;&lt; "Press Enter when workers are ready: ";
        std::cin.get();

        // é€šçŸ¥ç»“æœæ”¶é›†å™¨
        zmq::message_t start_msg("0");
        sink.send(start_msg, zmq::send_flags::none);

        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution&lt;&gt; dis(1, 100);

        int total_msec = 0;
        for (int task_id = 0; task_id &lt; num_tasks; ++task_id) {
            int workload = dis(gen);  // éšæœºå·¥ä½œè´Ÿè½½ï¼ˆ1-100msï¼‰
            total_msec += workload;

            std::string task = std::to_string(workload);
            zmq::message_t message(task.length());
            memcpy(message.data(), task.c_str(), task.length());

            sender.send(message, zmq::send_flags::none);
        }

        std::cout &lt;&lt; "Total expected cost: " &lt;&lt; total_msec &lt;&lt; " ms" &lt;&lt; std::endl;
    }
};

int main() {
    TaskVentilator ventilator;
    ventilator.distributeWork(100);
    return 0;
}
</code></pre>
<p><strong>å·¥ä½œè€…ï¼ˆworker.cppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;

class Worker {
private:
    zmq::context_t context;
    zmq::socket_t receiver;  // PULL socket
    zmq::socket_t sender;    // PUSH socket
    int worker_id;

public:
    Worker(int id) : context(1),
                     receiver(context, ZMQ_PULL),
                     sender(context, ZMQ_PUSH),
                     worker_id(id) {
        receiver.connect("tcp://localhost:5557");
        sender.connect("tcp://localhost:5558");
        std::cout &lt;&lt; "Worker " &lt;&lt; worker_id &lt;&lt; " ready" &lt;&lt; std::endl;
    }

    void work() {
        while (true) {
            zmq::message_t message;
            receiver.recv(message, zmq::recv_flags::none);

            std::string work_str = std::string(
                static_cast&lt;char*&gt;(message.data()),
                message.size()
            );

            int workload = std::stoi(work_str);
            std::cout &lt;&lt; "Worker " &lt;&lt; worker_id &lt;&lt; " processing: "
                     &lt;&lt; workload &lt;&lt; "ms" &lt;&lt; std::endl;

            // æ‰§è¡Œä»»åŠ¡ï¼ˆæ¨¡æ‹Ÿï¼‰
            std::this_thread::sleep_for(std::chrono::milliseconds(workload));

            // å‘é€å®Œæˆä¿¡å·åˆ°ç»“æœæ”¶é›†å™¨
            zmq::message_t result("1");
            sender.send(result, zmq::send_flags::none);
        }
    }
};

int main(int argc, char* argv[]) {
    int worker_id = (argc &gt; 1) ? std::atoi(argv[1]) : 0;
    Worker worker(worker_id);
    worker.work();
    return 0;
}
</code></pre>
<p><strong>ç»“æœæ”¶é›†å™¨ï¼ˆsink.cppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;
#include &lt;chrono&gt;

class ResultSink {
private:
    zmq::context_t context;
    zmq::socket_t receiver;  // PULL socket

public:
    ResultSink() : context(1), receiver(context, ZMQ_PULL) {
        receiver.bind("tcp://*:5558");
        std::cout &lt;&lt; "Result sink ready" &lt;&lt; std::endl;
    }

    void collectResults(int num_tasks = 100) {
        // ç­‰å¾…å¼€å§‹ä¿¡å·
        zmq::message_t start;
        receiver.recv(start, zmq::recv_flags::none);

        auto start_time = std::chrono::high_resolution_clock::now();

        // æ¥æ”¶æ‰€æœ‰ç»“æœ
        for (int task_nbr = 0; task_nbr &lt; num_tasks; ++task_nbr) {
            zmq::message_t result;
            receiver.recv(result, zmq::recv_flags::none);

            if ((task_nbr + 1) % 10 == 0) {
                std::cout &lt;&lt; ":" &lt;&lt; std::flush;
            } else {
                std::cout &lt;&lt; "." &lt;&lt; std::flush;
            }
        }

        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
            end_time - start_time
        ).count();

        std::cout &lt;&lt; "\nTotal elapsed time: " &lt;&lt; duration &lt;&lt; " ms" &lt;&lt; std::endl;
    }
};

int main() {
    ResultSink sink;
    sink.collectResults(100);
    return 0;
}
</code></pre>
<p><strong>è¿è¡Œæµç¨‹ï¼š</strong></p>
<pre><code class="language-bash"># ç»ˆç«¯1ï¼šå¯åŠ¨ç»“æœæ”¶é›†å™¨
./sink

# ç»ˆç«¯2-4ï¼šå¯åŠ¨3ä¸ªå·¥ä½œè€…
./worker 1
./worker 2
./worker 3

# ç»ˆç«¯5ï¼šå¯åŠ¨ä»»åŠ¡åˆ†å‘å™¨
./ventilator
# æŒ‰å›è½¦å¼€å§‹åˆ†å‘ä»»åŠ¡
</code></pre>
<p><strong>è´Ÿè½½å‡è¡¡æœºåˆ¶ï¼š</strong></p>
<ul>
<li>ZeroMQè‡ªåŠ¨å°†ä»»åŠ¡<strong>å…¬å¹³åˆ†å‘</strong>åˆ°æ‰€æœ‰è¿æ¥çš„worker</li>
<li>ä½¿ç”¨è½®è¯¢ï¼ˆround-robinï¼‰ç®—æ³•</li>
<li>å·¥ä½œè€…ä¹‹é—´è‡ªåŠ¨è´Ÿè½½å‡è¡¡</li>
</ul>
<hr />
<h3 id="æ¨¡å¼4è·¯ç”±æ¨¡å¼router-dealer"><a class="header" href="#æ¨¡å¼4è·¯ç”±æ¨¡å¼router-dealer">æ¨¡å¼4ï¼šè·¯ç”±æ¨¡å¼ï¼ˆROUTER-DEALERï¼‰</a></h3>
<p><strong>ä½¿ç”¨åœºæ™¯ï¼š</strong> å¼‚æ­¥è¯·æ±‚-åº”ç­”ï¼Œé«˜å¹¶å‘æœåŠ¡ï¼Œè´Ÿè½½å‡è¡¡</p>
<h4 id="å¼‚æ­¥æœåŠ¡å™¨æ¶æ„"><a class="header" href="#å¼‚æ­¥æœåŠ¡å™¨æ¶æ„">å¼‚æ­¥æœåŠ¡å™¨æ¶æ„</a></h4>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

class AsyncServer {
private:
    zmq::context_t context;
    zmq::socket_t frontend;  // ROUTER socket - é¢å‘å®¢æˆ·ç«¯
    zmq::socket_t backend;   // DEALER socket - é¢å‘å·¥ä½œè€…

public:
    AsyncServer() : context(1),
                    frontend(context, ZMQ_ROUTER),
                    backend(context, ZMQ_DEALER) {
        frontend.bind("tcp://*:5559");
        backend.bind("tcp://*:5560");
        std::cout &lt;&lt; "Async server started" &lt;&lt; std::endl;
    }

    void run() {
        // å¯åŠ¨ä»£ç†ï¼ˆè‡ªåŠ¨åœ¨frontendå’Œbackendä¹‹é—´è½¬å‘æ¶ˆæ¯ï¼‰
        zmq::proxy(frontend, backend);
    }
};

class AsyncWorker {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    int worker_id;

public:
    AsyncWorker(int id) : context(1), socket(context, ZMQ_REP), worker_id(id) {
        socket.connect("tcp://localhost:5560");
    }

    void work() {
        while (true) {
            zmq::message_t request;
            socket.recv(request, zmq::recv_flags::none);

            std::string req_str = std::string(
                static_cast&lt;char*&gt;(request.data()),
                request.size()
            );

            std::cout &lt;&lt; "Worker " &lt;&lt; worker_id &lt;&lt; " received: " &lt;&lt; req_str &lt;&lt; std::endl;

            // å¤„ç†è¯·æ±‚
            std::this_thread::sleep_for(std::chrono::milliseconds(100));

            // å‘é€åº”ç­”
            std::string reply = "Worker " + std::to_string(worker_id) + " processed: " + req_str;
            zmq::message_t response(reply.length());
            memcpy(response.data(), reply.c_str(), reply.length());
            socket.send(response, zmq::send_flags::none);
        }
    }
};

// æœåŠ¡å™¨ä¸»å‡½æ•°
void runServer() {
    AsyncServer server;
    server.run();
}

// å·¥ä½œè€…ä¸»å‡½æ•°
void runWorker(int id) {
    AsyncWorker worker(id);
    worker.work();
}

// å®¢æˆ·ç«¯ï¼ˆä¸æ™®é€šREQå®¢æˆ·ç«¯ç›¸åŒï¼‰
void runClient(int client_id) {
    zmq::context_t context(1);
    zmq::socket_t socket(context, ZMQ_REQ);
    socket.connect("tcp://localhost:5559");

    for (int i = 0; i &lt; 5; ++i) {
        std::string request = "Request " + std::to_string(i) + " from client " + std::to_string(client_id);
        zmq::message_t msg(request.length());
        memcpy(msg.data(), request.c_str(), request.length());
        socket.send(msg, zmq::send_flags::none);

        zmq::message_t reply;
        socket.recv(reply, zmq::recv_flags::none);

        std::cout &lt;&lt; "Client " &lt;&lt; client_id &lt;&lt; " received: "
                 &lt;&lt; std::string(static_cast&lt;char*&gt;(reply.data()), reply.size()) &lt;&lt; std::endl;
    }
}
</code></pre>
<hr />
<h3 id="æ¨¡å¼5é…å¯¹æ¨¡å¼pair"><a class="header" href="#æ¨¡å¼5é…å¯¹æ¨¡å¼pair">æ¨¡å¼5ï¼šé…å¯¹æ¨¡å¼ï¼ˆPAIRï¼‰</a></h3>
<p><strong>ä½¿ç”¨åœºæ™¯ï¼š</strong> è¿›ç¨‹å†…çº¿ç¨‹é—´é€šä¿¡ï¼Œä¸“ç”¨é€šé“</p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

void thread_a(zmq::context_t&amp; context) {
    zmq::socket_t socket(context, ZMQ_PAIR);
    socket.bind("inproc://channel");

    for (int i = 0; i &lt; 5; ++i) {
        std::string msg = "Message " + std::to_string(i) + " from A";
        socket.send(zmq::buffer(msg), zmq::send_flags::none);
        std::cout &lt;&lt; "A sent: " &lt;&lt; msg &lt;&lt; std::endl;

        zmq::message_t reply;
        socket.recv(reply, zmq::recv_flags::none);
        std::cout &lt;&lt; "A received: " &lt;&lt; reply.to_string() &lt;&lt; std::endl;
    }
}

void thread_b(zmq::context_t&amp; context) {
    zmq::socket_t socket(context, ZMQ_PAIR);
    socket.connect("inproc://channel");

    for (int i = 0; i &lt; 5; ++i) {
        zmq::message_t msg;
        socket.recv(msg, zmq::recv_flags::none);
        std::cout &lt;&lt; "B received: " &lt;&lt; msg.to_string() &lt;&lt; std::endl;

        std::string reply = "Reply " + std::to_string(i) + " from B";
        socket.send(zmq::buffer(reply), zmq::send_flags::none);
        std::cout &lt;&lt; "B sent: " &lt;&lt; reply &lt;&lt; std::endl;
    }
}

int main() {
    zmq::context_t context(1);

    std::thread ta(thread_a, std::ref(context));
    std::thread tb(thread_b, std::ref(context));

    ta.join();
    tb.join();

    return 0;
}
</code></pre>
<hr />
<h2 id="-é«˜çº§ç‰¹æ€§"><a class="header" href="#-é«˜çº§ç‰¹æ€§">ğŸš€ é«˜çº§ç‰¹æ€§</a></h2>
<h3 id="1-å¤šéƒ¨åˆ†æ¶ˆæ¯multipart-messages"><a class="header" href="#1-å¤šéƒ¨åˆ†æ¶ˆæ¯multipart-messages">1. å¤šéƒ¨åˆ†æ¶ˆæ¯ï¼ˆMultipart Messagesï¼‰</a></h3>
<p>å¤šéƒ¨åˆ†æ¶ˆæ¯å…è®¸å‘é€é€»è¾‘ä¸Šç›¸å…³çš„å¤šä¸ªå¸§ã€‚</p>
<pre><code class="language-cpp">class MultipartMessaging {
private:
    zmq::context_t context;
    zmq::socket_t socket;

public:
    MultipartMessaging() : context(1), socket(context, ZMQ_DEALER) {
        socket.connect("tcp://localhost:5555");
    }

    // å‘é€å¤šéƒ¨åˆ†æ¶ˆæ¯
    void sendMultipart() {
        // ç¬¬ä¸€éƒ¨åˆ†ï¼šç©ºå¸§ï¼ˆèº«ä»½ï¼‰
        socket.send(zmq::message_t(), zmq::send_flags::sndmore);

        // ç¬¬äºŒéƒ¨åˆ†ï¼šæ¶ˆæ¯å¤´
        std::string header = "HEADER";
        socket.send(zmq::buffer(header), zmq::send_flags::sndmore);

        // ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ¶ˆæ¯ä½“
        std::string body = "BODY_DATA";
        socket.send(zmq::buffer(body), zmq::send_flags::sndmore);

        // æœ€åä¸€éƒ¨åˆ†ï¼šæ— sndmoreæ ‡å¿—
        std::string footer = "FOOTER";
        socket.send(zmq::buffer(footer), zmq::send_flags::none);
    }

    // æ¥æ”¶å¤šéƒ¨åˆ†æ¶ˆæ¯
    std::vector&lt;std::string&gt; receiveMultipart() {
        std::vector&lt;std::string&gt; parts;

        while (true) {
            zmq::message_t message;
            socket.recv(message, zmq::recv_flags::none);
            parts.push_back(message.to_string());

            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šéƒ¨åˆ†
            int more;
            size_t more_size = sizeof(more);
            socket.getsockopt(ZMQ_RCVMORE, &amp;more, &amp;more_size);

            if (!more) break;
        }

        return parts;
    }
};
</code></pre>
<p><strong>å®é™…åº”ç”¨ç¤ºä¾‹ï¼š</strong></p>
<pre><code class="language-cpp">// æ¶ˆæ¯ç»“æ„ï¼š[èº«ä»½] [ä¸»é¢˜] [å†…å®¹]
void publishWithMetadata() {
    zmq::context_t ctx(1);
    zmq::socket_t pub(ctx, ZMQ_PUB);
    pub.bind("tcp://*:5556");

    // å‘é€å¸¦å…ƒæ•°æ®çš„æ¶ˆæ¯
    pub.send(zmq::buffer("weather"), zmq::send_flags::sndmore);  // ä¸»é¢˜
    pub.send(zmq::buffer("25Â°C"), zmq::send_flags::sndmore);     // æ•°æ®
    pub.send(zmq::buffer("2025-01-15"), zmq::send_flags::none);  // æ—¶é—´æˆ³
}
</code></pre>
<hr />
<h3 id="2-è½®è¯¢æœºåˆ¶polling"><a class="header" href="#2-è½®è¯¢æœºåˆ¶polling">2. è½®è¯¢æœºåˆ¶ï¼ˆPollingï¼‰</a></h3>
<p>è½®è¯¢å…è®¸ç›‘å¬å¤šä¸ªsocketçš„äº‹ä»¶ã€‚</p>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

class MultiSocketPoller {
private:
    zmq::context_t context;
    std::vector&lt;zmq::socket_t&gt; sockets;
    std::vector&lt;zmq::pollitem_t&gt; poll_items;

public:
    MultiSocketPoller() : context(1) {
        // åˆ›å»ºå¤šä¸ªè®¢é˜…socket
        for (int i = 0; i &lt; 3; ++i) {
            sockets.emplace_back(context, ZMQ_SUB);
            sockets[i].connect("tcp://localhost:" + std::to_string(5556 + i));
            sockets[i].setsockopt(ZMQ_SUBSCRIBE, "", 0);

            // æ·»åŠ åˆ°è½®è¯¢é¡¹
            poll_items.push_back({sockets[i], 0, ZMQ_POLLIN, 0});
        }
    }

    void poll() {
        while (true) {
            // è½®è¯¢æ‰€æœ‰socketï¼Œè¶…æ—¶æ—¶é—´1000ms
            zmq::poll(poll_items, std::chrono::milliseconds(1000));

            for (size_t i = 0; i &lt; poll_items.size(); ++i) {
                if (poll_items[i].revents &amp; ZMQ_POLLIN) {
                    zmq::message_t message;
                    sockets[i].recv(message, zmq::recv_flags::dontwait);

                    std::cout &lt;&lt; "Socket " &lt;&lt; i &lt;&lt; ": "
                             &lt;&lt; message.to_string() &lt;&lt; std::endl;
                }
            }
        }
    }
};
</code></pre>
<p><strong>è½®è¯¢é«˜çº§ç”¨æ³•ï¼š</strong></p>
<pre><code class="language-cpp">// åŒæ—¶ç›‘å¬POLLINå’ŒPOLLOUTäº‹ä»¶
zmq::pollitem_t items[] = {
    { socket, 0, ZMQ_POLLIN | ZMQ_POLLOUT, 0 }
};

zmq::poll(items, 1, std::chrono::milliseconds(100));

if (items[0].revents &amp; ZMQ_POLLIN) {
    // socketå¯è¯»
}
if (items[0].revents &amp; ZMQ_POLLOUT) {
    // socketå¯å†™
}
</code></pre>
<hr />
<h3 id="3-socketé€‰é¡¹ä¼˜åŒ–"><a class="header" href="#3-socketé€‰é¡¹ä¼˜åŒ–">3. Socketé€‰é¡¹ä¼˜åŒ–</a></h3>
<pre><code class="language-cpp">class SocketOptimizer {
public:
    static void optimizeSocket(zmq::socket_t&amp; socket) {
        // 1. è®¾ç½®é«˜æ°´ä½æ ‡è®°ï¼ˆHWMï¼‰- é˜²æ­¢å†…å­˜æº¢å‡º
        int hwm = 1000;
        socket.setsockopt(ZMQ_SNDHWM, &amp;hwm, sizeof(hwm));  // å‘é€é˜Ÿåˆ—ä¸Šé™
        socket.setsockopt(ZMQ_RCVHWM, &amp;hwm, sizeof(hwm));  // æ¥æ”¶é˜Ÿåˆ—ä¸Šé™

        // 2. è®¾ç½®è¶…æ—¶æ—¶é—´
        int send_timeout = 5000;  // 5ç§’
        int recv_timeout = 5000;
        socket.setsockopt(ZMQ_SNDTIMEO, &amp;send_timeout, sizeof(send_timeout));
        socket.setsockopt(ZMQ_RCVTIMEO, &amp;recv_timeout, sizeof(recv_timeout));

        // 3. è®¾ç½®TCPä¿æ´»ï¼ˆæ£€æµ‹æ–­å¼€è¿æ¥ï¼‰
        int keepalive = 1;
        int keepalive_idle = 60;      // 60ç§’æ— æ•°æ®åˆ™å‘é€ä¿æ´»æ¢æµ‹
        int keepalive_interval = 10;  // æ¢æµ‹é—´éš”10ç§’
        int keepalive_count = 3;      // å¤±è´¥3æ¬¡åˆ™è®¤ä¸ºæ–­å¼€

        socket.setsockopt(ZMQ_TCP_KEEPALIVE, &amp;keepalive, sizeof(keepalive));
        socket.setsockopt(ZMQ_TCP_KEEPALIVE_IDLE, &amp;keepalive_idle, sizeof(keepalive_idle));
        socket.setsockopt(ZMQ_TCP_KEEPALIVE_INTVL, &amp;keepalive_interval, sizeof(keepalive_interval));
        socket.setsockopt(ZMQ_TCP_KEEPALIVE_CNT, &amp;keepalive_count, sizeof(keepalive_count));

        // 4. ç¦ç”¨Nagleç®—æ³•ï¼ˆé™ä½å»¶è¿Ÿï¼‰
        int nodelay = 1;
        socket.setsockopt(ZMQ_TCP_NODELAY, &amp;nodelay, sizeof(nodelay));

        // 5. è®¾ç½®è¿æ¥é‡è¯•é—´éš”
        int reconnect_ivl = 100;      // é‡è¿åˆå§‹é—´éš”100ms
        int reconnect_ivl_max = 5000; // æœ€å¤§é—´éš”5ç§’
        socket.setsockopt(ZMQ_RECONNECT_IVL, &amp;reconnect_ivl, sizeof(reconnect_ivl));
        socket.setsockopt(ZMQ_RECONNECT_IVL_MAX, &amp;reconnect_ivl_max, sizeof(reconnect_ivl_max));

        // 6. è®¾ç½®Lingeræ—¶é—´ï¼ˆå…³é—­socketæ—¶çš„ç­‰å¾…æ—¶é—´ï¼‰
        int linger = 0;  // ç«‹å³ä¸¢å¼ƒæœªå‘é€æ¶ˆæ¯
        socket.setsockopt(ZMQ_LINGER, &amp;linger, sizeof(linger));
    }
};
</code></pre>
<hr />
<h2 id="-é”™è¯¯å¤„ç†ä¸å¯é æ€§"><a class="header" href="#-é”™è¯¯å¤„ç†ä¸å¯é æ€§">ğŸ› ï¸ é”™è¯¯å¤„ç†ä¸å¯é æ€§</a></h2>
<h3 id="1-å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ"><a class="header" href="#1-å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ">1. å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ</a></h3>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;

class RobustZMQClient {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    int max_retries;

public:
    RobustZMQClient(int retries = 3)
        : context(1), socket(context, ZMQ_REQ), max_retries(retries) {
        socket.connect("tcp://localhost:5555");

        // è®¾ç½®è¶…æ—¶
        int timeout = 2500;
        socket.setsockopt(ZMQ_RCVTIMEO, &amp;timeout, sizeof(timeout));
    }

    bool sendWithRetry(const std::string&amp; message, std::string&amp; reply) {
        for (int attempt = 0; attempt &lt; max_retries; ++attempt) {
            try {
                // å‘é€è¯·æ±‚
                socket.send(zmq::buffer(message), zmq::send_flags::none);

                // æ¥æ”¶åº”ç­”
                zmq::message_t response;
                auto result = socket.recv(response, zmq::recv_flags::none);

                if (result) {
                    reply = response.to_string();
                    return true;
                }

                // è¶…æ—¶ï¼Œé‡è¯•
                std::cerr &lt;&lt; "Timeout on attempt " &lt;&lt; (attempt + 1) &lt;&lt; std::endl;

                // é‡æ–°åˆ›å»ºsocketï¼ˆREQ socketåœ¨å¤±è´¥åéœ€è¦é‡å»ºï¼‰
                socket.close();
                socket = zmq::socket_t(context, ZMQ_REQ);
                socket.connect("tcp://localhost:5555");

                int timeout = 2500;
                socket.setsockopt(ZMQ_RCVTIMEO, &amp;timeout, sizeof(timeout));

            } catch (const zmq::error_t&amp; e) {
                std::cerr &lt;&lt; "Error on attempt " &lt;&lt; (attempt + 1)
                         &lt;&lt; ": " &lt;&lt; e.what() &lt;&lt; std::endl;

                if (attempt == max_retries - 1) {
                    return false;
                }

                std::this_thread::sleep_for(std::chrono::milliseconds(100 * (attempt + 1)));
            }
        }

        return false;
    }
};
</code></pre>
<hr />
<h3 id="2-å¿ƒè·³æœºåˆ¶heartbeat"><a class="header" href="#2-å¿ƒè·³æœºåˆ¶heartbeat">2. å¿ƒè·³æœºåˆ¶ï¼ˆHeartbeatï¼‰</a></h3>
<pre><code class="language-cpp">#include &lt;zmq.hpp&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;atomic&gt;

class HeartbeatClient {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    std::atomic&lt;bool&gt; running;
    std::thread heartbeat_thread;
    std::chrono::seconds heartbeat_interval;

public:
    HeartbeatClient()
        : context(1), socket(context, ZMQ_DEALER),
          running(false), heartbeat_interval(5) {

        socket.connect("tcp://localhost:5555");

        // è®¾ç½®identity
        std::string identity = "CLIENT_" + std::to_string(time(nullptr));
        socket.setsockopt(ZMQ_IDENTITY, identity.c_str(), identity.length());
    }

    void start() {
        running = true;

        // å¯åŠ¨å¿ƒè·³çº¿ç¨‹
        heartbeat_thread = std::thread([this]() {
            while (running) {
                sendHeartbeat();
                std::this_thread::sleep_for(heartbeat_interval);
            }
        });
    }

    void sendHeartbeat() {
        try {
            socket.send(zmq::buffer("HEARTBEAT"), zmq::send_flags::dontwait);
            std::cout &lt;&lt; "Heartbeat sent" &lt;&lt; std::endl;
        } catch (const zmq::error_t&amp; e) {
            std::cerr &lt;&lt; "Heartbeat failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }

    void stop() {
        running = false;
        if (heartbeat_thread.joinable()) {
            heartbeat_thread.join();
        }
    }

    ~HeartbeatClient() {
        stop();
    }
};

class HeartbeatServer {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    std::map&lt;std::string, std::chrono::steady_clock::time_point&gt; clients;
    std::chrono::seconds timeout;

public:
    HeartbeatServer() : context(1), socket(context, ZMQ_ROUTER), timeout(15) {
        socket.bind("tcp://*:5555");
    }

    void run() {
        zmq::pollitem_t items[] = { { socket, 0, ZMQ_POLLIN, 0 } };

        while (true) {
            zmq::poll(items, 1, std::chrono::milliseconds(1000));

            if (items[0].revents &amp; ZMQ_POLLIN) {
                // æ¥æ”¶æ¶ˆæ¯
                zmq::message_t identity;
                zmq::message_t message;

                socket.recv(identity, zmq::recv_flags::none);
                socket.recv(message, zmq::recv_flags::none);

                std::string client_id = identity.to_string();
                std::string msg = message.to_string();

                if (msg == "HEARTBEAT") {
                    // æ›´æ–°å®¢æˆ·ç«¯æœ€åæ´»è·ƒæ—¶é—´
                    clients[client_id] = std::chrono::steady_clock::now();
                    std::cout &lt;&lt; "Heartbeat from " &lt;&lt; client_id &lt;&lt; std::endl;
                }
            }

            // æ£€æŸ¥è¶…æ—¶å®¢æˆ·ç«¯
            checkTimeouts();
        }
    }

    void checkTimeouts() {
        auto now = std::chrono::steady_clock::now();

        for (auto it = clients.begin(); it != clients.end(); ) {
            auto elapsed = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(
                now - it-&gt;second
            );

            if (elapsed &gt; timeout) {
                std::cout &lt;&lt; "Client " &lt;&lt; it-&gt;first &lt;&lt; " timed out" &lt;&lt; std::endl;
                it = clients.erase(it);
            } else {
                ++it;
            }
        }
    }
};
</code></pre>
<hr />
<h2 id="-æ€§èƒ½ä¼˜åŒ–ä¸è°ƒä¼˜"><a class="header" href="#-æ€§èƒ½ä¼˜åŒ–ä¸è°ƒä¼˜">ğŸ“Š æ€§èƒ½ä¼˜åŒ–ä¸è°ƒä¼˜</a></h2>
<h3 id="1-é›¶æ‹·è´æŠ€æœ¯"><a class="header" href="#1-é›¶æ‹·è´æŠ€æœ¯">1. é›¶æ‹·è´æŠ€æœ¯</a></h3>
<pre><code class="language-cpp">// ä¼ ç»Ÿæ–¹å¼ï¼ˆæœ‰æ‹·è´ï¼‰
void sendTraditional(zmq::socket_t&amp; socket, const std::vector&lt;char&gt;&amp; data) {
    zmq::message_t msg(data.size());
    memcpy(msg.data(), data.data(), data.size());  // æ‹·è´ï¼
    socket.send(msg, zmq::send_flags::none);
}

// é›¶æ‹·è´æ–¹å¼
void sendZeroCopy(zmq::socket_t&amp; socket, std::vector&lt;char&gt;&amp;&amp; data) {
    // ä½¿ç”¨è‡ªå®šä¹‰é‡Šæ”¾å‡½æ•°
    auto free_fn = [](void* data, void* hint) {
        delete[] static_cast&lt;char*&gt;(data);
    };

    char* buffer = new char[data.size()];
    std::memcpy(buffer, data.data(), data.size());

    zmq::message_t msg(buffer, data.size(), free_fn);
    socket.send(msg, zmq::send_flags::none);
}
</code></pre>
<hr />
<h3 id="2-æ‰¹é‡å¤„ç†"><a class="header" href="#2-æ‰¹é‡å¤„ç†">2. æ‰¹é‡å¤„ç†</a></h3>
<pre><code class="language-cpp">class BatchProcessor {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    std::vector&lt;std::string&gt; batch;
    size_t batch_size;
    std::chrono::milliseconds batch_timeout;
    std::chrono::steady_clock::time_point last_send;

public:
    BatchProcessor(size_t size = 100, int timeout_ms = 1000)
        : context(1), socket(context, ZMQ_PUSH),
          batch_size(size), batch_timeout(timeout_ms) {

        socket.bind("tcp://*:5563");
        batch.reserve(batch_size);
        last_send = std::chrono::steady_clock::now();
    }

    void addMessage(const std::string&amp; message) {
        batch.push_back(message);

        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
            now - last_send
        );

        // æ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶åˆ™å‘é€ï¼š
        // 1. æ‰¹æ¬¡å·²æ»¡
        // 2. è¶…è¿‡è¶…æ—¶æ—¶é—´
        if (batch.size() &gt;= batch_size || elapsed &gt;= batch_timeout) {
            sendBatch();
        }
    }

    void sendBatch() {
        if (batch.empty()) return;

        std::cout &lt;&lt; "Sending batch of " &lt;&lt; batch.size() &lt;&lt; " messages" &lt;&lt; std::endl;

        // å‘é€å¤šéƒ¨åˆ†æ¶ˆæ¯
        for (size_t i = 0; i &lt; batch.size(); ++i) {
            auto flags = (i == batch.size() - 1) ?
                zmq::send_flags::none : zmq::send_flags::sndmore;

            socket.send(zmq::buffer(batch[i]), flags);
        }

        batch.clear();
        last_send = std::chrono::steady_clock::now();
    }

    ~BatchProcessor() {
        sendBatch();  // å‘é€å‰©ä½™æ¶ˆæ¯
    }
};
</code></pre>
<hr />
<h3 id="3-æ€§èƒ½åŸºå‡†æµ‹è¯•"><a class="header" href="#3-æ€§èƒ½åŸºå‡†æµ‹è¯•">3. æ€§èƒ½åŸºå‡†æµ‹è¯•</a></h3>
<pre><code class="language-cpp">#include &lt;chrono&gt;
#include &lt;iostream&gt;

class ZMQBenchmark {
public:
    static void benchmarkLatency(int message_count = 10000) {
        zmq::context_t context(1);
        zmq::socket_t server(context, ZMQ_REP);
        zmq::socket_t client(context, ZMQ_REQ);

        server.bind("tcp://127.0.0.1:5555");
        client.connect("tcp://127.0.0.1:5555");

        std::this_thread::sleep_for(std::chrono::milliseconds(100));

        auto start = std::chrono::high_resolution_clock::now();

        for (int i = 0; i &lt; message_count; ++i) {
            // å®¢æˆ·ç«¯å‘é€
            client.send(zmq::buffer("ping"), zmq::send_flags::none);

            // æœåŠ¡å™¨æ¥æ”¶
            zmq::message_t request;
            server.recv(request, zmq::recv_flags::none);

            // æœåŠ¡å™¨å‘é€
            server.send(zmq::buffer("pong"), zmq::send_flags::none);

            // å®¢æˆ·ç«¯æ¥æ”¶
            zmq::message_t reply;
            client.recv(reply, zmq::recv_flags::none);
        }

        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(
            end - start
        ).count();

        double latency = static_cast&lt;double&gt;(duration) / (message_count * 2);

        std::cout &lt;&lt; "Messages: " &lt;&lt; message_count &lt;&lt; std::endl;
        std::cout &lt;&lt; "Average latency: " &lt;&lt; latency &lt;&lt; " Î¼s" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Messages per second: "
                 &lt;&lt; (message_count * 1000000.0 / duration) &lt;&lt; std::endl;
    }

    static void benchmarkThroughput(int message_size = 1024, int message_count = 100000) {
        zmq::context_t context(1);
        zmq::socket_t sender(context, ZMQ_PUSH);
        zmq::socket_t receiver(context, ZMQ_PULL);

        sender.bind("tcp://127.0.0.1:5555");
        receiver.connect("tcp://127.0.0.1:5555");

        std::this_thread::sleep_for(std::chrono::milliseconds(100));

        // å‡†å¤‡æ¶ˆæ¯
        std::vector&lt;char&gt; data(message_size, 'X');

        auto start = std::chrono::high_resolution_clock::now();

        // å‘é€çº¿ç¨‹
        std::thread sender_thread([&amp;]() {
            for (int i = 0; i &lt; message_count; ++i) {
                sender.send(zmq::buffer(data), zmq::send_flags::none);
            }
        });

        // æ¥æ”¶çº¿ç¨‹
        std::thread receiver_thread([&amp;]() {
            for (int i = 0; i &lt; message_count; ++i) {
                zmq::message_t msg;
                receiver.recv(msg, zmq::recv_flags::none);
            }
        });

        sender_thread.join();
        receiver_thread.join();

        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(
            end - start
        ).count();

        double throughput = (message_count * message_size * 1000.0) / (duration * 1024 * 1024);

        std::cout &lt;&lt; "Message size: " &lt;&lt; message_size &lt;&lt; " bytes" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Messages: " &lt;&lt; message_count &lt;&lt; std::endl;
        std::cout &lt;&lt; "Duration: " &lt;&lt; duration &lt;&lt; " ms" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Throughput: " &lt;&lt; throughput &lt;&lt; " MB/s" &lt;&lt; std::endl;
    }
};

int main() {
    std::cout &lt;&lt; "=== Latency Benchmark ===" &lt;&lt; std::endl;
    ZMQBenchmark::benchmarkLatency(10000);

    std::cout &lt;&lt; "\n=== Throughput Benchmark ===" &lt;&lt; std::endl;
    ZMQBenchmark::benchmarkThroughput(1024, 100000);

    return 0;
}
</code></pre>
<hr />
<h2 id="-å®æˆ˜é¡¹ç›®åˆ†å¸ƒå¼æ—¥å¿—æ”¶é›†ç³»ç»Ÿ"><a class="header" href="#-å®æˆ˜é¡¹ç›®åˆ†å¸ƒå¼æ—¥å¿—æ”¶é›†ç³»ç»Ÿ">ğŸ—ï¸ å®æˆ˜é¡¹ç›®ï¼šåˆ†å¸ƒå¼æ—¥å¿—æ”¶é›†ç³»ç»Ÿ</a></h2>
<h3 id="é¡¹ç›®æ¶æ„"><a class="header" href="#é¡¹ç›®æ¶æ„">é¡¹ç›®æ¶æ„</a></h3>
<pre><code>[åº”ç”¨1] â”€â”€â”
[åº”ç”¨2] â”€â”€â”¼â”€â†’ [æ—¥å¿—ä»£ç†] â”€â”€â†’ [æ—¥å¿—å¤„ç†å™¨] â”€â”€â†’ [å­˜å‚¨/åˆ†æ]
[åº”ç”¨3] â”€â”€â”˜
</code></pre>
<h3 id="æ—¥å¿—ç”Ÿäº§è€…åº”ç”¨ç«¯"><a class="header" href="#æ—¥å¿—ç”Ÿäº§è€…åº”ç”¨ç«¯">æ—¥å¿—ç”Ÿäº§è€…ï¼ˆåº”ç”¨ç«¯ï¼‰</a></h3>
<pre><code class="language-cpp">// log_producer.h
#ifndef LOG_PRODUCER_H
#define LOG_PRODUCER_H

#include &lt;zmq.hpp&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;

enum class LogLevel {
    DEBUG, INFO, WARNING, ERROR, FATAL
};

class LogProducer {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    std::string application_name;

    std::string levelToString(LogLevel level) {
        switch (level) {
            case LogLevel::DEBUG:   return "DEBUG";
            case LogLevel::INFO:    return "INFO";
            case LogLevel::WARNING: return "WARNING";
            case LogLevel::ERROR:   return "ERROR";
            case LogLevel::FATAL:   return "FATAL";
            default: return "UNKNOWN";
        }
    }

    std::string getCurrentTimestamp() {
        auto now = std::chrono::system_clock::now();
        auto time_t_now = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss &lt;&lt; std::put_time(std::localtime(&amp;time_t_now), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }

public:
    LogProducer(const std::string&amp; app_name)
        : context(1), socket(context, ZMQ_PUSH), application_name(app_name) {

        socket.connect("tcp://localhost:5555");

        // ä¼˜åŒ–è®¾ç½®
        int hwm = 10000;
        socket.setsockopt(ZMQ_SNDHWM, &amp;hwm, sizeof(hwm));
    }

    void log(LogLevel level, const std::string&amp; message) {
        std::stringstream log_entry;
        log_entry &lt;&lt; getCurrentTimestamp() &lt;&lt; " "
                 &lt;&lt; "[" &lt;&lt; application_name &lt;&lt; "] "
                 &lt;&lt; "[" &lt;&lt; levelToString(level) &lt;&lt; "] "
                 &lt;&lt; message;

        std::string log_str = log_entry.str();
        socket.send(zmq::buffer(log_str), zmq::send_flags::dontwait);
    }

    void debug(const std::string&amp; msg) { log(LogLevel::DEBUG, msg); }
    void info(const std::string&amp; msg) { log(LogLevel::INFO, msg); }
    void warning(const std::string&amp; msg) { log(LogLevel::WARNING, msg); }
    void error(const std::string&amp; msg) { log(LogLevel::ERROR, msg); }
    void fatal(const std::string&amp; msg) { log(LogLevel::FATAL, msg); }
};

#endif // LOG_PRODUCER_H
</code></pre>
<h3 id="æ—¥å¿—ä»£ç†è´Ÿè½½å‡è¡¡"><a class="header" href="#æ—¥å¿—ä»£ç†è´Ÿè½½å‡è¡¡">æ—¥å¿—ä»£ç†ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰</a></h3>
<pre><code class="language-cpp">// log_proxy.cpp
#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;csignal&gt;
#include &lt;atomic&gt;

std::atomic&lt;bool&gt; running(true);

void signalHandler(int signum) {
    std::cout &lt;&lt; "\nShutting down log proxy..." &lt;&lt; std::endl;
    running = false;
}

class LogProxy {
private:
    zmq::context_t context;
    zmq::socket_t frontend;  // PULL - æ¥æ”¶æ—¥å¿—
    zmq::socket_t backend;   // PUSH - è½¬å‘åˆ°å¤„ç†å™¨

public:
    LogProxy() : context(1),
                 frontend(context, ZMQ_PULL),
                 backend(context, ZMQ_PUSH) {

        frontend.bind("tcp://*:5555");
        backend.bind("tcp://*:5556");

        std::cout &lt;&lt; "Log proxy started" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Frontend: tcp://*:5555" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Backend: tcp://*:5556" &lt;&lt; std::endl;
    }

    void run() {
        zmq::pollitem_t items[] = {
            { frontend, 0, ZMQ_POLLIN, 0 }
        };

        uint64_t message_count = 0;

        while (running) {
            zmq::poll(items, 1, std::chrono::milliseconds(100));

            if (items[0].revents &amp; ZMQ_POLLIN) {
                zmq::message_t message;
                frontend.recv(message, zmq::recv_flags::none);

                // è½¬å‘åˆ°backend
                backend.send(message, zmq::send_flags::none);

                message_count++;
                if (message_count % 1000 == 0) {
                    std::cout &lt;&lt; "Forwarded " &lt;&lt; message_count &lt;&lt; " messages" &lt;&lt; std::endl;
                }
            }
        }
    }
};

int main() {
    signal(SIGINT, signalHandler);
    signal(SIGTERM, signalHandler);

    LogProxy proxy;
    proxy.run();

    return 0;
}
</code></pre>
<h3 id="æ—¥å¿—å¤„ç†å™¨"><a class="header" href="#æ—¥å¿—å¤„ç†å™¨">æ—¥å¿—å¤„ç†å™¨</a></h3>
<pre><code class="language-cpp">// log_processor.cpp
#include &lt;zmq.hpp&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;thread&gt;
#include &lt;queue&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;atomic&gt;

class LogProcessor {
private:
    zmq::context_t context;
    zmq::socket_t socket;
    std::ofstream log_file;
    std::queue&lt;std::string&gt; log_queue;
    std::mutex queue_mutex;
    std::condition_variable queue_cv;
    std::atomic&lt;bool&gt; running;
    std::thread writer_thread;

public:
    LogProcessor(const std::string&amp; output_file)
        : context(1), socket(context, ZMQ_PULL), running(false) {

        socket.connect("tcp://localhost:5556");

        log_file.open(output_file, std::ios::app);
        if (!log_file.is_open()) {
            throw std::runtime_error("Failed to open log file");
        }

        std::cout &lt;&lt; "Log processor started, writing to " &lt;&lt; output_file &lt;&lt; std::endl;
    }

    void start() {
        running = true;

        // å¯åŠ¨å†™å…¥çº¿ç¨‹
        writer_thread = std::thread(&amp;LogProcessor::writerLoop, this);

        // ä¸»æ¥æ”¶å¾ªç¯
        receiverLoop();
    }

    void receiverLoop() {
        while (running) {
            zmq::message_t message;
            auto result = socket.recv(message, zmq::recv_flags::none);

            if (result) {
                std::string log_entry = message.to_string();

                // æ·»åŠ åˆ°é˜Ÿåˆ—
                {
                    std::lock_guard&lt;std::mutex&gt; lock(queue_mutex);
                    log_queue.push(log_entry);
                }
                queue_cv.notify_one();

                // åŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°
                std::cout &lt;&lt; log_entry &lt;&lt; std::endl;
            }
        }
    }

    void writerLoop() {
        while (running) {
            std::unique_lock&lt;std::mutex&gt; lock(queue_mutex);

            // ç­‰å¾…é˜Ÿåˆ—éç©º
            queue_cv.wait(lock, [this] {
                return !log_queue.empty() || !running;
            });

            while (!log_queue.empty()) {
                std::string log_entry = log_queue.front();
                log_queue.pop();

                lock.unlock();

                // å†™å…¥æ–‡ä»¶
                log_file &lt;&lt; log_entry &lt;&lt; std::endl;
                log_file.flush();

                lock.lock();
            }
        }
    }

    void stop() {
        running = false;
        queue_cv.notify_all();

        if (writer_thread.joinable()) {
            writer_thread.join();
        }

        log_file.close();
    }

    ~LogProcessor() {
        stop();
    }
};

int main() {
    try {
        LogProcessor processor("application.log");
        processor.start();
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}
</code></pre>
<h3 id="ç¤ºä¾‹åº”ç”¨"><a class="header" href="#ç¤ºä¾‹åº”ç”¨">ç¤ºä¾‹åº”ç”¨</a></h3>
<pre><code class="language-cpp">// example_app.cpp
#include "log_producer.h"
#include &lt;thread&gt;
#include &lt;random&gt;

int main() {
    LogProducer logger("ExampleApp");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dis(1, 5);

    logger.info("Application started");

    for (int i = 0; i &lt; 100; ++i) {
        int event_type = dis(gen);

        switch (event_type) {
            case 1:
                logger.debug("Processing request #" + std::to_string(i));
                break;
            case 2:
                logger.info("User action completed");
                break;
            case 3:
                logger.warning("Slow query detected");
                break;
            case 4:
                logger.error("Failed to connect to database");
                break;
            case 5:
                logger.fatal("Critical system failure");
                break;
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    logger.info("Application shutting down");

    return 0;
}
</code></pre>
<hr />
<h2 id="-cmakeæ„å»ºé…ç½®"><a class="header" href="#-cmakeæ„å»ºé…ç½®">ğŸ“‹ CMakeæ„å»ºé…ç½®</a></h2>
<h3 id="cmakeliststxt"><a class="header" href="#cmakeliststxt">CMakeLists.txt</a></h3>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.12)
project(ZeroMQLearning VERSION 1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# æŸ¥æ‰¾ZeroMQ
find_package(PkgConfig REQUIRED)
pkg_check_modules(ZMQ REQUIRED libzmq)

# æŸ¥æ‰¾cppzmqå¤´æ–‡ä»¶
find_path(CPPZMQ_INCLUDE_DIR zmq.hpp
    PATHS /usr/local/include /usr/include
)

if(NOT CPPZMQ_INCLUDE_DIR)
    message(FATAL_ERROR "cppzmq not found")
endif()

# åŒ…å«ç›®å½•
include_directories(
    ${ZMQ_INCLUDE_DIRS}
    ${CPPZMQ_INCLUDE_DIR}
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

# é“¾æ¥ç›®å½•
link_directories(${ZMQ_LIBRARY_DIRS})

# ç¼–è¯‘é€‰é¡¹
add_compile_options(${ZMQ_CFLAGS_OTHER})

# åŸºç¡€ç¤ºä¾‹
add_executable(req_rep_server examples/req_rep_server.cpp)
add_executable(req_rep_client examples/req_rep_client.cpp)
add_executable(pub_sub_publisher examples/pub_sub_publisher.cpp)
add_executable(pub_sub_subscriber examples/pub_sub_subscriber.cpp)

target_link_libraries(req_rep_server ${ZMQ_LIBRARIES} pthread)
target_link_libraries(req_rep_client ${ZMQ_LIBRARIES} pthread)
target_link_libraries(pub_sub_publisher ${ZMQ_LIBRARIES} pthread)
target_link_libraries(pub_sub_subscriber ${ZMQ_LIBRARIES} pthread)

# æ—¥å¿—ç³»ç»Ÿç¤ºä¾‹
add_executable(log_proxy examples/log_proxy.cpp)
add_executable(log_processor examples/log_processor.cpp)
add_executable(example_app examples/example_app.cpp)

target_link_libraries(log_proxy ${ZMQ_LIBRARIES} pthread)
target_link_libraries(log_processor ${ZMQ_LIBRARIES} pthread)
target_link_libraries(example_app ${ZMQ_LIBRARIES} pthread)

# å®‰è£…è§„åˆ™
install(TARGETS req_rep_server req_rep_client
    RUNTIME DESTINATION bin
)
</code></pre>
<h3 id="ç¼–è¯‘å’Œè¿è¡Œ"><a class="header" href="#ç¼–è¯‘å’Œè¿è¡Œ">ç¼–è¯‘å’Œè¿è¡Œ</a></h3>
<pre><code class="language-bash"># åˆ›å»ºæ„å»ºç›®å½•
mkdir build &amp;&amp; cd build

# é…ç½®
cmake ..

# ç¼–è¯‘
make -j$(nproc)

# è¿è¡Œç¤ºä¾‹
./req_rep_server
./req_rep_client
</code></pre>
<hr />
<h2 id="-å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ"><a class="header" href="#-å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ">âš ï¸ å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ</a></h2>
<h3 id="1-req-repæ¨¡å¼çŠ¶æ€æœºé”™è¯¯"><a class="header" href="#1-req-repæ¨¡å¼çŠ¶æ€æœºé”™è¯¯">1. REQ-REPæ¨¡å¼çŠ¶æ€æœºé”™è¯¯</a></h3>
<p><strong>é—®é¢˜ï¼š</strong></p>
<pre><code class="language-cpp">// é”™è¯¯ï¼šè¿ç»­å‘é€ä¸¤æ¬¡
client.send(msg1);
client.send(msg2);  // çŠ¶æ€æœºé”™è¯¯ï¼
</code></pre>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<pre><code class="language-cpp">// æ­£ç¡®ï¼šå¿…é¡»åœ¨sendå’Œrecvä¹‹é—´äº¤æ›¿
client.send(msg1);
client.recv(reply1);
client.send(msg2);
client.recv(reply2);
</code></pre>
<hr />
<h3 id="2-æ…¢è¿æ¥é—®é¢˜slow-joiner"><a class="header" href="#2-æ…¢è¿æ¥é—®é¢˜slow-joiner">2. æ…¢è¿æ¥é—®é¢˜ï¼ˆSlow Joinerï¼‰</a></h3>
<p><strong>é—®é¢˜ï¼š</strong> PUB-SUBæ¨¡å¼ä¸‹ï¼Œè®¢é˜…è€…åˆšè¿æ¥æ—¶ä¼šä¸¢å¤±æ¶ˆæ¯</p>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<pre><code class="language-cpp">// å‘å¸ƒè€…å»¶è¿Ÿå¯åŠ¨
zmq::socket_t publisher(context, ZMQ_PUB);
publisher.bind("tcp://*:5556");
std::this_thread::sleep_for(std::chrono::milliseconds(500));  // ç­‰å¾…è®¢é˜…è€…è¿æ¥

// æˆ–ä½¿ç”¨åŒæ­¥æœºåˆ¶
</code></pre>
<hr />
<h3 id="3-é«˜æ°´ä½æ ‡è®°hwmæº¢å‡º"><a class="header" href="#3-é«˜æ°´ä½æ ‡è®°hwmæº¢å‡º">3. é«˜æ°´ä½æ ‡è®°ï¼ˆHWMï¼‰æº¢å‡º</a></h3>
<p><strong>é—®é¢˜ï¼š</strong> æ¶ˆæ¯ç§¯å‹å¯¼è‡´å†…å­˜æº¢å‡ºæˆ–æ¶ˆæ¯ä¸¢å¤±</p>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<pre><code class="language-cpp">// è®¾ç½®åˆç†çš„HWM
int hwm = 1000;
socket.setsockopt(ZMQ_SNDHWM, &amp;hwm, sizeof(hwm));
socket.setsockopt(ZMQ_RCVHWM, &amp;hwm, sizeof(hwm));

// ç›‘æ§é˜Ÿåˆ—æ·±åº¦
size_t events;
size_t events_size = sizeof(events);
socket.getsockopt(ZMQ_EVENTS, &amp;events, &amp;events_size);
</code></pre>
<hr />
<h3 id="4-contexté”€æ¯é¡ºåº"><a class="header" href="#4-contexté”€æ¯é¡ºåº">4. Contexté”€æ¯é¡ºåº</a></h3>
<p><strong>é—®é¢˜ï¼š</strong> å…ˆé”€æ¯contextå†é”€æ¯socketå¯¼è‡´å´©æºƒ</p>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<pre><code class="language-cpp">// æ­£ç¡®é¡ºåº
{
    zmq::context_t context(1);
    zmq::socket_t socket(context, ZMQ_REQ);
    // ...
    socket.close();  // å…ˆå…³é—­socket
}  // contextè‡ªåŠ¨é”€æ¯
</code></pre>
<hr />
<h2 id="-å­¦ä¹ éªŒè¯æ ‡å‡†"><a class="header" href="#-å­¦ä¹ éªŒè¯æ ‡å‡†">âœ… å­¦ä¹ éªŒè¯æ ‡å‡†</a></h2>
<h3 id="åˆçº§éªŒè¯é€šè¿‡35å³å¯"><a class="header" href="#åˆçº§éªŒè¯é€šè¿‡35å³å¯">åˆçº§éªŒè¯ï¼ˆé€šè¿‡3/5å³å¯ï¼‰</a></h3>
<ol>
<li>âœ… èƒ½å¤Ÿç‹¬ç«‹æ­å»ºREQ-REPå®¢æˆ·ç«¯-æœåŠ¡å™¨ç¨‹åº</li>
<li>âœ… ç†è§£å¹¶å®ç°PUB-SUBæ¨¡å¼çš„ä¸»é¢˜è¿‡æ»¤</li>
<li>âœ… ä½¿ç”¨PUSH-PULLæ¨¡å¼å®ç°ç®€å•ä»»åŠ¡åˆ†å‘</li>
<li>âœ… æ­£ç¡®é…ç½®CMakeç¼–è¯‘ZeroMQé¡¹ç›®</li>
<li>âœ… å¤„ç†åŸºæœ¬çš„å‘é€/æ¥æ”¶è¶…æ—¶</li>
</ol>
<h3 id="ä¸­çº§éªŒè¯é€šè¿‡46å³å¯"><a class="header" href="#ä¸­çº§éªŒè¯é€šè¿‡46å³å¯">ä¸­çº§éªŒè¯ï¼ˆé€šè¿‡4/6å³å¯ï¼‰</a></h3>
<ol>
<li>âœ… å®ç°å¯é çš„é‡è¿å’Œé”™è¯¯å¤„ç†æœºåˆ¶</li>
<li>âœ… ä½¿ç”¨ROUTER-DEALERæ„å»ºå¼‚æ­¥æœåŠ¡å™¨</li>
<li>âœ… å®ç°å¤šsocketè½®è¯¢ï¼ˆpollingï¼‰</li>
<li>âœ… ä¼˜åŒ–socketå‚æ•°ï¼ˆHWMã€TCP_NODELAYç­‰ï¼‰</li>
<li>âœ… å®ç°å¿ƒè·³æ£€æµ‹æœºåˆ¶</li>
<li>âœ… æ„å»ºç®€å•çš„è´Ÿè½½å‡è¡¡ç³»ç»Ÿ</li>
</ol>
<h3 id="é«˜çº§éªŒè¯é€šè¿‡35å³å¯"><a class="header" href="#é«˜çº§éªŒè¯é€šè¿‡35å³å¯">é«˜çº§éªŒè¯ï¼ˆé€šè¿‡3/5å³å¯ï¼‰</a></h3>
<ol>
<li>âœ… è®¾è®¡å¹¶å®ç°åˆ†å¸ƒå¼æ—¥å¿—æ”¶é›†ç³»ç»Ÿ</li>
<li>âœ… å®ç°é›¶æ‹·è´æ¶ˆæ¯ä¼ è¾“</li>
<li>âœ… å®Œæˆæ€§èƒ½åŸºå‡†æµ‹è¯•ï¼ˆå»¶è¿Ÿå’Œååé‡ï¼‰</li>
<li>âœ… ä¸å…¶ä»–ç³»ç»Ÿé›†æˆï¼ˆå¦‚gRPCã€Redisï¼‰</li>
<li>âœ… ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œç›‘æ§</li>
</ol>
<hr />
<h2 id="-æ‰©å±•å­¦ä¹ èµ„æº"><a class="header" href="#-æ‰©å±•å­¦ä¹ èµ„æº">ğŸ“š æ‰©å±•å­¦ä¹ èµ„æº</a></h2>
<h3 id="å®˜æ–¹èµ„æº"><a class="header" href="#å®˜æ–¹èµ„æº">å®˜æ–¹èµ„æº</a></h3>
<ul>
<li><strong>ZeroMQå®˜æ–¹æ–‡æ¡£</strong>: http://zeromq.org/</li>
<li><strong>cppzmq GitHub</strong>: https://github.com/zeromq/cppzmq</li>
<li><strong>ZeroMQ Guideï¼ˆæŒ‡å—ï¼‰</strong>: http://zguide.zeromq.org/</li>
</ul>
<h3 id="æ¨èä¹¦ç±"><a class="header" href="#æ¨èä¹¦ç±">æ¨èä¹¦ç±</a></h3>
<ul>
<li>ã€ŠZeroMQã€‹by Pieter Hintjensï¼ˆå®˜æ–¹æŒ‡å—ä½œè€…ï¼‰</li>
<li>ã€ŠDistributed Systems with ZeroMQã€‹</li>
</ul>
<h3 id="å·¥å…·æ¨è"><a class="header" href="#å·¥å…·æ¨è">å·¥å…·æ¨è</a></h3>
<ul>
<li><strong>zmqpp</strong>: å¦ä¸€ä¸ªC++ç»‘å®šï¼ˆé¢å‘å¯¹è±¡ï¼‰</li>
<li><strong>netcat-zmq</strong>: ZeroMQç‰ˆæœ¬çš„netcatè°ƒè¯•å·¥å…·</li>
<li><strong>zproto</strong>: åè®®ä»£ç ç”Ÿæˆå™¨</li>
</ul>
<h3 id="ç›¸å…³æŠ€æœ¯"><a class="header" href="#ç›¸å…³æŠ€æœ¯">ç›¸å…³æŠ€æœ¯</a></h3>
<ul>
<li><strong>nanomsg</strong>: ZeroMQä½œè€…çš„æ–°é¡¹ç›®</li>
<li><strong>nng</strong>: nanomsgçš„ç»§ä»»è€…</li>
<li><strong>gRPC</strong>: Googleçš„RPCæ¡†æ¶ï¼ˆå¯ä¸ZeroMQå¯¹æ¯”å­¦ä¹ ï¼‰</li>
</ul>
<hr />
<h2 id="-ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„"><a class="header" href="#-ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„">ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„</a></h2>
<h3 id="çŸ­æœŸç›®æ ‡1-2å‘¨"><a class="header" href="#çŸ­æœŸç›®æ ‡1-2å‘¨">çŸ­æœŸç›®æ ‡ï¼ˆ1-2å‘¨ï¼‰</a></h3>
<ul>
<li>å®Œæˆæ‰€æœ‰åŸºç¡€æ¶ˆæ¯æ¨¡å¼çš„å®ç°</li>
<li>æ„å»ºä¸€ä¸ªå®Œæ•´çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨åº”ç”¨</li>
<li>æŒæ¡é”™è¯¯å¤„ç†å’Œè¶…æ—¶æœºåˆ¶</li>
</ul>
<h3 id="ä¸­æœŸç›®æ ‡1-2æœˆ"><a class="header" href="#ä¸­æœŸç›®æ ‡1-2æœˆ">ä¸­æœŸç›®æ ‡ï¼ˆ1-2æœˆï¼‰</a></h3>
<ul>
<li>å®ç°åˆ†å¸ƒå¼æ—¥å¿—æ”¶é›†ç³»ç»Ÿ</li>
<li>å­¦ä¹ é«˜çº§è·¯ç”±æ¨¡å¼</li>
<li>æ€§èƒ½æµ‹è¯•å’Œè°ƒä¼˜</li>
</ul>
<h3 id="é•¿æœŸç›®æ ‡3-6æœˆ"><a class="header" href="#é•¿æœŸç›®æ ‡3-6æœˆ">é•¿æœŸç›®æ ‡ï¼ˆ3-6æœˆï¼‰</a></h3>
<ul>
<li>åœ¨ç”Ÿäº§é¡¹ç›®ä¸­åº”ç”¨ZeroMQ</li>
<li>ä¸å¾®æœåŠ¡æ¶æ„é›†æˆ</li>
<li>è´¡çŒ®å¼€æºZeroMQç”Ÿæ€</li>
</ul>
<hr />
<h2 id="-æŠ€æœ¯è¦ç‚¹æ€»ç»“"><a class="header" href="#-æŠ€æœ¯è¦ç‚¹æ€»ç»“">ğŸ“Œ æŠ€æœ¯è¦ç‚¹æ€»ç»“</a></h2>
<h3 id="æ ¸å¿ƒä¼˜åŠ¿"><a class="header" href="#æ ¸å¿ƒä¼˜åŠ¿">æ ¸å¿ƒä¼˜åŠ¿</a></h3>
<ol>
<li><strong>æ— ä»£ç†æ¶æ„</strong> - å»ä¸­å¿ƒåŒ–ï¼Œå‡å°‘å•ç‚¹æ•…éšœ</li>
<li><strong>å¤šç§æ¨¡å¼</strong> - REQ-REPã€PUB-SUBã€PUSH-PULLã€ROUTER-DEALERç­‰</li>
<li><strong>é«˜æ€§èƒ½</strong> - å¼‚æ­¥I/Oï¼Œä½å»¶è¿Ÿï¼ˆå¾®ç§’çº§ï¼‰</li>
<li><strong>è‡ªåŠ¨é‡è¿</strong> - ç½‘ç»œä¸­æ–­åè‡ªåŠ¨æ¢å¤</li>
<li><strong>è·¨è¯­è¨€</strong> - 40+ç§è¯­è¨€ç»‘å®š</li>
<li><strong>ç®€å•API</strong> - ç±»ä¼¼socketçš„ç¼–ç¨‹æ¥å£</li>
</ol>
<h3 id="ä½¿ç”¨åœºæ™¯"><a class="header" href="#ä½¿ç”¨åœºæ™¯">ä½¿ç”¨åœºæ™¯</a></h3>
<p>âœ… <strong>é€‚åˆ</strong>ï¼šå¾®æœåŠ¡é€šä¿¡ã€å®æ—¶æ•°æ®æµã€åˆ†å¸ƒå¼ä»»åŠ¡ã€æ¸¸æˆæœåŠ¡å™¨ã€é‡‘èäº¤æ˜“
âŒ <strong>ä¸é€‚åˆ</strong>ï¼šéœ€è¦æŒä¹…åŒ–ã€å¤æ‚è·¯ç”±ã€Webç®¡ç†ç•Œé¢</p>
<h3 id="ä¸å…¶ä»–æŠ€æœ¯å¯¹æ¯”"><a class="header" href="#ä¸å…¶ä»–æŠ€æœ¯å¯¹æ¯”">ä¸å…¶ä»–æŠ€æœ¯å¯¹æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ç‰¹æ€§</th><th>ZeroMQ</th><th>RabbitMQ</th><th>Kafka</th><th>gRPC</th></tr></thead><tbody>
<tr><td>æ¶æ„</td><td>æ— ä»£ç†</td><td>æœ‰ä»£ç†</td><td>æœ‰ä»£ç†</td><td>æ— ä»£ç†</td></tr>
<tr><td>å»¶è¿Ÿ</td><td>æä½(Î¼s)</td><td>ä½(ms)</td><td>ä¸­(ms)</td><td>ä½(ms)</td></tr>
<tr><td>ååé‡</td><td>æé«˜</td><td>é«˜</td><td>æé«˜</td><td>ä¸­</td></tr>
<tr><td>æŒä¹…åŒ–</td><td>å¦</td><td>æ˜¯</td><td>æ˜¯</td><td>å¦</td></tr>
<tr><td>å­¦ä¹ æ›²çº¿</td><td>é™¡å³­</td><td>ä¸­ç­‰</td><td>é™¡å³­</td><td>ä¸­ç­‰</td></tr>
</tbody></table>
</div>
<hr />
<p><strong>å­¦ä¹ å»ºè®®ï¼š</strong>
ZeroMQæ˜¯æ„å»ºé«˜æ€§èƒ½åˆ†å¸ƒå¼ç³»ç»Ÿçš„åˆ©å™¨ï¼Œå»ºè®®ä»ç®€å•çš„REQ-REPæ¨¡å¼å¼€å§‹ï¼Œé€æ­¥æŒæ¡å¤æ‚æ¨¡å¼ã€‚é‡ç‚¹ç†è§£æ¶ˆæ¯æ¨¡å¼çš„é€‚ç”¨åœºæ™¯å’Œé™åˆ¶ï¼Œç»“åˆå®é™…é¡¹ç›®éœ€æ±‚é€‰æ‹©åˆé€‚çš„æ¶æ„ã€‚</p>
<p><strong>è®°ä½ï¼š</strong> ZeroMQæ˜¯ä¸€ä¸ªå·¥å…·åº“è€Œéå®Œæ•´çš„æ¶ˆæ¯é˜Ÿåˆ—ç³»ç»Ÿï¼Œéœ€è¦å¼€å‘è€…è‡ªå·±å®ç°å¯é æ€§ã€æŒä¹…åŒ–ç­‰é«˜çº§ç‰¹æ€§ã€‚</p>
<hr />
<p><em>æœ¬ç¬”è®°ç”±æŠ€æœ¯å­¦ä¹ ç¬”è®°ç”Ÿæˆä¸“å®¶åˆ›å»ºï¼ŒæŒç»­æ›´æ–°ä¸­...</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ç¼–ç¨‹/c++/xmake.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ç¼–ç¨‹/c++/æ¸¸æˆå¼•æ“-README.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ç¼–ç¨‹/c++/xmake.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ç¼–ç¨‹/c++/æ¸¸æˆå¼•æ“-README.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

