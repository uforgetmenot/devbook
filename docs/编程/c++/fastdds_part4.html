<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fast DDS 深度技术学习笔记（第四部分） - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="fast-dds-深度技术学习笔记第四部分"><a class="header" href="#fast-dds-深度技术学习笔记第四部分">Fast DDS 深度技术学习笔记（第四部分）</a></h1>
<blockquote>
<p>本笔记分为4个部分，本文件为第四部分（最后一部分），包含常见问题、验证标准、总结</p>
<ul>
<li><a href="fastdds.html">第一部分：技术概述、模块一、模块二</a></li>
<li><a href="fastdds_part2.html">第二部分：模块三、模块四</a></li>
<li><a href="fastdds_part3.html">第三部分：模块五、模块六、模块七</a></li>
</ul>
</blockquote>
<hr />
<h2 id="常见问题与调试技巧"><a class="header" href="#常见问题与调试技巧">常见问题与调试技巧</a></h2>
<h3 id="问题1无法发现对方discovery失败"><a class="header" href="#问题1无法发现对方discovery失败">问题1：无法发现对方（Discovery失败）</a></h3>
<p><strong>现象：</strong></p>
<ul>
<li>DataWriter和DataReader都创建成功</li>
<li>但PublicationMatchedStatus显示current_count = 0</li>
<li>数据无法传输</li>
</ul>
<p><strong>排查步骤：</strong></p>
<pre><code class="language-cpp">class DiscoveryDebugging {
public:
    // 步骤1：检查Domain ID
    void check_domain_id() {
        /*
        确保发布者和订阅者在同一个Domain

        发布者:
        DomainParticipant* pub_participant = factory-&gt;create_participant(0, qos);

        订阅者:
        DomainParticipant* sub_participant = factory-&gt;create_participant(0, qos);
                                                                         ^
                                                                      必须相同
        */
    }

    // 步骤2：检查Topic名称和类型
    void check_topic_and_type() {
        /*
        Topic名称必须完全一致（区分大小写）
        类型名称必须完全一致

        发布者:
        Topic* topic = participant-&gt;create_topic("SensorData", "SensorReading", qos);
                                                   ^^^^^^^^^      ^^^^^^^^^^^^^

        订阅者:
        Topic* topic = participant-&gt;create_topic("SensorData", "SensorReading", qos);
                                                   ^^^^^^^^^      ^^^^^^^^^^^^^
                                                   都必须一致
        */
    }

    // 步骤3：检查QoS兼容性
    void check_qos_compatibility() {
        // 使用监听器诊断
        class DiagnosticListener : public DataWriterListener {
        public:
            void on_publication_matched(
                DataWriter* writer,
                const PublicationMatchedStatus&amp; info) override {

                std::cout &lt;&lt; "Publication matched event:" &lt;&lt; std::endl;
                std::cout &lt;&lt; "  Current count: " &lt;&lt; info.current_count &lt;&lt; std::endl;
                std::cout &lt;&lt; "  Total count: " &lt;&lt; info.total_count &lt;&lt; std::endl;
                std::cout &lt;&lt; "  Current count change: " &lt;&lt; info.current_count_change &lt;&lt; std::endl;

                if (info.current_count == 0 &amp;&amp; info.total_count &gt; 0) {
                    std::cout &lt;&lt; "  ⚠ WARNING: Reader found but not matched" &lt;&lt; std::endl;
                    std::cout &lt;&lt; "  Possible QoS incompatibility!" &lt;&lt; std::endl;
                    std::cout &lt;&lt; "  Check Reliability, Durability, History, etc." &lt;&lt; std::endl;
                }
            }
        };
    }

    // 步骤4：检查网络和防火墙
    void check_network() {
        using namespace eprosima::fastdds::dds;

        /*
        1. 检查是否可以Ping通对方
           ping 192.168.1.100

        2. 检查多播是否启用
           Linux: ip maddr show
           确保网卡支持多播

        3. 检查防火墙规则
           Fast DDS默认使用UDP端口 7400-7500
           确保这些端口开放

           Linux:
           sudo iptables -A INPUT -p udp --dport 7400:7500 -j ACCEPT

           Windows:
           在Windows防火墙中添加规则

        4. 使用tcpdump/Wireshark抓包
           sudo tcpdump -i eth0 port 7400 -X
           检查是否有SPDP/SEDP包

        5. 强制使用单播（绕过多播问题）
        */
        DomainParticipantQos qos;

        // 禁用多播
        qos.wire_protocol().builtin.avoid_builtin_multicast = true;

        // 添加对等点（单播）
        Locator_t peer;
        peer.kind = LOCATOR_KIND_UDPv4;
        peer.port = 7400;
        IPLocator::setIPv4(peer, "192.168.1.100");
        qos.wire_protocol().builtin.initialPeersList.push_back(peer);
    }

    // 步骤5：启用详细日志
    void enable_verbose_logging() {
        using namespace eprosima::fastdds::dds;

        // 设置日志级别
        Log::SetVerbosity(Log::Kind::Info);  // 或 Log::Kind::Warning, Log::Kind::Error

        // 设置日志过滤
        Log::SetCategoryFilter(std::regex("RTPS"));  // 只显示RTPS相关日志

        /*
        日志级别：
        - Error: 只显示错误
        - Warning: 显示警告和错误
        - Info: 显示信息、警告、错误（推荐调试）
        */

        // 也可以通过环境变量设置
        // export FASTDDS_LOG_LEVEL=info
    }
};
</code></pre>
<h3 id="问题2数据传输性能低"><a class="header" href="#问题2数据传输性能低">问题2：数据传输性能低</a></h3>
<p><strong>现象：</strong></p>
<ul>
<li>延迟高（&gt;1ms）</li>
<li>吞吐量低（&lt;10MB/s）</li>
<li>CPU占用高</li>
</ul>
<p><strong>优化方案：</strong></p>
<pre><code class="language-cpp">class PerformanceOptimization {
public:
    // 优化1：使用共享内存传输（同机器）
    void use_shared_memory() {
        using namespace eprosima::fastdds::dds;

        DomainParticipantQos qos;
        qos.transport().use_builtin_transports = false;

        auto shm = std::make_shared&lt;eprosima::fastdds::rtps::SharedMemTransportDescriptor&gt;();
        shm-&gt;segment_size(2 * 1024 * 1024);  // 2MB段
        qos.transport().user_transports.push_back(shm);

        // 性能提升：延迟从200μs降到50μs，吞吐量从100MB/s提升到2GB/s
    }

    // 优化2：启用批量传输
    void enable_batching() {
        using namespace eprosima::fastdds::dds;

        PublisherQos pub_qos;
        pub_qos.properties().properties().emplace_back("fastdds.batch_mode", "true");
        pub_qos.properties().properties().emplace_back("fastdds.batch_max_size", "65536");

        // 性能提升：小消息吞吐量提升3-5倍
    }

    // 优化3：启用零拷贝（数据共享）
    void enable_zero_copy() {
        using namespace eprosima::fastdds::dds;

        DataWriterQos writer_qos;
        writer_qos.data_sharing().automatic();  // 或 .on("/tmp")

        // 性能提升：大消息（&gt;100KB）吞吐量提升5-10倍
    }

    // 优化4：调整QoS策略
    void optimize_qos() {
        using namespace eprosima::fastdds::dds;

        // 对于高频传感器数据：使用BEST_EFFORT
        DataWriterQos qos;
        qos.reliability().kind = BEST_EFFORT_RELIABILITY_QOS;  // 不等待ACK
        qos.durability().kind = VOLATILE_DURABILITY_QOS;
        qos.history().kind = KEEP_LAST_HISTORY_QOS;
        qos.history().depth = 1;  // 只保留最新值

        // 性能提升：延迟降低50%，吞吐量提升30%
    }

    // 优化5：增大缓冲区
    void increase_buffers() {
        using namespace eprosima::fastdds::dds;

        DomainParticipantQos qos;
        qos.transport().use_builtin_transports = false;

        auto udp = std::make_shared&lt;eprosima::fastdds::rtps::UDPv4TransportDescriptor&gt;();
        udp-&gt;sendBufferSize = 2 * 1024 * 1024;     // 2MB
        udp-&gt;receiveBufferSize = 2 * 1024 * 1024;  // 2MB

        qos.transport().user_transports.push_back(udp);

        // 性能提升：减少丢包，提升高负载下的吞吐量
    }

    // 优化6：使用异步发布
    void use_async_publish() {
        using namespace eprosima::fastdds::dds;

        DataWriterQos qos;
        qos.publish_mode().kind = ASYNCHRONOUS_PUBLISH_MODE;

        // 性能提升：write()调用立即返回，不阻塞
    }

    // 综合优化示例
    void apply_all_optimizations() {
        using namespace eprosima::fastdds::dds;

        // 参与者优化
        DomainParticipantQos participant_qos;
        participant_qos.transport().use_builtin_transports = false;

        auto shm = std::make_shared&lt;eprosima::fastdds::rtps::SharedMemTransportDescriptor&gt;();
        shm-&gt;segment_size(4 * 1024 * 1024);

        auto udp = std::make_shared&lt;eprosima::fastdds::rtps::UDPv4TransportDescriptor&gt;();
        udp-&gt;sendBufferSize = 2 * 1024 * 1024;
        udp-&gt;receiveBufferSize = 2 * 1024 * 1024;

        participant_qos.transport().user_transports.push_back(shm);
        participant_qos.transport().user_transports.push_back(udp);

        DomainParticipant* participant = DomainParticipantFactory::get_instance()
            -&gt;create_participant(0, participant_qos);

        // 发布者优化
        PublisherQos pub_qos;
        pub_qos.properties().properties().emplace_back("fastdds.batch_mode", "true");
        pub_qos.properties().properties().emplace_back("fastdds.batch_max_size", "131072");

        Publisher* publisher = participant-&gt;create_publisher(pub_qos);

        // DataWriter优化
        DataWriterQos writer_qos;
        writer_qos.reliability().kind = BEST_EFFORT_RELIABILITY_QOS;
        writer_qos.durability().kind = VOLATILE_DURABILITY_QOS;
        writer_qos.history().kind = KEEP_LAST_HISTORY_QOS;
        writer_qos.history().depth = 1;
        writer_qos.publish_mode().kind = ASYNCHRONOUS_PUBLISH_MODE;
        writer_qos.data_sharing().automatic();

        // DataWriter* writer = publisher-&gt;create_datawriter(topic, writer_qos);

        std::cout &lt;&lt; "All optimizations applied!" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Expected performance:" &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Latency: 50-100 μs (local)" &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Throughput: 1-2 GB/s (local with SHM)" &lt;&lt; std::endl;
    }
};
</code></pre>
<h3 id="问题3内存泄漏"><a class="header" href="#问题3内存泄漏">问题3：内存泄漏</a></h3>
<p><strong>现象：</strong></p>
<ul>
<li>程序运行一段时间后内存持续增长</li>
<li>使用valgrind检测到内存泄漏</li>
</ul>
<p><strong>排查与修复：</strong></p>
<pre><code class="language-cpp">class MemoryLeakPrevention {
public:
    // 问题1：未正确删除DDS实体
    void correct_cleanup_order() {
        /*
        正确的清理顺序（相反于创建顺序）：
        1. DataReader / DataWriter
        2. Subscriber / Publisher
        3. Topic
        4. DomainParticipant
        */

        // ✅ 正确示例
        class ProperCleanup {
        private:
            DomainParticipant* participant_;
            Publisher* publisher_;
            Subscriber* subscriber_;
            Topic* topic_;
            DataWriter* writer_;
            DataReader* reader_;

        public:
            ~ProperCleanup() {
                // 步骤1：删除DataReader/DataWriter
                if (reader_ &amp;&amp; subscriber_) {
                    subscriber_-&gt;delete_datareader(reader_);
                }
                if (writer_ &amp;&amp; publisher_) {
                    publisher_-&gt;delete_datawriter(writer_);
                }

                // 步骤2：删除Subscriber/Publisher
                if (subscriber_ &amp;&amp; participant_) {
                    participant_-&gt;delete_subscriber(subscriber_);
                }
                if (publisher_ &amp;&amp; participant_) {
                    participant_-&gt;delete_publisher(publisher_);
                }

                // 步骤3：删除Topic
                if (topic_ &amp;&amp; participant_) {
                    participant_-&gt;delete_topic(topic_);
                }

                // 步骤4：删除Participant
                if (participant_) {
                    DomainParticipantFactory::get_instance()-&gt;delete_participant(participant_);
                }
            }
        };

        // ❌ 错误示例：顺序错误
        // delete participant_;  // 先删除participant
        // delete writer_;       // 再删除writer - 段错误！
    }

    // 问题2：监听器对象未释放
    void manage_listener_lifetime() {
        /*
        监听器对象的生命周期必须长于DataReader/DataWriter
        */

        // ❌ 错误：监听器对象在栈上，作用域结束后被销毁
        void create_reader_bad() {
            MyListener listener;  // 栈对象

            DataReader* reader = subscriber_-&gt;create_datareader(
                topic_, qos, &amp;listener);

            // listener在函数结束时销毁，但reader仍在使用它 - 段错误！
        }

        // ✅ 正确：监听器对象在堆上
        class GoodListenerManagement {
        private:
            DataReader* reader_;
            std::unique_ptr&lt;DataReaderListener&gt; listener_;

        public:
            void create_reader() {
                listener_ = std::make_unique&lt;MyListener&gt;();

                reader_ = subscriber_-&gt;create_datareader(
                    topic_, qos, listener_.get());
            }

            ~GoodListenerManagement() {
                if (reader_) {
                    subscriber_-&gt;delete_datareader(reader_);
                }
                // listener_会在reader_删除后自动释放
            }
        };
    }

    // 问题3：历史数据未清理
    void manage_history() {
        using namespace eprosima::fastdds::dds;

        // 设置合理的ResourceLimits
        DataWriterQos qos;
        qos.history().kind = KEEP_LAST_HISTORY_QOS;
        qos.history().depth = 10;  // 不要设置过大

        qos.resource_limits().max_samples = 100;
        qos.resource_limits().max_instances = 10;
        qos.resource_limits().max_samples_per_instance = 10;

        /*
        内存占用 ≈ max_samples * sizeof(SampleType)

        如果max_samples = 10000, sizeof(SampleType) = 1KB
        则内存占用 ≈ 10MB

        设置过大会导致内存占用过高
        */
    }

    // 使用valgrind检测内存泄漏
    void detect_memory_leaks() {
        /*
        编译时添加调试符号：
        g++ -g -o myapp main.cpp -lfastrtps -lfastcdr

        运行valgrind：
        valgrind --leak-check=full --show-leak-kinds=all ./myapp

        输出示例：
        ==12345== LEAK SUMMARY:
        ==12345==    definitely lost: 1,024 bytes in 1 blocks
        ==12345==    indirectly lost: 512 bytes in 2 blocks
        ==12345==      possibly lost: 0 bytes in 0 blocks

        关注 "definitely lost" 和 "indirectly lost"

        定位泄漏位置：
        ==12345==    at malloc (vg_replace_malloc.c:380)
        ==12345==    by MyClass::create_participant (myclass.cpp:42)
        ==12345==    by main (main.cpp:15)

        修复：在myclass.cpp:42附近添加对应的delete操作
        */
    }
};
</code></pre>
<h3 id="问题4段错误segmentation-fault"><a class="header" href="#问题4段错误segmentation-fault">问题4：段错误（Segmentation Fault）</a></h3>
<p><strong>常见原因与修复：</strong></p>
<pre><code class="language-cpp">class SegfaultDebugging {
public:
    // 原因1：访问空指针
    void null_pointer_access() {
        // ❌ 错误
        DataWriter* writer = nullptr;
        writer-&gt;write(&amp;sample);  // 段错误！

        // ✅ 正确：总是检查指针
        if (writer != nullptr) {
            writer-&gt;write(&amp;sample);
        }

        // 或使用断言（调试版本）
        assert(writer != nullptr);
        writer-&gt;write(&amp;sample);
    }

    // 原因2：使用已删除的对象
    void use_after_delete() {
        // ❌ 错误
        DataWriter* writer = publisher_-&gt;create_datawriter(topic_, qos);
        publisher_-&gt;delete_datawriter(writer);
        writer-&gt;write(&amp;sample);  // 段错误！writer已被删除

        // ✅ 正确：删除后置空
        publisher_-&gt;delete_datawriter(writer);
        writer = nullptr;

        // 或使用智能指针
        struct DataWriterDeleter {
            Publisher* pub;
            void operator()(DataWriter* w) {
                if (pub &amp;&amp; w) pub-&gt;delete_datawriter(w);
            }
        };

        std::unique_ptr&lt;DataWriter, DataWriterDeleter&gt; writer_ptr(
            publisher_-&gt;create_datawriter(topic_, qos),
            DataWriterDeleter{publisher_});
    }

    // 原因3：多线程竞争
    void thread_safety() {
        /*
        Fast DDS的线程安全规则：
        1. DomainParticipant是线程安全的
        2. DataWriter和DataReader是线程安全的
        3. 但不能同时创建/删除同一个实体

        ❌ 错误：多线程同时操作
        */
        std::thread t1([this]() {
            participant_-&gt;create_publisher(PUBLISHER_QOS_DEFAULT);
        });

        std::thread t2([this]() {
            participant_-&gt;create_subscriber(SUBSCRIBER_QOS_DEFAULT);
        });

        // ✅ 正确：加锁保护
        std::mutex participant_mutex_;

        std::thread t1_safe([this]() {
            std::lock_guard&lt;std::mutex&gt; lock(participant_mutex_);
            participant_-&gt;create_publisher(PUBLISHER_QOS_DEFAULT);
        });

        std::thread t2_safe([this]() {
            std::lock_guard&lt;std::mutex&gt; lock(participant_mutex_);
            participant_-&gt;create_subscriber(SUBSCRIBER_QOS_DEFAULT);
        });
    }

    // 使用gdb调试段错误
    void debug_with_gdb() {
        /*
        1. 编译时添加调试符号：
           g++ -g -o myapp main.cpp -lfastrtps -lfastcdr

        2. 运行gdb：
           gdb ./myapp

        3. 设置断点：
           (gdb) break main
           (gdb) run

        4. 发生段错误时：
           (gdb) backtrace   # 查看调用栈
           (gdb) frame 0     # 切换到栈帧
           (gdb) print writer  # 打印变量
           (gdb) info locals  # 查看所有局部变量

        5. 检查核心转储文件：
           ulimit -c unlimited  # 启用核心转储
           ./myapp              # 运行程序（崩溃后生成core文件）
           gdb ./myapp core     # 分析core文件

        6. 常见段错误位置：
           - 指针未初始化：int* p; *p = 10;
           - 访问已删除对象：delete p; p-&gt;foo();
           - 数组越界：int arr[10]; arr[100] = 0;
           - 栈溢出：递归过深
        */
    }
};
</code></pre>
<h3 id="问题5qos不匹配警告"><a class="header" href="#问题5qos不匹配警告">问题5：QoS不匹配警告</a></h3>
<p><strong>现象：</strong></p>
<pre><code>[RTPS_QOS_CHECK] QoS incompatible: Reliability offered (BEST_EFFORT) does not match requested (RELIABLE)
</code></pre>
<p><strong>QoS兼容性规则：</strong></p>
<pre><code class="language-cpp">class QoSCompatibilityGuide {
public:
    void explain_qos_compatibility() {
        std::cout &lt;&lt; "=== QoS 兼容性规则 ===" &lt;&lt; std::endl;

        std::cout &lt;&lt; "\n1. Reliability (可靠性):" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: RELIABLE,   Reader: RELIABLE    ✓ 匹配" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: RELIABLE,   Reader: BEST_EFFORT ✓ 匹配（Writer提供更高保证）" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: BEST_EFFORT, Reader: RELIABLE    ✗ 不匹配" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: BEST_EFFORT, Reader: BEST_EFFORT ✓ 匹配" &lt;&lt; std::endl;

        std::cout &lt;&lt; "\n2. Durability (持久性):" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: TRANSIENT_LOCAL, Reader: VOLATILE         ✓ 匹配" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: TRANSIENT_LOCAL, Reader: TRANSIENT_LOCAL  ✓ 匹配" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: VOLATILE,        Reader: TRANSIENT_LOCAL  ✗ 不匹配" &lt;&lt; std::endl;

        std::cout &lt;&lt; "\n3. Deadline (截止时间):" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: 100ms, Reader: 200ms  ✓ 匹配（Writer更频繁）" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer: 200ms, Reader: 100ms  ✗ 不匹配（Writer太慢）" &lt;&lt; std::endl;

        std::cout &lt;&lt; "\n4. Ownership (所有权):" &lt;&lt; std::endl;
        std::cout &lt;&lt; "   Writer和Reader的ownership.kind必须完全一致" &lt;&lt; std::endl;

        std::cout &lt;&lt; "\n总原则：Writer提供的QoS必须满足或超过Reader要求的QoS" &lt;&lt; std::endl;
    }

    // 诊断工具
    void diagnose_qos_mismatch() {
        using namespace eprosima::fastdds::dds;

        class DiagnosticListener : public DataWriterListener {
        public:
            void on_publication_matched(
                DataWriter* writer,
                const PublicationMatchedStatus&amp; info) override {

                if (info.current_count_change == 0 &amp;&amp; info.total_count_change &gt; 0) {
                    std::cout &lt;&lt; "⚠ QoS不匹配！检测到Reader但未匹配" &lt;&lt; std::endl;
                    std::cout &lt;&lt; "可能的原因：" &lt;&lt; std::endl;
                    std::cout &lt;&lt; "  - Reliability不兼容" &lt;&lt; std::endl;
                    std::cout &lt;&lt; "  - Durability不兼容" &lt;&lt; std::endl;
                    std::cout &lt;&lt; "  - Deadline不兼容" &lt;&lt; std::endl;
                    std::cout &lt;&lt; "  - Ownership不兼容" &lt;&lt; std::endl;
                }

                if (info.current_count_change &gt; 0) {
                    std::cout &lt;&lt; "✓ QoS匹配成功" &lt;&lt; std::endl;
                }
            }
        };
    }

    // 快速修复
    void quick_fix_qos_mismatch() {
        using namespace eprosima::fastdds::dds;

        /*
        方法1：都使用默认QoS
        */
        DataWriterQos writer_qos = DATAWRITER_QOS_DEFAULT;
        DataReaderQos reader_qos = DATAREADER_QOS_DEFAULT;

        /*
        方法2：Writer提供最高保证
        */
        DataWriterQos high_qos;
        high_qos.reliability().kind = RELIABLE_RELIABILITY_QOS;
        high_qos.durability().kind = TRANSIENT_LOCAL_DURABILITY_QOS;

        // Reader可以使用更低的要求
        DataReaderQos low_qos;
        low_qos.reliability().kind = BEST_EFFORT_RELIABILITY_QOS;  // 仍可匹配
        low_qos.durability().kind = VOLATILE_DURABILITY_QOS;       // 仍可匹配

        /*
        方法3：使用QoS配置文件（XML）
        确保Writer和Reader使用相同的profile
        */
    }
};
</code></pre>
<hr />
<h2 id="学习验证标准"><a class="header" href="#学习验证标准">学习验证标准</a></h2>
<p>完成Fast DDS学习后，您应该能够达到以下标准：</p>
<h3 id="基础能力验证必须掌握"><a class="header" href="#基础能力验证必须掌握">基础能力验证（必须掌握）</a></h3>
<h4 id="1-dds核心概念"><a class="header" href="#1-dds核心概念">1. DDS核心概念</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够解释Domain、Participant、Topic、Publisher、Subscriber的关系</li>
<li><input disabled="" type="checkbox"/>
理解DCPS（Data-Centric Publish-Subscribe）模型</li>
<li><input disabled="" type="checkbox"/>
能够绘制Fast DDS的架构图</li>
<li><input disabled="" type="checkbox"/>
理解服务发现机制（SPDP/SEDP）</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code class="language-cpp">// 任务：不查阅资料，从头编写一个HelloWorld发布-订阅程序
// 要求：
// 1. 创建DomainParticipant
// 2. 定义IDL类型并注册
// 3. 创建Topic
// 4. 创建Publisher和DataWriter
// 5. 创建Subscriber和DataReader
// 6. 实现数据发送和接收
// 时间限制：30分钟
</code></pre>
<h4 id="2-qos策略配置"><a class="header" href="#2-qos策略配置">2. QoS策略配置</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够根据应用场景选择合适的QoS策略</li>
<li><input disabled="" type="checkbox"/>
理解Reliability、Durability、History的区别</li>
<li><input disabled="" type="checkbox"/>
能够配置ResourceLimits避免内存泄漏</li>
<li><input disabled="" type="checkbox"/>
理解QoS兼容性规则</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code class="language-cpp">// 任务：为以下场景配置合适的QoS

// 场景1：高频传感器数据（100Hz），允许丢失
// 要求：延迟&lt;1ms，吞吐量&gt;1000 samples/sec
DataWriterQos sensor_qos;
// TODO: 配置QoS

// 场景2：配置管理系统，不允许丢失，晚启动的节点也要收到
DataWriterQos config_qos;
// TODO: 配置QoS

// 场景3：控制指令，可靠传输，但不能阻塞太久
DataWriterQos control_qos;
// TODO: 配置QoS

// 验证标准：
// - 所有QoS配置合理
// - 能够解释为什么这样配置
// - 时间限制：15分钟
</code></pre>
<h4 id="3-idl类型定义"><a class="header" href="#3-idl类型定义">3. IDL类型定义</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够编写IDL文件定义数据类型</li>
<li><input disabled="" type="checkbox"/>
理解基本类型、数组、序列、结构、枚举</li>
<li><input disabled="" type="checkbox"/>
能够使用fastddsgen生成C++代码</li>
<li><input disabled="" type="checkbox"/>
理解@key的作用（Instance区分）</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code class="language-idl">// 任务：为智能家居系统定义IDL类型
// 要求：
// 1. 传感器读数（温度、湿度、光照）
// 2. 设备状态（开关、亮度、颜色）
// 3. 告警消息（类型、级别、时间戳）
// 4. 使用@key定义Instance
// 5. 使用枚举和结构嵌套
// 时间限制：20分钟
</code></pre>
<h3 id="进阶能力验证推荐掌握"><a class="header" href="#进阶能力验证推荐掌握">进阶能力验证（推荐掌握）</a></h3>
<h4 id="4-传输层优化"><a class="header" href="#4-传输层优化">4. 传输层优化</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够配置共享内存传输</li>
<li><input disabled="" type="checkbox"/>
理解零拷贝（Data Sharing）原理</li>
<li><input disabled="" type="checkbox"/>
能够配置流量控制</li>
<li><input disabled="" type="checkbox"/>
能够进行性能基准测试</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code class="language-cpp">// 任务：优化大数据传输性能
// 场景：传输10MB图像数据，要求吞吐量&gt;500MB/s
// 步骤：
// 1. 实现基线版本（默认UDP）
// 2. 测量延迟和吞吐量
// 3. 应用优化（SHM + Zero-Copy + Batching）
// 4. 再次测量并对比
// 验证标准：吞吐量提升至少5倍
// 时间限制：1小时
</code></pre>
<h4 id="5-服务发现配置"><a class="header" href="#5-服务发现配置">5. 服务发现配置</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够配置Simple Discovery参数</li>
<li><input disabled="" type="checkbox"/>
能够搭建Discovery Server</li>
<li><input disabled="" type="checkbox"/>
理解静态发现的使用场景</li>
<li><input disabled="" type="checkbox"/>
能够诊断发现问题</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code class="language-cpp">// 任务：搭建Discovery Server系统
// 要求：
// 1. 配置Discovery Server（端口11811）
// 2. 配置2个Client连接到Server
// 3. 实现数据通信
// 4. 观察发现过程（使用监听器）
// 验证标准：Client成功通过Server发现彼此
// 时间限制：40分钟
</code></pre>
<h4 id="6-安全传输"><a class="header" href="#6-安全传输">6. 安全传输</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够生成安全证书</li>
<li><input disabled="" type="checkbox"/>
能够配置DDS Security</li>
<li><input disabled="" type="checkbox"/>
理解认证、访问控制、加密三大插件</li>
<li><input disabled="" type="checkbox"/>
能够调试安全问题</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code class="language-bash"># 任务：搭建安全通信系统
# 步骤：
# 1. 生成CA证书和参与者证书
# 2. 创建governance.xml和permissions.xml
# 3. 配置安全参与者
# 4. 实现加密通信
# 验证标准：
# - 使用Wireshark确认数据已加密
# - 未授权节点无法通信
# 时间限制：2小时
</code></pre>
<h3 id="高级能力验证可选掌握"><a class="header" href="#高级能力验证可选掌握">高级能力验证（可选掌握）</a></h3>
<h4 id="7-实战项目"><a class="header" href="#7-实战项目">7. 实战项目</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够设计并实现完整的分布式系统</li>
<li><input disabled="" type="checkbox"/>
能够处理异常情况（节点掉线、网络中断）</li>
<li><input disabled="" type="checkbox"/>
能够进行性能调优</li>
<li><input disabled="" type="checkbox"/>
能够部署到生产环境</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code>任务：实现分布式机器人控制系统
组件：
1. 传感器节点（3个）：发布传感器数据
2. 控制节点（1个）：接收数据并发送控制指令
3. 监控节点（1个）：实时监控系统状态
4. 配置节点（1个）：动态配置传感器参数

要求：
- 使用混合传输（SHM + UDP）
- 实现安全通信
- 支持节点动态上下线
- 提供监控界面（简单CLI）
- 性能要求：延迟&lt;10ms，支持10+ nodes

验证标准：
- 系统稳定运行30分钟无崩溃
- 能够处理节点异常
- 性能满足要求

时间限制：1天
</code></pre>
<h4 id="8-故障排查能力"><a class="header" href="#8-故障排查能力">8. 故障排查能力</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
能够使用日志诊断问题</li>
<li><input disabled="" type="checkbox"/>
能够使用Wireshark抓包分析</li>
<li><input disabled="" type="checkbox"/>
能够使用gdb调试段错误</li>
<li><input disabled="" type="checkbox"/>
能够使用valgrind检测内存泄漏</li>
</ul>
<p><strong>验证方式：</strong></p>
<pre><code>任务：诊断并修复以下问题

问题1：程序运行后无法发现对方
提示：检查Domain ID、QoS、网络配置

问题2：数据传输延迟很高（&gt;100ms）
提示：检查传输配置、QoS策略

问题3：程序运行一段时间后崩溃
提示：使用gdb和valgrind诊断

验证标准：能够在1小时内定位并修复所有问题
</code></pre>
<hr />
<h2 id="学习总结"><a class="header" href="#学习总结">学习总结</a></h2>
<h3 id="fast-dds技术栈总览"><a class="header" href="#fast-dds技术栈总览">Fast DDS技术栈总览</a></h3>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                   应用层 (Application)                  │
│  - 业务逻辑                                              │
│  - 数据处理                                              │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│                DDS API (DCPS Layer)                      │
│  - DomainParticipant, Topic, Publisher, Subscriber     │
│  - DataWriter, DataReader                              │
│  - QoS Policies                                        │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│              RTPS Protocol (Wire Protocol)              │
│  - Discovery (SPDP, SEDP)                              │
│  - Reliability Protocol                                │
│  - Liveliness Protocol                                 │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│            Transport Layer (UDP/TCP/SHM)                │
│  - Shared Memory                                        │
│  - UDPv4 / UDPv6                                       │
│  - TCPv4 / TCPv6                                       │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="核心知识点回顾"><a class="header" href="#核心知识点回顾">核心知识点回顾</a></h3>
<h4 id="1-dcps模型5个核心概念"><a class="header" href="#1-dcps模型5个核心概念">1. DCPS模型（5个核心概念）</a></h4>
<pre><code>Domain → DomainParticipant → Topic → Publisher/Subscriber → DataWriter/DataReader
</code></pre>
<ul>
<li><strong>Domain</strong>: 逻辑隔离的通信域</li>
<li><strong>DomainParticipant</strong>: 应用在Domain中的代理</li>
<li><strong>Topic</strong>: 数据类型和名称的契约</li>
<li><strong>Publisher/Subscriber</strong>: 发布/订阅容器</li>
<li><strong>DataWriter/DataReader</strong>: 实际的数据端点</li>
</ul>
<h4 id="2-qos策略22种核心8种"><a class="header" href="#2-qos策略22种核心8种">2. QoS策略（22种，核心8种）</a></h4>
<div class="table-wrapper"><table><thead><tr><th>策略</th><th>作用</th><th>常用值</th></tr></thead><tbody>
<tr><td>Reliability</td><td>可靠性</td><td>RELIABLE / BEST_EFFORT</td></tr>
<tr><td>Durability</td><td>持久性</td><td>VOLATILE / TRANSIENT_LOCAL</td></tr>
<tr><td>History</td><td>历史缓存</td><td>KEEP_LAST(N) / KEEP_ALL</td></tr>
<tr><td>ResourceLimits</td><td>资源限制</td><td>max_samples, max_instances</td></tr>
<tr><td>Deadline</td><td>更新周期</td><td>Duration_t(sec, nanosec)</td></tr>
<tr><td>Lifespan</td><td>数据生命周期</td><td>Duration_t(sec, nanosec)</td></tr>
<tr><td>Ownership</td><td>所有权</td><td>SHARED / EXCLUSIVE</td></tr>
<tr><td>Partition</td><td>分区</td><td>字符串列表</td></tr>
</tbody></table>
</div>
<h4 id="3-传输层3种主要传输"><a class="header" href="#3-传输层3种主要传输">3. 传输层（3种主要传输）</a></h4>
<div class="table-wrapper"><table><thead><tr><th>传输</th><th>延迟</th><th>吞吐量</th><th>适用场景</th></tr></thead><tbody>
<tr><td>UDP</td><td>200μs</td><td>100MB/s</td><td>跨机器通信</td></tr>
<tr><td>TCP</td><td>500μs</td><td>120MB/s</td><td>WAN、防火墙环境</td></tr>
<tr><td>SHM</td><td>50μs</td><td>2GB/s</td><td>本地进程间通信</td></tr>
</tbody></table>
</div>
<h4 id="4-服务发现3种模式"><a class="header" href="#4-服务发现3种模式">4. 服务发现（3种模式）</a></h4>
<div class="table-wrapper"><table><thead><tr><th>模式</th><th>网络复杂度</th><th>适用规模</th><th>优点</th><th>缺点</th></tr></thead><tbody>
<tr><td>Simple Discovery</td><td>O(N²)</td><td>&lt;50 nodes</td><td>去中心化</td><td>流量大</td></tr>
<tr><td>Discovery Server</td><td>O(N)</td><td>&gt;50 nodes</td><td>流量小</td><td>单点故障</td></tr>
<tr><td>Static Discovery</td><td>O(1)</td><td>固定拓扑</td><td>零开销</td><td>缺乏灵活性</td></tr>
</tbody></table>
</div>
<h4 id="5-性能优化6大技巧"><a class="header" href="#5-性能优化6大技巧">5. 性能优化（6大技巧）</a></h4>
<ol>
<li><strong>使用共享内存</strong>：本地通信性能提升10倍</li>
<li><strong>启用数据共享</strong>：零拷贝，大数据传输提升5-10倍</li>
<li><strong>批量传输</strong>：小消息吞吐量提升3-5倍</li>
<li><strong>异步发布</strong>：write()调用不阻塞</li>
<li><strong>增大缓冲区</strong>：减少丢包</li>
<li><strong>选择合适QoS</strong>：BEST_EFFORT降低延迟50%</li>
</ol>
<h3 id="实战经验总结"><a class="header" href="#实战经验总结">实战经验总结</a></h3>
<h4 id="开发流程"><a class="header" href="#开发流程">开发流程</a></h4>
<pre><code>1. 需求分析
   - 确定数据类型（IDL定义）
   - 确定QoS需求（可靠性、延迟、吞吐量）
   - 确定拓扑结构（节点数量、通信模式）

2. 设计阶段
   - 设计Topic结构
   - 设计QoS配置
   - 选择传输方式
   - 选择发现模式

3. 实现阶段
   - 编写IDL文件
   - 生成代码（fastddsgen）
   - 实现发布者和订阅者
   - 配置QoS和传输

4. 测试阶段
   - 功能测试（数据正确性）
   - 性能测试（延迟、吞吐量）
   - 压力测试（长时间运行）
   - 异常测试（节点掉线、网络中断）

5. 部署阶段
   - 配置生产环境参数
   - 监控系统运行
   - 日志分析
   - 性能调优
</code></pre>
<h4 id="调试技巧"><a class="header" href="#调试技巧">调试技巧</a></h4>
<pre><code>1. 发现问题
   - 启用详细日志（Log::SetVerbosity(Log::Info)）
   - 使用发现监听器（on_participant_discovery）
   - 检查网络配置（ping、多播、防火墙）

2. 性能问题
   - 使用性能基准测试工具
   - 分析瓶颈（CPU、网络、磁盘）
   - 应用优化技巧

3. 崩溃问题
   - 使用gdb定位段错误
   - 使用valgrind检测内存泄漏
   - 检查清理顺序

4. QoS问题
   - 使用监听器诊断匹配失败
   - 检查QoS兼容性规则
   - 使用XML配置统一QoS
</code></pre>
<h3 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h3>
<h4 id="1-代码组织"><a class="header" href="#1-代码组织">1. 代码组织</a></h4>
<pre><code class="language-cpp">class BestPractices {
    // ✓ 好的实践
    class GoodOrganization {
    private:
        // 1. 使用RAII管理资源
        struct ParticipantRAII {
            DomainParticipant* participant;
            ~ParticipantRAII() {
                if (participant) {
                    DomainParticipantFactory::get_instance()-&gt;delete_participant(participant);
                }
            }
        };

        // 2. 封装DDS操作
        class DDSManager {
        public:
            bool initialize();
            bool publish(const Data&amp; data);
            bool subscribe(std::function&lt;void(const Data&amp;)&gt; callback);
            void shutdown();
        };

        // 3. 使用配置类
        struct DDSConfig {
            int domain_id = 0;
            std::string participant_name;
            bool use_shared_memory = true;
            bool enable_security = false;
        };
    };
};
</code></pre>
<h4 id="2-错误处理"><a class="header" href="#2-错误处理">2. 错误处理</a></h4>
<pre><code class="language-cpp">// ✓ 总是检查返回值
ReturnCode_t ret = writer-&gt;write(&amp;sample);
if (ret != ReturnCode_t::RETCODE_OK) {
    std::cerr &lt;&lt; "Write failed: " &lt;&lt; ret &lt;&lt; std::endl;
    // 处理错误...
}

// ✓ 使用异常处理
try {
    TypeSupport type(new HelloWorldPubSubType());
    type.register_type(participant);
} catch (const std::exception&amp; e) {
    std::cerr &lt;&lt; "Type registration failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
}

// ✓ 使用监听器处理异常事件
class RobustListener : public DataReaderListener {
    void on_sample_lost(DataReader*, const SampleLostStatus&amp; status) override {
        std::cerr &lt;&lt; "Samples lost: " &lt;&lt; status.total_count &lt;&lt; std::endl;
    }

    void on_subscription_matched(DataReader*, const SubscriptionMatchedStatus&amp; info) override {
        if (info.current_count == 0 &amp;&amp; info.total_count &gt; 0) {
            std::cerr &lt;&lt; "All writers disconnected!" &lt;&lt; std::endl;
        }
    }
};
</code></pre>
<h4 id="3-性能考量"><a class="header" href="#3-性能考量">3. 性能考量</a></h4>
<pre><code class="language-cpp">// ✓ 优先使用监听器而非轮询
class EfficientReading {
    // 好：事件驱动
    class MyListener : public DataReaderListener {
        void on_data_available(DataReader* reader) override {
            // 数据到达时自动调用
        }
    };

    // 避免：轮询（浪费CPU）
    void bad_polling() {
        while (true) {
            reader-&gt;take_next_sample(&amp;sample, &amp;info);  // 持续轮询
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    }
};
</code></pre>
<hr />
<h2 id="扩展资源与进阶方向"><a class="header" href="#扩展资源与进阶方向">扩展资源与进阶方向</a></h2>
<h3 id="官方资源"><a class="header" href="#官方资源">官方资源</a></h3>
<ol>
<li>
<p><strong>Fast DDS官方文档</strong></p>
<ul>
<li>网址：https://fast-dds.docs.eprosima.com/</li>
<li>内容：完整的API参考、用户手册、示例代码</li>
</ul>
</li>
<li>
<p><strong>GitHub仓库</strong></p>
<ul>
<li>Fast DDS: https://github.com/eProsima/Fast-DDS</li>
<li>Fast DDS-Gen: https://github.com/eProsima/Fast-DDS-Gen</li>
<li>示例: https://github.com/eProsima/Fast-DDS/tree/master/examples</li>
</ul>
</li>
<li>
<p><strong>eProsima官网</strong></p>
<ul>
<li>网址：https://www.eprosima.com/</li>
<li>内容：技术博客、白皮书、培训资料</li>
</ul>
</li>
<li>
<p><strong>OMG DDS规范</strong></p>
<ul>
<li>DDS v1.4: https://www.omg.org/spec/DDS/</li>
<li>DDS-RTPS v2.5: https://www.omg.org/spec/DDSI-RTPS/</li>
<li>DDS Security v1.1: https://www.omg.org/spec/DDS-SECURITY/</li>
</ul>
</li>
</ol>
<h3 id="社区资源"><a class="header" href="#社区资源">社区资源</a></h3>
<ol>
<li>
<p><strong>Fast DDS论坛</strong></p>
<ul>
<li>网址：https://github.com/eProsima/Fast-DDS/discussions</li>
<li>用途：技术讨论、问题求助</li>
</ul>
</li>
<li>
<p><strong>Stack Overflow</strong></p>
<ul>
<li>标签：[fastdds], [fast-rtps], [dds]</li>
<li>用途：具体问题解答</li>
</ul>
</li>
<li>
<p><strong>ROS 2社区</strong></p>
<ul>
<li>Fast DDS是ROS 2的默认DDS实现</li>
<li>ROS Discourse: https://discourse.ros.org/</li>
</ul>
</li>
</ol>
<h3 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h3>
<ol>
<li>
<p><strong>书籍推荐</strong></p>
<ul>
<li>《Real-Time Publish-Subscribe Middleware》by Gerardo Pardo-Castellote</li>
<li>《DDS for the Internet of Things》by Angelo Corsaro</li>
</ul>
</li>
<li>
<p><strong>在线课程</strong></p>
<ul>
<li>eProsima官方培训：https://www.eprosima.com/index.php/training</li>
<li>Udemy：搜索"DDS"相关课程</li>
</ul>
</li>
<li>
<p><strong>视频教程</strong></p>
<ul>
<li>YouTube: eProsima官方频道</li>
<li>ROS 2 Tutorial系列（包含Fast DDS部分）</li>
</ul>
</li>
</ol>
<h3 id="进阶方向"><a class="header" href="#进阶方向">进阶方向</a></h3>
<h4 id="1-深入rtps协议"><a class="header" href="#1-深入rtps协议">1. 深入RTPS协议</a></h4>
<pre><code>学习内容：
- RTPS协议栈详解
- 自定义传输插件
- 协议级性能优化
- Wireshark协议分析

项目实践：
- 实现自定义传输层（如CAN总线）
- 分析RTPS数据包结构
- 优化协议参数
</code></pre>
<h4 id="2-嵌入式系统部署"><a class="header" href="#2-嵌入式系统部署">2. 嵌入式系统部署</a></h4>
<pre><code>学习内容：
- 交叉编译Fast DDS
- 资源受限环境优化
- 静态链接与裁剪
- RTOS集成（FreeRTOS、Zephyr）

项目实践：
- 在ARM Cortex-M上运行Fast DDS
- 优化内存占用（&lt;1MB）
- 实现实时调度
</code></pre>
<h4 id="3-ros-2开发"><a class="header" href="#3-ros-2开发">3. ROS 2开发</a></h4>
<pre><code>学习内容：
- ROS 2架构
- rclcpp/rclpy API
- DDS与ROS 2的映射
- QoS配置最佳实践

项目实践：
- 开发ROS 2节点
- 自定义消息类型
- 多机器人协同
- 实时控制系统
</code></pre>
<h4 id="4-大规模系统架构"><a class="header" href="#4-大规模系统架构">4. 大规模系统架构</a></h4>
<pre><code>学习内容：
- Discovery Server高级配置
- 多域多分区设计
- 负载均衡策略
- 故障恢复机制

项目实践：
- 设计1000+节点系统
- 实现高可用架构
- 性能监控与调优
- 云端部署（Kubernetes）
</code></pre>
<h4 id="5-安全与加密"><a class="header" href="#5-安全与加密">5. 安全与加密</a></h4>
<pre><code>学习内容：
- PKI体系深入
- 自定义安全插件
- 密钥管理
- 安全审计

项目实践：
- 实现端到端加密
- 集成硬件安全模块（HSM）
- 安全策略设计
- 渗透测试
</code></pre>
<h4 id="6-跨语言绑定"><a class="header" href="#6-跨语言绑定">6. 跨语言绑定</a></h4>
<pre><code>学习内容：
- Python绑定（FastDDS-Python）
- Java绑定
- C#绑定
- Web接口（WebSocket/REST）

项目实践：
- 开发Python应用
- Web可视化界面
- 多语言混合系统
</code></pre>
<h3 id="职业发展路径"><a class="header" href="#职业发展路径">职业发展路径</a></h3>
<pre><code>初级开发者（0-1年）
├─ 掌握Fast DDS基础
├─ 能够开发简单应用
└─ 理解DDS核心概念

中级开发者（1-3年）
├─ 性能调优经验
├─ 复杂系统设计
├─ 故障排查能力
└─ 安全配置

高级开发者（3-5年）
├─ 架构设计能力
├─ 大规模系统经验
├─ 贡献开源社区
└─ 技术指导与培训

专家级（5年以上）
├─ RTPS协议专家
├─ 性能优化专家
├─ 标准委员会贡献
└─ 行业影响力
</code></pre>
<hr />
<h2 id="最后的话"><a class="header" href="#最后的话">最后的话</a></h2>
<p>Fast DDS是一个功能强大、设计优雅的DDS实现。通过本笔记的系统学习，您应该已经：</p>
<ol>
<li><strong>掌握核心概念</strong>：Domain、Participant、Topic、QoS、Discovery</li>
<li><strong>理解重点难点</strong>：QoS策略选择、传输优化、服务发现、安全配置</li>
<li><strong>具备实战能力</strong>：能够设计并实现生产级分布式系统</li>
<li><strong>了解进阶方向</strong>：嵌入式部署、ROS 2、大规模架构</li>
</ol>
<h3 id="学习建议"><a class="header" href="#学习建议">学习建议</a></h3>
<ol>
<li>
<p><strong>循序渐进</strong></p>
<ul>
<li>先掌握基础（模块一、二）</li>
<li>再学习优化（模块三、四）</li>
<li>后深入安全和实战（模块五、六）</li>
<li>最后探索高级特性（模块七）</li>
</ul>
</li>
<li>
<p><strong>动手实践</strong></p>
<ul>
<li>每个知识点都要写代码验证</li>
<li>遇到问题主动调试</li>
<li>参考官方示例但不照抄</li>
<li>尝试实现自己的项目</li>
</ul>
</li>
<li>
<p><strong>持续学习</strong></p>
<ul>
<li>关注Fast DDS版本更新</li>
<li>阅读源代码加深理解</li>
<li>参与社区讨论</li>
<li>分享经验帮助他人</li>
</ul>
</li>
<li>
<p><strong>注重原理</strong></p>
<ul>
<li>理解为什么这样设计</li>
<li>对比不同方案的优劣</li>
<li>思考适用场景</li>
<li>举一反三</li>
</ul>
</li>
</ol>
<h3 id="常见陷阱"><a class="header" href="#常见陷阱">常见陷阱</a></h3>
<ol>
<li>
<p>❌ <strong>过度依赖默认配置</strong></p>
<ul>
<li>不同场景需要不同QoS</li>
<li>性能优化需要调整传输参数</li>
<li>安全场景必须配置Security</li>
</ul>
</li>
<li>
<p>❌ <strong>忽略错误处理</strong></p>
<ul>
<li>总是检查返回值</li>
<li>使用监听器捕获异常事件</li>
<li>实现优雅的故障恢复</li>
</ul>
</li>
<li>
<p>❌ <strong>不重视资源管理</strong></p>
<ul>
<li>严格遵守清理顺序</li>
<li>设置合理的ResourceLimits</li>
<li>及时释放不需要的对象</li>
</ul>
</li>
<li>
<p>❌ <strong>盲目追求性能</strong></p>
<ul>
<li>先满足功能需求</li>
<li>测量后再优化</li>
<li>权衡性能与可靠性</li>
</ul>
</li>
</ol>
<h3 id="成功要素"><a class="header" href="#成功要素">成功要素</a></h3>
<pre><code>1. 扎实的基础
   - DDS概念清晰
   - QoS策略理解深入
   - API使用熟练

2. 丰富的实践
   - 多个项目经验
   - 不同场景尝试
   - 踩过足够的坑

3. 持续的学习
   - 关注技术发展
   - 深入源码研究
   - 总结最佳实践

4. 良好的习惯
   - 代码规范
   - 错误处理
   - 文档记录
   - 测试驱动
</code></pre>
<hr />
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<h3 id="a-快速参考"><a class="header" href="#a-快速参考">A. 快速参考</a></h3>
<h4 id="a1-常用qos配置"><a class="header" href="#a1-常用qos配置">A.1 常用QoS配置</a></h4>
<pre><code class="language-cpp">// 传感器数据
DataWriterQos sensor_qos;
sensor_qos.reliability().kind = BEST_EFFORT_RELIABILITY_QOS;
sensor_qos.history().kind = KEEP_LAST_HISTORY_QOS;
sensor_qos.history().depth = 1;

// 控制指令
DataWriterQos control_qos;
control_qos.reliability().kind = RELIABLE_RELIABILITY_QOS;
control_qos.history().kind = KEEP_LAST_HISTORY_QOS;
control_qos.history().depth = 10;

// 配置数据
DataWriterQos config_qos;
config_qos.reliability().kind = RELIABLE_RELIABILITY_QOS;
config_qos.durability().kind = TRANSIENT_LOCAL_DURABILITY_QOS;
config_qos.history().kind = KEEP_ALL_HISTORY_QOS;
</code></pre>
<h4 id="a2-常用命令"><a class="header" href="#a2-常用命令">A.2 常用命令</a></h4>
<pre><code class="language-bash"># 生成IDL代码
fastddsgen -replace -typeobject MyType.idl

# 启用详细日志
export FASTDDS_LOG_LEVEL=info

# Discovery Server
fastdds discovery -i 0 -l 127.0.0.1 -p 11811

# 性能测试
cd Fast-DDS/examples/C++/DDS/PerformanceTest
./PerformanceTest publisher
./PerformanceTest subscriber
</code></pre>
<h4 id="a3-调试技巧"><a class="header" href="#a3-调试技巧">A.3 调试技巧</a></h4>
<pre><code class="language-bash"># gdb调试
gdb --args ./myapp arg1 arg2
(gdb) run
(gdb) backtrace

# valgrind内存检测
valgrind --leak-check=full ./myapp

# tcpdump抓包
sudo tcpdump -i eth0 port 7400 -w fastdds.pcap

# Wireshark过滤器
rtps
</code></pre>
<h3 id="b-术语表"><a class="header" href="#b-术语表">B. 术语表</a></h3>
<div class="table-wrapper"><table><thead><tr><th>术语</th><th>英文</th><th>解释</th></tr></thead><tbody>
<tr><td>域</td><td>Domain</td><td>DDS逻辑隔离的通信空间</td></tr>
<tr><td>参与者</td><td>DomainParticipant</td><td>应用在Domain中的代理</td></tr>
<tr><td>主题</td><td>Topic</td><td>数据类型和名称的契约</td></tr>
<tr><td>发布者</td><td>Publisher</td><td>数据发送容器</td></tr>
<tr><td>订阅者</td><td>Subscriber</td><td>数据接收容器</td></tr>
<tr><td>数据写入器</td><td>DataWriter</td><td>实际发送数据的端点</td></tr>
<tr><td>数据读取器</td><td>DataReader</td><td>实际接收数据的端点</td></tr>
<tr><td>QoS</td><td>Quality of Service</td><td>服务质量策略</td></tr>
<tr><td>RTPS</td><td>Real-Time Publish Subscribe</td><td>实时发布订阅协议</td></tr>
<tr><td>DCPS</td><td>Data-Centric Publish-Subscribe</td><td>数据中心发布订阅</td></tr>
<tr><td>SPDP</td><td>Simple Participant Discovery Protocol</td><td>简单参与者发现协议</td></tr>
<tr><td>SEDP</td><td>Simple Endpoint Discovery Protocol</td><td>简单端点发现协议</td></tr>
<tr><td>IDL</td><td>Interface Definition Language</td><td>接口定义语言</td></tr>
</tbody></table>
</div>
<hr />
<p><strong>完成！</strong> 🎉</p>
<p>恭喜您完成Fast DDS深度技术学习笔记的学习！</p>
<p>希望这份笔记能够帮助您掌握Fast DDS，成为分布式系统开发专家。</p>
<p>记住：<strong>理论与实践相结合，持续学习与总结。</strong></p>
<p>祝您学习愉快，项目成功！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/c++/fastdds_part3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/c++/gstreamer.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/c++/fastdds_part3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/c++/gstreamer.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

