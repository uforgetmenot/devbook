<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ONNXRuntime 技术笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="onnxruntime-技术笔记"><a class="header" href="#onnxruntime-技术笔记">ONNXRuntime 技术笔记</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>ONNXRuntime是Microsoft开源的高性能机器学习推理引擎，用于执行ONNX（Open Neural Network Exchange）模型。它是一个跨平台的推理框架，支持多种硬件加速器（CPU、GPU、专用AI芯片），提供了丰富的C++、Python、C#、Java等语言绑定。ONNXRuntime优化了模型推理性能，广泛应用于生产环境的AI模型部署。</p>
<h3 id="核心特性"><a class="header" href="#核心特性">核心特性</a></h3>
<ul>
<li>高性能推理引擎，支持多种优化技术</li>
<li>跨平台支持（Windows、Linux、macOS、移动端）</li>
<li>多硬件后端支持（CPU、CUDA、DirectML、TensorRT等）</li>
<li>完整的ONNX标准支持</li>
<li>内存优化和计算图优化</li>
<li>量化模型支持</li>
<li>动态输入形状支持</li>
<li>丰富的语言绑定</li>
</ul>
<h2 id="系统架构"><a class="header" href="#系统架构">系统架构</a></h2>
<h3 id="核心架构组件"><a class="header" href="#核心架构组件">核心架构组件</a></h3>
<pre><code>应用程序层
    |
+------------------------+
|      Language APIs     |  语言绑定（C++/Python/C#等）
+------------------------+
    |
+------------------------+
|   Session Management   |  会话管理和模型加载
+------------------------+
    |
+------------------------+
|   Graph Optimization   |  计算图优化和转换
+------------------------+
    |
+------------------------+
|  Execution Providers   |  执行提供器（CPU/GPU/专用芯片）
+------------------------+
    |
+------------------------+
|    Memory Management   |  内存分配和管理
+------------------------+
    |
+------------------------+
|    Hardware Backends   |  硬件后端实现
+------------------------+
</code></pre>
<h3 id="执行提供器execution-providers"><a class="header" href="#执行提供器execution-providers">执行提供器（Execution Providers）</a></h3>
<ol>
<li>
<p><strong>CPU Provider</strong></p>
<ul>
<li>基于优化的CPU实现</li>
<li>SIMD指令支持</li>
<li>多线程并行计算</li>
</ul>
</li>
<li>
<p><strong>CUDA Provider</strong></p>
<ul>
<li>NVIDIA GPU加速</li>
<li>cuDNN库集成</li>
<li>CUDA内核优化</li>
</ul>
</li>
<li>
<p><strong>TensorRT Provider</strong></p>
<ul>
<li>NVIDIA TensorRT集成</li>
<li>深度优化推理</li>
<li>INT8量化支持</li>
</ul>
</li>
<li>
<p><strong>DirectML Provider</strong></p>
<ul>
<li>Windows DirectX机器学习</li>
<li>AMD/Intel/NVIDIA通用支持</li>
</ul>
</li>
</ol>
<h2 id="关键组件详解"><a class="header" href="#关键组件详解">关键组件详解</a></h2>
<h3 id="1-基础环境设置"><a class="header" href="#1-基础环境设置">1. 基础环境设置</a></h3>
<pre><code class="language-cpp">#include &lt;onnxruntime_cxx_api.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

class ONNXRuntimeEnvironment {
private:
    std::unique_ptr&lt;Ort::Env&gt; env;
    Ort::SessionOptions sessionOptions;

public:
    ONNXRuntimeEnvironment() {
        // 初始化ONNX Runtime环境
        env = std::make_unique&lt;Ort::Env&gt;(ORT_LOGGING_LEVEL_WARNING, "ONNXRuntimeApp");

        // 配置会话选项
        sessionOptions.SetIntraOpNumThreads(1);  // 设置线程数
        sessionOptions.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_EXTENDED);

        // 启用内存模式优化
        sessionOptions.SetExecutionMode(ExecutionMode::ORT_SEQUENTIAL);
    }

    Ort::Env&amp; getEnvironment() { return *env; }
    Ort::SessionOptions&amp; getSessionOptions() { return sessionOptions; }

    // 配置CPU执行提供器
    void configureCPU(int numThreads = 0) {
        if (numThreads &gt; 0) {
            sessionOptions.SetIntraOpNumThreads(numThreads);
        }
        // CPU优化选项
        sessionOptions.SetInterOpNumThreads(1);
    }

    // 配置CUDA执行提供器
    void configureCUDA(int deviceId = 0) {
        try {
            OrtCUDAProviderOptions cudaOptions{};
            cudaOptions.device_id = deviceId;
            cudaOptions.arena_extend_strategy = 1;  // 扩展策略
            cudaOptions.gpu_mem_limit = SIZE_MAX;    // GPU内存限制
            cudaOptions.cudnn_conv_algo_search = OrtCudnnConvAlgoSearch::OrtCudnnConvAlgoSearchExhaustive;

            sessionOptions.AppendExecutionProvider_CUDA(cudaOptions);
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "Failed to configure CUDA provider: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }

    // 配置TensorRT执行提供器
    void configureTensorRT(int deviceId = 0) {
        try {
            OrtTensorRTProviderOptions tensorrtOptions{};
            tensorrtOptions.device_id = deviceId;
            tensorrtOptions.trt_max_workspace_size = 1ULL &lt;&lt; 30;  // 1GB工作空间
            tensorrtOptions.trt_fp16_enable = true;               // 启用FP16
            tensorrtOptions.trt_int8_enable = false;              // 启用INT8

            sessionOptions.AppendExecutionProvider_TensorRT(tensorrtOptions);
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "Failed to configure TensorRT provider: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }
};
</code></pre>
<h3 id="2-模型加载和会话管理"><a class="header" href="#2-模型加载和会话管理">2. 模型加载和会话管理</a></h3>
<pre><code class="language-cpp">class ONNXModel {
private:
    std::unique_ptr&lt;Ort::Session&gt; session;
    std::vector&lt;std::string&gt; inputNames;
    std::vector&lt;std::string&gt; outputNames;
    std::vector&lt;std::vector&lt;int64_t&gt;&gt; inputShapes;
    std::vector&lt;std::vector&lt;int64_t&gt;&gt; outputShapes;
    std::vector&lt;ONNXTensorElementDataType&gt; inputTypes;
    std::vector&lt;ONNXTensorElementDataType&gt; outputTypes;

public:
    ONNXModel(Ort::Env&amp; env, const std::string&amp; modelPath, Ort::SessionOptions&amp; sessionOptions) {
        try {
            // 加载模型
#ifdef _WIN32
            std::wstring wideModelPath = std::wstring(modelPath.begin(), modelPath.end());
            session = std::make_unique&lt;Ort::Session&gt;(env, wideModelPath.c_str(), sessionOptions);
#else
            session = std::make_unique&lt;Ort::Session&gt;(env, modelPath.c_str(), sessionOptions);
#endif

            // 获取模型信息
            initializeModelInfo();
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "Failed to load model: " &lt;&lt; e.what() &lt;&lt; std::endl;
            throw;
        }
    }

private:
    void initializeModelInfo() {
        Ort::AllocatorWithDefaultOptions allocator;

        // 获取输入信息
        size_t numInputNodes = session-&gt;GetInputCount();
        inputNames.reserve(numInputNodes);
        inputShapes.reserve(numInputNodes);
        inputTypes.reserve(numInputNodes);

        for (size_t i = 0; i &lt; numInputNodes; i++) {
            // 获取输入名称
            auto inputName = session-&gt;GetInputNameAllocated(i, allocator);
            inputNames.push_back(std::string(inputName.get()));

            // 获取输入类型信息
            Ort::TypeInfo inputTypeInfo = session-&gt;GetInputTypeInfo(i);
            auto inputTensorInfo = inputTypeInfo.GetTensorTypeAndShapeInfo();

            inputTypes.push_back(inputTensorInfo.GetElementType());

            // 获取输入形状
            std::vector&lt;int64_t&gt; inputShape = inputTensorInfo.GetShape();
            inputShapes.push_back(inputShape);

            std::cout &lt;&lt; "Input " &lt;&lt; i &lt;&lt; ": " &lt;&lt; inputNames[i]
                     &lt;&lt; " Shape: [";
            for (size_t j = 0; j &lt; inputShape.size(); ++j) {
                std::cout &lt;&lt; inputShape[j];
                if (j &lt; inputShape.size() - 1) std::cout &lt;&lt; ", ";
            }
            std::cout &lt;&lt; "]" &lt;&lt; std::endl;
        }

        // 获取输出信息
        size_t numOutputNodes = session-&gt;GetOutputCount();
        outputNames.reserve(numOutputNodes);
        outputShapes.reserve(numOutputNodes);
        outputTypes.reserve(numOutputNodes);

        for (size_t i = 0; i &lt; numOutputNodes; i++) {
            // 获取输出名称
            auto outputName = session-&gt;GetOutputNameAllocated(i, allocator);
            outputNames.push_back(std::string(outputName.get()));

            // 获取输出类型信息
            Ort::TypeInfo outputTypeInfo = session-&gt;GetOutputTypeInfo(i);
            auto outputTensorInfo = outputTypeInfo.GetTensorTypeAndShapeInfo();

            outputTypes.push_back(outputTensorInfo.GetElementType());

            // 获取输出形状
            std::vector&lt;int64_t&gt; outputShape = outputTensorInfo.GetShape();
            outputShapes.push_back(outputShape);

            std::cout &lt;&lt; "Output " &lt;&lt; i &lt;&lt; ": " &lt;&lt; outputNames[i]
                     &lt;&lt; " Shape: [";
            for (size_t j = 0; j &lt; outputShape.size(); ++j) {
                std::cout &lt;&lt; outputShape[j];
                if (j &lt; outputShape.size() - 1) std::cout &lt;&lt; ", ";
            }
            std::cout &lt;&lt; "]" &lt;&lt; std::endl;
        }
    }

public:
    const std::vector&lt;std::string&gt;&amp; getInputNames() const { return inputNames; }
    const std::vector&lt;std::string&gt;&amp; getOutputNames() const { return outputNames; }
    const std::vector&lt;std::vector&lt;int64_t&gt;&gt;&amp; getInputShapes() const { return inputShapes; }
    const std::vector&lt;std::vector&lt;int64_t&gt;&gt;&amp; getOutputShapes() const { return outputShapes; }

    // 推理函数
    std::vector&lt;Ort::Value&gt; run(const std::vector&lt;Ort::Value&gt;&amp; inputTensors) {
        try {
            // 准备输入输出名称
            std::vector&lt;const char*&gt; inputNamesPtr;
            std::vector&lt;const char*&gt; outputNamesPtr;

            for (const auto&amp; name : inputNames) {
                inputNamesPtr.push_back(name.c_str());
            }

            for (const auto&amp; name : outputNames) {
                outputNamesPtr.push_back(name.c_str());
            }

            // 执行推理
            auto outputTensors = session-&gt;Run(Ort::RunOptions{nullptr},
                                            inputNamesPtr.data(),
                                            inputTensors.data(),
                                            inputTensors.size(),
                                            outputNamesPtr.data(),
                                            outputNames.size());

            return outputTensors;
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "Inference failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
            throw;
        }
    }
};
</code></pre>
<h3 id="3-张量操作和数据处理"><a class="header" href="#3-张量操作和数据处理">3. 张量操作和数据处理</a></h3>
<pre><code class="language-cpp">class TensorUtils {
public:
    // 创建输入张量
    template&lt;typename T&gt;
    static Ort::Value createTensor(Ort::MemoryInfo&amp; memoryInfo,
                                  const std::vector&lt;T&gt;&amp; data,
                                  const std::vector&lt;int64_t&gt;&amp; shape) {
        return Ort::Value::CreateTensor&lt;T&gt;(memoryInfo,
                                          const_cast&lt;T*&gt;(data.data()),
                                          data.size(),
                                          shape.data(),
                                          shape.size());
    }

    // 从张量提取数据
    template&lt;typename T&gt;
    static std::vector&lt;T&gt; extractTensorData(const Ort::Value&amp; tensor) {
        T* rawData = tensor.GetTensorMutableData&lt;T&gt;();
        size_t dataSize = tensor.GetTensorTypeAndShapeInfo().GetElementCount();
        return std::vector&lt;T&gt;(rawData, rawData + dataSize);
    }

    // 打印张量信息
    static void printTensorInfo(const Ort::Value&amp; tensor, const std::string&amp; name) {
        auto tensorInfo = tensor.GetTensorTypeAndShapeInfo();
        auto shape = tensorInfo.GetShape();
        auto type = tensorInfo.GetElementType();

        std::cout &lt;&lt; "Tensor: " &lt;&lt; name &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Shape: [";
        for (size_t i = 0; i &lt; shape.size(); ++i) {
            std::cout &lt;&lt; shape[i];
            if (i &lt; shape.size() - 1) std::cout &lt;&lt; ", ";
        }
        std::cout &lt;&lt; "]" &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Element Count: " &lt;&lt; tensorInfo.GetElementCount() &lt;&lt; std::endl;
        std::cout &lt;&lt; "  Data Type: " &lt;&lt; static_cast&lt;int&gt;(type) &lt;&lt; std::endl;
    }

    // 计算张量元素总数
    static size_t calculateElementCount(const std::vector&lt;int64_t&gt;&amp; shape) {
        size_t count = 1;
        for (int64_t dim : shape) {
            if (dim &gt; 0) count *= dim;
        }
        return count;
    }

    // 图像预处理（BGR to RGB，归一化等）
    static std::vector&lt;float&gt; preprocessImage(const std::vector&lt;uint8_t&gt;&amp; imageData,
                                            int width, int height, int channels,
                                            bool normalize = true,
                                            bool bgrToRgb = false) {
        std::vector&lt;float&gt; processedData;
        processedData.reserve(width * height * channels);

        for (int i = 0; i &lt; height; ++i) {
            for (int j = 0; j &lt; width; ++j) {
                for (int c = 0; c &lt; channels; ++c) {
                    int srcChannel = bgrToRgb ? (channels - 1 - c) : c;
                    int index = i * width * channels + j * channels + srcChannel;

                    float value = static_cast&lt;float&gt;(imageData[index]);
                    if (normalize) {
                        value = value / 255.0f;  // 归一化到[0,1]
                    }

                    processedData.push_back(value);
                }
            }
        }

        return processedData;
    }
};
</code></pre>
<h3 id="4-图像分类推理示例"><a class="header" href="#4-图像分类推理示例">4. 图像分类推理示例</a></h3>
<pre><code class="language-cpp">class ImageClassifier {
private:
    std::unique_ptr&lt;ONNXModel&gt; model;
    Ort::MemoryInfo memoryInfo;
    std::vector&lt;std::string&gt; classLabels;

public:
    ImageClassifier(Ort::Env&amp; env, const std::string&amp; modelPath,
                   Ort::SessionOptions&amp; sessionOptions,
                   const std::vector&lt;std::string&gt;&amp; labels)
        : classLabels(labels),
          memoryInfo(Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault)) {
        model = std::make_unique&lt;ONNXModel&gt;(env, modelPath, sessionOptions);
    }

    struct ClassificationResult {
        int classId;
        std::string className;
        float confidence;
    };

    std::vector&lt;ClassificationResult&gt; classify(const std::vector&lt;uint8_t&gt;&amp; imageData,
                                             int width, int height, int channels = 3,
                                             int topK = 5) {
        // 预处理图像
        auto processedImage = TensorUtils::preprocessImage(imageData, width, height, channels,
                                                         true, true);  // 归一化和BGR to RGB

        // 创建输入张量
        std::vector&lt;int64_t&gt; inputShape = {1, channels, height, width};  // NCHW格式
        auto inputTensor = TensorUtils::createTensor&lt;float&gt;(memoryInfo, processedImage, inputShape);

        // 执行推理
        std::vector&lt;Ort::Value&gt; inputTensors;
        inputTensors.push_back(std::move(inputTensor));

        auto outputTensors = model-&gt;run(inputTensors);

        // 处理输出
        auto predictions = TensorUtils::extractTensorData&lt;float&gt;(outputTensors[0]);

        // 应用Softmax
        applySoftmax(predictions);

        // 获取Top-K结果
        return getTopKResults(predictions, topK);
    }

private:
    void applySoftmax(std::vector&lt;float&gt;&amp; logits) {
        float maxLogit = *std::max_element(logits.begin(), logits.end());

        // 数值稳定性：减去最大值
        for (float&amp; logit : logits) {
            logit -= maxLogit;
        }

        // 计算指数和总和
        float sumExp = 0.0f;
        for (float&amp; logit : logits) {
            logit = std::exp(logit);
            sumExp += logit;
        }

        // 归一化
        for (float&amp; logit : logits) {
            logit /= sumExp;
        }
    }

    std::vector&lt;ClassificationResult&gt; getTopKResults(const std::vector&lt;float&gt;&amp; probabilities,
                                                   int topK) {
        std::vector&lt;std::pair&lt;float, int&gt;&gt; indexed_probs;
        for (size_t i = 0; i &lt; probabilities.size(); ++i) {
            indexed_probs.emplace_back(probabilities[i], i);
        }

        // 按概率降序排序
        std::partial_sort(indexed_probs.begin(),
                         indexed_probs.begin() + std::min(topK, static_cast&lt;int&gt;(indexed_probs.size())),
                         indexed_probs.end(),
                         [](const auto&amp; a, const auto&amp; b) { return a.first &gt; b.first; });

        std::vector&lt;ClassificationResult&gt; results;
        for (int i = 0; i &lt; std::min(topK, static_cast&lt;int&gt;(indexed_probs.size())); ++i) {
            ClassificationResult result;
            result.classId = indexed_probs[i].second;
            result.confidence = indexed_probs[i].first;
            result.className = (result.classId &lt; classLabels.size()) ?
                               classLabels[result.classId] : "Unknown";
            results.push_back(result);
        }

        return results;
    }
};
</code></pre>
<h3 id="5-目标检测推理示例"><a class="header" href="#5-目标检测推理示例">5. 目标检测推理示例</a></h3>
<pre><code class="language-cpp">struct BoundingBox {
    float x, y, width, height;
    int classId;
    float confidence;
    std::string className;
};

class ObjectDetector {
private:
    std::unique_ptr&lt;ONNXModel&gt; model;
    Ort::MemoryInfo memoryInfo;
    std::vector&lt;std::string&gt; classLabels;
    float confThreshold;
    float nmsThreshold;

public:
    ObjectDetector(Ort::Env&amp; env, const std::string&amp; modelPath,
                  Ort::SessionOptions&amp; sessionOptions,
                  const std::vector&lt;std::string&gt;&amp; labels,
                  float confThresh = 0.5f, float nmsThresh = 0.4f)
        : classLabels(labels), confThreshold(confThresh), nmsThreshold(nmsThresh),
          memoryInfo(Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault)) {
        model = std::make_unique&lt;ONNXModel&gt;(env, modelPath, sessionOptions);
    }

    std::vector&lt;BoundingBox&gt; detect(const std::vector&lt;uint8_t&gt;&amp; imageData,
                                   int originalWidth, int originalHeight,
                                   int modelInputWidth = 640, int modelInputHeight = 640) {
        // 预处理图像（resize + normalize）
        auto resizedImage = resizeAndNormalize(imageData, originalWidth, originalHeight,
                                              modelInputWidth, modelInputHeight);

        // 创建输入张量
        std::vector&lt;int64_t&gt; inputShape = {1, 3, modelInputHeight, modelInputWidth};
        auto inputTensor = TensorUtils::createTensor&lt;float&gt;(memoryInfo, resizedImage, inputShape);

        // 执行推理
        std::vector&lt;Ort::Value&gt; inputTensors;
        inputTensors.push_back(std::move(inputTensor));

        auto outputTensors = model-&gt;run(inputTensors);

        // 解析输出（假设YOLO格式）
        auto rawDetections = TensorUtils::extractTensorData&lt;float&gt;(outputTensors[0]);

        // 后处理
        auto detections = postprocess(rawDetections, modelInputWidth, modelInputHeight,
                                    originalWidth, originalHeight);

        // 应用NMS
        return applyNMS(detections);
    }

private:
    std::vector&lt;float&gt; resizeAndNormalize(const std::vector&lt;uint8_t&gt;&amp; imageData,
                                        int srcWidth, int srcHeight,
                                        int dstWidth, int dstHeight) {
        // 简化的resize实现（实际应用中可能需要更复杂的插值算法）
        std::vector&lt;float&gt; resized(dstWidth * dstHeight * 3);

        float scaleX = static_cast&lt;float&gt;(srcWidth) / dstWidth;
        float scaleY = static_cast&lt;float&gt;(srcHeight) / dstHeight;

        for (int y = 0; y &lt; dstHeight; ++y) {
            for (int x = 0; x &lt; dstWidth; ++x) {
                int srcX = static_cast&lt;int&gt;(x * scaleX);
                int srcY = static_cast&lt;int&gt;(y * scaleY);

                srcX = std::min(srcX, srcWidth - 1);
                srcY = std::min(srcY, srcHeight - 1);

                for (int c = 0; c &lt; 3; ++c) {
                    int srcIdx = srcY * srcWidth * 3 + srcX * 3 + (2 - c);  // BGR to RGB
                    int dstIdx = c * dstHeight * dstWidth + y * dstWidth + x;  // CHW格式

                    resized[dstIdx] = imageData[srcIdx] / 255.0f;  // 归一化
                }
            }
        }

        return resized;
    }

    std::vector&lt;BoundingBox&gt; postprocess(const std::vector&lt;float&gt;&amp; predictions,
                                       int modelWidth, int modelHeight,
                                       int imageWidth, int imageHeight) {
        std::vector&lt;BoundingBox&gt; boxes;

        // 假设输出格式为 [batch, num_detections, 85] (YOLO v5格式)
        // 85 = 4 (bbox) + 1 (objectness) + 80 (classes)
        int numDetections = predictions.size() / 85;

        float scaleX = static_cast&lt;float&gt;(imageWidth) / modelWidth;
        float scaleY = static_cast&lt;float&gt;(imageHeight) / modelHeight;

        for (int i = 0; i &lt; numDetections; ++i) {
            int offset = i * 85;

            float objectness = predictions[offset + 4];
            if (objectness &lt; confThreshold) continue;

            // 找到最高概率的类别
            int bestClassId = 0;
            float bestClassProb = 0.0f;
            for (int j = 0; j &lt; 80; ++j) {
                float classProb = predictions[offset + 5 + j];
                if (classProb &gt; bestClassProb) {
                    bestClassProb = classProb;
                    bestClassId = j;
                }
            }

            float confidence = objectness * bestClassProb;
            if (confidence &lt; confThreshold) continue;

            // 解析边界框
            float centerX = predictions[offset] * scaleX;
            float centerY = predictions[offset + 1] * scaleY;
            float width = predictions[offset + 2] * scaleX;
            float height = predictions[offset + 3] * scaleY;

            BoundingBox box;
            box.x = centerX - width / 2.0f;
            box.y = centerY - height / 2.0f;
            box.width = width;
            box.height = height;
            box.classId = bestClassId;
            box.confidence = confidence;
            box.className = (bestClassId &lt; classLabels.size()) ?
                           classLabels[bestClassId] : "Unknown";

            boxes.push_back(box);
        }

        return boxes;
    }

    std::vector&lt;BoundingBox&gt; applyNMS(std::vector&lt;BoundingBox&gt;&amp; boxes) {
        // 按置信度排序
        std::sort(boxes.begin(), boxes.end(),
                 [](const BoundingBox&amp; a, const BoundingBox&amp; b) {
                     return a.confidence &gt; b.confidence;
                 });

        std::vector&lt;bool&gt; suppressed(boxes.size(), false);
        std::vector&lt;BoundingBox&gt; result;

        for (size_t i = 0; i &lt; boxes.size(); ++i) {
            if (suppressed[i]) continue;

            result.push_back(boxes[i]);

            // 抑制重叠的框
            for (size_t j = i + 1; j &lt; boxes.size(); ++j) {
                if (suppressed[j] || boxes[i].classId != boxes[j].classId) continue;

                float iou = calculateIOU(boxes[i], boxes[j]);
                if (iou &gt; nmsThreshold) {
                    suppressed[j] = true;
                }
            }
        }

        return result;
    }

    float calculateIOU(const BoundingBox&amp; box1, const BoundingBox&amp; box2) {
        float x1 = std::max(box1.x, box2.x);
        float y1 = std::max(box1.y, box2.y);
        float x2 = std::min(box1.x + box1.width, box2.x + box2.width);
        float y2 = std::min(box1.y + box1.height, box2.y + box2.height);

        if (x2 &lt;= x1 || y2 &lt;= y1) return 0.0f;

        float intersection = (x2 - x1) * (y2 - y1);
        float area1 = box1.width * box1.height;
        float area2 = box2.width * box2.height;
        float unionArea = area1 + area2 - intersection;

        return intersection / unionArea;
    }
};
</code></pre>
<h2 id="性能优化策略"><a class="header" href="#性能优化策略">性能优化策略</a></h2>
<h3 id="1-模型优化"><a class="header" href="#1-模型优化">1. 模型优化</a></h3>
<pre><code class="language-cpp">class ModelOptimizer {
public:
    // 图优化配置
    static Ort::SessionOptions configureGraphOptimization() {
        Ort::SessionOptions options;

        // 启用所有图优化级别
        options.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_ALL);

        // 启用并行执行
        options.SetExecutionMode(ExecutionMode::ORT_PARALLEL);

        // 设置线程数
        options.SetIntraOpNumThreads(std::thread::hardware_concurrency());

        // 启用内存模式
        options.EnableMemPattern();

        return options;
    }

    // 量化模型支持
    static bool supportsQuantization(const std::string&amp; modelPath) {
        try {
            Ort::Env env(ORT_LOGGING_LEVEL_WARNING, "QuantizationCheck");
            Ort::SessionOptions options;

            // 尝试加载模型
            Ort::Session session(env, modelPath.c_str(), options);

            // 检查模型是否包含量化操作
            // 这里是简化实现，实际可能需要更复杂的检查
            return true;
        } catch (...) {
            return false;
        }
    }

    // 动态形状处理
    static std::vector&lt;int64_t&gt; resolveDynamicShape(const std::vector&lt;int64_t&gt;&amp; modelShape,
                                                   const std::vector&lt;int64_t&gt;&amp; actualShape) {
        std::vector&lt;int64_t&gt; resolvedShape = modelShape;

        for (size_t i = 0; i &lt; modelShape.size() &amp;&amp; i &lt; actualShape.size(); ++i) {
            if (modelShape[i] == -1) {  // 动态维度
                resolvedShape[i] = actualShape[i];
            }
        }

        return resolvedShape;
    }
};
</code></pre>
<h3 id="2-内存管理优化"><a class="header" href="#2-内存管理优化">2. 内存管理优化</a></h3>
<pre><code class="language-cpp">class MemoryOptimizer {
private:
    std::unique_ptr&lt;Ort::MemoryInfo&gt; cpuMemoryInfo;
    std::unique_ptr&lt;Ort::MemoryInfo&gt; cudaMemoryInfo;

public:
    MemoryOptimizer() {
        cpuMemoryInfo = std::make_unique&lt;Ort::MemoryInfo&gt;(
            Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault));

#ifdef USE_CUDA
        cudaMemoryInfo = std::make_unique&lt;Ort::MemoryInfo&gt;(
            "Cuda", OrtArenaAllocator, 0, OrtMemTypeDefault);
#endif
    }

    // 内存池配置
    static Ort::SessionOptions configureMemoryOptimization() {
        Ort::SessionOptions options;

        // 启用内存模式
        options.EnableMemPattern();

        // 配置内存分配器
        options.SetExecutionMode(ExecutionMode::ORT_SEQUENTIAL);

        return options;
    }

    // 张量内存预分配
    template&lt;typename T&gt;
    Ort::Value preallocateTensor(const std::vector&lt;int64_t&gt;&amp; shape, bool useGPU = false) {
        size_t elementCount = 1;
        for (int64_t dim : shape) {
            elementCount *= dim;
        }

        if (useGPU &amp;&amp; cudaMemoryInfo) {
            return Ort::Value::CreateTensor&lt;T&gt;(*cudaMemoryInfo, elementCount, shape.data(), shape.size());
        } else {
            return Ort::Value::CreateTensor&lt;T&gt;(*cpuMemoryInfo, elementCount, shape.data(), shape.size());
        }
    }

    // 内存使用监控
    class MemoryMonitor {
    private:
        size_t peakMemoryUsage;
        std::chrono::steady_clock::time_point startTime;

    public:
        MemoryMonitor() : peakMemoryUsage(0) {
            startTime = std::chrono::steady_clock::now();
        }

        void updatePeakUsage() {
            // 实际实现中需要调用系统API获取内存使用情况
            // 这里是简化示例
        }

        void reportMemoryUsage() {
            auto endTime = std::chrono::steady_clock::now();
            auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(endTime - startTime);

            std::cout &lt;&lt; "Memory monitoring results:" &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Peak memory usage: " &lt;&lt; peakMemoryUsage / (1024 * 1024) &lt;&lt; " MB" &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Monitoring duration: " &lt;&lt; duration.count() &lt;&lt; " ms" &lt;&lt; std::endl;
        }
    };
};
</code></pre>
<h3 id="3-批处理优化"><a class="header" href="#3-批处理优化">3. 批处理优化</a></h3>
<pre><code class="language-cpp">class BatchProcessor {
private:
    std::unique_ptr&lt;ONNXModel&gt; model;
    size_t maxBatchSize;
    Ort::MemoryInfo memoryInfo;

public:
    BatchProcessor(std::unique_ptr&lt;ONNXModel&gt; model, size_t batchSize = 8)
        : model(std::move(model)), maxBatchSize(batchSize),
          memoryInfo(Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault)) {
    }

    // 批量推理
    template&lt;typename T&gt;
    std::vector&lt;std::vector&lt;Ort::Value&gt;&gt; processBatches(
        const std::vector&lt;std::vector&lt;T&gt;&gt;&amp; inputData,
        const std::vector&lt;int64_t&gt;&amp; singleInputShape) {

        std::vector&lt;std::vector&lt;Ort::Value&gt;&gt; allResults;

        for (size_t i = 0; i &lt; inputData.size(); i += maxBatchSize) {
            size_t currentBatchSize = std::min(maxBatchSize, inputData.size() - i);

            // 创建批量输入张量
            std::vector&lt;T&gt; batchData;
            std::vector&lt;int64_t&gt; batchShape = singleInputShape;
            batchShape[0] = currentBatchSize;  // 设置批量维度

            size_t elementCountPerSample = TensorUtils::calculateElementCount(
                std::vector&lt;int64_t&gt;(singleInputShape.begin() + 1, singleInputShape.end()));

            for (size_t j = 0; j &lt; currentBatchSize; ++j) {
                batchData.insert(batchData.end(),
                               inputData[i + j].begin(),
                               inputData[i + j].end());
            }

            auto batchTensor = TensorUtils::createTensor&lt;T&gt;(memoryInfo, batchData, batchShape);

            // 执行批量推理
            std::vector&lt;Ort::Value&gt; inputTensors;
            inputTensors.push_back(std::move(batchTensor));

            auto batchResults = model-&gt;run(inputTensors);

            // 分离批量结果
            auto separatedResults = separateBatchResults(batchResults, currentBatchSize);
            allResults.insert(allResults.end(), separatedResults.begin(), separatedResults.end());
        }

        return allResults;
    }

private:
    std::vector&lt;std::vector&lt;Ort::Value&gt;&gt; separateBatchResults(
        const std::vector&lt;Ort::Value&gt;&amp; batchResults, size_t batchSize) {

        std::vector&lt;std::vector&lt;Ort::Value&gt;&gt; separatedResults(batchSize);

        // 简化实现：假设每个输出都需要按批量维度分离
        // 实际实现会更复杂，需要处理不同的张量形状
        for (size_t i = 0; i &lt; batchSize; ++i) {
            separatedResults[i].resize(batchResults.size());
            // 这里需要实现张量分割逻辑
        }

        return separatedResults;
    }
};
</code></pre>
<h2 id="调试和性能分析"><a class="header" href="#调试和性能分析">调试和性能分析</a></h2>
<h3 id="1-性能分析工具"><a class="header" href="#1-性能分析工具">1. 性能分析工具</a></h3>
<pre><code class="language-cpp">class PerformanceProfiler {
private:
    std::chrono::steady_clock::time_point startTime;
    std::vector&lt;std::pair&lt;std::string, double&gt;&gt; timings;

public:
    void startTiming(const std::string&amp; operation) {
        startTime = std::chrono::steady_clock::now();
    }

    void endTiming(const std::string&amp; operation) {
        auto endTime = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration&lt;double, std::milli&gt;(endTime - startTime);
        timings.emplace_back(operation, duration.count());
    }

    void reportTimings() {
        std::cout &lt;&lt; "\n=== Performance Report ===" &lt;&lt; std::endl;
        double totalTime = 0.0;

        for (const auto&amp; timing : timings) {
            std::cout &lt;&lt; timing.first &lt;&lt; ": " &lt;&lt; timing.second &lt;&lt; " ms" &lt;&lt; std::endl;
            totalTime += timing.second;
        }

        std::cout &lt;&lt; "Total time: " &lt;&lt; totalTime &lt;&lt; " ms" &lt;&lt; std::endl;
        std::cout &lt;&lt; "========================\n" &lt;&lt; std::endl;
    }

    // 自动计时器
    class ScopedTimer {
    private:
        PerformanceProfiler&amp; profiler;
        std::string operation;

    public:
        ScopedTimer(PerformanceProfiler&amp; p, const std::string&amp; op)
            : profiler(p), operation(op) {
            profiler.startTiming(operation);
        }

        ~ScopedTimer() {
            profiler.endTiming(operation);
        }
    };
};

#define PROFILE_SCOPE(profiler, name) \
    PerformanceProfiler::ScopedTimer timer(profiler, name)
</code></pre>
<h3 id="2-模型验证和调试"><a class="header" href="#2-模型验证和调试">2. 模型验证和调试</a></h3>
<pre><code class="language-cpp">class ModelValidator {
private:
    std::unique_ptr&lt;ONNXModel&gt; model;

public:
    ModelValidator(std::unique_ptr&lt;ONNXModel&gt; model) : model(std::move(model)) {}

    // 验证输入输出形状
    bool validateInputShapes(const std::vector&lt;std::vector&lt;int64_t&gt;&gt;&amp; inputShapes) {
        auto modelInputShapes = model-&gt;getInputShapes();

        if (inputShapes.size() != modelInputShapes.size()) {
            std::cerr &lt;&lt; "Input count mismatch. Expected: " &lt;&lt; modelInputShapes.size()
                     &lt;&lt; ", Got: " &lt;&lt; inputShapes.size() &lt;&lt; std::endl;
            return false;
        }

        for (size_t i = 0; i &lt; inputShapes.size(); ++i) {
            if (!shapesCompatible(modelInputShapes[i], inputShapes[i])) {
                std::cerr &lt;&lt; "Input shape " &lt;&lt; i &lt;&lt; " mismatch." &lt;&lt; std::endl;
                printShapeComparison(modelInputShapes[i], inputShapes[i]);
                return false;
            }
        }

        return true;
    }

    // 随机输入测试
    bool testWithRandomInputs(int numTests = 10) {
        auto inputShapes = model-&gt;getInputShapes();
        Ort::MemoryInfo memoryInfo = Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault);

        for (int test = 0; test &lt; numTests; ++test) {
            std::vector&lt;Ort::Value&gt; randomInputs;

            for (const auto&amp; shape : inputShapes) {
                size_t elementCount = TensorUtils::calculateElementCount(shape);
                std::vector&lt;float&gt; randomData(elementCount);

                // 生成随机数据
                std::random_device rd;
                std::mt19937 gen(rd());
                std::uniform_real_distribution&lt;float&gt; dis(-1.0f, 1.0f);

                for (float&amp; value : randomData) {
                    value = dis(gen);
                }

                randomInputs.push_back(
                    TensorUtils::createTensor&lt;float&gt;(memoryInfo, randomData, shape));
            }

            try {
                auto outputs = model-&gt;run(randomInputs);
                std::cout &lt;&lt; "Test " &lt;&lt; (test + 1) &lt;&lt; " passed" &lt;&lt; std::endl;

                // 验证输出的合理性
                for (size_t i = 0; i &lt; outputs.size(); ++i) {
                    if (!validateOutputTensor(outputs[i], i)) {
                        std::cerr &lt;&lt; "Output validation failed for tensor " &lt;&lt; i &lt;&lt; std::endl;
                        return false;
                    }
                }
            } catch (const std::exception&amp; e) {
                std::cerr &lt;&lt; "Test " &lt;&lt; (test + 1) &lt;&lt; " failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
                return false;
            }
        }

        return true;
    }

private:
    bool shapesCompatible(const std::vector&lt;int64_t&gt;&amp; modelShape,
                         const std::vector&lt;int64_t&gt;&amp; inputShape) {
        if (modelShape.size() != inputShape.size()) return false;

        for (size_t i = 0; i &lt; modelShape.size(); ++i) {
            if (modelShape[i] != -1 &amp;&amp; modelShape[i] != inputShape[i]) {
                return false;
            }
        }

        return true;
    }

    void printShapeComparison(const std::vector&lt;int64_t&gt;&amp; expected,
                            const std::vector&lt;int64_t&gt;&amp; actual) {
        std::cout &lt;&lt; "  Expected: [";
        for (size_t i = 0; i &lt; expected.size(); ++i) {
            std::cout &lt;&lt; expected[i];
            if (i &lt; expected.size() - 1) std::cout &lt;&lt; ", ";
        }
        std::cout &lt;&lt; "]" &lt;&lt; std::endl;

        std::cout &lt;&lt; "  Actual: [";
        for (size_t i = 0; i &lt; actual.size(); ++i) {
            std::cout &lt;&lt; actual[i];
            if (i &lt; actual.size() - 1) std::cout &lt;&lt; ", ";
        }
        std::cout &lt;&lt; "]" &lt;&lt; std::endl;
    }

    bool validateOutputTensor(const Ort::Value&amp; tensor, size_t index) {
        auto tensorInfo = tensor.GetTensorTypeAndShapeInfo();
        auto shape = tensorInfo.GetShape();

        // 检查是否包含NaN或无穷大值
        if (tensorInfo.GetElementType() == ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT) {
            auto data = TensorUtils::extractTensorData&lt;float&gt;(tensor);

            for (float value : data) {
                if (std::isnan(value) || std::isinf(value)) {
                    std::cerr &lt;&lt; "Output tensor " &lt;&lt; index
                             &lt;&lt; " contains NaN or Inf values" &lt;&lt; std::endl;
                    return false;
                }
            }
        }

        return true;
    }
};
</code></pre>
<h2 id="编译和部署"><a class="header" href="#编译和部署">编译和部署</a></h2>
<h3 id="1-cmake配置"><a class="header" href="#1-cmake配置">1. CMake配置</a></h3>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.12)
project(ONNXRuntimeApp)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找ONNX Runtime
find_path(ONNXRUNTIME_INCLUDE_DIR
    NAMES onnxruntime_cxx_api.h
    PATHS /usr/local/include/onnxruntime
          /usr/include/onnxruntime
          ${CMAKE_CURRENT_SOURCE_DIR}/onnxruntime/include
)

find_library(ONNXRUNTIME_LIBRARY
    NAMES onnxruntime
    PATHS /usr/local/lib
          /usr/lib
          ${CMAKE_CURRENT_SOURCE_DIR}/onnxruntime/lib
)

# 创建可执行文件
add_executable(${PROJECT_NAME}
    main.cpp
    # 其他源文件...
)

# 包含头文件
target_include_directories(${PROJECT_NAME} PRIVATE
    ${ONNXRUNTIME_INCLUDE_DIR}
)

# 链接库
target_link_libraries(${PROJECT_NAME}
    ${ONNXRUNTIME_LIBRARY}
)

# 如果使用CUDA
option(USE_CUDA "Enable CUDA support" OFF)
if(USE_CUDA)
    find_package(CUDA REQUIRED)
    target_compile_definitions(${PROJECT_NAME} PRIVATE USE_CUDA)
    target_link_libraries(${PROJECT_NAME} ${CUDA_LIBRARIES})
endif()

# 复制动态库（Windows）
if(WIN32)
    find_file(ONNXRUNTIME_DLL
        NAMES onnxruntime.dll
        PATHS ${CMAKE_CURRENT_SOURCE_DIR}/onnxruntime/lib
              /usr/local/bin
    )

    if(ONNXRUNTIME_DLL)
        add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
            ${ONNXRUNTIME_DLL}
            $&lt;TARGET_FILE_DIR:${PROJECT_NAME}&gt;
        )
    endif()
endif()
</code></pre>
<h3 id="2-部署配置"><a class="header" href="#2-部署配置">2. 部署配置</a></h3>
<pre><code class="language-cpp">class DeploymentHelper {
public:
    // 检查运行时环境
    static bool checkRuntimeEnvironment() {
        std::cout &lt;&lt; "Checking ONNXRuntime environment..." &lt;&lt; std::endl;

        try {
            // 检查基本功能
            Ort::Env env(ORT_LOGGING_LEVEL_WARNING, "EnvironmentCheck");
            std::cout &lt;&lt; "✓ ONNXRuntime environment created successfully" &lt;&lt; std::endl;

            // 检查可用的执行提供器
            auto providers = Ort::GetAvailableProviders();
            std::cout &lt;&lt; "Available providers:" &lt;&lt; std::endl;
            for (const auto&amp; provider : providers) {
                std::cout &lt;&lt; "  - " &lt;&lt; provider &lt;&lt; std::endl;
            }

            return true;
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "✗ Environment check failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
            return false;
        }
    }

    // 模型兼容性检查
    static bool checkModelCompatibility(const std::string&amp; modelPath) {
        try {
            Ort::Env env(ORT_LOGGING_LEVEL_WARNING, "CompatibilityCheck");
            Ort::SessionOptions options;

            // 尝试加载模型
            Ort::Session session(env, modelPath.c_str(), options);
            std::cout &lt;&lt; "✓ Model loaded successfully: " &lt;&lt; modelPath &lt;&lt; std::endl;

            // 检查输入输出信息
            size_t inputCount = session.GetInputCount();
            size_t outputCount = session.GetOutputCount();

            std::cout &lt;&lt; "Model info:" &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Inputs: " &lt;&lt; inputCount &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Outputs: " &lt;&lt; outputCount &lt;&lt; std::endl;

            return true;
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "✗ Model compatibility check failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
            return false;
        }
    }

    // 性能基准测试
    static void benchmarkModel(const std::string&amp; modelPath, int iterations = 100) {
        try {
            Ort::Env env(ORT_LOGGING_LEVEL_WARNING, "Benchmark");
            Ort::SessionOptions options;
            Ort::Session session(env, modelPath.c_str(), options);

            // 创建随机输入
            Ort::MemoryInfo memoryInfo = Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault);
            std::vector&lt;Ort::Value&gt; inputs;

            // 这里需要根据具体模型创建输入张量
            // 简化示例

            auto start = std::chrono::high_resolution_clock::now();

            for (int i = 0; i &lt; iterations; ++i) {
                auto outputs = session.Run(Ort::RunOptions{nullptr}, nullptr, nullptr, 0, nullptr, 0);
            }

            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);

            double avgTime = static_cast&lt;double&gt;(duration.count()) / iterations;
            std::cout &lt;&lt; "Benchmark results:" &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Iterations: " &lt;&lt; iterations &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Total time: " &lt;&lt; duration.count() &lt;&lt; " ms" &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Average time per inference: " &lt;&lt; avgTime &lt;&lt; " ms" &lt;&lt; std::endl;
            std::cout &lt;&lt; "  Throughput: " &lt;&lt; 1000.0 / avgTime &lt;&lt; " FPS" &lt;&lt; std::endl;

        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "Benchmark failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
        }
    }
};
</code></pre>
<h2 id="技术要点总结"><a class="header" href="#技术要点总结">技术要点总结</a></h2>
<ol>
<li><strong>高性能推理</strong>：优化的计算图执行和多硬件后端支持</li>
<li><strong>跨平台兼容</strong>：统一的API接口和广泛的平台支持</li>
<li><strong>硬件加速</strong>：CPU、GPU、专用AI芯片的完整支持</li>
<li><strong>易于集成</strong>：简洁的C++ API和丰富的语言绑定</li>
<li><strong>生产就绪</strong>：稳定可靠的推理引擎，适合生产环境部署</li>
<li><strong>标准兼容</strong>：完整的ONNX标准支持，良好的模型生态</li>
</ol>
<p>ONNXRuntime是现代AI应用部署的核心工具，其高性能和跨平台特性使其成为将机器学习模型投入生产环境的理想选择。通过深入理解其架构和优化策略，开发者可以构建高效、稳定的AI推理服务。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/c++/live555.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/c++/opencv.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/c++/live555.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/c++/opencv.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

