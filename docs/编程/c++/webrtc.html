<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WebRTC (Web Real-Time Communication) å®Œæ•´å­¦ä¹ æŒ‡å— - å¼€å‘</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">å¼€å‘</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="æœç´¢æœ¬ä¹¦å†…å®¹..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="webrtc-web-real-time-communication-å®Œæ•´å­¦ä¹ æŒ‡å—"><a class="header" href="#webrtc-web-real-time-communication-å®Œæ•´å­¦ä¹ æŒ‡å—">WebRTC (Web Real-Time Communication) å®Œæ•´å­¦ä¹ æŒ‡å—</a></h1>
<h2 id="-è¯¾ç¨‹æ¦‚è¿°"><a class="header" href="#-è¯¾ç¨‹æ¦‚è¿°">ğŸ“š è¯¾ç¨‹æ¦‚è¿°</a></h2>
<h3 id="æŠ€æœ¯å®šä½"><a class="header" href="#æŠ€æœ¯å®šä½">æŠ€æœ¯å®šä½</a></h3>
<p>WebRTCï¼ˆWeb Real-Time Communicationï¼‰æ˜¯ç”±Googleä¸»å¯¼çš„å¼€æºé¡¹ç›®ï¼Œæ—¨åœ¨é€šè¿‡ç®€å•çš„APIä¸ºæµè§ˆå™¨å’Œç§»åŠ¨åº”ç”¨æä¾›å®æ—¶é€šä¿¡ï¼ˆRTCï¼‰åŠŸèƒ½ã€‚å®ƒæ”¯æŒ<strong>ç‚¹å¯¹ç‚¹éŸ³è§†é¢‘é€šä¿¡</strong>å’Œ<strong>æ•°æ®ä¼ è¾“</strong>ï¼Œæ— éœ€å®‰è£…ä»»ä½•æ’ä»¶ï¼Œå·²æˆä¸ºç°ä»£å®æ—¶é€šä¿¡åº”ç”¨çš„æ ‡å‡†æŠ€æœ¯ã€‚</p>
<h3 id="æ ¸å¿ƒç‰¹æ€§"><a class="header" href="#æ ¸å¿ƒç‰¹æ€§">æ ¸å¿ƒç‰¹æ€§</a></h3>
<ul>
<li><strong>ç‚¹å¯¹ç‚¹é€šä¿¡ï¼ˆP2Pï¼‰</strong>ï¼šç›´æ¥ç«¯åˆ°ç«¯è¿æ¥ï¼Œå‡å°‘æœåŠ¡å™¨è´Ÿè½½å’Œå»¶è¿Ÿ</li>
<li><strong>å®æ—¶éŸ³è§†é¢‘</strong>ï¼šæ”¯æŒé«˜æ¸…éŸ³è§†é¢‘ä¼ è¾“ï¼Œä½å»¶è¿Ÿï¼ˆ&lt;500msï¼‰</li>
<li><strong>æ•°æ®é€šé“ï¼ˆDataChannelï¼‰</strong>ï¼šæ”¯æŒä»»æ„æ•°æ®ä¼ è¾“</li>
<li><strong>NATç©¿é€</strong>ï¼šé€šè¿‡ICEã€STUNã€TURNå®ç°ç½‘ç»œç©¿é€</li>
<li><strong>è‡ªé€‚åº”ç ç‡</strong>ï¼šæ ¹æ®ç½‘ç»œçŠ¶å†µè‡ªåŠ¨è°ƒæ•´è´¨é‡</li>
<li><strong>éŸ³è§†é¢‘å¤„ç†</strong>ï¼šå†…ç½®å›å£°æ¶ˆé™¤ã€å™ªå£°æŠ‘åˆ¶ã€è‡ªåŠ¨å¢ç›Š</li>
<li><strong>ç«¯åˆ°ç«¯åŠ å¯†</strong>ï¼šDTLSå’ŒSRTPåŠ å¯†ä¿éšœå®‰å…¨</li>
<li><strong>è·¨å¹³å°æ”¯æŒ</strong>ï¼šWebã€Androidã€iOSã€æ¡Œé¢åº”ç”¨</li>
</ul>
<h3 id="å­¦ä¹ ç›®æ ‡"><a class="header" href="#å­¦ä¹ ç›®æ ‡">å­¦ä¹ ç›®æ ‡</a></h3>
<p><strong>åˆçº§ç›®æ ‡ï¼ˆ0-1ä¸ªæœˆï¼‰</strong></p>
<ul>
<li>ç†è§£WebRTCæ¶æ„å’Œæ ¸å¿ƒæ¦‚å¿µ</li>
<li>æŒæ¡ä¿¡ä»¤æµç¨‹å’ŒSDPåè®®</li>
<li>å®ç°ç®€å•çš„P2PéŸ³è§†é¢‘é€šè¯</li>
<li>ç†è§£ICEã€STUNã€TURNçš„ä½œç”¨</li>
</ul>
<p><strong>ä¸­çº§ç›®æ ‡ï¼ˆ1-3ä¸ªæœˆï¼‰</strong></p>
<ul>
<li>ä½¿ç”¨Native C++ APIå¼€å‘åº”ç”¨</li>
<li>å®ç°æ•°æ®é€šé“ä¼ è¾“</li>
<li>éŸ³è§†é¢‘ç¼–è§£ç ä¼˜åŒ–</li>
<li>å¤„ç†ç½‘ç»œæŠ–åŠ¨å’Œä¸¢åŒ…</li>
<li>æ„å»ºä¿¡ä»¤æœåŠ¡å™¨</li>
</ul>
<p><strong>é«˜çº§ç›®æ ‡ï¼ˆ3-6ä¸ªæœˆï¼‰</strong></p>
<ul>
<li>å®ç°å¤šæ–¹è§†é¢‘ä¼šè®®</li>
<li>åª’ä½“æœåŠ¡å™¨é›†æˆï¼ˆSFU/MCUï¼‰</li>
<li>æ€§èƒ½ä¼˜åŒ–å’Œè´¨é‡æ§åˆ¶</li>
<li>ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œç›‘æ§</li>
<li>ç§»åŠ¨ç«¯é€‚é…</li>
</ul>
<h3 id="é€‚ç”¨åœºæ™¯"><a class="header" href="#é€‚ç”¨åœºæ™¯">é€‚ç”¨åœºæ™¯</a></h3>
<p>âœ… <strong>é€‚åˆä½¿ç”¨WebRTCçš„åœºæ™¯ï¼š</strong></p>
<ul>
<li>è§†é¢‘ä¼šè®®å’Œè¿œç¨‹ä¼šè®®</li>
<li>åœ¨çº¿æ•™è‚²å’Œç›´æ’­è¯¾å ‚</li>
<li>è¿œç¨‹åŒ»ç–—å’Œè¿œç¨‹åä½œ</li>
<li>æ¸¸æˆè¯­éŸ³å’Œå®æ—¶äº’åŠ¨</li>
<li>è§†é¢‘å®¢æœå’Œåœ¨çº¿å’¨è¯¢</li>
<li>IoTè®¾å¤‡éŸ³è§†é¢‘ç›‘æ§</li>
<li>P2Pæ–‡ä»¶ä¼ è¾“</li>
</ul>
<p>âŒ <strong>ä¸é€‚åˆä½¿ç”¨WebRTCçš„åœºæ™¯ï¼š</strong></p>
<ul>
<li>å•å‘ç›´æ’­ï¼ˆä½¿ç”¨HLS/DASHæ›´åˆé€‚ï¼‰</li>
<li>å¤§è§„æ¨¡å¹¿æ’­ï¼ˆéœ€è¦CDNæ”¯æŒï¼‰</li>
<li>å½•åˆ¶å’Œç‚¹æ’­ï¼ˆä½¿ç”¨ä¼ ç»Ÿæµåª’ä½“ï¼‰</li>
<li>æä½å»¶è¿Ÿè¦æ±‚ï¼ˆ&lt;100msï¼Œéœ€ä¸“ç”¨åè®®ï¼‰</li>
</ul>
<hr />
<h2 id="-ç¯å¢ƒæ­å»º"><a class="header" href="#-ç¯å¢ƒæ­å»º">ğŸ”§ ç¯å¢ƒæ­å»º</a></h2>
<h3 id="æ–¹å¼ä¸€ä½¿ç”¨å®˜æ–¹é¢„ç¼–è¯‘åº“æ¨èå…¥é—¨"><a class="header" href="#æ–¹å¼ä¸€ä½¿ç”¨å®˜æ–¹é¢„ç¼–è¯‘åº“æ¨èå…¥é—¨">æ–¹å¼ä¸€ï¼šä½¿ç”¨å®˜æ–¹é¢„ç¼–è¯‘åº“ï¼ˆæ¨èå…¥é—¨ï¼‰</a></h3>
<h4 id="ubuntudebian"><a class="header" href="#ubuntudebian">Ubuntu/Debian</a></h4>
<pre><code class="language-bash"># å®‰è£…ä¾èµ–
sudo apt-get update
sudo apt-get install -y \
    build-essential \
    cmake \
    git \
    pkg-config \
    libssl-dev \
    libopus-dev \
    libvpx-dev

# ä¸‹è½½WebRTCé¢„ç¼–è¯‘åº“ï¼ˆä»¥M96ç‰ˆæœ¬ä¸ºä¾‹ï¼‰
wget https://github.com/webrtc-sdk/libwebrtc/releases/download/96.0.0/libwebrtc-linux-x64.tar.gz
tar -xzf libwebrtc-linux-x64.tar.gz -C /usr/local/

# éªŒè¯å®‰è£…
ls /usr/local/include/webrtc/
ls /usr/local/lib/libwebrtc.a
</code></pre>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<pre><code class="language-bash"># å®‰è£…Homebrewä¾èµ–
brew install cmake pkg-config openssl opus libvpx

# ä¸‹è½½WebRTCé¢„ç¼–è¯‘åº“
curl -L https://github.com/webrtc-sdk/libwebrtc/releases/download/96.0.0/libwebrtc-macos.tar.gz -o libwebrtc.tar.gz
tar -xzf libwebrtc.tar.gz -C /usr/local/
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<pre><code class="language-powershell"># ä½¿ç”¨vcpkgï¼ˆéœ€è¦Visual Studio 2019+ï¼‰
vcpkg install webrtc

# æˆ–ä¸‹è½½é¢„ç¼–è¯‘åŒ…
# https://github.com/webrtc-sdk/libwebrtc/releases
</code></pre>
<hr />
<h3 id="æ–¹å¼äºŒä»æºç ç¼–è¯‘è¿›é˜¶ç”¨æˆ·"><a class="header" href="#æ–¹å¼äºŒä»æºç ç¼–è¯‘è¿›é˜¶ç”¨æˆ·">æ–¹å¼äºŒï¼šä»æºç ç¼–è¯‘ï¼ˆè¿›é˜¶ç”¨æˆ·ï¼‰</a></h3>
<h4 id="1-å®‰è£…depot_tools"><a class="header" href="#1-å®‰è£…depot_tools">1. å®‰è£…depot_tools</a></h4>
<pre><code class="language-bash"># å…‹éš†depot_tools
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
export PATH=$PATH:$(pwd)/depot_tools

# é…ç½®ç¯å¢ƒå˜é‡ï¼ˆæ·»åŠ åˆ°~/.bashrcï¼‰
echo 'export PATH=$PATH:$HOME/depot_tools' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h4 id="2-ä¸‹è½½webrtcæºç "><a class="header" href="#2-ä¸‹è½½webrtcæºç ">2. ä¸‹è½½WebRTCæºç </a></h4>
<pre><code class="language-bash"># åˆ›å»ºå·¥ä½œç›®å½•
mkdir webrtc-checkout
cd webrtc-checkout

# è·å–æºç ï¼ˆçº¦10GBï¼Œéœ€è¦è¾ƒé•¿æ—¶é—´ï¼‰
fetch --nohooks webrtc

# åŒæ­¥ä¾èµ–
gclient sync
</code></pre>
<h4 id="3-ç¼–è¯‘webrtc"><a class="header" href="#3-ç¼–è¯‘webrtc">3. ç¼–è¯‘WebRTC</a></h4>
<pre><code class="language-bash">cd src

# ç”Ÿæˆæ„å»ºé…ç½®ï¼ˆDebugç‰ˆæœ¬ï¼‰
gn gen out/Debug --args='is_debug=true rtc_include_tests=false'

# ç”Ÿæˆæ„å»ºé…ç½®ï¼ˆReleaseç‰ˆæœ¬ï¼‰
gn gen out/Release --args='is_debug=false rtc_include_tests=false rtc_use_h264=true'

# ç¼–è¯‘ï¼ˆä½¿ç”¨å¤šæ ¸åŠ é€Ÿï¼‰
ninja -C out/Release

# éªŒè¯ç¼–è¯‘ç»“æœ
ls out/Release/obj/libwebrtc.a
</code></pre>
<p><strong>ç¼–è¯‘é€‰é¡¹è¯´æ˜ï¼š</strong></p>
<pre><code class="language-gn"># å¸¸ç”¨ç¼–è¯‘å‚æ•°
is_debug=false              # Releaseæ¨¡å¼
rtc_include_tests=false     # ä¸ç¼–è¯‘æµ‹è¯•
rtc_use_h264=true          # å¯ç”¨H.264ç¼–è§£ç 
rtc_use_x11=false          # ç¦ç”¨X11ï¼ˆæœåŠ¡å™¨ç¯å¢ƒï¼‰
is_clang=true              # ä½¿ç”¨Clangç¼–è¯‘å™¨
target_cpu="x64"           # ç›®æ ‡CPUæ¶æ„
use_custom_libcxx=false    # ä½¿ç”¨ç³»ç»Ÿæ ‡å‡†åº“
</code></pre>
<hr />
<h3 id="ç¬¬ä¸‰æ­¥éªŒè¯ç¯å¢ƒ"><a class="header" href="#ç¬¬ä¸‰æ­¥éªŒè¯ç¯å¢ƒ">ç¬¬ä¸‰æ­¥ï¼šéªŒè¯ç¯å¢ƒ</a></h3>
<p>åˆ›å»ºæµ‹è¯•æ–‡ä»¶ <code>test_webrtc.cpp</code>ï¼š</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;webrtc/api/peer_connection_interface.h&gt;
#include &lt;webrtc/api/create_peerconnection_factory.h&gt;

int main() {
    std::cout &lt;&lt; "WebRTC Version: " &lt;&lt; webrtc::kBranchHead &lt;&lt; std::endl;
    std::cout &lt;&lt; "WebRTC environment setup successfully!" &lt;&lt; std::endl;

    // åˆå§‹åŒ–çº¿ç¨‹
    rtc::Thread* network_thread = rtc::Thread::CreateWithSocketServer().release();
    rtc::Thread* worker_thread = rtc::Thread::Create().release();
    rtc::Thread* signaling_thread = rtc::Thread::Create().release();

    network_thread-&gt;Start();
    worker_thread-&gt;Start();
    signaling_thread-&gt;Start();

    // åˆ›å»ºPeerConnectionFactory
    auto factory = webrtc::CreatePeerConnectionFactory(
        network_thread,
        worker_thread,
        signaling_thread,
        nullptr,
        webrtc::CreateBuiltinAudioEncoderFactory(),
        webrtc::CreateBuiltinAudioDecoderFactory(),
        webrtc::CreateBuiltinVideoEncoderFactory(),
        webrtc::CreateBuiltinVideoDecoderFactory(),
        nullptr,
        nullptr
    );

    if (factory) {
        std::cout &lt;&lt; "PeerConnectionFactory created successfully!" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Failed to create PeerConnectionFactory" &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}
</code></pre>
<p>ç¼–è¯‘è¿è¡Œï¼š</p>
<pre><code class="language-bash"># ç¼–è¯‘
g++ -std=c++17 test_webrtc.cpp -o test_webrtc \
    -I/usr/local/include/webrtc \
    -L/usr/local/lib \
    -lwebrtc \
    -lpthread

# è¿è¡Œ
./test_webrtc
</code></pre>
<hr />
<h2 id="-æ ¸å¿ƒæ¦‚å¿µ"><a class="header" href="#-æ ¸å¿ƒæ¦‚å¿µ">ğŸ“– æ ¸å¿ƒæ¦‚å¿µ</a></h2>
<h3 id="1-webrtcæ¶æ„"><a class="header" href="#1-webrtcæ¶æ„">1. WebRTCæ¶æ„</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          JavaScript API (Web)               â”‚
â”‚    getUserMedia, RTCPeerConnection, etc.    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         WebRTC Native C++ API               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PeerConnection  â”‚  MediaStream  â”‚  Data   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Session Management (SDP/ICE)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Audio Engine  â”‚  Video Engine  â”‚  Network â”‚
â”‚  - å›å£°æ¶ˆé™¤    â”‚  - ç¼–è§£ç       â”‚  - ä¼ è¾“  â”‚
â”‚  - å™ªå£°æŠ‘åˆ¶    â”‚  - ç¼©æ”¾/æ—‹è½¬   â”‚  - QoS   â”‚
â”‚  - å¢ç›Šæ§åˆ¶    â”‚  - æ¸²æŸ“        â”‚  - æ‹¥å¡  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="2-ä¿¡ä»¤æµç¨‹signaling"><a class="header" href="#2-ä¿¡ä»¤æµç¨‹signaling">2. ä¿¡ä»¤æµç¨‹ï¼ˆSignalingï¼‰</a></h3>
<p>WebRTCæœ¬èº«<strong>ä¸å®šä¹‰ä¿¡ä»¤åè®®</strong>ï¼Œéœ€è¦å¼€å‘è€…è‡ªè¡Œå®ç°ã€‚å¸¸ç”¨çš„ä¿¡ä»¤åè®®æœ‰WebSocketã€SIPã€XMPPç­‰ã€‚</p>
<pre><code>Peer A (å‘¼å«æ–¹)        ä¿¡ä»¤æœåŠ¡å™¨         Peer B (æ¥æ”¶æ–¹)
     |                    |                    |
     |--- createOffer ---&gt;|                    |
     |                    |                    |
     |&lt;-- SDP Offer ------|                    |
     |                    |                    |
     |--Offer via Signal-&gt;|--Offer via Signal-&gt;|
     |                    |                    |
     |                    |&lt;---createAnswer----|
     |                    |                    |
     |                    |&lt;-- SDP Answer -----|
     |&lt;-Answer via Signal-|                    |
     |                    |                    |
     |&lt;===== ICE Candidate Exchange =========&gt;|
     |                    |                    |
     |&lt;========= P2P Media Connection ========&gt;|
</code></pre>
<p><strong>å…³é”®æ­¥éª¤ï¼š</strong></p>
<ol>
<li><strong>Offer/Answeräº¤æ¢</strong>ï¼šäº¤æ¢SDPï¼ˆä¼šè¯æè¿°åè®®ï¼‰ä¿¡æ¯</li>
<li><strong>ICEå€™é€‰äº¤æ¢</strong>ï¼šäº¤æ¢ç½‘ç»œåœ°å€ä¿¡æ¯</li>
<li><strong>å»ºç«‹è¿æ¥</strong>ï¼šé€šè¿‡ICEåå•†æœ€ä¼˜è·¯å¾„</li>
<li><strong>åª’ä½“ä¼ è¾“</strong>ï¼šå¼€å§‹éŸ³è§†é¢‘æ•°æ®ä¼ è¾“</li>
</ol>
<hr />
<h3 id="3-sdpsession-description-protocol"><a class="header" href="#3-sdpsession-description-protocol">3. SDPï¼ˆSession Description Protocolï¼‰</a></h3>
<p>SDPæè¿°äº†åª’ä½“ä¼šè¯çš„å‚æ•°ã€‚</p>
<p><strong>ç¤ºä¾‹SDPï¼š</strong></p>
<pre><code class="language-sdp">v=0
o=- 4611731400430051336 2 IN IP4 127.0.0.1
s=-
t=0 0
a=group:BUNDLE 0 1
a=msid-semantic: WMS stream

m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=ice-ufrag:F7gI
a=ice-pwd:x9cml/YzichV2+XlhiMu8g
a=ice-options:trickle
a=fingerprint:sha-256 49:66:12:17:0D:1C:91:AE:57:4C:C6:36:DD:D5:5D:20
a=setup:actpass
a=mid:0
a=sendrecv
a=rtcp-mux
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10;useinbandfec=1

m=video 9 UDP/TLS/RTP/SAVPF 96 97 98
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=ice-ufrag:F7gI
a=ice-pwd:x9cml/YzichV2+XlhiMu8g
a=ice-options:trickle
a=fingerprint:sha-256 49:66:12:17:0D:1C:91:AE:57:4C:C6:36:DD:D5:5D:20
a=setup:actpass
a=mid:1
a=sendrecv
a=rtcp-mux
a=rtpmap:96 VP8/90000
a=rtpmap:97 VP9/90000
a=rtpmap:98 H264/90000
</code></pre>
<p><strong>SDPå…³é”®å­—æ®µï¼š</strong></p>
<ul>
<li><code>v=</code> - ç‰ˆæœ¬</li>
<li><code>o=</code> - æºä¿¡æ¯</li>
<li><code>s=</code> - ä¼šè¯åç§°</li>
<li><code>t=</code> - æ—¶é—´æè¿°</li>
<li><code>m=</code> - åª’ä½“æè¿°ï¼ˆaudio/videoï¼‰</li>
<li><code>a=</code> - å±æ€§ï¼ˆç¼–è§£ç å™¨ã€ICEä¿¡æ¯ç­‰ï¼‰</li>
</ul>
<hr />
<h3 id="4-iceinteractive-connectivity-establishment"><a class="header" href="#4-iceinteractive-connectivity-establishment">4. ICEï¼ˆInteractive Connectivity Establishmentï¼‰</a></h3>
<p>ICEæ˜¯NATç©¿é€çš„æ ¸å¿ƒæœºåˆ¶ã€‚</p>
<p><strong>ICEå€™é€‰ç±»å‹ï¼š</strong></p>
<pre><code class="language-cpp">enum class IceCandidateType {
    HOST,       // æœ¬åœ°åœ°å€ï¼ˆå±€åŸŸç½‘IPï¼‰
    SRFLX,      // æœåŠ¡å™¨åå°„åœ°å€ï¼ˆé€šè¿‡STUNè·å–çš„å…¬ç½‘IPï¼‰
    PRFLX,      // å¯¹ç­‰åå°„åœ°å€ï¼ˆä»å¯¹ç«¯å­¦ä¹ åˆ°çš„åœ°å€ï¼‰
    RELAY       // ä¸­ç»§åœ°å€ï¼ˆé€šè¿‡TURNæœåŠ¡å™¨ä¸­ç»§ï¼‰
};
</code></pre>
<p><strong>ICEå€™é€‰ä¼˜å…ˆçº§ï¼š</strong></p>
<pre><code>HOST &gt; SRFLX &gt; PRFLX &gt; RELAY
ï¼ˆæœ¬åœ°ç›´è¿ &gt; STUNç©¿é€ &gt; å¯¹ç­‰å‘ç° &gt; TURNä¸­ç»§ï¼‰
</code></pre>
<p><strong>ICEè¿æ¥æµç¨‹ï¼š</strong></p>
<pre><code>1. æ”¶é›†å€™é€‰åœ°å€
   - æœ¬åœ°åœ°å€ï¼ˆHOSTï¼‰
   - STUNæœåŠ¡å™¨è·å–å…¬ç½‘IPï¼ˆSRFLXï¼‰
   - TURNæœåŠ¡å™¨ä¸­ç»§åœ°å€ï¼ˆRELAYï¼‰

2. äº¤æ¢å€™é€‰åœ°å€
   - é€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨äº¤æ¢ICEå€™é€‰

3. è¿æ¥æ€§æ£€æŸ¥
   - å°è¯•æ‰€æœ‰å€™é€‰åœ°å€ç»„åˆ
   - é€‰æ‹©æœ€ä¼˜è·¯å¾„ï¼ˆå»¶è¿Ÿæœ€ä½ï¼‰

4. å»ºç«‹è¿æ¥
   - æˆåŠŸå»ºç«‹P2Pæˆ–ä¸­ç»§è¿æ¥
</code></pre>
<hr />
<h3 id="5-stunå’ŒturnæœåŠ¡å™¨"><a class="header" href="#5-stunå’ŒturnæœåŠ¡å™¨">5. STUNå’ŒTURNæœåŠ¡å™¨</a></h3>
<p><strong>STUNï¼ˆSession Traversal Utilities for NATï¼‰</strong></p>
<ul>
<li>ä½œç”¨ï¼šå¸®åŠ©å®¢æˆ·ç«¯å‘ç°è‡ªå·±çš„å…¬ç½‘IPå’Œç«¯å£</li>
<li>ä½¿ç”¨åœºæ™¯ï¼šå¤§å¤šæ•°NATç©¿é€ï¼ˆçº¦80%æˆåŠŸç‡ï¼‰</li>
<li>å…è´¹å…¬å…±æœåŠ¡å™¨ï¼š<code>stun:stun.l.google.com:19302</code></li>
</ul>
<p><strong>TURNï¼ˆTraversal Using Relays around NATï¼‰</strong></p>
<ul>
<li>ä½œç”¨ï¼šä½œä¸ºä¸­ç»§æœåŠ¡å™¨è½¬å‘åª’ä½“æµ</li>
<li>ä½¿ç”¨åœºæ™¯ï¼šSTUNå¤±è´¥æ—¶çš„å¤‡é€‰æ–¹æ¡ˆï¼ˆå¯¹ç§°NATï¼‰</li>
<li>éœ€è¦è‡ªå»ºæˆ–ä»˜è´¹æœåŠ¡</li>
</ul>
<p><strong>é…ç½®ç¤ºä¾‹ï¼š</strong></p>
<pre><code class="language-cpp">webrtc::PeerConnectionInterface::RTCConfiguration config;

// STUNæœåŠ¡å™¨
webrtc::PeerConnectionInterface::IceServer stun_server;
stun_server.uri = "stun:stun.l.google.com:19302";
config.servers.push_back(stun_server);

// TURNæœåŠ¡å™¨
webrtc::PeerConnectionInterface::IceServer turn_server;
turn_server.uri = "turn:turn.example.com:3478";
turn_server.username = "user";
turn_server.password = "pass";
config.servers.push_back(turn_server);
</code></pre>
<hr />
<h2 id="-å®Œæ•´å®æˆ˜p2pè§†é¢‘é€šè¯"><a class="header" href="#-å®Œæ•´å®æˆ˜p2pè§†é¢‘é€šè¯">ğŸ¯ å®Œæ•´å®æˆ˜ï¼šP2Pè§†é¢‘é€šè¯</a></h2>
<h3 id="1-peerconnectionç®¡ç†å™¨"><a class="header" href="#1-peerconnectionç®¡ç†å™¨">1. PeerConnectionç®¡ç†å™¨</a></h3>
<pre><code class="language-cpp">// peer_connection_manager.h
#ifndef PEER_CONNECTION_MANAGER_H
#define PEER_CONNECTION_MANAGER_H

#include &lt;webrtc/api/peer_connection_interface.h&gt;
#include &lt;webrtc/api/create_peerconnection_factory.h&gt;
#include &lt;webrtc/api/audio_codecs/builtin_audio_decoder_factory.h&gt;
#include &lt;webrtc/api/audio_codecs/builtin_audio_encoder_factory.h&gt;
#include &lt;webrtc/api/video_codecs/builtin_video_decoder_factory.h&gt;
#include &lt;webrtc/api/video_codecs/builtin_video_encoder_factory.h&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;

class PeerConnectionManager : public webrtc::PeerConnectionObserver,
                               public webrtc::CreateSessionDescriptionObserver {
public:
    using OnIceCandidateCallback = std::function&lt;void(const webrtc::IceCandidateInterface*)&gt;;
    using OnTrackCallback = std::function&lt;void(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;)&gt;;
    using OnDataChannelCallback = std::function&lt;void(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt;)&gt;;

    PeerConnectionManager();
    ~PeerConnectionManager();

    bool Initialize();
    void CreateOffer();
    void CreateAnswer();
    void SetRemoteDescription(const std::string&amp; type, const std::string&amp; sdp);
    void AddIceCandidate(const std::string&amp; sdp_mid, int sdp_mline_index, const std::string&amp; candidate);

    bool AddAudioTrack();
    bool AddVideoTrack();
    rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; CreateDataChannel(const std::string&amp; label);

    void SetOnIceCandidateCallback(OnIceCandidateCallback callback) {
        on_ice_candidate_ = callback;
    }
    void SetOnTrackCallback(OnTrackCallback callback) {
        on_track_ = callback;
    }

    // PeerConnectionObserverå®ç°
    void OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState new_state) override;
    void OnIceGatheringChange(webrtc::PeerConnectionInterface::IceGatheringState new_state) override;
    void OnIceCandidate(const webrtc::IceCandidateInterface* candidate) override;
    void OnTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver) override;
    void OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; data_channel) override;

    // CreateSessionDescriptionObserverå®ç°
    void OnSuccess(webrtc::SessionDescriptionInterface* desc) override;
    void OnFailure(webrtc::RTCError error) override;

private:
    std::unique_ptr&lt;rtc::Thread&gt; network_thread_;
    std::unique_ptr&lt;rtc::Thread&gt; worker_thread_;
    std::unique_ptr&lt;rtc::Thread&gt; signaling_thread_;

    rtc::scoped_refptr&lt;webrtc::PeerConnectionFactoryInterface&gt; peer_connection_factory_;
    rtc::scoped_refptr&lt;webrtc::PeerConnectionInterface&gt; peer_connection_;
    rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audio_track_;
    rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; video_track_;

    OnIceCandidateCallback on_ice_candidate_;
    OnTrackCallback on_track_;
    OnDataChannelCallback on_data_channel_;
};

#endif // PEER_CONNECTION_MANAGER_H
</code></pre>
<p><strong>å®ç°æ–‡ä»¶ï¼š</strong></p>
<pre><code class="language-cpp">// peer_connection_manager.cpp
#include "peer_connection_manager.h"
#include &lt;iostream&gt;

PeerConnectionManager::PeerConnectionManager() {
}

PeerConnectionManager::~PeerConnectionManager() {
    if (peer_connection_) {
        peer_connection_-&gt;Close();
    }
}

bool PeerConnectionManager::Initialize() {
    // åˆ›å»ºçº¿ç¨‹
    network_thread_ = rtc::Thread::CreateWithSocketServer();
    worker_thread_ = rtc::Thread::Create();
    signaling_thread_ = rtc::Thread::Create();

    network_thread_-&gt;Start();
    worker_thread_-&gt;Start();
    signaling_thread_-&gt;Start();

    // åˆ›å»ºPeerConnectionFactory
    peer_connection_factory_ = webrtc::CreatePeerConnectionFactory(
        network_thread_.get(),
        worker_thread_.get(),
        signaling_thread_.get(),
        nullptr,  // default audio device module
        webrtc::CreateBuiltinAudioEncoderFactory(),
        webrtc::CreateBuiltinAudioDecoderFactory(),
        webrtc::CreateBuiltinVideoEncoderFactory(),
        webrtc::CreateBuiltinVideoDecoderFactory(),
        nullptr,  // audio mixer
        nullptr   // audio processing
    );

    if (!peer_connection_factory_) {
        std::cerr &lt;&lt; "Failed to create PeerConnectionFactory" &lt;&lt; std::endl;
        return false;
    }

    // é…ç½®ICEæœåŠ¡å™¨
    webrtc::PeerConnectionInterface::RTCConfiguration config;

    webrtc::PeerConnectionInterface::IceServer stun_server;
    stun_server.uri = "stun:stun.l.google.com:19302";
    config.servers.push_back(stun_server);

    webrtc::PeerConnectionInterface::IceServer turn_server;
    turn_server.uri = "turn:turn.example.com:3478";
    turn_server.username = "username";
    turn_server.password = "password";
    config.servers.push_back(turn_server);

    // è®¾ç½®ICEä¼ è¾“ç­–ç•¥
    config.type = webrtc::PeerConnectionInterface::kRelay;  // æˆ– kAll, kNoHost
    config.bundle_policy = webrtc::PeerConnectionInterface::kBundlePolicyMaxBundle;
    config.rtcp_mux_policy = webrtc::PeerConnectionInterface::kRtcpMuxPolicyRequire;

    // åˆ›å»ºPeerConnection
    webrtc::PeerConnectionDependencies dependencies(this);
    auto result = peer_connection_factory_-&gt;CreatePeerConnectionOrError(
        config, std::move(dependencies));

    if (!result.ok()) {
        std::cerr &lt;&lt; "Failed to create PeerConnection: "
                 &lt;&lt; result.error().message() &lt;&lt; std::endl;
        return false;
    }

    peer_connection_ = result.MoveValue();
    std::cout &lt;&lt; "PeerConnection initialized successfully" &lt;&lt; std::endl;
    return true;
}

void PeerConnectionManager::CreateOffer() {
    if (!peer_connection_) {
        std::cerr &lt;&lt; "PeerConnection not initialized" &lt;&lt; std::endl;
        return;
    }

    webrtc::PeerConnectionInterface::RTCOfferAnswerOptions options;
    options.offer_to_receive_audio = true;
    options.offer_to_receive_video = true;

    peer_connection_-&gt;CreateOffer(this, options);
}

void PeerConnectionManager::CreateAnswer() {
    if (!peer_connection_) {
        std::cerr &lt;&lt; "PeerConnection not initialized" &lt;&lt; std::endl;
        return;
    }

    webrtc::PeerConnectionInterface::RTCOfferAnswerOptions options;
    peer_connection_-&gt;CreateAnswer(this, options);
}

void PeerConnectionManager::SetRemoteDescription(const std::string&amp; type, const std::string&amp; sdp) {
    webrtc::SdpParseError error;
    std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; session_description(
        webrtc::CreateSessionDescription(type, sdp, &amp;error));

    if (!session_description) {
        std::cerr &lt;&lt; "Failed to parse SDP: " &lt;&lt; error.description &lt;&lt; std::endl;
        return;
    }

    peer_connection_-&gt;SetRemoteDescription(
        std::move(session_description),
        [](webrtc::RTCError error) {
            if (!error.ok()) {
                std::cerr &lt;&lt; "SetRemoteDescription failed: " &lt;&lt; error.message() &lt;&lt; std::endl;
            } else {
                std::cout &lt;&lt; "SetRemoteDescription success" &lt;&lt; std::endl;
            }
        });
}

void PeerConnectionManager::AddIceCandidate(const std::string&amp; sdp_mid,
                                            int sdp_mline_index,
                                            const std::string&amp; candidate) {
    webrtc::SdpParseError error;
    std::unique_ptr&lt;webrtc::IceCandidateInterface&gt; ice_candidate(
        webrtc::CreateIceCandidate(sdp_mid, sdp_mline_index, candidate, &amp;error));

    if (!ice_candidate) {
        std::cerr &lt;&lt; "Failed to parse ICE candidate: " &lt;&lt; error.description &lt;&lt; std::endl;
        return;
    }

    peer_connection_-&gt;AddIceCandidate(
        std::move(ice_candidate),
        [](webrtc::RTCError error) {
            if (!error.ok()) {
                std::cerr &lt;&lt; "AddIceCandidate failed: " &lt;&lt; error.message() &lt;&lt; std::endl;
            }
        });
}

bool PeerConnectionManager::AddAudioTrack() {
    cricket::AudioOptions options;
    options.echo_cancellation = true;
    options.noise_suppression = true;
    options.auto_gain_control = true;

    rtc::scoped_refptr&lt;webrtc::AudioSourceInterface&gt; audio_source =
        peer_connection_factory_-&gt;CreateAudioSource(options);

    audio_track_ = peer_connection_factory_-&gt;CreateAudioTrack("audio_label", audio_source);

    auto result = peer_connection_-&gt;AddTrack(audio_track_, {"stream_id"});
    if (!result.ok()) {
        std::cerr &lt;&lt; "Failed to add audio track: " &lt;&lt; result.error().message() &lt;&lt; std::endl;
        return false;
    }

    std::cout &lt;&lt; "Audio track added successfully" &lt;&lt; std::endl;
    return true;
}

bool PeerConnectionManager::AddVideoTrack() {
    // è¿™é‡Œéœ€è¦å®ç°è§†é¢‘é‡‡é›†ï¼Œç®€åŒ–ç¤ºä¾‹çœç•¥
    // å®é™…åº”ç”¨ä¸­éœ€è¦ä½¿ç”¨VideoCapturer
    std::cout &lt;&lt; "Video track not implemented in this example" &lt;&lt; std::endl;
    return false;
}

rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; PeerConnectionManager::CreateDataChannel(const std::string&amp; label) {
    webrtc::DataChannelInit config;
    config.ordered = true;
    config.reliable = true;

    auto data_channel = peer_connection_-&gt;CreateDataChannel(label, &amp;config);
    if (!data_channel) {
        std::cerr &lt;&lt; "Failed to create data channel" &lt;&lt; std::endl;
        return nullptr;
    }

    std::cout &lt;&lt; "Data channel created: " &lt;&lt; label &lt;&lt; std::endl;
    return data_channel;
}

// PeerConnectionObserverå›è°ƒ
void PeerConnectionManager::OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState new_state) {
    std::cout &lt;&lt; "Signaling state changed: " &lt;&lt; new_state &lt;&lt; std::endl;
}

void PeerConnectionManager::OnIceGatheringChange(webrtc::PeerConnectionInterface::IceGatheringState new_state) {
    std::cout &lt;&lt; "ICE gathering state changed: " &lt;&lt; new_state &lt;&lt; std::endl;
}

void PeerConnectionManager::OnIceCandidate(const webrtc::IceCandidateInterface* candidate) {
    std::cout &lt;&lt; "New ICE candidate" &lt;&lt; std::endl;
    if (on_ice_candidate_) {
        on_ice_candidate_(candidate);
    }
}

void PeerConnectionManager::OnTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver) {
    std::cout &lt;&lt; "New track received" &lt;&lt; std::endl;
    if (on_track_) {
        on_track_(receiver);
    }
}

void PeerConnectionManager::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; data_channel) {
    std::cout &lt;&lt; "New data channel received: " &lt;&lt; data_channel-&gt;label() &lt;&lt; std::endl;
    if (on_data_channel_) {
        on_data_channel_(data_channel);
    }
}

// CreateSessionDescriptionObserverå›è°ƒ
void PeerConnectionManager::OnSuccess(webrtc::SessionDescriptionInterface* desc) {
    std::string sdp;
    desc-&gt;ToString(&amp;sdp);
    std::cout &lt;&lt; "Created " &lt;&lt; desc-&gt;type() &lt;&lt; " SDP:\n" &lt;&lt; sdp &lt;&lt; std::endl;

    // è®¾ç½®æœ¬åœ°æè¿°
    peer_connection_-&gt;SetLocalDescription(
        std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt;(desc),
        [](webrtc::RTCError error) {
            if (!error.ok()) {
                std::cerr &lt;&lt; "SetLocalDescription failed: " &lt;&lt; error.message() &lt;&lt; std::endl;
            } else {
                std::cout &lt;&lt; "SetLocalDescription success" &lt;&lt; std::endl;
            }
        });

    // è¿™é‡Œåº”è¯¥å°†SDPé€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨å‘é€ç»™å¯¹ç«¯
    // SendSignalingMessage(desc-&gt;type(), sdp);
}

void PeerConnectionManager::OnFailure(webrtc::RTCError error) {
    std::cerr &lt;&lt; "Create session description failed: " &lt;&lt; error.message() &lt;&lt; std::endl;
}
</code></pre>
<hr />
<h3 id="2-ä¿¡ä»¤æœåŠ¡å™¨websocket"><a class="header" href="#2-ä¿¡ä»¤æœåŠ¡å™¨websocket">2. ä¿¡ä»¤æœåŠ¡å™¨ï¼ˆWebSocketï¼‰</a></h3>
<p>ä½¿ç”¨WebSocketå®ç°ç®€å•çš„ä¿¡ä»¤æœåŠ¡å™¨ã€‚</p>
<p><strong>æœåŠ¡å™¨ç«¯ï¼ˆNode.jsç¤ºä¾‹ï¼‰ï¼š</strong></p>
<pre><code class="language-javascript">// signaling_server.js
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

const clients = new Map();

wss.on('connection', (ws) =&gt; {
    const clientId = generateId();
    clients.set(clientId, ws);
    console.log(`Client ${clientId} connected`);

    // å‘é€å®¢æˆ·ç«¯ID
    ws.send(JSON.stringify({
        type: 'id',
        id: clientId
    }));

    ws.on('message', (message) =&gt; {
        try {
            const data = JSON.parse(message);
            console.log(`Received from ${clientId}:`, data.type);

            // è½¬å‘æ¶ˆæ¯ç»™ç›®æ ‡å®¢æˆ·ç«¯
            if (data.to &amp;&amp; clients.has(data.to)) {
                const targetWs = clients.get(data.to);
                data.from = clientId;
                targetWs.send(JSON.stringify(data));
            }
        } catch (error) {
            console.error('Error processing message:', error);
        }
    });

    ws.on('close', () =&gt; {
        clients.delete(clientId);
        console.log(`Client ${clientId} disconnected`);
    });
});

function generateId() {
    return Math.random().toString(36).substr(2, 9);
}

console.log('Signaling server running on ws://localhost:8080');
</code></pre>
<p><strong>C++å®¢æˆ·ç«¯ï¼ˆä½¿ç”¨websocketppï¼‰ï¼š</strong></p>
<pre><code class="language-cpp">// signaling_client.h
#ifndef SIGNALING_CLIENT_H
#define SIGNALING_CLIENT_H

#include &lt;websocketpp/config/asio_no_tls_client.hpp&gt;
#include &lt;websocketpp/client.hpp&gt;
#include &lt;functional&gt;
#include &lt;string&gt;

typedef websocketpp::client&lt;websocketpp::config::asio_client&gt; client;

class SignalingClient {
public:
    using OnMessageCallback = std::function&lt;void(const std::string&amp;)&gt;;

    SignalingClient(const std::string&amp; uri);
    void Connect();
    void Send(const std::string&amp; message);
    void SetOnMessageCallback(OnMessageCallback callback) {
        on_message_ = callback;
    }

private:
    void OnOpen(websocketpp::connection_hdl hdl);
    void OnMessage(websocketpp::connection_hdl hdl, client::message_ptr msg);
    void OnClose(websocketpp::connection_hdl hdl);

    client ws_client_;
    std::string uri_;
    websocketpp::connection_hdl connection_;
    OnMessageCallback on_message_;
};

#endif // SIGNALING_CLIENT_H
</code></pre>
<hr />
<h3 id="3-æ•°æ®é€šé“datachannel"><a class="header" href="#3-æ•°æ®é€šé“datachannel">3. æ•°æ®é€šé“ï¼ˆDataChannelï¼‰</a></h3>
<pre><code class="language-cpp">// data_channel_manager.h
#ifndef DATA_CHANNEL_MANAGER_H
#define DATA_CHANNEL_MANAGER_H

#include &lt;webrtc/api/data_channel_interface.h&gt;
#include &lt;functional&gt;
#include &lt;string&gt;

class DataChannelObserver : public webrtc::DataChannelObserver {
public:
    using OnMessageCallback = std::function&lt;void(const std::string&amp;)&gt;;
    using OnStateChangeCallback = std::function&lt;void(webrtc::DataChannelInterface::DataState)&gt;;

    DataChannelObserver(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; data_channel);
    ~DataChannelObserver();

    void Send(const std::string&amp; message);
    void Send(const uint8_t* data, size_t length);

    void SetOnMessageCallback(OnMessageCallback callback) {
        on_message_ = callback;
    }
    void SetOnStateChangeCallback(OnStateChangeCallback callback) {
        on_state_change_ = callback;
    }

    // DataChannelObserverå®ç°
    void OnStateChange() override;
    void OnMessage(const webrtc::DataBuffer&amp; buffer) override;
    void OnBufferedAmountChange(uint64_t sent_data_size) override;

private:
    rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; data_channel_;
    OnMessageCallback on_message_;
    OnStateChangeCallback on_state_change_;
};

#endif // DATA_CHANNEL_MANAGER_H
</code></pre>
<p><strong>å®ç°ï¼š</strong></p>
<pre><code class="language-cpp">// data_channel_manager.cpp
#include "data_channel_manager.h"
#include &lt;iostream&gt;

DataChannelObserver::DataChannelObserver(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; data_channel)
    : data_channel_(data_channel) {
    data_channel_-&gt;RegisterObserver(this);
}

DataChannelObserver::~DataChannelObserver() {
    data_channel_-&gt;UnregisterObserver();
}

void DataChannelObserver::Send(const std::string&amp; message) {
    webrtc::DataBuffer buffer(rtc::CopyOnWriteBuffer(message.c_str(), message.length()), false);
    if (!data_channel_-&gt;Send(buffer)) {
        std::cerr &lt;&lt; "Failed to send message" &lt;&lt; std::endl;
    }
}

void DataChannelObserver::Send(const uint8_t* data, size_t length) {
    webrtc::DataBuffer buffer(rtc::CopyOnWriteBuffer(data, length), true);
    if (!data_channel_-&gt;Send(buffer)) {
        std::cerr &lt;&lt; "Failed to send binary data" &lt;&lt; std::endl;
    }
}

void DataChannelObserver::OnStateChange() {
    auto state = data_channel_-&gt;state();
    std::cout &lt;&lt; "DataChannel state changed: " &lt;&lt; state &lt;&lt; std::endl;

    if (on_state_change_) {
        on_state_change_(state);
    }
}

void DataChannelObserver::OnMessage(const webrtc::DataBuffer&amp; buffer) {
    if (buffer.binary) {
        std::cout &lt;&lt; "Received binary data, size: " &lt;&lt; buffer.data.size() &lt;&lt; std::endl;
    } else {
        std::string message(buffer.data.data&lt;char&gt;(), buffer.data.size());
        std::cout &lt;&lt; "Received message: " &lt;&lt; message &lt;&lt; std::endl;

        if (on_message_) {
            on_message_(message);
        }
    }
}

void DataChannelObserver::OnBufferedAmountChange(uint64_t sent_data_size) {
    std::cout &lt;&lt; "Buffered amount: " &lt;&lt; sent_data_size &lt;&lt; std::endl;
}
</code></pre>
<hr />
<h2 id="-éŸ³è§†é¢‘å¤„ç†"><a class="header" href="#-éŸ³è§†é¢‘å¤„ç†">ğŸ¬ éŸ³è§†é¢‘å¤„ç†</a></h2>
<h3 id="1-è§†é¢‘é‡‡é›†"><a class="header" href="#1-è§†é¢‘é‡‡é›†">1. è§†é¢‘é‡‡é›†</a></h3>
<pre><code class="language-cpp">// video_capturer.h
#ifndef VIDEO_CAPTURER_H
#define VIDEO_CAPTURER_H

#include &lt;webrtc/modules/video_capture/video_capture.h&gt;
#include &lt;webrtc/api/video/video_frame.h&gt;
#include &lt;webrtc/media/base/adapted_video_track_source.h&gt;

class VideoCapturer : public rtc::AdaptedVideoTrackSource,
                      public rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt; {
public:
    static rtc::scoped_refptr&lt;VideoCapturer&gt; Create(size_t width,
                                                     size_t height,
                                                     size_t fps);

    VideoCapturer();
    ~VideoCapturer() override;

    bool Start();
    void Stop();

    // VideoSinkInterface
    void OnFrame(const webrtc::VideoFrame&amp; frame) override;

    // AdaptedVideoTrackSource
    bool is_screencast() const override { return false; }
    absl::optional&lt;bool&gt; needs_denoising() const override { return false; }
    webrtc::MediaSourceInterface::SourceState state() const override {
        return webrtc::MediaSourceInterface::kLive;
    }
    bool remote() const override { return false; }

private:
    rtc::scoped_refptr&lt;webrtc::VideoCaptureModule&gt; capture_module_;
    webrtc::VideoCaptureCapability capability_;
};

#endif // VIDEO_CAPTURER_H
</code></pre>
<p><strong>å®ç°ï¼š</strong></p>
<pre><code class="language-cpp">// video_capturer.cpp
#include "video_capturer.h"
#include &lt;iostream&gt;

rtc::scoped_refptr&lt;VideoCapturer&gt; VideoCapturer::Create(size_t width, size_t height, size_t fps) {
    auto capturer = rtc::make_ref_counted&lt;VideoCapturer&gt;();

    capturer-&gt;capability_.width = width;
    capturer-&gt;capability_.height = height;
    capturer-&gt;capability_.maxFPS = fps;
    capturer-&gt;capability_.videoType = webrtc::VideoType::kI420;

    if (!capturer-&gt;Start()) {
        return nullptr;
    }

    return capturer;
}

VideoCapturer::VideoCapturer() {
}

VideoCapturer::~VideoCapturer() {
    Stop();
}

bool VideoCapturer::Start() {
    std::unique_ptr&lt;webrtc::VideoCaptureModule::DeviceInfo&gt; device_info(
        webrtc::VideoCaptureFactory::CreateDeviceInfo());

    if (!device_info) {
        std::cerr &lt;&lt; "Failed to create device info" &lt;&lt; std::endl;
        return false;
    }

    // è·å–ç¬¬ä¸€ä¸ªæ‘„åƒå¤´
    uint32_t num_devices = device_info-&gt;NumberOfDevices();
    if (num_devices == 0) {
        std::cerr &lt;&lt; "No video capture devices found" &lt;&lt; std::endl;
        return false;
    }

    char device_name[256];
    char device_id[256];
    device_info-&gt;GetDeviceName(0, device_name, sizeof(device_name),
                               device_id, sizeof(device_id));

    std::cout &lt;&lt; "Using camera: " &lt;&lt; device_name &lt;&lt; std::endl;

    // åˆ›å»ºcapture module
    capture_module_ = webrtc::VideoCaptureFactory::Create(device_id);
    if (!capture_module_) {
        std::cerr &lt;&lt; "Failed to create capture module" &lt;&lt; std::endl;
        return false;
    }

    capture_module_-&gt;RegisterCaptureDataCallback(this);

    // å¯åŠ¨é‡‡é›†
    if (capture_module_-&gt;StartCapture(capability_) != 0) {
        std::cerr &lt;&lt; "Failed to start capture" &lt;&lt; std::endl;
        return false;
    }

    std::cout &lt;&lt; "Video capture started: " &lt;&lt; capability_.width &lt;&lt; "x"
             &lt;&lt; capability_.height &lt;&lt; "@" &lt;&lt; capability_.maxFPS &lt;&lt; "fps" &lt;&lt; std::endl;

    return true;
}

void VideoCapturer::Stop() {
    if (capture_module_) {
        capture_module_-&gt;StopCapture();
        capture_module_-&gt;DeRegisterCaptureDataCallback();
        capture_module_ = nullptr;
    }
}

void VideoCapturer::OnFrame(const webrtc::VideoFrame&amp; frame) {
    // è½¬å‘ç»™VideoTrackSource
    OnCapturedFrame(frame);
}
</code></pre>
<hr />
<h3 id="2-è§†é¢‘æ¸²æŸ“"><a class="header" href="#2-è§†é¢‘æ¸²æŸ“">2. è§†é¢‘æ¸²æŸ“</a></h3>
<pre><code class="language-cpp">// video_renderer.h
#ifndef VIDEO_RENDERER_H
#define VIDEO_RENDERER_H

#include &lt;webrtc/api/media_stream_interface.h&gt;
#include &lt;webrtc/api/video/video_sink_interface.h&gt;
#include &lt;webrtc/api/video/video_frame.h&gt;

class VideoRenderer : public rtc::VideoSinkInterface&lt;webrtc::VideoFrame&gt; {
public:
    VideoRenderer();
    ~VideoRenderer();

    void SetVideoTrack(rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; track);

    // VideoSinkInterface
    void OnFrame(const webrtc::VideoFrame&amp; frame) override;

private:
    void RenderFrame(const webrtc::VideoFrame&amp; frame);
    void SaveFrameToFile(const webrtc::VideoFrame&amp; frame);

    rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; video_track_;
    int frame_count_;
};

#endif // VIDEO_RENDERER_H
</code></pre>
<p><strong>å®ç°ï¼š</strong></p>
<pre><code class="language-cpp">// video_renderer.cpp
#include "video_renderer.h"
#include &lt;webrtc/common_video/libyuv/include/webrtc_libyuv.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

VideoRenderer::VideoRenderer() : frame_count_(0) {
}

VideoRenderer::~VideoRenderer() {
    if (video_track_) {
        video_track_-&gt;RemoveSink(this);
    }
}

void VideoRenderer::SetVideoTrack(rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; track) {
    if (video_track_) {
        video_track_-&gt;RemoveSink(this);
    }

    video_track_ = track;

    if (video_track_) {
        video_track_-&gt;AddOrUpdateSink(this, rtc::VideoSinkWants());
        std::cout &lt;&lt; "Video track attached to renderer" &lt;&lt; std::endl;
    }
}

void VideoRenderer::OnFrame(const webrtc::VideoFrame&amp; frame) {
    RenderFrame(frame);

    // æ¯ç§’ä¿å­˜ä¸€å¸§ï¼ˆå‡è®¾30fpsï¼‰
    if (frame_count_ % 30 == 0) {
        SaveFrameToFile(frame);
    }

    frame_count_++;
}

void VideoRenderer::RenderFrame(const webrtc::VideoFrame&amp; frame) {
    // è¿™é‡Œåº”è¯¥å®ç°å®é™…çš„æ¸²æŸ“é€»è¾‘
    // å¯ä»¥ä½¿ç”¨SDLã€OpenGLã€æˆ–å¹³å°ç‰¹å®šçš„API

    int width = frame.width();
    int height = frame.height();

    // ç®€åŒ–ç¤ºä¾‹ï¼šåªæ‰“å°å¸§ä¿¡æ¯
    if (frame_count_ % 30 == 0) {
        std::cout &lt;&lt; "Rendering frame " &lt;&lt; frame_count_
                 &lt;&lt; " (" &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; ")" &lt;&lt; std::endl;
    }
}

void VideoRenderer::SaveFrameToFile(const webrtc::VideoFrame&amp; frame) {
    // ä¿å­˜ä¸ºYUVæ–‡ä»¶ï¼ˆå¯ç”¨ffplayæ’­æ”¾ï¼‰
    auto buffer = frame.video_frame_buffer()-&gt;ToI420();

    std::ofstream file("output.yuv", std::ios::binary | std::ios::app);
    if (!file.is_open()) {
        return;
    }

    int width = buffer-&gt;width();
    int height = buffer-&gt;height();

    // å†™å…¥Yå¹³é¢
    for (int i = 0; i &lt; height; ++i) {
        file.write(reinterpret_cast&lt;const char*&gt;(buffer-&gt;DataY() + i * buffer-&gt;StrideY()), width);
    }

    // å†™å…¥Uå¹³é¢
    for (int i = 0; i &lt; height / 2; ++i) {
        file.write(reinterpret_cast&lt;const char*&gt;(buffer-&gt;DataU() + i * buffer-&gt;StrideU()), width / 2);
    }

    // å†™å…¥Vå¹³é¢
    for (int i = 0; i &lt; height / 2; ++i) {
        file.write(reinterpret_cast&lt;const char*&gt;(buffer-&gt;DataV() + i * buffer-&gt;StrideV()), width / 2);
    }

    file.close();
}
</code></pre>
<hr />
<h2 id="-cmakeæ„å»ºé…ç½®"><a class="header" href="#-cmakeæ„å»ºé…ç½®">ğŸ“‹ CMakeæ„å»ºé…ç½®</a></h2>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.12)
project(WebRTCApp VERSION 1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# WebRTCè·¯å¾„
set(WEBRTC_ROOT "/usr/local" CACHE PATH "WebRTC root directory")
set(WEBRTC_INCLUDE_DIR "${WEBRTC_ROOT}/include")
set(WEBRTC_LIBRARY "${WEBRTC_ROOT}/lib/libwebrtc.a")

# æŸ¥æ‰¾WebRTC
if(NOT EXISTS "${WEBRTC_LIBRARY}")
    message(FATAL_ERROR "WebRTC library not found at ${WEBRTC_LIBRARY}")
endif()

# åŒ…å«ç›®å½•
include_directories(
    ${WEBRTC_INCLUDE_DIR}
    ${WEBRTC_INCLUDE_DIR}/third_party/abseil-cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

# ç¼–è¯‘é€‰é¡¹
add_compile_options(
    -DWEBRTC_POSIX
    -DWEBRTC_LINUX
    -fno-rtti
)

# å¯æ‰§è¡Œæ–‡ä»¶
add_executable(webrtc_app
    src/main.cpp
    src/peer_connection_manager.cpp
    src/data_channel_manager.cpp
    src/video_capturer.cpp
    src/video_renderer.cpp
)

# é“¾æ¥åº“
target_link_libraries(webrtc_app
    ${WEBRTC_LIBRARY}
    pthread
    dl
    rt
    X11
)

# å®‰è£…è§„åˆ™
install(TARGETS webrtc_app
    RUNTIME DESTINATION bin
)
</code></pre>
<hr />
<h2 id="-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ"><a class="header" href="#-å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ">âš ï¸ å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ</a></h2>
<h3 id="1-iceè¿æ¥å¤±è´¥"><a class="header" href="#1-iceè¿æ¥å¤±è´¥">1. ICEè¿æ¥å¤±è´¥</a></h3>
<p><strong>é—®é¢˜ï¼š</strong> æ— æ³•å»ºç«‹P2Pè¿æ¥</p>
<p><strong>æ’æŸ¥æ­¥éª¤ï¼š</strong></p>
<pre><code class="language-cpp">// å¯ç”¨è¯¦ç»†æ—¥å¿—
rtc::LogMessage::LogToDebug(rtc::LS_VERBOSE);
rtc::LogMessage::LogTimestamps();
rtc::LogMessage::LogThreads();

// æ£€æŸ¥ICEçŠ¶æ€
void OnIceConnectionChange(webrtc::PeerConnectionInterface::IceConnectionState new_state) {
    switch (new_state) {
        case webrtc::PeerConnectionInterface::kIceConnectionNew:
            std::cout &lt;&lt; "ICE: New" &lt;&lt; std::endl;
            break;
        case webrtc::PeerConnectionInterface::kIceConnectionChecking:
            std::cout &lt;&lt; "ICE: Checking" &lt;&lt; std::endl;
            break;
        case webrtc::PeerConnectionInterface::kIceConnectionConnected:
            std::cout &lt;&lt; "ICE: Connected" &lt;&lt; std::endl;
            break;
        case webrtc::PeerConnectionInterface::kIceConnectionCompleted:
            std::cout &lt;&lt; "ICE: Completed" &lt;&lt; std::endl;
            break;
        case webrtc::PeerConnectionInterface::kIceConnectionFailed:
            std::cout &lt;&lt; "ICE: Failed" &lt;&lt; std::endl;
            // å°è¯•é‡å¯ICE
            peer_connection_-&gt;RestartIce();
            break;
        case webrtc::PeerConnectionInterface::kIceConnectionDisconnected:
            std::cout &lt;&lt; "ICE: Disconnected" &lt;&lt; std::endl;
            break;
        case webrtc::PeerConnectionInterface::kIceConnectionClosed:
            std::cout &lt;&lt; "ICE: Closed" &lt;&lt; std::endl;
            break;
    }
}
</code></pre>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<ul>
<li>ç¡®ä¿STUN/TURNæœåŠ¡å™¨é…ç½®æ­£ç¡®</li>
<li>æ£€æŸ¥é˜²ç«å¢™å’ŒNATè®¾ç½®</li>
<li>ä½¿ç”¨TURNæœåŠ¡å™¨ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ</li>
</ul>
<hr />
<h3 id="2-éŸ³é¢‘å›å£°é—®é¢˜"><a class="header" href="#2-éŸ³é¢‘å›å£°é—®é¢˜">2. éŸ³é¢‘å›å£°é—®é¢˜</a></h3>
<p><strong>é—®é¢˜ï¼š</strong> å¬åˆ°è‡ªå·±çš„å£°éŸ³å›å£°</p>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<pre><code class="language-cpp">// å¯ç”¨å›å£°æ¶ˆé™¤
cricket::AudioOptions options;
options.echo_cancellation = true;
options.noise_suppression = true;
options.auto_gain_control = true;
options.highpass_filter = true;
options.typing_detection = true;

// è°ƒæ•´å›å£°æ¶ˆé™¤å‚æ•°
options.echo_cancellation_mode = webrtc::EchoCancellationMode::kAecm;
options.experimental_agc = true;
options.experimental_ns = true;

rtc::scoped_refptr&lt;webrtc::AudioSourceInterface&gt; audio_source =
    peer_connection_factory_-&gt;CreateAudioSource(options);
</code></pre>
<hr />
<h3 id="3-è§†é¢‘å¡é¡¿æˆ–èŠ±å±"><a class="header" href="#3-è§†é¢‘å¡é¡¿æˆ–èŠ±å±">3. è§†é¢‘å¡é¡¿æˆ–èŠ±å±</a></h3>
<p><strong>é—®é¢˜ï¼š</strong> è§†é¢‘æ’­æ”¾ä¸æµç•…</p>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<pre><code class="language-cpp">// 1. è°ƒæ•´ç¼–ç å‚æ•°
webrtc::RtpParameters parameters = sender-&gt;GetParameters();
for (auto&amp; encoding : parameters.encodings) {
    encoding.max_bitrate_bps = 2500000;  // 2.5 Mbps
    encoding.min_bitrate_bps = 500000;   // 500 Kbps
    encoding.max_framerate = 30;
}
sender-&gt;SetParameters(parameters);

// 2. å¯ç”¨FECï¼ˆå‰å‘çº é”™ï¼‰
parameters.encodings[0].fec = webrtc::FecMechanism::kRed;

// 3. è°ƒæ•´ç¼“å†²åŒºå¤§å°
config.media_config.video.enable_prerenderer_smoothing = true;
</code></pre>
<hr />
<h3 id="4-å†…å­˜æ³„æ¼"><a class="header" href="#4-å†…å­˜æ³„æ¼">4. å†…å­˜æ³„æ¼</a></h3>
<p><strong>é—®é¢˜ï¼š</strong> é•¿æ—¶é—´è¿è¡Œåå†…å­˜æŒç»­å¢é•¿</p>
<p><strong>è§£å†³æ–¹æ¡ˆï¼š</strong></p>
<pre><code class="language-cpp">// æ­£ç¡®é‡Šæ”¾èµ„æº
class ResourceManager {
public:
    ~ResourceManager() {
        // 1. ç§»é™¤è½¨é“
        if (peer_connection_ &amp;&amp; audio_sender_) {
            peer_connection_-&gt;RemoveTrack(audio_sender_);
        }
        if (peer_connection_ &amp;&amp; video_sender_) {
            peer_connection_-&gt;RemoveTrack(video_sender_);
        }

        // 2. å…³é—­PeerConnection
        if (peer_connection_) {
            peer_connection_-&gt;Close();
            peer_connection_ = nullptr;
        }

        // 3. é‡Šæ”¾å·¥å‚
        peer_connection_factory_ = nullptr;

        // 4. åœæ­¢çº¿ç¨‹
        if (network_thread_) {
            network_thread_-&gt;Stop();
        }
        if (worker_thread_) {
            worker_thread_-&gt;Stop();
        }
        if (signaling_thread_) {
            signaling_thread_-&gt;Stop();
        }
    }
};
</code></pre>
<hr />
<h2 id="-æ€§èƒ½ä¼˜åŒ–"><a class="header" href="#-æ€§èƒ½ä¼˜åŒ–">ğŸš€ æ€§èƒ½ä¼˜åŒ–</a></h2>
<h3 id="1-ç¼–ç å™¨ä¼˜åŒ–"><a class="header" href="#1-ç¼–ç å™¨ä¼˜åŒ–">1. ç¼–ç å™¨ä¼˜åŒ–</a></h3>
<pre><code class="language-cpp">// VP8ç¼–ç å™¨é…ç½®
void ConfigureVP8Encoder(webrtc::VideoCodec&amp; codec) {
    codec.codecType = webrtc::kVideoCodecVP8;
    codec.width = 1280;
    codec.height = 720;
    codec.startBitrate = 1000;  // kbps
    codec.maxBitrate = 2000;
    codec.minBitrate = 300;
    codec.maxFramerate = 30;

    // VP8ç‰¹å®šå‚æ•°
    codec.VP8()-&gt;complexity = webrtc::VideoCodecComplexity::kComplexityNormal;
    codec.VP8()-&gt;numberOfTemporalLayers = 3;
    codec.VP8()-&gt;denoisingOn = true;
    codec.VP8()-&gt;automaticResizeOn = true;
    codec.VP8()-&gt;frameDroppingOn = true;
}

// H.264ç¼–ç å™¨é…ç½®
void ConfigureH264Encoder(webrtc::VideoCodec&amp; codec) {
    codec.codecType = webrtc::kVideoCodecH264;
    codec.width = 1920;
    codec.height = 1080;
    codec.startBitrate = 2000;
    codec.maxBitrate = 5000;
    codec.minBitrate = 500;
    codec.maxFramerate = 30;

    // H.264ç‰¹å®šå‚æ•°
    codec.H264()-&gt;profile = webrtc::H264::kProfileConstrainedBaseline;
    codec.H264()-&gt;frameDroppingOn = true;
    codec.H264()-&gt;keyFrameInterval = 3000;
}
</code></pre>
<hr />
<h3 id="2-å¸¦å®½è‡ªé€‚åº”"><a class="header" href="#2-å¸¦å®½è‡ªé€‚åº”">2. å¸¦å®½è‡ªé€‚åº”</a></h3>
<pre><code class="language-cpp">class BitrateObserver : public webrtc::BitrateStatisticsObserver {
public:
    void OnStatsUpdated(const webrtc::BitrateStatistics&amp; statistics) override {
        uint32_t bitrate_bps = statistics.bitrate_bps;
        uint32_t packet_rate = statistics.packet_rate;

        std::cout &lt;&lt; "Current bitrate: " &lt;&lt; (bitrate_bps / 1000) &lt;&lt; " kbps" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Packet rate: " &lt;&lt; packet_rate &lt;&lt; " pps" &lt;&lt; std::endl;

        // æ ¹æ®å¸¦å®½è°ƒæ•´è´¨é‡
        if (bitrate_bps &lt; 500000) {
            // é™ä½åˆ†è¾¨ç‡åˆ°360p
            AdjustResolution(640, 360);
        } else if (bitrate_bps &lt; 1000000) {
            // ä½¿ç”¨480p
            AdjustResolution(854, 480);
        } else if (bitrate_bps &gt;= 2000000) {
            // ä½¿ç”¨720p
            AdjustResolution(1280, 720);
        }
    }

private:
    void AdjustResolution(int width, int height) {
        // è°ƒæ•´è§†é¢‘æºåˆ†è¾¨ç‡
        if (video_source_) {
            video_source_-&gt;SetResolution(width, height);
        }
    }

    rtc::scoped_refptr&lt;webrtc::VideoTrackSourceInterface&gt; video_source_;
};
</code></pre>
<hr />
<h3 id="3-ç½‘ç»œç»Ÿè®¡ç›‘æ§"><a class="header" href="#3-ç½‘ç»œç»Ÿè®¡ç›‘æ§">3. ç½‘ç»œç»Ÿè®¡ç›‘æ§</a></h3>
<pre><code class="language-cpp">void GetConnectionStats(rtc::scoped_refptr&lt;webrtc::PeerConnectionInterface&gt; pc) {
    pc-&gt;GetStats([](const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp; report) {
        for (const auto&amp; stats : *report) {
            if (stats.type() == webrtc::RTCInboundRtpStreamStats::kType) {
                auto inbound = stats.cast_to&lt;webrtc::RTCInboundRtpStreamStats&gt;();

                std::cout &lt;&lt; "=== Inbound Stats ===" &lt;&lt; std::endl;
                std::cout &lt;&lt; "Packets received: " &lt;&lt; *inbound.packets_received &lt;&lt; std::endl;
                std::cout &lt;&lt; "Packets lost: " &lt;&lt; *inbound.packets_lost &lt;&lt; std::endl;
                std::cout &lt;&lt; "Bytes received: " &lt;&lt; *inbound.bytes_received &lt;&lt; std::endl;
                std::cout &lt;&lt; "Jitter: " &lt;&lt; *inbound.jitter &lt;&lt; std::endl;

                if (inbound.frame_width &amp;&amp; inbound.frame_height) {
                    std::cout &lt;&lt; "Resolution: " &lt;&lt; *inbound.frame_width
                             &lt;&lt; "x" &lt;&lt; *inbound.frame_height &lt;&lt; std::endl;
                }

                if (inbound.frames_per_second) {
                    std::cout &lt;&lt; "FPS: " &lt;&lt; *inbound.frames_per_second &lt;&lt; std::endl;
                }
            }

            if (stats.type() == webrtc::RTCOutboundRtpStreamStats::kType) {
                auto outbound = stats.cast_to&lt;webrtc::RTCOutboundRtpStreamStats&gt;();

                std::cout &lt;&lt; "=== Outbound Stats ===" &lt;&lt; std::endl;
                std::cout &lt;&lt; "Packets sent: " &lt;&lt; *outbound.packets_sent &lt;&lt; std::endl;
                std::cout &lt;&lt; "Bytes sent: " &lt;&lt; *outbound.bytes_sent &lt;&lt; std::endl;

                if (outbound.target_bitrate) {
                    std::cout &lt;&lt; "Target bitrate: " &lt;&lt; (*outbound.target_bitrate / 1000) &lt;&lt; " kbps" &lt;&lt; std::endl;
                }
            }
        }
    });
}
</code></pre>
<hr />
<h2 id="-å­¦ä¹ éªŒè¯æ ‡å‡†"><a class="header" href="#-å­¦ä¹ éªŒè¯æ ‡å‡†">âœ… å­¦ä¹ éªŒè¯æ ‡å‡†</a></h2>
<h3 id="åˆçº§éªŒè¯é€šè¿‡35å³å¯"><a class="header" href="#åˆçº§éªŒè¯é€šè¿‡35å³å¯">åˆçº§éªŒè¯ï¼ˆé€šè¿‡3/5å³å¯ï¼‰</a></h3>
<ol>
<li>âœ… èƒ½å¤Ÿç¼–è¯‘å’Œè¿è¡ŒWebRTCç¤ºä¾‹ç¨‹åº</li>
<li>âœ… ç†è§£ä¿¡ä»¤æµç¨‹å’ŒSDPäº¤æ¢</li>
<li>âœ… å®ç°ç®€å•çš„P2PéŸ³é¢‘é€šè¯</li>
<li>âœ… ç†è§£ICEã€STUNã€TURNçš„ä½œç”¨å’ŒåŒºåˆ«</li>
<li>âœ… ä½¿ç”¨DataChannelä¼ è¾“æ–‡æœ¬æ¶ˆæ¯</li>
</ol>
<h3 id="ä¸­çº§éªŒè¯é€šè¿‡46å³å¯"><a class="header" href="#ä¸­çº§éªŒè¯é€šè¿‡46å³å¯">ä¸­çº§éªŒè¯ï¼ˆé€šè¿‡4/6å³å¯ï¼‰</a></h3>
<ol>
<li>âœ… å®ç°å®Œæ•´çš„P2Pè§†é¢‘é€šè¯åº”ç”¨</li>
<li>âœ… å®ç°è§†é¢‘é‡‡é›†å’Œæ¸²æŸ“</li>
<li>âœ… é…ç½®å’Œè°ƒä¼˜éŸ³è§†é¢‘ç¼–è§£ç å™¨</li>
<li>âœ… å¤„ç†ç½‘ç»œå˜åŒ–å’Œé‡è¿</li>
<li>âœ… å®ç°ä¿¡ä»¤æœåŠ¡å™¨ï¼ˆWebSocketï¼‰</li>
<li>âœ… ç›‘æ§å’Œåˆ†æè¿æ¥ç»Ÿè®¡ä¿¡æ¯</li>
</ol>
<h3 id="é«˜çº§éªŒè¯é€šè¿‡35å³å¯"><a class="header" href="#é«˜çº§éªŒè¯é€šè¿‡35å³å¯">é«˜çº§éªŒè¯ï¼ˆé€šè¿‡3/5å³å¯ï¼‰</a></h3>
<ol>
<li>âœ… å®ç°å¤šæ–¹è§†é¢‘ä¼šè®®ï¼ˆ3äººä»¥ä¸Šï¼‰</li>
<li>âœ… é›†æˆåª’ä½“æœåŠ¡å™¨ï¼ˆå¦‚Janusã€Mediasoupï¼‰</li>
<li>âœ… å®ç°å±å¹•å…±äº«å’Œå½•åˆ¶åŠŸèƒ½</li>
<li>âœ… ä¼˜åŒ–ç§»åŠ¨ç«¯æ€§èƒ½å’Œç”µæ± æ¶ˆè€—</li>
<li>âœ… ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œç›‘æ§ç³»ç»Ÿ</li>
</ol>
<hr />
<h2 id="-æ‰©å±•å­¦ä¹ èµ„æº"><a class="header" href="#-æ‰©å±•å­¦ä¹ èµ„æº">ğŸ“š æ‰©å±•å­¦ä¹ èµ„æº</a></h2>
<h3 id="å®˜æ–¹èµ„æº"><a class="header" href="#å®˜æ–¹èµ„æº">å®˜æ–¹èµ„æº</a></h3>
<ul>
<li><strong>WebRTCå®˜ç½‘</strong>: https://webrtc.org/</li>
<li><strong>WebRTC GitHub</strong>: https://github.com/webrtc</li>
<li><strong>WebRTC APIæ–‡æ¡£</strong>: https://w3c.github.io/webrtc-pc/</li>
<li><strong>Google Codelabs</strong>: https://codelabs.developers.google.com/</li>
</ul>
<h3 id="æ¨èä¹¦ç±"><a class="header" href="#æ¨èä¹¦ç±">æ¨èä¹¦ç±</a></h3>
<ul>
<li>ã€ŠReal-Time Communication with WebRTCã€‹by Salvatore Loreto</li>
<li>ã€ŠWebRTC Cookbookã€‹by Andrii Sergiienko</li>
<li>ã€ŠLearning WebRTCã€‹by Dan Ristic</li>
</ul>
<h3 id="å¼€æºé¡¹ç›®"><a class="header" href="#å¼€æºé¡¹ç›®">å¼€æºé¡¹ç›®</a></h3>
<ul>
<li><strong>Janus Gateway</strong>: é«˜æ€§èƒ½WebRTCæœåŠ¡å™¨</li>
<li><strong>Mediasoup</strong>: SFUåª’ä½“æœåŠ¡å™¨</li>
<li><strong>Jitsi</strong>: å¼€æºè§†é¢‘ä¼šè®®è§£å†³æ–¹æ¡ˆ</li>
<li><strong>OWTï¼ˆOpen WebRTC Toolkitï¼‰</strong>: Intelå¼€æºWebRTCå·¥å…·åŒ…</li>
</ul>
<h3 id="ç›¸å…³æŠ€æœ¯"><a class="header" href="#ç›¸å…³æŠ€æœ¯">ç›¸å…³æŠ€æœ¯</a></h3>
<ul>
<li><strong>SIP</strong>: ä¼ ç»ŸVoIPä¿¡ä»¤åè®®</li>
<li><strong>RTMP/HLS/DASH</strong>: æµåª’ä½“åè®®</li>
<li><strong>FFmpeg</strong>: éŸ³è§†é¢‘å¤„ç†å·¥å…·</li>
<li><strong>GStreamer</strong>: å¤šåª’ä½“æ¡†æ¶</li>
</ul>
<hr />
<h2 id="-ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„"><a class="header" href="#-ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„">ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ è·¯å¾„</a></h2>
<h3 id="çŸ­æœŸç›®æ ‡1-2å‘¨"><a class="header" href="#çŸ­æœŸç›®æ ‡1-2å‘¨">çŸ­æœŸç›®æ ‡ï¼ˆ1-2å‘¨ï¼‰</a></h3>
<ul>
<li>å®ŒæˆP2PéŸ³è§†é¢‘é€šè¯ç¤ºä¾‹</li>
<li>ç†è§£ä¿¡ä»¤å’ŒICEæµç¨‹</li>
<li>å®ç°æ•°æ®é€šé“ä¼ è¾“</li>
</ul>
<h3 id="ä¸­æœŸç›®æ ‡1-2æœˆ"><a class="header" href="#ä¸­æœŸç›®æ ‡1-2æœˆ">ä¸­æœŸç›®æ ‡ï¼ˆ1-2æœˆï¼‰</a></h3>
<ul>
<li>å¼€å‘å®Œæ•´çš„è§†é¢‘ä¼šè®®åº”ç”¨</li>
<li>å®ç°å±å¹•å…±äº«å’Œå½•åˆ¶</li>
<li>é›†æˆåª’ä½“æœåŠ¡å™¨</li>
</ul>
<h3 id="é•¿æœŸç›®æ ‡3-6æœˆ"><a class="header" href="#é•¿æœŸç›®æ ‡3-6æœˆ">é•¿æœŸç›®æ ‡ï¼ˆ3-6æœˆï¼‰</a></h3>
<ul>
<li>ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œä¼˜åŒ–</li>
<li>ç§»åŠ¨ç«¯é€‚é…ï¼ˆAndroid/iOSï¼‰</li>
<li>è´¡çŒ®å¼€æºWebRTCé¡¹ç›®</li>
</ul>
<hr />
<h2 id="-æŠ€æœ¯è¦ç‚¹æ€»ç»“"><a class="header" href="#-æŠ€æœ¯è¦ç‚¹æ€»ç»“">ğŸ“Œ æŠ€æœ¯è¦ç‚¹æ€»ç»“</a></h2>
<h3 id="æ ¸å¿ƒä¼˜åŠ¿"><a class="header" href="#æ ¸å¿ƒä¼˜åŠ¿">æ ¸å¿ƒä¼˜åŠ¿</a></h3>
<ol>
<li><strong>ä½å»¶è¿Ÿ</strong> - ç«¯åˆ°ç«¯å»¶è¿Ÿ&lt;500msï¼Œé€‚åˆå®æ—¶é€šä¿¡</li>
<li><strong>P2Pæ¶æ„</strong> - å‡å°‘æœåŠ¡å™¨è´Ÿè½½å’Œæˆæœ¬</li>
<li><strong>é«˜è´¨é‡</strong> - è‡ªé€‚åº”ç ç‡å’ŒéŸ³è§†é¢‘ä¼˜åŒ–</li>
<li><strong>å®‰å…¨æ€§</strong> - DTLS/SRTPåŠ å¯†ä¼ è¾“</li>
<li><strong>è·¨å¹³å°</strong> - Webã€ç§»åŠ¨ç«¯ã€æ¡Œé¢ç»Ÿä¸€API</li>
<li><strong>å¼€æºå…è´¹</strong> - Googleä¸»å¯¼çš„å¼€æºé¡¹ç›®</li>
</ol>
<h3 id="ä½¿ç”¨åœºæ™¯å¯¹æ¯”"><a class="header" href="#ä½¿ç”¨åœºæ™¯å¯¹æ¯”">ä½¿ç”¨åœºæ™¯å¯¹æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>åœºæ™¯</th><th>WebRTC</th><th>RTMP/HLS</th><th>WebSocket</th></tr></thead><tbody>
<tr><td>è§†é¢‘ä¼šè®®</td><td>âœ… æœ€ä½³</td><td>âŒ å»¶è¿Ÿé«˜</td><td>âŒ æ— åª’ä½“</td></tr>
<tr><td>ç›´æ’­</td><td>âš ï¸ é€‚åˆå°è§„æ¨¡</td><td>âœ… å¤§è§„æ¨¡</td><td>âŒ æ— åª’ä½“</td></tr>
<tr><td>ç‚¹æ’­</td><td>âŒ ä¸é€‚åˆ</td><td>âœ… é€‚åˆ</td><td>âŒ æ— åª’ä½“</td></tr>
<tr><td>æ•°æ®ä¼ è¾“</td><td>âœ… é€‚åˆ</td><td>âŒ ä¸æ”¯æŒ</td><td>âœ… é€‚åˆ</td></tr>
<tr><td>å»¶è¿Ÿ</td><td>&lt;500ms</td><td>3-30s</td><td>&lt;100ms</td></tr>
</tbody></table>
</div>
<h3 id="ä¸å…¶ä»–æŠ€æœ¯å¯¹æ¯”"><a class="header" href="#ä¸å…¶ä»–æŠ€æœ¯å¯¹æ¯”">ä¸å…¶ä»–æŠ€æœ¯å¯¹æ¯”</a></h3>
<div class="table-wrapper"><table><thead><tr><th>ç‰¹æ€§</th><th>WebRTC</th><th>SIP/RTP</th><th>RTMP</th></tr></thead><tbody>
<tr><td>å»¶è¿Ÿ</td><td>æä½</td><td>ä½</td><td>ä¸­</td></tr>
<tr><td>æ˜“ç”¨æ€§</td><td>é«˜</td><td>ä½</td><td>ä¸­</td></tr>
<tr><td>NATç©¿é€</td><td>å†…ç½®</td><td>éœ€è¦</td><td>éœ€è¦</td></tr>
<tr><td>æµè§ˆå™¨æ”¯æŒ</td><td>âœ…</td><td>âŒ</td><td>âŒ</td></tr>
<tr><td>æœåŠ¡å™¨æˆæœ¬</td><td>ä½</td><td>ä¸­</td><td>é«˜</td></tr>
</tbody></table>
</div>
<hr />
<p><strong>å­¦ä¹ å»ºè®®ï¼š</strong>
WebRTCæ˜¯ç°ä»£å®æ—¶é€šä¿¡çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œå»ºè®®ä»ç®€å•çš„éŸ³é¢‘é€šè¯å¼€å§‹ï¼Œé€æ­¥æŒæ¡è§†é¢‘ä¼ è¾“ã€æ•°æ®é€šé“ç­‰é«˜çº§ç‰¹æ€§ã€‚é‡ç‚¹ç†è§£ä¿¡ä»¤æµç¨‹ã€ICEåå•†å’Œåª’ä½“å¤„ç†æµç¨‹ï¼Œè¿™æ˜¯å®ç°å¤æ‚åº”ç”¨çš„åŸºç¡€ã€‚</p>
<p><strong>è®°ä½ï¼š</strong> WebRTCåªæ˜¯ä¼ è¾“å±‚ï¼Œå®é™…åº”ç”¨è¿˜éœ€è¦è®¾è®¡ä¿¡ä»¤åè®®ã€ç”¨æˆ·ç®¡ç†ã€ä¼šè®®æ§åˆ¶ç­‰ä¸šåŠ¡é€»è¾‘ã€‚</p>
<hr />
<p><em>æœ¬ç¬”è®°ç”±æŠ€æœ¯å­¦ä¹ ç¬”è®°ç”Ÿæˆä¸“å®¶åˆ›å»ºï¼ŒæŒç»­æ›´æ–°ä¸­...</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ç¼–ç¨‹/c++/protobuf.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ç¼–ç¨‹/c++/xmake.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ç¼–ç¨‹/c++/protobuf.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ç¼–ç¨‹/c++/xmake.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

