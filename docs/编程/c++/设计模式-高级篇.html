<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++设计模式完整学习指南 - 高级篇 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="c设计模式完整学习指南---高级篇"><a class="header" href="#c设计模式完整学习指南---高级篇">C++设计模式完整学习指南 - 高级篇</a></h1>
<blockquote>
<p>本文档是《C++设计模式完整学习指南》的高级篇，深入讲解更多设计模式和高级应用技巧。</p>
<p><strong>导航</strong>: <a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">← 返回主文档</a> | <a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B.html">实战案例 →</a> | <a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">性能优化 →</a></p>
</blockquote>
<hr />
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ol>
<li><a href="#%E5%BA%8F%E5%88%97%E6%A8%A1%E5%BC%8F">序列模式</a>
<ul>
<li>双缓冲模式</li>
<li>游戏循环模式</li>
<li>更新方法模式</li>
</ul>
</li>
<li><a href="#%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F">行为模式</a>
<ul>
<li>字节码模式</li>
<li>子类沙箱模式</li>
<li>类型对象模式</li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E8%80%A6%E6%A8%A1%E5%BC%8F">解耦模式</a>
<ul>
<li>组件模式</li>
<li>事件队列模式</li>
<li>服务定位器模式</li>
</ul>
</li>
<li><a href="#%E4%BC%98%E5%8C%96%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80">优化模式基础</a>
<ul>
<li>数据局部性</li>
<li>脏标记模式</li>
<li>空间分区</li>
</ul>
</li>
</ol>
<hr />
<h2 id="第一章序列模式-sequencing-patterns"><a class="header" href="#第一章序列模式-sequencing-patterns">第一章：序列模式 (Sequencing Patterns)</a></h2>
<h3 id="11-双缓冲模式-double-buffer"><a class="header" href="#11-双缓冲模式-double-buffer">1.1 双缓冲模式 (Double Buffer)</a></h3>
<h4 id="核心思想"><a class="header" href="#核心思想">核心思想</a></h4>
<p>使用两个缓冲区，一个用于读取，一个用于写入，在操作完成后交换它们。这样可以避免状态更新过程中的不一致问题。</p>
<h4 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h4>
<ol>
<li><strong>图形渲染</strong> - 避免画面撕裂</li>
<li><strong>物理模拟</strong> - 确保所有对象使用同一时刻的状态</li>
<li><strong>AI系统</strong> - 避免更新顺序影响决策</li>
<li><strong>音频缓冲</strong> - 平滑音频播放</li>
</ol>
<h4 id="问题示例"><a class="header" href="#问题示例">问题示例</a></h4>
<pre><code class="language-cpp">// 问题：对象在更新时互相影响
class Actor {
public:
    void update() {
        // 使用其他Actor的当前状态
        // 但其他Actor可能还没更新或已经更新了
        Vector force = calculateForces();
        position_ += force * deltaTime;
    }

private:
    Vector position_;
};

// 更新循环
for (auto&amp; actor : actors) {
    actor.update();  // 顺序会影响结果！
}
</code></pre>
<h4 id="解决方案双缓冲"><a class="header" href="#解决方案双缓冲">解决方案：双缓冲</a></h4>
<pre><code class="language-cpp">class FrameBuffer {
public:
    FrameBuffer(int width, int height)
        : width_(width), height_(height) {
        current_ = new Color[width * height];
        next_ = new Color[width * height];
    }

    ~FrameBuffer() {
        delete[] current_;
        delete[] next_;
    }

    // 读取当前帧
    Color getPixel(int x, int y) const {
        return current_[y * width_ + x];
    }

    // 写入下一帧
    void setPixel(int x, int y, Color color) {
        next_[y * width_ + x] = color;
    }

    // 交换缓冲区
    void swap() {
        Color* temp = current_;
        current_ = next_;
        next_ = temp;
    }

    // 清空下一帧缓冲区
    void clear() {
        memset(next_, 0, width_ * height_ * sizeof(Color));
    }

private:
    Color* current_;  // 当前显示的缓冲区
    Color* next_;     // 正在绘制的缓冲区
    int width_;
    int height_;
};

// 使用
void renderFrame() {
    frameBuffer.clear();

    // 绘制到next缓冲区
    for (auto&amp; sprite : sprites) {
        sprite.draw(frameBuffer);
    }

    // 交换缓冲区，显示新帧
    frameBuffer.swap();
}
</code></pre>
<h4 id="物理引擎中的应用"><a class="header" href="#物理引擎中的应用">物理引擎中的应用</a></h4>
<pre><code class="language-cpp">class GameObject {
public:
    void update(float deltaTime) {
        // 从当前状态读取
        velocity_ = calculateVelocity(currentState_);

        // 写入到下一个状态
        nextState_.position = currentState_.position + velocity_ * deltaTime;
        nextState_.velocity = velocity_;
    }

    void swapBuffers() {
        currentState_ = nextState_;
    }

    const State&amp; getState() const {
        return currentState_;  // 其他对象读取的是稳定的状态
    }

private:
    struct State {
        Vector position;
        Vector velocity;
        float rotation;
    };

    State currentState_;  // 读缓冲区
    State nextState_;     // 写缓冲区
};

// 游戏循环
void gameLoop() {
    while (running) {
        // 第一阶段：所有对象更新到next缓冲区
        for (auto&amp; obj : gameObjects) {
            obj.update(deltaTime);
        }

        // 第二阶段：交换缓冲区
        for (auto&amp; obj : gameObjects) {
            obj.swapBuffers();
        }

        // 现在所有对象都在同一时刻
        render();
    }
}
</code></pre>
<h4 id="性能优化技巧"><a class="header" href="#性能优化技巧">性能优化技巧</a></h4>
<p><strong>技巧1：只在需要时复制</strong></p>
<pre><code class="language-cpp">class SmartBuffer {
public:
    void update() {
        if (!isDirty_) {
            return;  // 没有改变，不需要交换
        }

        swap();
        isDirty_ = false;
    }

    void markDirty() {
        isDirty_ = true;
    }

private:
    bool isDirty_;
};
</code></pre>
<p><strong>技巧2：使用指针交换而非数据复制</strong></p>
<pre><code class="language-cpp">// 好：只交换指针（O(1)）
void swap() {
    std::swap(current_, next_);
}

// 坏：复制整个缓冲区（O(n)）
void swap() {
    memcpy(current_, next_, size_);
}
</code></pre>
<hr />
<h3 id="12-游戏循环模式-game-loop"><a class="header" href="#12-游戏循环模式-game-loop">1.2 游戏循环模式 (Game Loop)</a></h3>
<h4 id="核心思想-1"><a class="header" href="#核心思想-1">核心思想</a></h4>
<p>将游戏时间的推进与用户输入和处理器速度解耦。</p>
<h4 id="经典游戏循环"><a class="header" href="#经典游戏循环">经典游戏循环</a></h4>
<pre><code class="language-cpp">class GameLoop {
public:
    void run() {
        const double MS_PER_UPDATE = 16.0;  // 60 FPS
        double previous = getCurrentTime();
        double lag = 0.0;

        while (running_) {
            double current = getCurrentTime();
            double elapsed = current - previous;
            previous = current;
            lag += elapsed;

            // 处理输入
            processInput();

            // 固定时间步长更新
            while (lag &gt;= MS_PER_UPDATE) {
                update(MS_PER_UPDATE);
                lag -= MS_PER_UPDATE;
            }

            // 渲染（使用插值）
            render(lag / MS_PER_UPDATE);
        }
    }

private:
    void processInput() {
        // 处理输入事件
    }

    void update(double deltaTime) {
        // 更新游戏状态
        physics_.update(deltaTime);
        gameObjects_.update(deltaTime);
        ai_.update(deltaTime);
    }

    void render(double interpolation) {
        // 渲染当前帧
        // interpolation用于平滑显示
    }

    bool running_;
    Physics physics_;
    GameObjects gameObjects_;
    AI ai_;
};
</code></pre>
<h4 id="不同的时间步长策略"><a class="header" href="#不同的时间步长策略">不同的时间步长策略</a></h4>
<p><strong>策略1：固定时间步长</strong></p>
<pre><code class="language-cpp">void fixedTimeStep() {
    const float FIXED_DT = 1.0f / 60.0f;

    while (running) {
        update(FIXED_DT);
        render();
        waitUntilNextFrame();  // 限制帧率
    }
}
</code></pre>
<p>优点：</p>
<ul>
<li>确定性，便于调试</li>
<li>物理模拟稳定</li>
</ul>
<p>缺点：</p>
<ul>
<li>快速机器会空等</li>
<li>慢速机器会卡顿</li>
</ul>
<p><strong>策略2：可变时间步长</strong></p>
<pre><code class="language-cpp">void variableTimeStep() {
    double lastTime = getCurrentTime();

    while (running) {
        double currentTime = getCurrentTime();
        double deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        update(deltaTime);
        render();
    }
}
</code></pre>
<p>优点：</p>
<ul>
<li>适应不同速度的硬件</li>
<li>流畅</li>
</ul>
<p>缺点：</p>
<ul>
<li>不确定性</li>
<li>物理模拟可能不稳定</li>
<li>时间步长过大时会出问题</li>
</ul>
<p><strong>策略3：固定更新，可变渲染（推荐）</strong></p>
<pre><code class="language-cpp">void hybridTimeStep() {
    const double FIXED_DT = 1.0 / 60.0;
    double currentTime = getCurrentTime();
    double accumulator = 0.0;

    while (running) {
        double newTime = getCurrentTime();
        double frameTime = newTime - currentTime;

        // 限制最大帧时间，防止"死亡螺旋"
        if (frameTime &gt; 0.25) {
            frameTime = 0.25;
        }

        currentTime = newTime;
        accumulator += frameTime;

        // 固定时间步长更新
        while (accumulator &gt;= FIXED_DT) {
            update(FIXED_DT);
            accumulator -= FIXED_DT;
        }

        // 渲染（可以使用插值）
        const double alpha = accumulator / FIXED_DT;
        render(alpha);
    }
}
</code></pre>
<h4 id="插值渲染"><a class="header" href="#插值渲染">插值渲染</a></h4>
<pre><code class="language-cpp">class Sprite {
public:
    void update(float dt) {
        previousPosition_ = currentPosition_;
        currentPosition_ += velocity_ * dt;
    }

    Vector getRenderPosition(float alpha) const {
        // 在当前位置和上一帧位置之间插值
        return previousPosition_ * (1.0f - alpha) + currentPosition_ * alpha;
    }

private:
    Vector previousPosition_;
    Vector currentPosition_;
    Vector velocity_;
};

void render(float alpha) {
    for (auto&amp; sprite : sprites) {
        Vector pos = sprite.getRenderPosition(alpha);
        drawSprite(sprite, pos);
    }
}
</code></pre>
<hr />
<h3 id="13-更新方法模式-update-method"><a class="header" href="#13-更新方法模式-update-method">1.3 更新方法模式 (Update Method)</a></h3>
<h4 id="核心思想-2"><a class="header" href="#核心思想-2">核心思想</a></h4>
<p>通过每帧调用一次更新方法来模拟独立对象的行为。</p>
<h4 id="基本实现"><a class="header" href="#基本实现">基本实现</a></h4>
<pre><code class="language-cpp">class GameObject {
public:
    virtual ~GameObject() {}
    virtual void update(float deltaTime) = 0;
};

class Enemy : public GameObject {
public:
    virtual void update(float deltaTime) override {
        // 更新AI
        ai_.update(deltaTime);

        // 更新动画
        animation_.update(deltaTime);

        // 更新物理
        position_ += velocity_ * deltaTime;
    }

private:
    AI ai_;
    Animation animation_;
    Vector position_;
    Vector velocity_;
};

// 游戏世界
class World {
public:
    void update(float deltaTime) {
        for (auto obj : gameObjects_) {
            obj-&gt;update(deltaTime);
        }
    }

private:
    std::vector&lt;GameObject*&gt; gameObjects_;
};
</code></pre>
<h4 id="更新顺序的重要性"><a class="header" href="#更新顺序的重要性">更新顺序的重要性</a></h4>
<pre><code class="language-cpp">// 问题：更新顺序会影响结果
void updateBad() {
    player.update();      // 玩家攻击敌人
    enemy.update();       // 敌人还没意识到被攻击
    physics.update();     // 应用伤害
}

// 解决方案：分阶段更新
void updateGood() {
    // 阶段1：处理输入和AI决策
    for (auto obj : gameObjects) {
        obj-&gt;processInput();
    }

    // 阶段2：更新物理
    physics.update();

    // 阶段3：响应碰撞和交互
    for (auto obj : gameObjects) {
        obj-&gt;handleCollisions();
    }

    // 阶段4：更新动画
    for (auto obj : gameObjects) {
        obj-&gt;updateAnimation();
    }
}
</code></pre>
<h4 id="跳过失活对象"><a class="header" href="#跳过失活对象">跳过失活对象</a></h4>
<pre><code class="language-cpp">class World {
public:
    void update(float deltaTime) {
        for (auto obj : gameObjects_) {
            if (obj-&gt;isActive()) {
                obj-&gt;update(deltaTime);
            }
        }
    }
};

class GameObject {
public:
    bool isActive() const { return active_; }
    void setActive(bool active) { active_ = active; }

    virtual void update(float deltaTime) {
        if (!active_) return;
        // 更新逻辑
    }

private:
    bool active_;
};
</code></pre>
<h4 id="休眠对象优化"><a class="header" href="#休眠对象优化">休眠对象优化</a></h4>
<pre><code class="language-cpp">class GameObject {
public:
    void update(float deltaTime) {
        if (shouldSleep()) {
            sleep();
            return;
        }

        if (sleeping_) {
            wakeUp();
        }

        // 正常更新
        doUpdate(deltaTime);
    }

private:
    bool shouldSleep() const {
        // 根据条件判断是否应该休眠
        return velocity_.lengthSquared() &lt; SLEEP_THRESHOLD &amp;&amp;
               timeSinceLastInteraction_ &gt; SLEEP_DELAY;
    }

    void sleep() {
        sleeping_ = true;
        // 从活动列表移到休眠列表
    }

    void wakeUp() {
        sleeping_ = false;
        // 从休眠列表移回活动列表
    }

    bool sleeping_;
    Vector velocity_;
    float timeSinceLastInteraction_;
};
</code></pre>
<hr />
<h2 id="第二章行为模式-behavioral-patterns"><a class="header" href="#第二章行为模式-behavioral-patterns">第二章：行为模式 (Behavioral Patterns)</a></h2>
<h3 id="21-字节码模式-bytecode"><a class="header" href="#21-字节码模式-bytecode">2.1 字节码模式 (Bytecode)</a></h3>
<h4 id="核心思想-3"><a class="header" href="#核心思想-3">核心思想</a></h4>
<p>将行为编码为虚拟机指令，实现数据驱动的行为定义。</p>
<h4 id="使用场景-1"><a class="header" href="#使用场景-1">使用场景</a></h4>
<ol>
<li><strong>脚本系统</strong> - 让非程序员定义游戏行为</li>
<li><strong>技能系统</strong> - 灵活定义技能效果</li>
<li><strong>关卡脚本</strong> - 定义关卡事件序列</li>
<li><strong>AI行为树</strong> - 用数据定义AI逻辑</li>
</ol>
<h4 id="简单虚拟机实现"><a class="header" href="#简单虚拟机实现">简单虚拟机实现</a></h4>
<pre><code class="language-cpp">enum Instruction {
    INST_SET_HEALTH,
    INST_SET_WISDOM,
    INST_SET_AGILITY,
    INST_PLAY_SOUND,
    INST_SPAWN_PARTICLES,
    INST_LITERAL,
    INST_ADD,
    INST_DIVIDE
};

class VM {
public:
    void interpret(const uint8_t* bytecode) {
        int stackSize = 0;
        int stack[MAX_STACK];

        for (;;) {
            uint8_t instruction = *bytecode++;

            switch (instruction) {
                case INST_LITERAL: {
                    int value = *bytecode++;
                    stack[stackSize++] = value;
                    break;
                }

                case INST_ADD: {
                    int b = stack[--stackSize];
                    int a = stack[--stackSize];
                    stack[stackSize++] = a + b;
                    break;
                }

                case INST_SET_HEALTH: {
                    int value = stack[--stackSize];
                    setHealth(value);
                    break;
                }

                case INST_PLAY_SOUND: {
                    int soundId = stack[--stackSize];
                    playSound(soundId);
                    break;
                }

                // 更多指令...
            }
        }
    }

private:
    void setHealth(int value) { /* ... */ }
    void playSound(int id) { /* ... */ }
};
</code></pre>
<h4 id="技能系统示例"><a class="header" href="#技能系统示例">技能系统示例</a></h4>
<pre><code class="language-cpp">class SkillVM {
public:
    struct Skill {
        std::vector&lt;uint8_t&gt; bytecode;
        std::string name;
        int manaCost;
    };

    void executeSkill(const Skill&amp; skill, GameObject* caster, GameObject* target) {
        context_.caster = caster;
        context_.target = target;
        interpret(skill.bytecode.data());
    }

private:
    struct Context {
        GameObject* caster;
        GameObject* target;
        int damage;
        Vector targetPosition;
    };

    Context context_;

    void interpret(const uint8_t* code) {
        const uint8_t* pc = code;  // Program Counter

        while (*pc != INST_END) {
            switch (*pc++) {
                case INST_CALCULATE_DAMAGE: {
                    int baseDamage = readInt(pc);
                    int multiplier = readInt(pc);
                    context_.damage = baseDamage * multiplier;
                    break;
                }

                case INST_APPLY_DAMAGE: {
                    context_.target-&gt;takeDamage(context_.damage);
                    break;
                }

                case INST_SPAWN_EFFECT: {
                    int effectId = readInt(pc);
                    spawnEffect(effectId, context_.targetPosition);
                    break;
                }

                case INST_HEAL: {
                    int amount = readInt(pc);
                    context_.caster-&gt;heal(amount);
                    break;
                }

                case INST_IF_HEALTH_BELOW: {
                    int threshold = readInt(pc);
                    int jumpOffset = readInt(pc);
                    if (context_.target-&gt;getHealth() &lt; threshold) {
                        pc += jumpOffset;
                    }
                    break;
                }
            }
        }
    }

    int readInt(const uint8_t*&amp; pc) {
        int value = *reinterpret_cast&lt;const int*&gt;(pc);
        pc += sizeof(int);
        return value;
    }
};

// 定义技能
// 火球术：造成100点伤害，消耗50法力，播放火焰特效
Skill fireball = {
    {
        INST_CALCULATE_DAMAGE, 100, 1,
        INST_APPLY_DAMAGE,
        INST_SPAWN_EFFECT, EFFECT_FIRE,
        INST_END
    },
    "Fireball",
    50
};

// 吸血术：造成50伤害，治疗施法者25点生命
Skill lifeDrain = {
    {
        INST_CALCULATE_DAMAGE, 50, 1,
        INST_APPLY_DAMAGE,
        INST_HEAL, 25,
        INST_SPAWN_EFFECT, EFFECT_DARK,
        INST_END
    },
    "Life Drain",
    30
};
</code></pre>
<h4 id="从脚本编译到字节码"><a class="header" href="#从脚本编译到字节码">从脚本编译到字节码</a></h4>
<pre><code class="language-cpp">class SkillCompiler {
public:
    std::vector&lt;uint8_t&gt; compile(const std::string&amp; script) {
        std::vector&lt;uint8_t&gt; bytecode;
        auto tokens = tokenize(script);

        for (const auto&amp; token : tokens) {
            if (token == "damage") {
                bytecode.push_back(INST_CALCULATE_DAMAGE);
                bytecode.push_back(getNextInt());
                bytecode.push_back(1);
            } else if (token == "heal") {
                bytecode.push_back(INST_HEAL);
                bytecode.push_back(getNextInt());
            } else if (token == "effect") {
                bytecode.push_back(INST_SPAWN_EFFECT);
                bytecode.push_back(getEffectId(getNextToken()));
            }
        }

        bytecode.push_back(INST_END);
        return bytecode;
    }

private:
    std::vector&lt;std::string&gt; tokenize(const std::string&amp; script);
    int getNextInt();
    std::string getNextToken();
    int getEffectId(const std::string&amp; name);
};

// 使用
SkillCompiler compiler;
auto bytecode = compiler.compile("damage 100 effect fire");
Skill skill = { bytecode, "Custom Spell", 50 };
</code></pre>
<hr />
<h3 id="22-子类沙箱模式-subclass-sandbox"><a class="header" href="#22-子类沙箱模式-subclass-sandbox">2.2 子类沙箱模式 (Subclass Sandbox)</a></h3>
<h4 id="核心思想-4"><a class="header" href="#核心思想-4">核心思想</a></h4>
<p>定义一个基类，提供一组受保护的操作方法，派生类通过组合这些操作来实现自己的行为。</p>
<h4 id="使用场景-2"><a class="header" href="#使用场景-2">使用场景</a></h4>
<ol>
<li><strong>技能系统</strong> - 每个技能组合基础效果</li>
<li><strong>怪物AI</strong> - 不同怪物组合基础行为</li>
<li><strong>武器系统</strong> - 武器效果组合</li>
<li><strong>粒子效果</strong> - 组合基础粒子行为</li>
</ol>
<h4 id="基本实现-1"><a class="header" href="#基本实现-1">基本实现</a></h4>
<pre><code class="language-cpp">class Superpower {
public:
    virtual ~Superpower() {}

    // 模板方法
    void activate() {
        // 预处理
        if (!canActivate()) {
            return;
        }

        consumeEnergy();

        // 派生类实现具体效果
        performEffect();

        // 后处理
        playActivationSound();
        startCooldown();
    }

protected:
    // 沙箱方法：派生类可用的操作
    void move(double x, double y, double z) {
        // 移动角色
    }

    void playSound(SoundId sound, double volume) {
        // 播放声音
    }

    void spawnParticles(ParticleType type) {
        // 生成粒子
    }

    void createExplosion(const Vector&amp; position, float radius, float damage) {
        // 创建爆炸
    }

    void applyBuff(BuffType buff, float duration) {
        // 应用增益效果
    }

    void shootProjectile(const Vector&amp; direction, float speed) {
        // 发射投射物
    }

    GameObject* findNearestEnemy(float radius) {
        // 查找最近的敌人
    }

    // 派生类必须实现
    virtual void performEffect() = 0;

    // 可选的钩子方法
    virtual bool canActivate() { return energy_ &gt;= energyCost_; }
    virtual void consumeEnergy() { energy_ -= energyCost_; }
    virtual void playActivationSound() { playSound(activationSound_, 1.0f); }
    virtual void startCooldown() { cooldownTimer_ = cooldownDuration_; }

private:
    float energy_;
    float energyCost_;
    float cooldownTimer_;
    float cooldownDuration_;
    SoundId activationSound_;
};

// 具体技能：震地
class GroundSlam : public Superpower {
protected:
    virtual void performEffect() override {
        // 1. 播放动画
        move(0, -5, 0);  // 下蹲

        // 2. 创建震波
        spawnParticles(PARTICLE_SHOCKWAVE);

        // 3. 对范围内敌人造成伤害
        auto enemies = findEnemiesInRadius(10.0f);
        for (auto enemy : enemies) {
            enemy-&gt;takeDamage(50);
            enemy-&gt;knockback(enemyPos - playerPos);
        }

        // 4. 播放音效
        playSound(SOUND_EARTHQUAKE, 1.0f);

        // 5. 屏幕震动
        shake(0.5f, 0.3f);
    }
};

// 具体技能：瞬移
class Teleport : public Superpower {
protected:
    virtual void performEffect() override {
        // 1. 保存当前位置
        Vector oldPos = getPosition();

        // 2. 粒子效果
        spawnParticles(PARTICLE_TELEPORT_OUT);

        // 3. 移动到目标位置
        Vector targetPos = getCursorPosition();
        move(targetPos.x, targetPos.y, targetPos.z);

        // 4. 到达粒子效果
        spawnParticles(PARTICLE_TELEPORT_IN);

        // 5. 短暂无敌
        applyBuff(BUFF_INVULNERABLE, 0.5f);
    }

    virtual bool canActivate() override {
        if (!Superpower::canActivate()) {
            return false;
        }

        // 额外检查：目标位置是否可达
        Vector targetPos = getCursorPosition();
        return isPositionValid(targetPos);
    }
};

// 具体技能：火球
class Fireball : public Superpower {
protected:
    virtual void performEffect() override {
        // 1. 计算方向
        Vector direction = getAimDirection();

        // 2. 发射火球
        shootProjectile(direction, 20.0f);

        // 3. 火焰轨迹
        spawnParticles(PARTICLE_FIRE_TRAIL);

        // 4. 发射音效
        playSound(SOUND_FIRE_WHOOSH, 0.8f);
    }

    // 火球有连发机制
    virtual void startCooldown() override {
        if (consecutiveShots_ &lt; 3) {
            cooldownTimer_ = 0.2f;  // 短冷却
            consecutiveShots_++;
        } else {
            cooldownTimer_ = 3.0f;  // 长冷却
            consecutiveShots_ = 0;
        }
    }

private:
    int consecutiveShots_;
};
</code></pre>
<h4 id="优点"><a class="header" href="#优点">优点</a></h4>
<ol>
<li><strong>易于添加新行为</strong> - 只需继承并组合已有操作</li>
<li><strong>代码复用</strong> - 所有技能共享基础操作</li>
<li><strong>一致性</strong> - 所有技能遵循相同的激活流程</li>
<li><strong>安全</strong> - 派生类只能使用受保护的操作</li>
</ol>
<h4 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h4>
<p><strong>避免过度膨胀基类</strong>：</p>
<pre><code class="language-cpp">// 不好：基类提供太多操作
class Superpower {
protected:
    void method1();
    void method2();
    // ... 100个方法
    void method100();
};

// 好：按类别组织
class Superpower {
protected:
    Audio&amp; getAudio() { return audio_; }
    Physics&amp; getPhysics() { return physics_; }
    Graphics&amp; getGraphics() { return graphics_; }

private:
    Audio audio_;
    Physics physics_;
    Graphics graphics_;
};

class Fireball : public Superpower {
    virtual void performEffect() override {
        getAudio().playSound(SOUND_FIRE);
        getPhysics().shootProjectile(...);
        getGraphics().spawnParticles(...);
    }
};
</code></pre>
<hr />
<h3 id="23-类型对象模式-type-object"><a class="header" href="#23-类型对象模式-type-object">2.3 类型对象模式 (Type Object)</a></h3>
<h4 id="核心思想-5"><a class="header" href="#核心思想-5">核心思想</a></h4>
<p>创建一个类来支持新类型的灵活创建，每个类型的实例都引用同一个类型对象。</p>
<h4 id="使用场景-3"><a class="header" href="#使用场景-3">使用场景</a></h4>
<ol>
<li><strong>怪物类型</strong> - 不同种类的怪物共享属性模板</li>
<li><strong>装备系统</strong> - 装备类型定义基础属性</li>
<li><strong>建筑系统</strong> - 建筑类型定义蓝图</li>
<li><strong>单位系统</strong> - RTS游戏中的单位类型</li>
</ol>
<h4 id="问题类爆炸"><a class="header" href="#问题类爆炸">问题：类爆炸</a></h4>
<pre><code class="language-cpp">// 糟糕的做法：每种怪物都是一个类
class Dragon : public Monster { /* ... */ };
class Troll : public Monster { /* ... */ };
class Goblin : public Monster { /* ... */ };
// ... 100种怪物 = 100个类
</code></pre>
<h4 id="解决方案类型对象"><a class="header" href="#解决方案类型对象">解决方案：类型对象</a></h4>
<pre><code class="language-cpp">// 怪物类型（共享的模板）
class Breed {
public:
    Breed(int health, const std::string&amp; attack, int damage)
        : health_(health), attack_(attack), damage_(damage) {}

    int getHealth() const { return health_; }
    const std::string&amp; getAttack() const { return attack_; }
    int getDamage() const { return damage_; }

private:
    int health_;           // 基础生命值
    std::string attack_;   // 攻击方式描述
    int damage_;           // 基础伤害
};

// 怪物实例（引用类型）
class Monster {
public:
    Monster(Breed* breed)
        : breed_(breed),
          health_(breed-&gt;getHealth()) {}

    void attack(Monster* target) {
        std::cout &lt;&lt; "使用 " &lt;&lt; breed_-&gt;getAttack() &lt;&lt; " 攻击!\n";
        target-&gt;takeDamage(breed_-&gt;getDamage());
    }

    void takeDamage(int damage) {
        health_ -= damage;
    }

    int getHealth() const { return health_; }

private:
    Breed* breed_;    // 指向类型对象
    int health_;      // 当前生命值（实例特定）
};

// 使用
int main() {
    // 定义怪物类型
    Breed dragon(230, "火焰吐息", 50);
    Breed troll(48, "巨拳", 15);
    Breed goblin(20, "匕首", 8);

    // 创建怪物实例
    Monster dragon1(&amp;dragon);
    Monster dragon2(&amp;dragon);  // 共享类型
    Monster troll1(&amp;troll);
    Monster goblin1(&amp;goblin);

    dragon1.attack(&amp;goblin1);
}
</code></pre>
<h4 id="高级继承类型对象"><a class="header" href="#高级继承类型对象">高级：继承类型对象</a></h4>
<pre><code class="language-cpp">class Breed {
public:
    Breed(Breed* parent, int health, const std::string&amp; attack, int damage)
        : parent_(parent),
          health_(health),
          attack_(attack),
          damage_(damage) {}

    int getHealth() const {
        // 如果自己没定义，使用父类型的值
        if (health_ != 0 || parent_ == nullptr) {
            return health_;
        }
        return parent_-&gt;getHealth();
    }

    const std::string&amp; getAttack() const {
        if (!attack_.empty() || parent_ == nullptr) {
            return attack_;
        }
        return parent_-&gt;getAttack();
    }

private:
    Breed* parent_;
    int health_;
    std::string attack_;
    int damage_;
};

// 使用继承
Breed base(nullptr, 100, "撕咬", 10);
Breed dragon(&amp;base, 230, "火焰吐息", 50);  // 继承base，覆盖属性
Breed redDragon(&amp;dragon, 0, "", 80);       // 继承dragon，只改伤害
</code></pre>
<h4 id="数据驱动的类型定义"><a class="header" href="#数据驱动的类型定义">数据驱动的类型定义</a></h4>
<pre><code class="language-cpp">class BreedManager {
public:
    void loadFromJSON(const std::string&amp; filename) {
        auto json = parseJSON(filename);

        for (auto&amp; breedData : json["breeds"]) {
            std::string name = breedData["name"];
            int health = breedData["health"];
            std::string attack = breedData["attack"];
            int damage = breedData["damage"];

            Breed* parent = nullptr;
            if (breedData.contains("parent")) {
                parent = getBreed(breedData["parent"]);
            }

            breeds_[name] = new Breed(parent, health, attack, damage);
        }
    }

    Breed* getBreed(const std::string&amp; name) {
        return breeds_[name];
    }

private:
    std::map&lt;std::string, Breed*&gt; breeds_;
};

// JSON配置文件
// {
//   "breeds": [
//     {
//       "name": "base_monster",
//       "health": 100,
//       "attack": "撕咬",
//       "damage": 10
//     },
//     {
//       "name": "dragon",
//       "parent": "base_monster",
//       "health": 230,
//       "attack": "火焰吐息",
//       "damage": 50
//     },
//     {
//       "name": "red_dragon",
//       "parent": "dragon",
//       "damage": 80
//     }
//   ]
// }
</code></pre>
<hr />
<h2 id="第三章解耦模式-decoupling-patterns"><a class="header" href="#第三章解耦模式-decoupling-patterns">第三章：解耦模式 (Decoupling Patterns)</a></h2>
<h3 id="31-组件模式-component"><a class="header" href="#31-组件模式-component">3.1 组件模式 (Component)</a></h3>
<h4 id="核心思想-6"><a class="header" href="#核心思想-6">核心思想</a></h4>
<p>允许一个实体跨多个领域而不让这些领域彼此耦合。将一个对象分解为多个组件，每个组件负责一个方面。</p>
<h4 id="问题上帝对象"><a class="header" href="#问题上帝对象">问题：上帝对象</a></h4>
<pre><code class="language-cpp">// 糟糕：一个类做所有事情
class GameObject {
public:
    void update() {
        // 更新物理
        velocity_ += acceleration_ * deltaTime;
        position_ += velocity_ * deltaTime;

        // 更新动画
        animation_.update();

        // 更新AI
        if (isEnemy) {
            findTarget();
            moveTowardsTarget();
        }

        // 更新渲染
        mesh_.update();
        updateShader();

        // 更新音频
        updateFootsteps();
        updateAmbientSounds();

        // 更新输入
        if (isPlayer) {
            handleInput();
        }
    }

private:
    // 物理
    Vector position_, velocity_, acceleration_;

    // 动画
    Animation animation_;

    // AI
    bool isEnemy;
    GameObject* target_;

    // 渲染
    Mesh mesh_;
    Shader shader_;

    // 音频
    Sound footsteps_, ambient_;

    // 输入
    bool isPlayer;

    // ... 更多字段
};
</code></pre>
<h4 id="解决方案组件模式"><a class="header" href="#解决方案组件模式">解决方案：组件模式</a></h4>
<pre><code class="language-cpp">// 基础组件接口
class Component {
public:
    virtual ~Component() {}
    virtual void update(float deltaTime) = 0;
    virtual void render() {}
};

// 游戏对象只是组件的容器
class GameObject {
public:
    void addComponent(Component* component) {
        components_.push_back(component);
    }

    template&lt;typename T&gt;
    T* getComponent() {
        for (auto comp : components_) {
            T* result = dynamic_cast&lt;T*&gt;(comp);
            if (result) {
                return result;
            }
        }
        return nullptr;
    }

    void update(float deltaTime) {
        for (auto comp : components_) {
            comp-&gt;update(deltaTime);
        }
    }

    void render() {
        for (auto comp : components_) {
            comp-&gt;render();
        }
    }

private:
    std::vector&lt;Component*&gt; components_;
};

// 具体组件
class PhysicsComponent : public Component {
public:
    virtual void update(float deltaTime) override {
        velocity_ += acceleration_ * deltaTime;
        position_ += velocity_ * deltaTime;
    }

    Vector getPosition() const { return position_; }
    void setPosition(const Vector&amp; pos) { position_ = pos; }

private:
    Vector position_;
    Vector velocity_;
    Vector acceleration_;
};

class GraphicsComponent : public Component {
public:
    GraphicsComponent(const std::string&amp; meshFile)
        : mesh_(loadMesh(meshFile)) {}

    virtual void render() override {
        drawMesh(mesh_, getGameObject()-&gt;getComponent&lt;PhysicsComponent&gt;()-&gt;getPosition());
    }

private:
    Mesh mesh_;
};

class InputComponent : public Component {
public:
    virtual void update(float deltaTime) override {
        if (isKeyPressed(KEY_LEFT)) {
            auto physics = getGameObject()-&gt;getComponent&lt;PhysicsComponent&gt;();
            physics-&gt;applyForce(Vector(-10, 0, 0));
        }
        if (isKeyPressed(KEY_RIGHT)) {
            auto physics = getGameObject()-&gt;getComponent&lt;PhysicsComponent&gt;();
            physics-&gt;applyForce(Vector(10, 0, 0));
        }
    }
};

// 使用：组合不同组件创建不同类型的对象
GameObject* createPlayer() {
    auto player = new GameObject();
    player-&gt;addComponent(new PhysicsComponent());
    player-&gt;addComponent(new GraphicsComponent("player.mesh"));
    player-&gt;addComponent(new InputComponent());
    player-&gt;addComponent(new AnimationComponent());
    return player;
}

GameObject* createEnemy() {
    auto enemy = new GameObject();
    enemy-&gt;addComponent(new PhysicsComponent());
    enemy-&gt;addComponent(new GraphicsComponent("enemy.mesh"));
    enemy-&gt;addComponent(new AIComponent());
    enemy-&gt;addComponent(new AnimationComponent());
    return enemy;
}

GameObject* createStaticProp() {
    auto prop = new GameObject();
    prop-&gt;addComponent(new GraphicsComponent("prop.mesh"));
    // 静态物体只需要渲染，不需要物理和AI
    return prop;
}
</code></pre>
<h4 id="组件间通信"><a class="header" href="#组件间通信">组件间通信</a></h4>
<p><strong>方法1：直接引用其他组件</strong></p>
<pre><code class="language-cpp">class AIComponent : public Component {
public:
    virtual void update(float deltaTime) override {
        auto physics = getGameObject()-&gt;getComponent&lt;PhysicsComponent&gt;();
        auto target = findTarget();

        if (target) {
            Vector direction = target-&gt;getPosition() - physics-&gt;getPosition();
            physics-&gt;setVelocity(direction.normalize() * speed_);
        }
    }

private:
    GameObject* findTarget();
    float speed_;
};
</code></pre>
<p><strong>方法2：消息系统</strong></p>
<pre><code class="language-cpp">struct Message {
    enum Type {
        COLLISION,
        HEALTH_CHANGED,
        DEATH
    };

    Type type;
    void* data;
};

class Component {
public:
    virtual void receiveMessage(const Message&amp; msg) {}
};

class GameObject {
public:
    void sendMessage(const Message&amp; msg) {
        for (auto comp : components_) {
            comp-&gt;receiveMessage(msg);
        }
    }
};

class HealthComponent : public Component {
public:
    void takeDamage(int damage) {
        health_ -= damage;

        // 通知其他组件
        Message msg;
        msg.type = Message::HEALTH_CHANGED;
        msg.data = &amp;health_;
        getGameObject()-&gt;sendMessage(msg);

        if (health_ &lt;= 0) {
            Message deathMsg;
            deathMsg.type = Message::DEATH;
            getGameObject()-&gt;sendMessage(deathMsg);
        }
    }

    virtual void receiveMessage(const Message&amp; msg) override {
        if (msg.type == Message::COLLISION) {
            takeDamage(10);
        }
    }

private:
    int health_;
};

class AnimationComponent : public Component {
public:
    virtual void receiveMessage(const Message&amp; msg) override {
        if (msg.type == Message::DEATH) {
            playAnimation("death");
        } else if (msg.type == Message::HEALTH_CHANGED) {
            playAnimation("hurt");
        }
    }
};
</code></pre>
<hr />
<h3 id="32-事件队列模式-event-queue"><a class="header" href="#32-事件队列模式-event-queue">3.2 事件队列模式 (Event Queue)</a></h3>
<h4 id="核心思想-7"><a class="header" href="#核心思想-7">核心思想</a></h4>
<p>解耦发送消息或事件的时间和处理它的时间。</p>
<h4 id="使用场景-4"><a class="header" href="#使用场景-4">使用场景</a></h4>
<ol>
<li><strong>音频系统</strong> - 避免同时播放太多声音</li>
<li><strong>网络消息</strong> - 批量处理网络事件</li>
<li><strong>GUI事件</strong> - 鼠标点击、键盘输入</li>
<li><strong>游戏事件</strong> - 成就解锁、任务完成</li>
</ol>
<h4 id="基本实现-2"><a class="header" href="#基本实现-2">基本实现</a></h4>
<pre><code class="language-cpp">struct Event {
    enum Type {
        SOUND_PLAY,
        PARTICLE_SPAWN,
        ENTITY_SPAWN,
        ACHIEVEMENT_UNLOCK
    };

    Type type;

    union {
        struct {
            SoundId soundId;
            float volume;
        } sound;

        struct {
            ParticleType particleType;
            Vector position;
        } particle;

        struct {
            int entityType;
            Vector position;
        } entity;

        struct {
            AchievementId id;
        } achievement;
    };
};

class EventQueue {
public:
    EventQueue() : head_(0), tail_(0) {}

    void post(const Event&amp; event) {
        assert((tail_ + 1) % MAX_EVENTS != head_);  // 队列满
        events_[tail_] = event;
        tail_ = (tail_ + 1) % MAX_EVENTS;
    }

    bool poll(Event&amp; event) {
        if (head_ == tail_) {
            return false;  // 队列空
        }

        event = events_[head_];
        head_ = (head_ + 1) % MAX_EVENTS;
        return true;
    }

private:
    static const int MAX_EVENTS = 256;
    Event events_[MAX_EVENTS];
    int head_;
    int tail_;
};

// 使用
EventQueue audioQueue;

// 发送事件
void playSound(SoundId sound, float volume) {
    Event event;
    event.type = Event::SOUND_PLAY;
    event.sound.soundId = sound;
    event.sound.volume = volume;
    audioQueue.post(event);
}

// 处理事件
void AudioEngine::update() {
    const int MAX_SOUNDS_PER_FRAME = 10;
    int soundsPlayed = 0;

    Event event;
    while (audioQueue.poll(event) &amp;&amp; soundsPlayed &lt; MAX_SOUNDS_PER_FRAME) {
        if (event.type == Event::SOUND_PLAY) {
            actuallyPlaySound(event.sound.soundId, event.sound.volume);
            soundsPlayed++;
        }
    }
}
</code></pre>
<h4 id="带优先级的事件队列"><a class="header" href="#带优先级的事件队列">带优先级的事件队列</a></h4>
<pre><code class="language-cpp">struct PriorityEvent {
    Event event;
    int priority;

    bool operator&lt;(const PriorityEvent&amp; other) const {
        return priority &lt; other.priority;
    }
};

class PriorityEventQueue {
public:
    void post(const Event&amp; event, int priority) {
        PriorityEvent pe;
        pe.event = event;
        pe.priority = priority;
        queue_.push(pe);
    }

    bool poll(Event&amp; event) {
        if (queue_.empty()) {
            return false;
        }

        event = queue_.top().event;
        queue_.pop();
        return true;
    }

private:
    std::priority_queue&lt;PriorityEvent&gt; queue_;
};
</code></pre>
<h4 id="延迟事件"><a class="header" href="#延迟事件">延迟事件</a></h4>
<pre><code class="language-cpp">struct TimedEvent {
    Event event;
    float triggerTime;
};

class TimedEventQueue {
public:
    void schedule(const Event&amp; event, float delay) {
        TimedEvent te;
        te.event = event;
        te.triggerTime = currentTime_ + delay;
        events_.push_back(te);
    }

    void update(float deltaTime) {
        currentTime_ += deltaTime;

        auto it = events_.begin();
        while (it != events_.end()) {
            if (it-&gt;triggerTime &lt;= currentTime_) {
                processEvent(it-&gt;event);
                it = events_.erase(it);
            } else {
                ++it;
            }
        }
    }

private:
    float currentTime_;
    std::vector&lt;TimedEvent&gt; events_;
};

// 使用
eventQueue.schedule(explosionEvent, 2.0f);  // 2秒后爆炸
</code></pre>
<hr />
<h3 id="33-服务定位器模式-service-locator"><a class="header" href="#33-服务定位器模式-service-locator">3.3 服务定位器模式 (Service Locator)</a></h3>
<h4 id="核心思想-8"><a class="header" href="#核心思想-8">核心思想</a></h4>
<p>提供服务的全局访问点，而不耦合到服务的具体类。</p>
<h4 id="基本实现-3"><a class="header" href="#基本实现-3">基本实现</a></h4>
<pre><code class="language-cpp">class Audio {
public:
    virtual ~Audio() {}
    virtual void playSound(SoundId id) = 0;
    virtual void stopSound(SoundId id) = 0;
    virtual void stopAllSounds() = 0;
};

class ServiceLocator {
public:
    static Audio&amp; getAudio() { return *audio_; }

    static void provideAudio(Audio* audio) {
        audio_ = audio;
    }

private:
    static Audio* audio_;
};

Audio* ServiceLocator::audio_ = nullptr;

// 使用
int main() {
    ConsoleAudio audio;
    ServiceLocator::provideAudio(&amp;audio);

    // 游戏代码可以直接使用
    ServiceLocator::getAudio().playSound(SOUND_EXPLOSION);
}
</code></pre>
<h4 id="空服务模式"><a class="header" href="#空服务模式">空服务模式</a></h4>
<pre><code class="language-cpp">class NullAudio : public Audio {
public:
    virtual void playSound(SoundId id) override { /* 什么也不做 */ }
    virtual void stopSound(SoundId id) override { /* 什么也不做 */ }
    virtual void stopAllSounds() override { /* 什么也不做 */ }
};

class ServiceLocator {
public:
    static void initialize() {
        audio_ = &amp;nullAudio_;
    }

    static Audio&amp; getAudio() {
        return *audio_;
    }

    static void provideAudio(Audio* audio) {
        if (audio == nullptr) {
            audio_ = &amp;nullAudio_;
        } else {
            audio_ = audio;
        }
    }

private:
    static NullAudio nullAudio_;
    static Audio* audio_;
};

NullAudio ServiceLocator::nullAudio_;
Audio* ServiceLocator::audio_ = &amp;ServiceLocator::nullAudio_;
</code></pre>
<h4 id="运行时切换服务"><a class="header" href="#运行时切换服务">运行时切换服务</a></h4>
<pre><code class="language-cpp">class ServiceLocator {
public:
    static Audio&amp; getAudio() { return *audio_; }

    static void provideAudio(Audio* audio) {
        if (audio_ != nullptr) {
            audio_-&gt;stopAllSounds();  // 停止旧服务
        }
        audio_ = (audio != nullptr) ? audio : &amp;nullAudio_;
    }

private:
    static NullAudio nullAudio_;
    static Audio* audio_;
};

// 使用：在游戏中途切换音频引擎
void switchToOpenAL() {
    OpenALAudio* openAL = new OpenALAudio();
    ServiceLocator::provideAudio(openAL);
}

void muteAudio() {
    ServiceLocator::provideAudio(nullptr);  // 切换到空服务
}
</code></pre>
<hr />
<h2 id="第四章优化模式基础"><a class="header" href="#第四章优化模式基础">第四章：优化模式基础</a></h2>
<h3 id="41-数据局部性-data-locality"><a class="header" href="#41-数据局部性-data-locality">4.1 数据局部性 (Data Locality)</a></h3>
<h4 id="核心思想-9"><a class="header" href="#核心思想-9">核心思想</a></h4>
<p>合理安排数据以利用CPU缓存，提高访问速度。</p>
<h4 id="问题缓存失效"><a class="header" href="#问题缓存失效">问题：缓存失效</a></h4>
<pre><code class="language-cpp">// 不好：指针跳转导致缓存失效
class GameEntity {
public:
    void update() { ai_-&gt;update(); }

private:
    AI* ai_;
    Physics* physics_;
    Render* render_;
};

std::vector&lt;GameEntity*&gt; entities;

void updateAll() {
    for (auto entity : entities) {
        entity-&gt;update();  // 每次都跟随指针，缓存失效
    }
}
</code></pre>
<h4 id="解决方案连续数据"><a class="header" href="#解决方案连续数据">解决方案：连续数据</a></h4>
<pre><code class="language-cpp">// 好：数据连续存储
class AIComponent {
public:
    void update() { /* AI逻辑 */ }
};

class AIComponentArray {
public:
    void update() {
        for (int i = 0; i &lt; numComponents_; i++) {
            components_[i].update();  // 连续内存，缓存友好
        }
    }

private:
    static const int MAX_COMPONENTS = 1000;
    AIComponent components_[MAX_COMPONENTS];
    int numComponents_;
};
</code></pre>
<h4 id="热冷数据分离"><a class="header" href="#热冷数据分离">热/冷数据分离</a></h4>
<pre><code class="language-cpp">// 不好：混合热数据和冷数据
class Entity {
    Vector position_;      // 热：每帧访问
    Vector velocity_;      // 热：每帧访问
    Mesh* mesh_;          // 冷：偶尔访问
    Texture* texture_;    // 冷：偶尔访问
    std::string name_;    // 冷：很少访问
    int debugId_;         // 冷：只在调试时用
};

// 好：分离热数据和冷数据
class EntityData {
    Vector position_;
    Vector velocity_;
    int renderDataIndex_;  // 指向冷数据的索引
};

class RenderData {
    Mesh* mesh_;
    Texture* texture_;
    std::string name_;
};
</code></pre>
<hr />
<h3 id="42-脏标记模式-dirty-flag"><a class="header" href="#42-脏标记模式-dirty-flag">4.2 脏标记模式 (Dirty Flag)</a></h3>
<h4 id="核心思想-10"><a class="header" href="#核心思想-10">核心思想</a></h4>
<p>避免不必要的工作，直到结果真正需要时才计算。</p>
<h4 id="实现"><a class="header" href="#实现">实现</a></h4>
<pre><code class="language-cpp">class Transform {
public:
    void setPosition(const Vector&amp; pos) {
        position_ = pos;
        dirty_ = true;
    }

    const Matrix&amp; getWorldTransform() {
        if (dirty_) {
            worldTransform_ = calculateWorldTransform();
            dirty_ = false;
        }
        return worldTransform_;
    }

private:
    Vector position_;
    Vector rotation_;
    Vector scale_;

    Matrix worldTransform_;
    bool dirty_;
};
</code></pre>
<hr />
<h3 id="43-空间分区-spatial-partition"><a class="header" href="#43-空间分区-spatial-partition">4.3 空间分区 (Spatial Partition)</a></h3>
<h4 id="核心思想-11"><a class="header" href="#核心思想-11">核心思想</a></h4>
<p>将对象存储在按位置组织的数据结构中，高效查找对象。</p>
<h4 id="简单网格实现"><a class="header" href="#简单网格实现">简单网格实现</a></h4>
<pre><code class="language-cpp">class Grid {
public:
    Grid() {
        for (int i = 0; i &lt; NUM_CELLS; i++) {
            cells_[i] = nullptr;
        }
    }

    void add(Unit* unit) {
        int cellIndex = getCellIndex(unit-&gt;getPosition());
        unit-&gt;next_ = cells_[cellIndex];
        cells_[cellIndex] = unit;
    }

    std::vector&lt;Unit*&gt; getUnitsNear(const Vector&amp; position, float radius) {
        std::vector&lt;Unit*&gt; nearby;
        int cellIndex = getCellIndex(position);

        Unit* unit = cells_[cellIndex];
        while (unit != nullptr) {
            if (distance(unit-&gt;getPosition(), position) &lt; radius) {
                nearby.push_back(unit);
            }
            unit = unit-&gt;next_;
        }

        return nearby;
    }

private:
    static const int GRID_SIZE = 100;
    static const int NUM_CELLS = GRID_SIZE * GRID_SIZE;
    Unit* cells_[NUM_CELLS];

    int getCellIndex(const Vector&amp; pos) {
        int x = static_cast&lt;int&gt;(pos.x / CELL_SIZE);
        int y = static_cast&lt;int&gt;(pos.y / CELL_SIZE);
        return y * GRID_SIZE + x;
    }
};
</code></pre>
<hr />
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>本高级篇深入讲解了：</p>
<ol>
<li><strong>序列模式</strong> - 管理时间和更新顺序</li>
<li><strong>行为模式</strong> - 灵活定义对象行为</li>
<li><strong>解耦模式</strong> - 降低系统间耦合</li>
<li><strong>优化模式</strong> - 提升性能的技巧</li>
</ol>
<p>继续学习请查看：</p>
<ul>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">← 返回主文档</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B.html">实战案例 →</a></li>
<li><a href="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html">性能优化 →</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/c++/设计模式-性能优化.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/c++/设计模式.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/c++/设计模式-性能优化.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/c++/设计模式.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

