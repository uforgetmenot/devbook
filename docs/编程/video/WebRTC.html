<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WebRTC å®Œæ•´å­¦ä¹ ç¬”è®° - å¼€å‘</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">å¼€å‘</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="æœç´¢æœ¬ä¹¦å†…å®¹..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="webrtc-å®Œæ•´å­¦ä¹ ç¬”è®°"><a class="header" href="#webrtc-å®Œæ•´å­¦ä¹ ç¬”è®°">WebRTC å®Œæ•´å­¦ä¹ ç¬”è®°</a></h1>
<h2 id="-å­¦ä¹ è€…è§’è‰²å®šä½"><a class="header" href="#-å­¦ä¹ è€…è§’è‰²å®šä½">ğŸ“‹ å­¦ä¹ è€…è§’è‰²å®šä½</a></h2>
<ul>
<li><strong>ç›®æ ‡ç¾¤ä½“</strong>ï¼š0-5å¹´ç»éªŒçš„å®æ—¶é€šä¿¡å¼€å‘è€…ã€éŸ³è§†é¢‘å·¥ç¨‹å¸ˆã€Webå‰ç«¯å¼€å‘è€…</li>
<li><strong>å‰ç½®çŸ¥è¯†</strong>ï¼šJavaScriptåŸºç¡€ã€ç½‘ç»œç¼–ç¨‹ã€P2Pæ¦‚å¿µã€éŸ³è§†é¢‘ç¼–è§£ç åŸºç¡€</li>
<li><strong>å­¦ä¹ ç›®æ ‡</strong>ï¼šæŒæ¡WebRTCæ ¸å¿ƒæŠ€æœ¯ï¼Œèƒ½å¤Ÿç‹¬ç«‹å¼€å‘å®æ—¶éŸ³è§†é¢‘é€šä¿¡åº”ç”¨</li>
</ul>
<hr />
<h2 id="1-webrtc-åŸºç¡€æ¦‚å¿µ"><a class="header" href="#1-webrtc-åŸºç¡€æ¦‚å¿µ">1. WebRTC åŸºç¡€æ¦‚å¿µ</a></h2>
<h3 id="11-webrtc-ç®€ä»‹"><a class="header" href="#11-webrtc-ç®€ä»‹">1.1 WebRTC ç®€ä»‹</a></h3>
<h4 id="å®šä¹‰å’Œä½œç”¨"><a class="header" href="#å®šä¹‰å’Œä½œç”¨">å®šä¹‰å’Œä½œç”¨</a></h4>
<p><strong>WebRTC (Web Real-Time Communication)</strong> æ˜¯ä¸€ä¸ªæ”¯æŒç½‘é¡µæµè§ˆå™¨è¿›è¡Œå®æ—¶è¯­éŸ³é€šè¯æˆ–è§†é¢‘èŠå¤©çš„å¼€æºé¡¹ç›®ã€‚</p>
<p><strong>æ ¸å¿ƒç‰¹ç‚¹</strong>ï¼š</p>
<ul>
<li><strong>é›¶æ’ä»¶</strong>ï¼šåŸç”Ÿæµè§ˆå™¨æ”¯æŒï¼Œæ— éœ€å®‰è£…ä»»ä½•æ’ä»¶</li>
<li><strong>P2Pé€šä¿¡</strong>ï¼šç‚¹å¯¹ç‚¹ä¼ è¾“ï¼Œé™ä½æœåŠ¡å™¨è´Ÿè½½</li>
<li><strong>ä½å»¶è¿Ÿ</strong>ï¼šç«¯åˆ°ç«¯å»¶è¿Ÿé€šå¸¸åœ¨100msä»¥å†…</li>
<li><strong>å®‰å…¨æ€§</strong>ï¼šå¼ºåˆ¶åŠ å¯†ï¼ˆDTLS/SRTPï¼‰</li>
<li><strong>è·¨å¹³å°</strong>ï¼šWebã€iOSã€Androidã€æ¡Œé¢åº”ç”¨</li>
</ul>
<p><strong>åº”ç”¨åœºæ™¯</strong>ï¼š</p>
<pre><code>è§†é¢‘ä¼šè®®        â†’ Zoomã€Teamsã€Google Meet
åœ¨çº¿æ•™è‚²        â†’ åœ¨çº¿è¯¾å ‚ã€è¿œç¨‹åŸ¹è®­
ç¤¾äº¤åº”ç”¨        â†’ è§†é¢‘èŠå¤©ã€è¯­éŸ³é€šè¯
æ¸¸æˆç›´æ’­        â†’ ä½å»¶è¿Ÿäº’åŠ¨ç›´æ’­
è¿œç¨‹åä½œ        â†’ å±å¹•å…±äº«ã€è¿œç¨‹æ¡Œé¢
IoTè®¾å¤‡         â†’ æ™ºèƒ½é—¨é“ƒã€ç›‘æ§æ‘„åƒå¤´
</code></pre>
<h4 id="å‘å±•å†å²"><a class="header" href="#å‘å±•å†å²">å‘å±•å†å²</a></h4>
<pre><code>æ—¶é—´çº¿ï¼š
2011å¹´ â†’ Googleæ”¶è´­Global IP Solutionsï¼Œè·å¾—éŸ³è§†é¢‘ç¼–è§£ç æŠ€æœ¯
2011å¹´ â†’ Googleå¼€æºWebRTCé¡¹ç›®
2012å¹´ â†’ Chromeã€Firefoxå¼€å§‹æ”¯æŒWebRTC
2017å¹´ â†’ SafariåŠ å…¥WebRTCæ”¯æŒ
2021å¹´ â†’ WebRTC 1.0æˆä¸ºW3Cå’ŒIETFæ ‡å‡†
2024å¹´ â†’ ä¸»æµæµè§ˆå™¨å…¨é¢æ”¯æŒï¼Œç§»åŠ¨ç«¯åº”ç”¨å¹¿æ³›
</code></pre>
<h4 id="ä¸»è¦ç‰¹æ€§"><a class="header" href="#ä¸»è¦ç‰¹æ€§">ä¸»è¦ç‰¹æ€§</a></h4>
<p><strong>æŠ€æœ¯ç‰¹æ€§</strong>ï¼š</p>
<pre><code>éŸ³è§†é¢‘é‡‡é›†      â†’ getUserMedia API
åª’ä½“ç¼–è§£ç       â†’ VP8/VP9/H.264/Opus
P2Pè¿æ¥         â†’ ICE/STUN/TURN
æ•°æ®ä¼ è¾“        â†’ DataChannel
ä¼šè¯åå•†        â†’ SDP (Session Description Protocol)
NATç©¿é€         â†’ ICEæ¡†æ¶
å®‰å…¨åŠ å¯†        â†’ DTLS-SRTP
ç½‘ç»œé€‚åº”        â†’ å¸¦å®½è‡ªé€‚åº”ã€æ‹¥å¡æ§åˆ¶
</code></pre>
<h3 id="12-æ ¸å¿ƒç»„ä»¶"><a class="header" href="#12-æ ¸å¿ƒç»„ä»¶">1.2 æ ¸å¿ƒç»„ä»¶</a></h3>
<h4 id="mediastream-api"><a class="header" href="#mediastream-api">MediaStream API</a></h4>
<p><strong>getUserMedia</strong> - è·å–æœ¬åœ°åª’ä½“æµï¼š</p>
<pre><code class="language-javascript">// è·å–éŸ³è§†é¢‘æµ
async function getLocalStream() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                frameRate: { ideal: 30 }
            },
            audio: {
                echoCancellation: true,  // å›å£°æ¶ˆé™¤
                noiseSuppression: true,  // å™ªå£°æŠ‘åˆ¶
                autoGainControl: true    // è‡ªåŠ¨å¢ç›Š
            }
        });

        // æ˜¾ç¤ºæœ¬åœ°è§†é¢‘
        const videoElement = document.getElementById('localVideo');
        videoElement.srcObject = stream;

        return stream;
    } catch (error) {
        console.error('è·å–åª’ä½“æµå¤±è´¥:', error);
        throw error;
    }
}
</code></pre>
<p><strong>getDisplayMedia</strong> - å±å¹•å…±äº«ï¼š</p>
<pre><code class="language-javascript">// è·å–å±å¹•å…±äº«æµ
async function startScreenShare() {
    try {
        const screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: {
                cursor: "always",  // æ˜¾ç¤ºé¼ æ ‡
                displaySurface: "monitor"  // æ•´ä¸ªå±å¹•
            },
            audio: true  // åŒ…å«ç³»ç»ŸéŸ³é¢‘
        });

        return screenStream;
    } catch (error) {
        console.error('å±å¹•å…±äº«å¤±è´¥:', error);
        throw error;
    }
}
</code></pre>
<p><strong>MediaStreamæ“ä½œ</strong>ï¼š</p>
<pre><code class="language-javascript">class MediaStreamController {
    constructor(stream) {
        this.stream = stream;
    }

    // é™éŸ³/å–æ¶ˆé™éŸ³
    toggleAudio(muted) {
        this.stream.getAudioTracks().forEach(track =&gt; {
            track.enabled = !muted;
        });
    }

    // ç¦ç”¨/å¯ç”¨è§†é¢‘
    toggleVideo(enabled) {
        this.stream.getVideoTracks().forEach(track =&gt; {
            track.enabled = enabled;
        });
    }

    // åˆ‡æ¢æ‘„åƒå¤´
    async switchCamera() {
        const videoTrack = this.stream.getVideoTracks()[0];
        const constraints = videoTrack.getConstraints();

        // åˆ‡æ¢facingMode
        constraints.facingMode =
            constraints.facingMode === 'user' ? 'environment' : 'user';

        await videoTrack.applyConstraints(constraints);
    }

    // åœæ­¢æ‰€æœ‰è½¨é“
    stop() {
        this.stream.getTracks().forEach(track =&gt; track.stop());
    }

    // æ·»åŠ è½¨é“
    addTrack(track) {
        this.stream.addTrack(track);
    }

    // ç§»é™¤è½¨é“
    removeTrack(track) {
        this.stream.removeTrack(track);
    }
}
</code></pre>
<h4 id="rtcpeerconnection"><a class="header" href="#rtcpeerconnection">RTCPeerConnection</a></h4>
<p><strong>æ ¸å¿ƒAPI</strong> - P2Pè¿æ¥ç®¡ç†ï¼š</p>
<pre><code class="language-javascript">class WebRTCPeer {
    constructor(config) {
        // STUN/TURNæœåŠ¡å™¨é…ç½®
        this.config = config || {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                {
                    urls: 'turn:turn.example.com:3478',
                    username: 'user',
                    credential: 'pass'
                }
            ]
        };

        // åˆ›å»ºRTCPeerConnection
        this.pc = new RTCPeerConnection(this.config);

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        this.setupEventHandlers();
    }

    setupEventHandlers() {
        // ICEå€™é€‰æ”¶é›†
        this.pc.onicecandidate = (event) =&gt; {
            if (event.candidate) {
                // å‘é€ICEå€™é€‰åˆ°å¯¹ç«¯
                this.sendIceCandidate(event.candidate);
            }
        };

        // ICEè¿æ¥çŠ¶æ€å˜åŒ–
        this.pc.oniceconnectionstatechange = () =&gt; {
            console.log('ICEè¿æ¥çŠ¶æ€:', this.pc.iceConnectionState);

            switch (this.pc.iceConnectionState) {
                case 'connected':
                    console.log('P2Pè¿æ¥å»ºç«‹æˆåŠŸ');
                    break;
                case 'disconnected':
                    console.log('P2Pè¿æ¥æ–­å¼€');
                    break;
                case 'failed':
                    console.log('P2Pè¿æ¥å¤±è´¥');
                    this.handleConnectionFailure();
                    break;
            }
        };

        // æ¥æ”¶è¿œç«¯æµ
        this.pc.ontrack = (event) =&gt; {
            console.log('æ¥æ”¶åˆ°è¿œç«¯è½¨é“:', event.track.kind);

            const remoteVideo = document.getElementById('remoteVideo');
            if (!remoteVideo.srcObject) {
                remoteVideo.srcObject = new MediaStream();
            }
            remoteVideo.srcObject.addTrack(event.track);
        };

        // åå•†éœ€è¦äº‹ä»¶
        this.pc.onnegotiationneeded = async () =&gt; {
            console.log('éœ€è¦é‡æ–°åå•†');
            await this.createOffer();
        };

        // DataChannelæ¶ˆæ¯
        this.pc.ondatachannel = (event) =&gt; {
            this.handleDataChannel(event.channel);
        };
    }

    // æ·»åŠ æœ¬åœ°æµ
    addStream(stream) {
        stream.getTracks().forEach(track =&gt; {
            this.pc.addTrack(track, stream);
        });
    }

    // åˆ›å»ºOffer
    async createOffer() {
        try {
            const offer = await this.pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            });

            await this.pc.setLocalDescription(offer);

            // å‘é€offeråˆ°å¯¹ç«¯
            this.sendSignaling({
                type: 'offer',
                sdp: offer.sdp
            });

            return offer;
        } catch (error) {
            console.error('åˆ›å»ºOfferå¤±è´¥:', error);
            throw error;
        }
    }

    // åˆ›å»ºAnswer
    async createAnswer(offer) {
        try {
            await this.pc.setRemoteDescription(new RTCSessionDescription(offer));

            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);

            // å‘é€answeråˆ°å¯¹ç«¯
            this.sendSignaling({
                type: 'answer',
                sdp: answer.sdp
            });

            return answer;
        } catch (error) {
            console.error('åˆ›å»ºAnswerå¤±è´¥:', error);
            throw error;
        }
    }

    // æ·»åŠ ICEå€™é€‰
    async addIceCandidate(candidate) {
        try {
            await this.pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (error) {
            console.error('æ·»åŠ ICEå€™é€‰å¤±è´¥:', error);
        }
    }

    // å…³é—­è¿æ¥
    close() {
        if (this.pc) {
            this.pc.close();
            this.pc = null;
        }
    }

    // è·å–è¿æ¥ç»Ÿè®¡ä¿¡æ¯
    async getStats() {
        const stats = await this.pc.getStats();
        return this.parseStats(stats);
    }

    parseStats(stats) {
        const result = {
            audio: {},
            video: {}
        };

        stats.forEach(report =&gt; {
            if (report.type === 'inbound-rtp') {
                const mediaType = report.kind;
                result[mediaType].bytesReceived = report.bytesReceived;
                result[mediaType].packetsReceived = report.packetsReceived;
                result[mediaType].packetsLost = report.packetsLost;
            }
        });

        return result;
    }
}
</code></pre>
<h4 id="rtcdatachannel"><a class="header" href="#rtcdatachannel">RTCDataChannel</a></h4>
<p><strong>æ•°æ®é€šé“</strong> - P2Pæ•°æ®ä¼ è¾“ï¼š</p>
<pre><code class="language-javascript">class DataChannelManager {
    constructor(peerConnection) {
        this.pc = peerConnection;
        this.channels = {};
    }

    // åˆ›å»ºæ•°æ®é€šé“
    createChannel(label, options = {}) {
        const defaultOptions = {
            ordered: true,        // æœ‰åºä¼ è¾“
            maxRetransmits: 3    // æœ€å¤§é‡ä¼ æ¬¡æ•°
        };

        const channel = this.pc.createDataChannel(
            label,
            { ...defaultOptions, ...options }
        );

        this.setupChannelHandlers(channel, label);
        this.channels[label] = channel;

        return channel;
    }

    // è®¾ç½®æ•°æ®é€šé“äº‹ä»¶
    setupChannelHandlers(channel, label) {
        channel.onopen = () =&gt; {
            console.log(`æ•°æ®é€šé“ ${label} å·²æ‰“å¼€`);
        };

        channel.onclose = () =&gt; {
            console.log(`æ•°æ®é€šé“ ${label} å·²å…³é—­`);
            delete this.channels[label];
        };

        channel.onerror = (error) =&gt; {
            console.error(`æ•°æ®é€šé“ ${label} é”™è¯¯:`, error);
        };

        channel.onmessage = (event) =&gt; {
            this.handleMessage(label, event.data);
        };

        // ç›‘æ§ç¼“å†²åŒº
        channel.onbufferedamountlow = () =&gt; {
            console.log('ç¼“å†²åŒºä½æ°´ä½ï¼Œå¯ä»¥å‘é€æ›´å¤šæ•°æ®');
        };
    }

    // å‘é€æ¶ˆæ¯
    send(label, data) {
        const channel = this.channels[label];

        if (!channel) {
            console.error(`æ•°æ®é€šé“ ${label} ä¸å­˜åœ¨`);
            return false;
        }

        if (channel.readyState !== 'open') {
            console.error(`æ•°æ®é€šé“ ${label} æœªæ‰“å¼€`);
            return false;
        }

        // æ£€æŸ¥ç¼“å†²åŒº
        if (channel.bufferedAmount &gt; 16 * 1024 * 1024) {  // 16MB
            console.warn('ç¼“å†²åŒºæ»¡ï¼Œå»¶è¿Ÿå‘é€');
            return false;
        }

        try {
            channel.send(data);
            return true;
        } catch (error) {
            console.error('å‘é€æ•°æ®å¤±è´¥:', error);
            return false;
        }
    }

    // å‘é€æ–‡ä»¶
    async sendFile(label, file) {
        const channel = this.channels[label];
        if (!channel) return;

        const chunkSize = 16 * 1024;  // 16KB chunks
        let offset = 0;

        // å‘é€æ–‡ä»¶å…ƒæ•°æ®
        const metadata = {
            type: 'file-metadata',
            name: file.name,
            size: file.size,
            mimeType: file.type
        };
        channel.send(JSON.stringify(metadata));

        // åˆ†å—å‘é€æ–‡ä»¶æ•°æ®
        while (offset &lt; file.size) {
            const chunk = file.slice(offset, offset + chunkSize);
            const buffer = await chunk.arrayBuffer();

            // ç­‰å¾…ç¼“å†²åŒºå¯ç”¨
            while (channel.bufferedAmount &gt; chunkSize * 4) {
                await new Promise(resolve =&gt; setTimeout(resolve, 50));
            }

            channel.send(buffer);
            offset += chunkSize;

            // å‘é€è¿›åº¦
            const progress = (offset / file.size) * 100;
            this.onProgress?.(progress);
        }

        // å‘é€å®Œæˆæ ‡è®°
        channel.send(JSON.stringify({ type: 'file-complete' }));
    }

    // å¤„ç†æ¥æ”¶çš„æ¶ˆæ¯
    handleMessage(label, data) {
        // æ–‡æœ¬æ¶ˆæ¯
        if (typeof data === 'string') {
            try {
                const message = JSON.parse(data);
                this.onTextMessage?.(label, message);
            } catch {
                this.onTextMessage?.(label, data);
            }
        }
        // äºŒè¿›åˆ¶æ•°æ®
        else if (data instanceof ArrayBuffer) {
            this.onBinaryMessage?.(label, data);
        }
    }

    // å…³é—­é€šé“
    close(label) {
        const channel = this.channels[label];
        if (channel) {
            channel.close();
            delete this.channels[label];
        }
    }

    // å…³é—­æ‰€æœ‰é€šé“
    closeAll() {
        Object.keys(this.channels).forEach(label =&gt; {
            this.close(label);
        });
    }
}
</code></pre>
<h3 id="13-æ¶æ„åŸç†"><a class="header" href="#13-æ¶æ„åŸç†">1.3 æ¶æ„åŸç†</a></h3>
<h4 id="p2p-é€šä¿¡æ¨¡å¼"><a class="header" href="#p2p-é€šä¿¡æ¨¡å¼">P2P é€šä¿¡æ¨¡å¼</a></h4>
<p><strong>é€šä¿¡æ¶æ„</strong>ï¼š</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å®¢æˆ·ç«¯ A   â”‚                           â”‚  å®¢æˆ·ç«¯ B   â”‚
â”‚             â”‚                           â”‚             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚                           â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Browserâ”‚  â”‚                           â”‚  â”‚Browserâ”‚  â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”˜  â”‚                           â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”˜  â”‚
â”‚      â”‚      â”‚                           â”‚      â”‚      â”‚
â”‚  WebRTC API â”‚                           â”‚  WebRTC API â”‚
â”‚      â”‚      â”‚                           â”‚      â”‚      â”‚
â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜                           â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                         â”‚
       â”‚  â‘  ä¿¡ä»¤äº¤æ¢                              â”‚
       â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
       â”‚     (é€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨)                      â”‚
       â”‚                                         â”‚
       â”‚  â‘¡ P2Påª’ä½“æµ                             â”‚
       â”‚  â—„â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–ºâ”‚
       â”‚     (ç›´è¿ï¼ŒRTP/SRTP)                     â”‚
       â”‚                                         â”‚
       â”‚  â‘¢ NATç©¿é€                               â”‚
       â”‚  â†â”€â”€â”€â”€ STUN/TURNæœåŠ¡å™¨ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
</code></pre>
<p><strong>é€šä¿¡æµç¨‹</strong>ï¼š</p>
<pre><code>1. ä¿¡ä»¤é˜¶æ®µ (é€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨)
   â”œâ”€ Aå‘é€Offeråˆ°B
   â”œâ”€ Bå‘é€Answeråˆ°A
   â””â”€ äº¤æ¢ICEå€™é€‰

2. NATç©¿é€é˜¶æ®µ
   â”œâ”€ æ”¶é›†ICEå€™é€‰
   â”œâ”€ STUNè·å–å…¬ç½‘åœ°å€
   â””â”€ å¿…è¦æ—¶ä½¿ç”¨TURNä¸­ç»§

3. å»ºç«‹è¿æ¥
   â”œâ”€ DTLSæ¡æ‰‹ï¼ˆåŠ å¯†ï¼‰
   â””â”€ SRTPå¯†é’¥åå•†

4. åª’ä½“ä¼ è¾“
   â”œâ”€ éŸ³è§†é¢‘RTPæµ
   â”œâ”€ RTCPæ§åˆ¶ä¿¡æ¯
   â””â”€ DataChannelæ•°æ®
</code></pre>
<h4 id="ä¿¡ä»¤æœåŠ¡å™¨ä½œç”¨"><a class="header" href="#ä¿¡ä»¤æœåŠ¡å™¨ä½œç”¨">ä¿¡ä»¤æœåŠ¡å™¨ä½œç”¨</a></h4>
<p><strong>ä¿¡ä»¤æœåŠ¡å™¨èŒè´£</strong>ï¼š</p>
<pre><code>ä¸è´Ÿè´£ï¼š
âœ— åª’ä½“æ•°æ®ä¼ è¾“ï¼ˆP2Pç›´è¿ï¼‰
âœ— åŠ å¯†/è§£å¯†

è´Ÿè´£ï¼š
âœ“ SDPäº¤æ¢ï¼ˆOffer/Answerï¼‰
âœ“ ICEå€™é€‰äº¤æ¢
âœ“ ä¼šè¯ç®¡ç†
âœ“ ç”¨æˆ·åœ¨çº¿çŠ¶æ€
âœ“ æˆ¿é—´/é¢‘é“ç®¡ç†
</code></pre>
<p><strong>WebSocketä¿¡ä»¤æœåŠ¡å™¨ç¤ºä¾‹</strong>ï¼š</p>
<pre><code class="language-javascript">// Node.js + Socket.IOä¿¡ä»¤æœåŠ¡å™¨
const express = require('express');
const app = express();
const server = require('http').Server(app);
const io = require('socket.io')(server);

const rooms = new Map();  // æˆ¿é—´ç®¡ç†

io.on('connection', (socket) =&gt; {
    console.log('ç”¨æˆ·è¿æ¥:', socket.id);

    // åŠ å…¥æˆ¿é—´
    socket.on('join', (roomId) =&gt; {
        socket.join(roomId);

        if (!rooms.has(roomId)) {
            rooms.set(roomId, new Set());
        }
        rooms.get(roomId).add(socket.id);

        // é€šçŸ¥æˆ¿é—´å†…å…¶ä»–äºº
        socket.to(roomId).emit('user-joined', {
            userId: socket.id
        });

        // è¿”å›æˆ¿é—´å†…ç°æœ‰ç”¨æˆ·åˆ—è¡¨
        const users = Array.from(rooms.get(roomId))
            .filter(id =&gt; id !== socket.id);

        socket.emit('room-users', users);
    });

    // è½¬å‘Offer
    socket.on('offer', (data) =&gt; {
        socket.to(data.to).emit('offer', {
            from: socket.id,
            sdp: data.sdp
        });
    });

    // è½¬å‘Answer
    socket.on('answer', (data) =&gt; {
        socket.to(data.to).emit('answer', {
            from: socket.id,
            sdp: data.sdp
        });
    });

    // è½¬å‘ICEå€™é€‰
    socket.on('ice-candidate', (data) =&gt; {
        socket.to(data.to).emit('ice-candidate', {
            from: socket.id,
            candidate: data.candidate
        });
    });

    // ç¦»å¼€æˆ¿é—´
    socket.on('leave', (roomId) =&gt; {
        socket.leave(roomId);

        if (rooms.has(roomId)) {
            rooms.get(roomId).delete(socket.id);

            if (rooms.get(roomId).size === 0) {
                rooms.delete(roomId);
            } else {
                socket.to(roomId).emit('user-left', {
                    userId: socket.id
                });
            }
        }
    });

    // æ–­å¼€è¿æ¥
    socket.on('disconnect', () =&gt; {
        console.log('ç”¨æˆ·æ–­å¼€:', socket.id);

        // ä»æ‰€æœ‰æˆ¿é—´ç§»é™¤
        rooms.forEach((users, roomId) =&gt; {
            if (users.has(socket.id)) {
                users.delete(socket.id);

                socket.to(roomId).emit('user-left', {
                    userId: socket.id
                });

                if (users.size === 0) {
                    rooms.delete(roomId);
                }
            }
        });
    });
});

server.listen(3000, () =&gt; {
    console.log('ä¿¡ä»¤æœåŠ¡å™¨è¿è¡Œåœ¨ç«¯å£ 3000');
});
</code></pre>
<h4 id="nat-ç©¿é€åŸç†"><a class="header" href="#nat-ç©¿é€åŸç†">NAT ç©¿é€åŸç†</a></h4>
<p><strong>NATç±»å‹</strong>ï¼š</p>
<pre><code>1. Full Cone NAT (å®Œå…¨é”¥å½¢)
   - æœ€å®½æ¾
   - ä»»ä½•å¤–éƒ¨ä¸»æœºå¯ä»¥è¿æ¥
   - P2Pæœ€å®¹æ˜“æˆåŠŸ

2. Restricted Cone NAT (é™åˆ¶é”¥å½¢)
   - ä¸­ç­‰é™åˆ¶
   - åªæœ‰é€šä¿¡è¿‡çš„IPå¯ä»¥è¿æ¥
   - P2Pé€šå¸¸å¯ä»¥æˆåŠŸ

3. Port Restricted Cone NAT (ç«¯å£é™åˆ¶é”¥å½¢)
   - è¾ƒä¸¥æ ¼
   - å¿…é¡»åŒ¹é…IPå’Œç«¯å£
   - P2Péœ€è¦åŒæ­¥æ‰“æ´

4. Symmetric NAT (å¯¹ç§°å‹)
   - æœ€ä¸¥æ ¼
   - æ¯ä¸ªç›®æ ‡ä½¿ç”¨ä¸åŒçš„æ˜ å°„
   - P2På¾ˆéš¾æˆåŠŸï¼Œé€šå¸¸éœ€è¦TURN
</code></pre>
<p><strong>ICEæ¡†æ¶å·¥ä½œæµç¨‹</strong>ï¼š</p>
<pre><code>1. æ”¶é›†å€™é€‰åœ°å€
   â”œâ”€ Hostå€™é€‰ï¼ˆæœ¬åœ°åœ°å€ï¼‰
   â”œâ”€ Server Reflexiveï¼ˆSTUNè·å–çš„å…¬ç½‘åœ°å€ï¼‰
   â””â”€ Relayå€™é€‰ï¼ˆTURNä¸­ç»§åœ°å€ï¼‰

2. æŒ‰ä¼˜å…ˆçº§æ’åº
   Host &gt; Server Reflexive &gt; Relay

3. è¿æ¥æ€§æ£€æŸ¥
   â”œâ”€ å°è¯•æ‰€æœ‰å€™é€‰å¯¹
   â”œâ”€ å‘é€STUN Binding Request
   â””â”€ ç­‰å¾…å“åº”

4. é€‰æ‹©æœ€ä½³è·¯å¾„
   â”œâ”€ é€‰æ‹©å»¶è¿Ÿæœ€ä½çš„å€™é€‰å¯¹
   â”œâ”€ å»ºç«‹P2Pè¿æ¥
   â””â”€ å¤‡ç”¨å€™é€‰ä¿æŒå¾…å‘½
</code></pre>
<hr />
<h2 id="2-åª’ä½“å¤„ç†"><a class="header" href="#2-åª’ä½“å¤„ç†">2. åª’ä½“å¤„ç†</a></h2>
<h3 id="21-éŸ³é¢‘å¤„ç†"><a class="header" href="#21-éŸ³é¢‘å¤„ç†">2.1 éŸ³é¢‘å¤„ç†</a></h3>
<h4 id="éŸ³é¢‘é‡‡é›†"><a class="header" href="#éŸ³é¢‘é‡‡é›†">éŸ³é¢‘é‡‡é›†</a></h4>
<pre><code class="language-javascript">class AudioCapture {
    constructor() {
        this.audioContext = null;
        this.stream = null;
        this.analyser = null;
    }

    async start(constraints = {}) {
        const defaultConstraints = {
            audio: {
                echoCancellation: true,      // å›å£°æ¶ˆé™¤
                noiseSuppression: true,      // å™ªå£°æŠ‘åˆ¶
                autoGainControl: true,       // è‡ªåŠ¨å¢ç›Š
                sampleRate: 48000,           // é‡‡æ ·ç‡
                channelCount: 1              // å£°é“æ•°
            }
        };

        try {
            this.stream = await navigator.mediaDevices.getUserMedia({
                ...defaultConstraints,
                ...constraints
            });

            // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
            this.audioContext = new AudioContext();
            const source = this.audioContext.createMediaStreamSource(this.stream);

            // åˆ›å»ºåˆ†æå™¨
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
            source.connect(this.analyser);

            return this.stream;
        } catch (error) {
            console.error('éŸ³é¢‘é‡‡é›†å¤±è´¥:', error);
            throw error;
        }
    }

    // è·å–éŸ³é¢‘éŸ³é‡
    getVolume() {
        if (!this.analyser) return 0;

        const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteFrequencyData(dataArray);

        // è®¡ç®—å¹³å‡éŸ³é‡
        const sum = dataArray.reduce((a, b) =&gt; a + b, 0);
        return sum / dataArray.length;
    }

    // è·å–é¢‘è°±æ•°æ®
    getFrequencyData() {
        if (!this.analyser) return null;

        const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteFrequencyData(dataArray);

        return dataArray;
    }

    // åœæ­¢é‡‡é›†
    stop() {
        if (this.stream) {
            this.stream.getTracks().forEach(track =&gt; track.stop());
        }

        if (this.audioContext) {
            this.audioContext.close();
        }
    }
}
</code></pre>
<h4 id="éŸ³é¢‘ç¼–è§£ç "><a class="header" href="#éŸ³é¢‘ç¼–è§£ç ">éŸ³é¢‘ç¼–è§£ç </a></h4>
<p><strong>æ”¯æŒçš„ç¼–è§£ç å™¨</strong>ï¼š</p>
<pre><code>Opus (æ¨è)      â†’ é«˜è´¨é‡ã€ä½å»¶è¿Ÿã€å¯å˜ç ç‡
G.711           â†’ ç”µè¯è´¨é‡ã€é«˜å…¼å®¹æ€§
iLBC            â†’ ä½å¸¦å®½ã€æŠ—ä¸¢åŒ…
iSAC            â†’ è‡ªé€‚åº”ç ç‡
</code></pre>
<p><strong>ç¼–è§£ç å™¨é…ç½®</strong>ï¼š</p>
<pre><code class="language-javascript">// SDPä¸­é…ç½®éŸ³é¢‘ç¼–è§£ç å™¨
function setAudioCodec(sdp, codec) {
    const sdpLines = sdp.split('\r\n');
    let audioMLineIndex = -1;

    // æ‰¾åˆ°éŸ³é¢‘m=è¡Œ
    for (let i = 0; i &lt; sdpLines.length; i++) {
        if (sdpLines[i].startsWith('m=audio')) {
            audioMLineIndex = i;
            break;
        }
    }

    if (audioMLineIndex === -1) return sdp;

    // æŸ¥æ‰¾æŒ‡å®šç¼–è§£ç å™¨çš„payloadç±»å‹
    const codecPayload = sdpLines.find(line =&gt;
        line.includes(codec) &amp;&amp; line.startsWith('a=rtpmap:')
    );

    if (!codecPayload) return sdp;

    const payload = codecPayload.split(':')[1].split(' ')[0];

    // å°†æŒ‡å®šç¼–è§£ç å™¨ç§»åˆ°æœ€å‰é¢
    const mLine = sdpLines[audioMLineIndex].split(' ');
    const payloads = mLine.slice(3);

    const newPayloads = [payload, ...payloads.filter(p =&gt; p !== payload)];
    mLine.splice(3, payloads.length, ...newPayloads);

    sdpLines[audioMLineIndex] = mLine.join(' ');

    return sdpLines.join('\r\n');
}
</code></pre>
<h4 id="éŸ³é¢‘å¢å¼ºæŠ€æœ¯"><a class="header" href="#éŸ³é¢‘å¢å¼ºæŠ€æœ¯">éŸ³é¢‘å¢å¼ºæŠ€æœ¯</a></h4>
<p><strong>å›å£°æ¶ˆé™¤ (AEC)</strong>ï¼š</p>
<pre><code class="language-javascript">// å¯ç”¨ç¡¬ä»¶AEC
const constraints = {
    audio: {
        echoCancellation: {
            exact: true  // å¼ºåˆ¶å¯ç”¨
        }
    }
};

// è½¯ä»¶AECï¼ˆå½“ç¡¬ä»¶ä¸æ”¯æŒæ—¶ï¼‰
class SoftwareAEC {
    constructor(audioContext) {
        this.context = audioContext;
        this.processor = null;
    }

    enable(inputStream, outputStream) {
        // åˆ›å»ºéŸ³é¢‘å¤„ç†èŠ‚ç‚¹
        this.processor = this.context.createScriptProcessor(4096, 1, 1);

        // AECç®—æ³•å®ç°
        this.processor.onaudioprocess = (event) =&gt; {
            const input = event.inputBuffer.getChannelData(0);
            const output = event.outputBuffer.getChannelData(0);

            // ç®€åŒ–çš„AECç®—æ³•
            for (let i = 0; i &lt; input.length; i++) {
                // è¿™é‡Œåº”è¯¥å®ç°å®Œæ•´çš„AECç®—æ³•
                output[i] = this.processAEC(input[i]);
            }
        };

        return this.processor;
    }

    processAEC(sample) {
        // AECç®—æ³•å®ç°ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        // å®é™…åº”è¯¥ä½¿ç”¨Speexã€WebRTC AECç­‰æˆç†Ÿç®—æ³•
        return sample;
    }
}
</code></pre>
<p><strong>å™ªå£°æŠ‘åˆ¶ (NS)</strong>ï¼š</p>
<pre><code class="language-javascript">// å¯ç”¨å™ªå£°æŠ‘åˆ¶
const constraints = {
    audio: {
        noiseSuppression: true,
        // Googleç‰¹å®šçš„å™ªå£°æŠ‘åˆ¶çº§åˆ«
        googNoiseSuppression: true,
        googHighpassFilter: true  // é«˜é€šæ»¤æ³¢å™¨
    }
};
</code></pre>
<p><strong>è‡ªåŠ¨å¢ç›Šæ§åˆ¶ (AGC)</strong>ï¼š</p>
<pre><code class="language-javascript">// å¯ç”¨AGC
const constraints = {
    audio: {
        autoGainControl: true,
        // Googleç‰¹å®šçš„AGCè®¾ç½®
        googAutoGainControl: true,
        googAutoGainControl2: true
    }
};
</code></pre>
<h3 id="22-è§†é¢‘å¤„ç†"><a class="header" href="#22-è§†é¢‘å¤„ç†">2.2 è§†é¢‘å¤„ç†</a></h3>
<h4 id="è§†é¢‘é‡‡é›†"><a class="header" href="#è§†é¢‘é‡‡é›†">è§†é¢‘é‡‡é›†</a></h4>
<pre><code class="language-javascript">class VideoCapture {
    constructor() {
        this.stream = null;
        this.videoElement = null;
    }

    async start(constraints = {}) {
        const defaultConstraints = {
            video: {
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 },
                frameRate: { ideal: 30, max: 60 },
                facingMode: 'user'  // å‰ç½®æ‘„åƒå¤´
            }
        };

        try {
            this.stream = await navigator.mediaDevices.getUserMedia({
                ...defaultConstraints,
                ...constraints
            });

            return this.stream;
        } catch (error) {
            console.error('è§†é¢‘é‡‡é›†å¤±è´¥:', error);
            throw error;
        }
    }

    // åˆ‡æ¢æ‘„åƒå¤´
    async switchCamera() {
        const videoTrack = this.stream.getVideoTracks()[0];
        const currentFacing = videoTrack.getSettings().facingMode;

        const newFacing = currentFacing === 'user' ? 'environment' : 'user';

        // åœæ­¢å½“å‰è½¨é“
        videoTrack.stop();

        // è·å–æ–°çš„è§†é¢‘æµ
        const newStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: newFacing }
        });

        // æ›¿æ¢è½¨é“
        const newTrack = newStream.getVideoTracks()[0];
        this.stream.removeTrack(videoTrack);
        this.stream.addTrack(newTrack);

        return this.stream;
    }

    // æ‹ç…§
    async takeSnapshot() {
        if (!this.videoElement) return null;

        const canvas = document.createElement('canvas');
        canvas.width = this.videoElement.videoWidth;
        canvas.height = this.videoElement.videoHeight;

        const ctx = canvas.getContext('2d');
        ctx.drawImage(this.videoElement, 0, 0);

        return canvas.toDataURL('image/png');
    }

    // å½•åˆ¶è§†é¢‘
    startRecording() {
        if (!this.stream) return null;

        const mediaRecorder = new MediaRecorder(this.stream, {
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: 2500000  // 2.5 Mbps
        });

        const chunks = [];

        mediaRecorder.ondataavailable = (event) =&gt; {
            if (event.data.size &gt; 0) {
                chunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () =&gt; {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);

            // ä¸‹è½½æˆ–å¤„ç†è§†é¢‘
            this.onRecordingComplete?.(url, blob);
        };

        mediaRecorder.start(100);  // æ¯100msæ”¶é›†ä¸€æ¬¡æ•°æ®

        return mediaRecorder;
    }

    // åœæ­¢é‡‡é›†
    stop() {
        if (this.stream) {
            this.stream.getTracks().forEach(track =&gt; track.stop());
        }
    }
}
</code></pre>
<h4 id="è§†é¢‘ç¼–è§£ç "><a class="header" href="#è§†é¢‘ç¼–è§£ç ">è§†é¢‘ç¼–è§£ç </a></h4>
<p><strong>æ”¯æŒçš„ç¼–è§£ç å™¨</strong>ï¼š</p>
<pre><code>VP8             â†’ å¼€æºã€å¹¿æ³›æ”¯æŒ
VP9             â†’ é«˜æ•ˆã€YouTubeä½¿ç”¨
H.264           â†’ æœ€é€šç”¨ã€ç¡¬ä»¶åŠ é€Ÿ
H.265/HEVC      â†’ æ–°ä¸€ä»£ã€éƒ¨åˆ†æµè§ˆå™¨æ”¯æŒ
AV1             â†’ æœªæ¥è¶‹åŠ¿ã€å‹ç¼©ç‡æœ€é«˜
</code></pre>
<p><strong>ç¼–è§£ç å™¨ä¼˜å…ˆçº§é…ç½®</strong>ï¼š</p>
<pre><code class="language-javascript">function setPreferredVideoCodec(sdp, codec) {
    const sdpLines = sdp.split('\r\n');
    let videoMLineIndex = -1;

    // æ‰¾åˆ°è§†é¢‘m=è¡Œ
    for (let i = 0; i &lt; sdpLines.length; i++) {
        if (sdpLines[i].startsWith('m=video')) {
            videoMLineIndex = i;
            break;
        }
    }

    if (videoMLineIndex === -1) return sdp;

    // æŸ¥æ‰¾æ‰€æœ‰æŒ‡å®šç¼–è§£ç å™¨çš„payload
    const codecPayloads = sdpLines
        .filter(line =&gt; line.includes(codec) &amp;&amp; line.startsWith('a=rtpmap:'))
        .map(line =&gt; line.split(':')[1].split(' ')[0]);

    if (codecPayloads.length === 0) return sdp;

    // é‡æ’payloadé¡ºåº
    const mLine = sdpLines[videoMLineIndex].split(' ');
    const otherPayloads = mLine.slice(3).filter(p =&gt; !codecPayloads.includes(p));

    mLine.splice(3, mLine.length - 3, ...codecPayloads, ...otherPayloads);
    sdpLines[videoMLineIndex] = mLine.join(' ');

    return sdpLines.join('\r\n');
}

// ä½¿ç”¨ç¤ºä¾‹
peerConnection.createOffer().then(offer =&gt; {
    // ä¼˜å…ˆä½¿ç”¨H.264
    offer.sdp = setPreferredVideoCodec(offer.sdp, 'H264');
    return peerConnection.setLocalDescription(offer);
});
</code></pre>
<h4 id="åˆ†è¾¨ç‡å’Œå¸§ç‡æ§åˆ¶"><a class="header" href="#åˆ†è¾¨ç‡å’Œå¸§ç‡æ§åˆ¶">åˆ†è¾¨ç‡å’Œå¸§ç‡æ§åˆ¶</a></h4>
<pre><code class="language-javascript">class VideoQualityController {
    constructor(peerConnection) {
        this.pc = peerConnection;
        this.sender = null;
    }

    // è·å–è§†é¢‘å‘é€å™¨
    getSender() {
        if (!this.sender) {
            this.sender = this.pc.getSenders().find(s =&gt;
                s.track &amp;&amp; s.track.kind === 'video'
            );
        }
        return this.sender;
    }

    // è®¾ç½®åˆ†è¾¨ç‡
    async setResolution(width, height) {
        const sender = this.getSender();
        if (!sender) return;

        const params = sender.getParameters();

        if (!params.encodings) {
            params.encodings = [{}];
        }

        params.encodings[0].maxBitrate = this.calculateBitrate(width, height);

        await sender.setParameters(params);

        // åŒæ—¶æ›´æ–°è½¨é“çº¦æŸ
        const track = sender.track;
        await track.applyConstraints({
            width: { ideal: width },
            height: { ideal: height }
        });
    }

    // è®¾ç½®å¸§ç‡
    async setFrameRate(fps) {
        const sender = this.getSender();
        if (!sender) return;

        const track = sender.track;
        await track.applyConstraints({
            frameRate: { ideal: fps }
        });
    }

    // è®¾ç½®ç ç‡
    async setBitrate(bitrate) {
        const sender = this.getSender();
        if (!sender) return;

        const params = sender.getParameters();

        if (!params.encodings) {
            params.encodings = [{}];
        }

        params.encodings[0].maxBitrate = bitrate;

        await sender.setParameters(params);
    }

    // æ ¹æ®åˆ†è¾¨ç‡è®¡ç®—æ¨èç ç‡
    calculateBitrate(width, height) {
        const pixels = width * height;

        // ç®€å•çš„ç ç‡ä¼°ç®—å…¬å¼
        if (pixels &lt;= 640 * 480) return 500000;      // 500kbps
        if (pixels &lt;= 1280 * 720) return 1500000;    // 1.5Mbps
        if (pixels &lt;= 1920 * 1080) return 3000000;   // 3Mbps
        return 5000000;  // 5Mbps
    }

    // æ ¹æ®ç½‘ç»œçŠ¶å†µè‡ªé€‚åº”è°ƒæ•´è´¨é‡
    async adaptiveQuality(networkStats) {
        const { packetLoss, rtt, bandwidth } = networkStats;

        if (packetLoss &gt; 0.05) {  // ä¸¢åŒ…ç‡ &gt; 5%
            // é™ä½ç ç‡
            await this.setBitrate(bandwidth * 0.7);
        } else if (packetLoss &lt; 0.01 &amp;&amp; rtt &lt; 100) {  // ç½‘ç»œè‰¯å¥½
            // æå‡ç ç‡
            await this.setBitrate(bandwidth * 0.9);
        }
    }
}
</code></pre>
<h3 id="23-å±å¹•å…±äº«"><a class="header" href="#23-å±å¹•å…±äº«">2.3 å±å¹•å…±äº«</a></h3>
<h4 id="getdisplaymedia-api"><a class="header" href="#getdisplaymedia-api">getDisplayMedia API</a></h4>
<pre><code class="language-javascript">class ScreenShare {
    constructor() {
        this.screenStream = null;
    }

    async start(options = {}) {
        const defaultOptions = {
            video: {
                cursor: 'always',           // æ˜¾ç¤ºé¼ æ ‡
                displaySurface: 'monitor',  // æ•´ä¸ªå±å¹•
                logicalSurface: true,
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                frameRate: { ideal: 30 }
            },
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                sampleRate: 44100
            }
        };

        try {
            this.screenStream = await navigator.mediaDevices.getDisplayMedia({
                ...defaultOptions,
                ...options
            });

            // ç›‘å¬ç”¨æˆ·åœæ­¢å…±äº«
            this.screenStream.getVideoTracks()[0].onended = () =&gt; {
                console.log('ç”¨æˆ·åœæ­¢äº†å±å¹•å…±äº«');
                this.onStopped?.();
            };

            return this.screenStream;
        } catch (error) {
            console.error('å±å¹•å…±äº«å¤±è´¥:', error);
            throw error;
        }
    }

    // åœæ­¢å±å¹•å…±äº«
    stop() {
        if (this.screenStream) {
            this.screenStream.getTracks().forEach(track =&gt; track.stop());
            this.screenStream = null;
        }
    }

    // åˆ‡æ¢æ‘„åƒå¤´å’Œå±å¹•å…±äº«
    async switchToScreen(peerConnection, cameraStream) {
        // è·å–å±å¹•æµ
        const screenStream = await this.start();

        // è·å–å‘é€å™¨
        const videoSender = peerConnection.getSenders().find(sender =&gt;
            sender.track &amp;&amp; sender.track.kind === 'video'
        );

        if (videoSender) {
            // æ›¿æ¢è½¨é“
            await videoSender.replaceTrack(screenStream.getVideoTracks()[0]);

            // ä¿å­˜æ‘„åƒå¤´æµä»¥ä¾¿åˆ‡æ¢å›æ¥
            this.savedCameraStream = cameraStream;
        }

        return screenStream;
    }

    // åˆ‡æ¢å›æ‘„åƒå¤´
    async switchToCamera(peerConnection) {
        if (!this.savedCameraStream) return;

        const videoSender = peerConnection.getSenders().find(sender =&gt;
            sender.track &amp;&amp; sender.track.kind === 'video'
        );

        if (videoSender) {
            await videoSender.replaceTrack(
                this.savedCameraStream.getVideoTracks()[0]
            );
        }

        // åœæ­¢å±å¹•å…±äº«
        this.stop();
    }
}
</code></pre>
<h4 id="åº”ç”¨çª—å£æ•è·"><a class="header" href="#åº”ç”¨çª—å£æ•è·">åº”ç”¨çª—å£æ•è·</a></h4>
<pre><code class="language-javascript">// Chromeç‰¹å®šï¼šæ•è·ç‰¹å®šåº”ç”¨çª—å£
async function captureWindow() {
    try {
        // æç¤ºç”¨æˆ·é€‰æ‹©çª—å£
        const stream = await navigator.mediaDevices.getDisplayMedia({
            video: {
                displaySurface: 'window',  // ä»…æ˜¾ç¤ºçª—å£é€‰é¡¹
                cursor: 'always'
            }
        });

        return stream;
    } catch (error) {
        console.error('çª—å£æ•è·å¤±è´¥:', error);
        throw error;
    }
}

// æ•è·ç‰¹å®šæµè§ˆå™¨æ ‡ç­¾é¡µï¼ˆChromeæ‰©å±•ï¼‰
async function captureTab(tabId) {
    // éœ€è¦Chromeæ‰©å±•æƒé™ï¼štabCapture
    return new Promise((resolve, reject) =&gt; {
        chrome.tabCapture.capture({
            video: true,
            audio: true
        }, (stream) =&gt; {
            if (chrome.runtime.lastError) {
                reject(chrome.runtime.lastError);
            } else {
                resolve(stream);
            }
        });
    });
}
</code></pre>
<hr />
<h2 id="3-ç½‘ç»œè¿æ¥"><a class="header" href="#3-ç½‘ç»œè¿æ¥">3. ç½‘ç»œè¿æ¥</a></h2>
<h3 id="31-ä¿¡ä»¤è¿‡ç¨‹"><a class="header" href="#31-ä¿¡ä»¤è¿‡ç¨‹">3.1 ä¿¡ä»¤è¿‡ç¨‹</a></h3>
<h4 id="offeranswer-æœºåˆ¶"><a class="header" href="#offeranswer-æœºåˆ¶">Offer/Answer æœºåˆ¶</a></h4>
<p><strong>å®Œæ•´ä¿¡ä»¤æµç¨‹</strong>ï¼š</p>
<pre><code class="language-javascript">class SignalingController {
    constructor(peerConnection, signalingChannel) {
        this.pc = peerConnection;
        this.channel = signalingChannel;

        this.setupSignalingHandlers();
    }

    setupSignalingHandlers() {
        // æ¥æ”¶ä¿¡ä»¤æ¶ˆæ¯
        this.channel.on('message', async (message) =&gt; {
            switch (message.type) {
                case 'offer':
                    await this.handleOffer(message);
                    break;

                case 'answer':
                    await this.handleAnswer(message);
                    break;

                case 'ice-candidate':
                    await this.handleIceCandidate(message);
                    break;
            }
        });
    }

    // åˆ›å»ºå¹¶å‘é€Offer
    async createOffer() {
        try {
            const offer = await this.pc.createOffer({
                offerToReceiveAudio: true,
                offerToReceiveVideo: true,
                iceRestart: false
            });

            await this.pc.setLocalDescription(offer);

            // å‘é€offeråˆ°å¯¹ç«¯
            this.channel.send({
                type: 'offer',
                sdp: offer.sdp
            });

            console.log('Offerå·²å‘é€');
        } catch (error) {
            console.error('åˆ›å»ºOfferå¤±è´¥:', error);
            throw error;
        }
    }

    // å¤„ç†æ¥æ”¶åˆ°çš„Offer
    async handleOffer(message) {
        try {
            await this.pc.setRemoteDescription(
                new RTCSessionDescription({
                    type: 'offer',
                    sdp: message.sdp
                })
            );

            // åˆ›å»ºAnswer
            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);

            // å‘é€answeråˆ°å¯¹ç«¯
            this.channel.send({
                type: 'answer',
                sdp: answer.sdp
            });

            console.log('Answerå·²å‘é€');
        } catch (error) {
            console.error('å¤„ç†Offerå¤±è´¥:', error);
            throw error;
        }
    }

    // å¤„ç†æ¥æ”¶åˆ°çš„Answer
    async handleAnswer(message) {
        try {
            await this.pc.setRemoteDescription(
                new RTCSessionDescription({
                    type: 'answer',
                    sdp: message.sdp
                })
            );

            console.log('Answerå·²æ¥æ”¶');
        } catch (error) {
            console.error('å¤„ç†Answerå¤±è´¥:', error);
            throw error;
        }
    }

    // å¤„ç†ICEå€™é€‰
    async handleIceCandidate(message) {
        try {
            if (message.candidate) {
                await this.pc.addIceCandidate(
                    new RTCIceCandidate(message.candidate)
                );
            }
        } catch (error) {
            console.error('æ·»åŠ ICEå€™é€‰å¤±è´¥:', error);
        }
    }
}
</code></pre>
<h4 id="sdp-åè®®"><a class="header" href="#sdp-åè®®">SDP åè®®</a></h4>
<p><strong>SDPç»“æ„è§£æ</strong>ï¼š</p>
<pre><code>v=0                                    â† ç‰ˆæœ¬
o=- 123456 2 IN IP4 127.0.0.1         â† ä¼šè¯å‘èµ·è€…
s=-                                    â† ä¼šè¯å
t=0 0                                  â† æ—¶é—´
a=group:BUNDLE 0 1                     â† Bundleç»„ï¼ˆå¤šè·¯å¤ç”¨ï¼‰
a=msid-semantic: WMS stream_id         â† åª’ä½“æµæ ‡è¯†

m=audio 9 UDP/TLS/RTP/SAVPF 111 103   â† éŸ³é¢‘åª’ä½“æè¿°
c=IN IP4 0.0.0.0                       â† è¿æ¥åœ°å€
a=rtcp:9 IN IP4 0.0.0.0               â† RTCPåœ°å€
a=ice-ufrag:xxxx                       â† ICEç”¨æˆ·åç‰‡æ®µ
a=ice-pwd:xxxx                         â† ICEå¯†ç 
a=fingerprint:sha-256 ...              â† DTLSæŒ‡çº¹
a=setup:actpass                        â† DTLSè§’è‰²
a=mid:0                                â† åª’ä½“ID
a=sendrecv                             â† åª’ä½“æ–¹å‘
a=rtcp-mux                             â† RTCPå¤ç”¨
a=rtpmap:111 opus/48000/2             â† ç¼–è§£ç å™¨æ˜ å°„
a=fmtp:111 minptime=10;useinbandfec=1 â† æ ¼å¼å‚æ•°
a=ssrc:12345 cname:xxx                â† SSRCå’ŒCNAME

m=video 9 UDP/TLS/RTP/SAVPF 96 97     â† è§†é¢‘åª’ä½“æè¿°
...
</code></pre>
<p><strong>SDPæ“ä½œå·¥å…·</strong>ï¼š</p>
<pre><code class="language-javascript">class SDPManipulator {
    constructor(sdp) {
        this.sdp = sdp;
        this.lines = sdp.split('\r\n');
    }

    // è®¾ç½®ç ç‡
    setBitrate(mediaType, bitrate) {
        const pattern = new RegExp(`m=${mediaType}.*`);
        const mLineIndex = this.lines.findIndex(line =&gt; pattern.test(line));

        if (mLineIndex === -1) return this;

        // æ‰¾åˆ°å¯¹åº”çš„b=è¡Œ
        let bLineIndex = -1;
        for (let i = mLineIndex + 1; i &lt; this.lines.length; i++) {
            if (this.lines[i].startsWith('m=')) break;

            if (this.lines[i].startsWith('b=AS:')) {
                bLineIndex = i;
                break;
            }
        }

        const bLine = `b=AS:${bitrate}`;

        if (bLineIndex !== -1) {
            this.lines[bLineIndex] = bLine;
        } else {
            this.lines.splice(mLineIndex + 1, 0, bLine);
        }

        return this;
    }

    // ç§»é™¤ç¼–è§£ç å™¨
    removeCodec(codec) {
        // æ‰¾åˆ°å¹¶ç§»é™¤æŒ‡å®šç¼–è§£ç å™¨çš„æ‰€æœ‰ç›¸å…³è¡Œ
        this.lines = this.lines.filter(line =&gt; {
            return !line.includes(codec) ||
                   (!line.startsWith('a=rtpmap:') &amp;&amp;
                    !line.startsWith('a=fmtp:'));
        });

        return this;
    }

    // å¯ç”¨simulcast
    enableSimulcast() {
        const videoMLineIndex = this.lines.findIndex(line =&gt;
            line.startsWith('m=video')
        );

        if (videoMLineIndex === -1) return this;

        // æ·»åŠ simulcastå±æ€§
        const simulcastLine = 'a=simulcast:send 1;2;3';
        const rid1 = 'a=rid:1 send';
        const rid2 = 'a=rid:2 send';
        const rid3 = 'a=rid:3 send';

        this.lines.splice(videoMLineIndex + 1, 0,
            simulcastLine, rid1, rid2, rid3
        );

        return this;
    }

    // è¾“å‡ºSDP
    toString() {
        return this.lines.join('\r\n');
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const manipulator = new SDPManipulator(offer.sdp);
manipulator
    .setBitrate('video', 2000)
    .removeCodec('H265')
    .enableSimulcast();

offer.sdp = manipulator.toString();
</code></pre>
<hr />
<h2 id="æœªå®Œå¾…ç»­"><a class="header" href="#æœªå®Œå¾…ç»­">(æœªå®Œå¾…ç»­)</a></h2>
<p>ç”±äºç¯‡å¹…é™åˆ¶ï¼ŒWebRTCç¬”è®°çš„å‰©ä½™éƒ¨åˆ†ï¼ˆICEå€™é€‰ã€STUN/TURNã€è¿æ¥å»ºç«‹ç­‰ï¼‰å°†åˆ›å»ºè¡¥å……æ–‡ä»¶ç»§ç»­ã€‚</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ç¼–ç¨‹/video/RTSP_å®è·µæŒ‡å—.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ç¼–ç¨‹/video/WebRTC_å®è·µæŒ‡å—.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ç¼–ç¨‹/video/RTSP_å®è·µæŒ‡å—.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ç¼–ç¨‹/video/WebRTC_å®è·µæŒ‡å—.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

