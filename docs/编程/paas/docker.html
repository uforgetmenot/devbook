<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docker 容器化技术学习笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="docker-容器化技术学习笔记"><a class="header" href="#docker-容器化技术学习笔记">Docker 容器化技术学习笔记</a></h1>
<blockquote>
<p><strong>学习目标</strong>: 掌握Docker容器技术的核心原理、镜像构建、容器编排，能够在生产环境中部署和管理容器化应用</p>
<p><strong>适用人群</strong>: 后端开发工程师、运维工程师、DevOps工程师</p>
<p><strong>前置知识</strong>: Linux基础、进程管理、网络基础</p>
</blockquote>
<hr />
<h2 id="1-docker-基础概念"><a class="header" href="#1-docker-基础概念">1. Docker 基础概念</a></h2>
<h3 id="11-容器化技术"><a class="header" href="#11-容器化技术">1.1 容器化技术</a></h3>
<p><strong>什么是容器？</strong></p>
<p>容器是一种轻量级的虚拟化技术，将应用及其依赖打包在一起，提供隔离的运行环境。</p>
<p><strong>容器 vs 虚拟机</strong></p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody>
<tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr>
<tr><td>资源占用</td><td>MB级</td><td>GB级</td></tr>
<tr><td>性能</td><td>接近原生</td><td>有损耗</td></tr>
<tr><td>隔离级别</td><td>进程级</td><td>操作系统级</td></tr>
<tr><td>系统支持</td><td>共享宿主机内核</td><td>独立内核</td></tr>
</tbody></table>
</div>
<p><strong>架构对比</strong>:</p>
<pre><code>传统虚拟机架构:
应用 → Guest OS → Hypervisor → Host OS → 硬件

容器架构:
应用 → Docker Engine → Host OS → 硬件
</code></pre>
<p><strong>核心优势</strong>:</p>
<ul>
<li><strong>一致性</strong>: 开发、测试、生产环境完全一致</li>
<li><strong>轻量级</strong>: 共享内核，资源占用少</li>
<li><strong>快速部署</strong>: 秒级启动，快速扩缩容</li>
<li><strong>版本控制</strong>: 镜像分层，易于回滚</li>
<li><strong>隔离性</strong>: 进程、网络、文件系统隔离</li>
</ul>
<h3 id="12-docker-核心组件"><a class="header" href="#12-docker-核心组件">1.2 Docker 核心组件</a></h3>
<p><strong>Docker架构图</strong>:</p>
<pre><code>┌─────────────────────────────────────────┐
│         Docker Client (CLI)             │
│         docker build/run/push           │
└────────────────┬────────────────────────┘
                 │ REST API
┌────────────────▼────────────────────────┐
│          Docker Daemon (dockerd)        │
│  ┌──────────┬──────────┬──────────┐    │
│  │  Images  │Containers│ Networks │    │
│  └──────────┴──────────┴──────────┘    │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│        containerd (运行时)               │
│             runc (OCI)                  │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>组件说明</strong>:</p>
<p><strong>1. Docker Engine</strong></p>
<ul>
<li><strong>Docker Daemon (dockerd)</strong>: 后台服务，管理镜像、容器、网络、存储</li>
<li><strong>containerd</strong>: 容器运行时，管理容器生命周期</li>
<li><strong>runc</strong>: OCI运行时实现，实际执行容器</li>
</ul>
<p><strong>2. Docker Client</strong></p>
<ul>
<li>命令行工具 <code>docker</code></li>
<li>通过REST API与Daemon通信</li>
</ul>
<p><strong>3. Docker Registry</strong></p>
<ul>
<li>存储和分发镜像</li>
<li>公共仓库: Docker Hub</li>
<li>私有仓库: Harbor, Registry</li>
</ul>
<p><strong>镜像、容器、仓库三要素</strong>:</p>
<pre><code>镜像 (Image): 只读模板，包含应用和依赖
容器 (Container): 镜像的运行实例
仓库 (Registry): 存储镜像的服务
</code></pre>
<hr />
<h2 id="2-docker-安装与配置"><a class="header" href="#2-docker-安装与配置">2. Docker 安装与配置</a></h2>
<h3 id="21-安装-docker"><a class="header" href="#21-安装-docker">2.1 安装 Docker</a></h3>
<p><strong>Linux (Ubuntu/Debian)</strong></p>
<pre><code class="language-bash"># 卸载旧版本
sudo apt-get remove docker docker-engine docker.io containerd runc

# 安装依赖
sudo apt-get update
sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

# 添加Docker官方GPG密钥
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
  sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

# 添加Docker仓库
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

# 安装Docker
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin

# 验证安装
sudo docker run hello-world
</code></pre>
<p><strong>CentOS/RHEL</strong></p>
<pre><code class="language-bash"># 安装依赖
sudo yum install -y yum-utils

# 添加Docker仓库
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 安装Docker
sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin

# 启动Docker
sudo systemctl start docker
sudo systemctl enable docker
</code></pre>
<p><strong>非root用户使用Docker</strong></p>
<pre><code class="language-bash"># 将用户添加到docker组
sudo usermod -aG docker $USER

# 重新登录生效
newgrp docker
</code></pre>
<h3 id="22-配置-docker"><a class="header" href="#22-配置-docker">2.2 配置 Docker</a></h3>
<p><strong>镜像加速器配置 (国内)</strong></p>
<pre><code class="language-bash"># 创建daemon配置
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  "registry-mirrors": [
    "https://mirror.ccs.tencentyun.com",
    "https://docker.mirrors.ustc.edu.cn",
    "https://hub-mirror.c.163.com"
  ],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "3"
  },
  "storage-driver": "overlay2"
}
EOF

# 重启Docker
sudo systemctl daemon-reload
sudo systemctl restart docker

# 验证配置
docker info
</code></pre>
<p><strong>存储驱动配置</strong></p>
<pre><code class="language-bash"># 推荐使用overlay2
# 查看当前驱动
docker info | grep "Storage Driver"

# 在/etc/docker/daemon.json中配置
{
  "storage-driver": "overlay2"
}
</code></pre>
<p><strong>网络配置</strong></p>
<pre><code class="language-bash"># 修改默认网桥
{
  "bip": "192.168.1.1/24",
  "default-address-pools": [
    {
      "base": "172.30.0.0/16",
      "size": 24
    }
  ]
}
</code></pre>
<hr />
<h2 id="3-docker-镜像管理"><a class="header" href="#3-docker-镜像管理">3. Docker 镜像管理</a></h2>
<h3 id="31-镜像基础操作"><a class="header" href="#31-镜像基础操作">3.1 镜像基础操作</a></h3>
<p><strong>拉取镜像</strong></p>
<pre><code class="language-bash"># 拉取最新版本
docker pull nginx

# 拉取指定版本
docker pull nginx:1.23.3

# 拉取指定平台镜像
docker pull --platform linux/amd64 nginx
</code></pre>
<p><strong>查看镜像</strong></p>
<pre><code class="language-bash"># 列出所有镜像
docker images
docker image ls

# 查看镜像详细信息
docker inspect nginx:latest

# 查看镜像历史
docker history nginx:latest

# 查看镜像层
docker image inspect nginx:latest --format='{{.RootFS.Layers}}'
</code></pre>
<p><strong>删除镜像</strong></p>
<pre><code class="language-bash"># 删除单个镜像
docker rmi nginx:latest

# 删除所有悬空镜像
docker image prune

# 删除所有未使用的镜像
docker image prune -a

# 强制删除
docker rmi -f nginx:latest
</code></pre>
<p><strong>镜像标签管理</strong></p>
<pre><code class="language-bash"># 打标签
docker tag nginx:latest myregistry.com/nginx:v1.0

# 推送到仓库
docker push myregistry.com/nginx:v1.0

# 保存镜像为文件
docker save nginx:latest -o nginx.tar

# 从文件加载镜像
docker load -i nginx.tar

# 导出容器为镜像
docker export container_id &gt; container.tar
docker import container.tar mynewimage:latest
</code></pre>
<h3 id="32-构建自定义镜像"><a class="header" href="#32-构建自定义镜像">3.2 构建自定义镜像</a></h3>
<p><strong>Dockerfile 语法</strong></p>
<p><strong>基础指令</strong>:</p>
<pre><code class="language-dockerfile"># 基础镜像
FROM ubuntu:20.04

# 维护者信息
LABEL maintainer="your@email.com"

# 环境变量
ENV APP_HOME=/app \
    APP_VERSION=1.0

# 工作目录
WORKDIR $APP_HOME

# 复制文件
COPY package.json .
COPY src/ ./src/

# 执行命令
RUN apt-get update &amp;&amp; \
    apt-get install -y nodejs npm &amp;&amp; \
    npm install &amp;&amp; \
    rm -rf /var/lib/apt/lists/*

# 暴露端口
EXPOSE 8080

# 挂载点
VOLUME ["/data"]

# 启动命令
CMD ["node", "server.js"]
</code></pre>
<p><strong>完整示例 - Node.js应用</strong>:</p>
<pre><code class="language-dockerfile">FROM node:18-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 生产镜像
FROM node:18-alpine

WORKDIR /app

# 创建非root用户
RUN addgroup -g 1001 -S nodejs &amp;&amp; \
    adduser -S nodejs -u 1001

# 从builder阶段复制文件
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

# 切换用户
USER nodejs

EXPOSE 3000

CMD ["node", "dist/main.js"]
</code></pre>
<p><strong>构建镜像</strong></p>
<pre><code class="language-bash"># 基本构建
docker build -t myapp:v1.0 .

# 指定Dockerfile
docker build -f Dockerfile.prod -t myapp:prod .

# 使用构建参数
docker build --build-arg NODE_ENV=production -t myapp:v1.0 .

# 不使用缓存
docker build --no-cache -t myapp:v1.0 .

# 多平台构建
docker buildx build --platform linux/amd64,linux/arm64 -t myapp:v1.0 .
</code></pre>
<p><strong>多阶段构建</strong></p>
<pre><code class="language-dockerfile"># 阶段1: 编译
FROM golang:1.19 AS builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 go build -o main .

# 阶段2: 运行
FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/main .
CMD ["./main"]
</code></pre>
<p><strong>镜像优化策略</strong>:</p>
<ol>
<li><strong>使用小基础镜像</strong></li>
</ol>
<pre><code class="language-dockerfile"># 不推荐 (1GB+)
FROM ubuntu:20.04

# 推荐 (5MB)
FROM alpine:3.17

# 推荐 (更小)
FROM scratch  # 仅适用于静态编译程序
</code></pre>
<ol start="2">
<li><strong>合并RUN指令</strong></li>
</ol>
<pre><code class="language-dockerfile"># 不推荐
RUN apt-get update
RUN apt-get install -y nginx
RUN apt-get clean

# 推荐
RUN apt-get update &amp;&amp; \
    apt-get install -y nginx &amp;&amp; \
    apt-get clean &amp;&amp; \
    rm -rf /var/lib/apt/lists/*
</code></pre>
<ol start="3">
<li><strong>利用构建缓存</strong></li>
</ol>
<pre><code class="language-dockerfile"># 先复制依赖文件,再复制源码
COPY package.json .
RUN npm install
COPY . .
</code></pre>
<ol start="4">
<li><strong>.dockerignore文件</strong></li>
</ol>
<pre><code># .dockerignore
node_modules
*.log
.git
.env
README.md
</code></pre>
<hr />
<h2 id="4-docker-容器管理"><a class="header" href="#4-docker-容器管理">4. Docker 容器管理</a></h2>
<h3 id="41-容器生命周期"><a class="header" href="#41-容器生命周期">4.1 容器生命周期</a></h3>
<p><strong>创建和运行容器</strong></p>
<pre><code class="language-bash"># 创建但不启动
docker create --name mynginx nginx

# 启动已创建的容器
docker start mynginx

# 创建并启动 (最常用)
docker run -d --name mynginx -p 80:80 nginx

# 交互式运行
docker run -it ubuntu:20.04 /bin/bash

# 运行后自动删除
docker run --rm alpine echo "Hello"
</code></pre>
<p><strong>docker run 常用参数</strong>:</p>
<pre><code class="language-bash">docker run \
  -d                      # 后台运行
  --name myapp           # 容器名称
  -p 8080:80             # 端口映射 主机:容器
  -v /data:/data         # 挂载卷
  -e ENV=production      # 环境变量
  --restart=always       # 重启策略
  --memory=1g            # 内存限制
  --cpus=2               # CPU限制
  --network=mynet        # 网络
  --link db:database     # 链接其他容器(已废弃)
  nginx:latest
</code></pre>
<p><strong>停止和删除</strong></p>
<pre><code class="language-bash"># 停止容器
docker stop mynginx

# 强制停止
docker kill mynginx

# 删除容器
docker rm mynginx

# 停止并删除
docker rm -f mynginx

# 删除所有停止的容器
docker container prune

# 批量删除
docker rm -f $(docker ps -aq)
</code></pre>
<h3 id="42-容器操作"><a class="header" href="#42-容器操作">4.2 容器操作</a></h3>
<p><strong>进入容器</strong></p>
<pre><code class="language-bash"># exec方式 (推荐)
docker exec -it mynginx /bin/bash

# 以root用户进入
docker exec -it -u root mynginx /bin/bash

# 执行单条命令
docker exec mynginx ls /var/log
</code></pre>
<p><strong>查看容器</strong></p>
<pre><code class="language-bash"># 列出运行中的容器
docker ps

# 列出所有容器
docker ps -a

# 查看容器详情
docker inspect mynginx

# 查看容器端口映射
docker port mynginx

# 查看容器进程
docker top mynginx

# 查看容器文件系统变化
docker diff mynginx
</code></pre>
<p><strong>容器日志</strong></p>
<pre><code class="language-bash"># 查看日志
docker logs mynginx

# 实时查看日志
docker logs -f mynginx

# 查看最后100行
docker logs --tail 100 mynginx

# 显示时间戳
docker logs -t mynginx

# 查看指定时间后的日志
docker logs --since 2023-01-01T00:00:00 mynginx
</code></pre>
<p><strong>容器监控</strong></p>
<pre><code class="language-bash"># 实时查看资源使用
docker stats

# 查看指定容器
docker stats mynginx

# 查看容器事件
docker events

# 查看容器资源限制
docker inspect mynginx --format='{{.HostConfig.Memory}}'
</code></pre>
<p><strong>容器导入导出</strong></p>
<pre><code class="language-bash"># 提交容器为镜像
docker commit mynginx mynginx:v1.0

# 复制文件到容器
docker cp localfile.txt mynginx:/path/

# 从容器复制文件
docker cp mynginx:/path/file.txt ./
</code></pre>
<hr />
<h2 id="5-docker-数据管理"><a class="header" href="#5-docker-数据管理">5. Docker 数据管理</a></h2>
<h3 id="51-数据卷-volumes"><a class="header" href="#51-数据卷-volumes">5.1 数据卷 (Volumes)</a></h3>
<p>数据卷是Docker管理的持久化存储，存储在宿主机的 <code>/var/lib/docker/volumes/</code> 中。</p>
<p><strong>创建和管理</strong></p>
<pre><code class="language-bash"># 创建数据卷
docker volume create mydata

# 列出所有卷
docker volume ls

# 查看卷详情
docker volume inspect mydata

# 删除卷
docker volume rm mydata

# 清理未使用的卷
docker volume prune
</code></pre>
<p><strong>使用数据卷</strong></p>
<pre><code class="language-bash"># 挂载命名卷
docker run -d --name db \
  -v mydata:/var/lib/mysql \
  mysql:8.0

# 挂载匿名卷
docker run -d --name app \
  -v /app/data \
  myapp:latest

# 只读挂载
docker run -d --name nginx \
  -v mydata:/usr/share/nginx/html:ro \
  nginx
</code></pre>
<p><strong>数据卷备份与恢复</strong></p>
<pre><code class="language-bash"># 备份数据卷
docker run --rm \
  -v mydata:/source \
  -v $(pwd):/backup \
  alpine tar czf /backup/backup.tar.gz /source

# 恢复数据卷
docker run --rm \
  -v mydata:/target \
  -v $(pwd):/backup \
  alpine tar xzf /backup/backup.tar.gz -C /target --strip 1
</code></pre>
<h3 id="52-绑定挂载-bind-mounts"><a class="header" href="#52-绑定挂载-bind-mounts">5.2 绑定挂载 (Bind Mounts)</a></h3>
<p>直接将宿主机目录挂载到容器。</p>
<pre><code class="language-bash"># 挂载宿主机目录
docker run -d --name web \
  -v /home/user/website:/usr/share/nginx/html \
  nginx

# 使用--mount (推荐,更明确)
docker run -d --name web \
  --mount type=bind,source=/home/user/website,target=/usr/share/nginx/html \
  nginx

# 只读挂载
docker run -d --name web \
  -v /home/user/website:/usr/share/nginx/html:ro \
  nginx
</code></pre>
<p><strong>权限管理</strong></p>
<pre><code class="language-bash"># 容器内用户权限问题
# 方案1: 修改宿主机目录权限
sudo chown -R 1000:1000 /data

# 方案2: 指定容器运行用户
docker run -d --user 1000:1000 \
  -v /data:/data \
  myapp:latest
</code></pre>
<h3 id="53-临时文件系统-tmpfs"><a class="header" href="#53-临时文件系统-tmpfs">5.3 临时文件系统 (tmpfs)</a></h3>
<p>基于内存的临时存储。</p>
<pre><code class="language-bash"># 挂载tmpfs
docker run -d --name app \
  --tmpfs /tmp:rw,size=100m,mode=1777 \
  myapp:latest

# 使用--mount
docker run -d --name app \
  --mount type=tmpfs,target=/tmp,tmpfs-size=104857600 \
  myapp:latest
</code></pre>
<hr />
<h2 id="6-docker-网络"><a class="header" href="#6-docker-网络">6. Docker 网络</a></h2>
<h3 id="61-网络模式"><a class="header" href="#61-网络模式">6.1 网络模式</a></h3>
<p><strong>1. bridge (默认)</strong></p>
<pre><code class="language-bash"># 默认网桥模式
docker run -d --name web nginx

# 容器可以访问外网,外网通过端口映射访问容器
docker run -d -p 8080:80 nginx
</code></pre>
<p><strong>2. host</strong></p>
<pre><code class="language-bash"># 与宿主机共享网络栈
docker run -d --network host nginx

# 直接使用宿主机端口,性能最好
# 注意: 端口冲突风险
</code></pre>
<p><strong>3. none</strong></p>
<pre><code class="language-bash"># 无网络
docker run -d --network none alpine

# 适用于安全隔离场景
</code></pre>
<p><strong>4. overlay (Swarm/Kubernetes)</strong></p>
<pre><code class="language-bash"># 跨主机通信
docker network create -d overlay myoverlay
</code></pre>
<h3 id="62-自定义网络"><a class="header" href="#62-自定义网络">6.2 自定义网络</a></h3>
<p><strong>创建网络</strong></p>
<pre><code class="language-bash"># 创建bridge网络
docker network create mynet

# 指定子网
docker network create --subnet=172.18.0.0/16 mynet

# 指定网关
docker network create \
  --subnet=172.18.0.0/16 \
  --gateway=172.18.0.1 \
  mynet
</code></pre>
<p><strong>容器连接网络</strong></p>
<pre><code class="language-bash"># 创建时指定网络
docker run -d --name web --network mynet nginx

# 连接到网络
docker network connect mynet existing-container

# 断开网络
docker network disconnect mynet existing-container

# 查看网络详情
docker network inspect mynet
</code></pre>
<p><strong>容器间通信</strong></p>
<pre><code class="language-bash"># 在同一网络中,容器可通过容器名通信
docker network create app-net

docker run -d --name db --network app-net mysql:8.0
docker run -d --name web --network app-net nginx

# web容器中可以通过 db:3306 访问数据库
</code></pre>
<h3 id="63-端口映射"><a class="header" href="#63-端口映射">6.3 端口映射</a></h3>
<pre><code class="language-bash"># 映射到随机端口
docker run -d -P nginx

# 映射到指定端口
docker run -d -p 8080:80 nginx

# 映射到指定IP
docker run -d -p 127.0.0.1:8080:80 nginx

# 映射多个端口
docker run -d -p 80:80 -p 443:443 nginx

# 映射UDP端口
docker run -d -p 53:53/udp dnsserver

# 查看端口映射
docker port nginx
</code></pre>
<hr />
<h2 id="7-docker-compose"><a class="header" href="#7-docker-compose">7. Docker Compose</a></h2>
<h3 id="71-compose-基础"><a class="header" href="#71-compose-基础">7.1 Compose 基础</a></h3>
<p><strong>docker-compose.yml 语法</strong></p>
<p><strong>基本结构</strong>:</p>
<pre><code class="language-yaml">version: '3.8'

services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
    environment:
      - NGINX_HOST=localhost
      - NGINX_PORT=80

  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: mydb
    volumes:
      - db-data:/var/lib/mysql

volumes:
  db-data:

networks:
  default:
    driver: bridge
</code></pre>
<p><strong>完整示例 - WordPress</strong>:</p>
<pre><code class="language-yaml">version: '3.8'

services:
  wordpress:
    image: wordpress:latest
    restart: always
    ports:
      - "8080:80"
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    volumes:
      - wordpress:/var/www/html
    depends_on:
      - db
    networks:
      - wp-net

  db:
    image: mysql:8.0
    restart: always
    environment:
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress
      MYSQL_ROOT_PASSWORD: rootpassword
    volumes:
      - db:/var/lib/mysql
    networks:
      - wp-net

volumes:
  wordpress:
  db:

networks:
  wp-net:
    driver: bridge
</code></pre>
<h3 id="72-多容器应用"><a class="header" href="#72-多容器应用">7.2 多容器应用</a></h3>
<p><strong>微服务示例</strong>:</p>
<pre><code class="language-yaml">version: '3.8'

services:
  # API网关
  gateway:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - user-service
      - order-service
    networks:
      - app-net

  # 用户服务
  user-service:
    build:
      context: ./user-service
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://db:5432/users
    depends_on:
      - postgres
    networks:
      - app-net
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  # 订单服务
  order-service:
    build: ./order-service
    environment:
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
    networks:
      - app-net

  # PostgreSQL数据库
  postgres:
    image: postgres:14-alpine
    environment:
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-net

  # Redis缓存
  redis:
    image: redis:7-alpine
    networks:
      - app-net

volumes:
  postgres-data:

networks:
  app-net:
    driver: bridge
</code></pre>
<h3 id="73-compose-命令"><a class="header" href="#73-compose-命令">7.3 Compose 命令</a></h3>
<p><strong>基本命令</strong>:</p>
<pre><code class="language-bash"># 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose stop

# 停止并删除容器
docker-compose down

# 停止并删除容器、网络、卷
docker-compose down -v
</code></pre>
<p><strong>管理命令</strong>:</p>
<pre><code class="language-bash"># 构建镜像
docker-compose build

# 拉取镜像
docker-compose pull

# 重启服务
docker-compose restart web

# 暂停服务
docker-compose pause web

# 恢复服务
docker-compose unpause web

# 执行命令
docker-compose exec web sh

# 扩容服务
docker-compose up -d --scale web=3
</code></pre>
<p><strong>其他命令</strong>:</p>
<pre><code class="language-bash"># 验证配置文件
docker-compose config

# 查看镜像
docker-compose images

# 查看端口
docker-compose port web 80

# 查看事件
docker-compose events

# 删除停止的容器
docker-compose rm
</code></pre>
<hr />
<h2 id="8-docker-仓库管理"><a class="header" href="#8-docker-仓库管理">8. Docker 仓库管理</a></h2>
<h3 id="81-公共仓库---docker-hub"><a class="header" href="#81-公共仓库---docker-hub">8.1 公共仓库 - Docker Hub</a></h3>
<p><strong>登录和推送</strong></p>
<pre><code class="language-bash"># 登录Docker Hub
docker login

# 打标签
docker tag myapp:latest username/myapp:latest

# 推送镜像
docker push username/myapp:latest

# 拉取镜像
docker pull username/myapp:latest

# 登出
docker logout
</code></pre>
<p><strong>自动构建</strong></p>
<pre><code class="language-yaml"># 在Docker Hub关联GitHub仓库
# 创建Dockerfile
# 配置自动构建规则
# 每次git push时自动构建镜像
</code></pre>
<h3 id="82-私有仓库"><a class="header" href="#82-私有仓库">8.2 私有仓库</a></h3>
<p><strong>方式1: Docker Registry</strong></p>
<pre><code class="language-bash"># 启动Registry
docker run -d -p 5000:5000 \
  --name registry \
  -v /data/registry:/var/lib/registry \
  registry:2

# 推送镜像
docker tag myapp:latest localhost:5000/myapp:latest
docker push localhost:5000/myapp:latest

# 拉取镜像
docker pull localhost:5000/myapp:latest
</code></pre>
<p><strong>方式2: Harbor (企业级)</strong></p>
<p>Harbor提供Web UI、RBAC、镜像扫描、复制等功能。</p>
<p><strong>安装Harbor</strong>:</p>
<pre><code class="language-bash"># 下载Harbor
wget https://github.com/goharbor/harbor/releases/download/v2.7.0/harbor-offline-installer-v2.7.0.tgz
tar xvf harbor-offline-installer-v2.7.0.tgz
cd harbor

# 修改配置
cp harbor.yml.tmpl harbor.yml
vim harbor.yml
# 修改hostname、数据目录等

# 安装
sudo ./install.sh

# 访问 http://your-harbor-host
# 默认用户名: admin
# 默认密码: Harbor12345
</code></pre>
<p><strong>使用Harbor</strong>:</p>
<pre><code class="language-bash"># 登录Harbor
docker login harbor.example.com

# 推送镜像
docker tag myapp:latest harbor.example.com/library/myapp:latest
docker push harbor.example.com/library/myapp:latest

# 拉取镜像
docker pull harbor.example.com/library/myapp:latest
</code></pre>
<hr />
<h2 id="9-docker-安全"><a class="header" href="#9-docker-安全">9. Docker 安全</a></h2>
<h3 id="91-容器安全"><a class="header" href="#91-容器安全">9.1 容器安全</a></h3>
<p><strong>用户权限管理</strong></p>
<pre><code class="language-bash"># 以非root用户运行
docker run -d --user 1000:1000 nginx

# Dockerfile中创建用户
FROM node:18-alpine
RUN addgroup -g 1001 -S nodejs &amp;&amp; \
    adduser -S nodejs -u 1001
USER nodejs
</code></pre>
<p><strong>资源限制</strong></p>
<pre><code class="language-bash"># CPU限制
docker run -d --cpus=2 nginx                 # 2个CPU
docker run -d --cpu-shares=512 nginx         # CPU权重

# 内存限制
docker run -d --memory=1g nginx              # 最大1GB
docker run -d --memory=1g --memory-swap=2g nginx  # 内存+交换

# IO限制
docker run -d --device-read-bps /dev/sda:1mb nginx
docker run -d --device-write-bps /dev/sda:1mb nginx
</code></pre>
<p><strong>安全策略</strong></p>
<pre><code class="language-bash"># 只读文件系统
docker run -d --read-only nginx

# 禁止特权模式
docker run -d --security-opt=no-new-privileges nginx

# 限制capabilities
docker run -d --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx

# AppArmor/SELinux
docker run -d --security-opt apparmor=docker-default nginx
</code></pre>
<h3 id="92-镜像安全"><a class="header" href="#92-镜像安全">9.2 镜像安全</a></h3>
<p><strong>镜像扫描</strong></p>
<pre><code class="language-bash"># 使用Docker Scout扫描
docker scout cves nginx:latest

# 使用Trivy扫描
trivy image nginx:latest

# 使用Clair扫描
# Harbor集成Clair进行扫描
</code></pre>
<p><strong>最小化镜像</strong></p>
<pre><code class="language-dockerfile"># 使用精简基础镜像
FROM alpine:3.17

# 多阶段构建
FROM golang:1.19 AS builder
WORKDIR /app
COPY . .
RUN go build -o app

FROM scratch
COPY --from=builder /app/app /app
CMD ["/app"]

# 删除不必要文件
RUN rm -rf /tmp/* /var/cache/apk/*
</code></pre>
<p><strong>镜像签名</strong></p>
<pre><code class="language-bash"># 启用Docker Content Trust
export DOCKER_CONTENT_TRUST=1

# 推送签名镜像
docker push myimage:signed

# 只拉取签名镜像
docker pull myimage:signed
</code></pre>
<hr />
<h2 id="10-生产环境最佳实践"><a class="header" href="#10-生产环境最佳实践">10. 生产环境最佳实践</a></h2>
<h3 id="101-dockerfile最佳实践"><a class="header" href="#101-dockerfile最佳实践">10.1 Dockerfile最佳实践</a></h3>
<pre><code class="language-dockerfile"># 1. 使用官方基础镜像
FROM node:18-alpine

# 2. 设置工作目录
WORKDIR /app

# 3. 复制依赖文件优先(利用缓存)
COPY package*.json ./

# 4. 安装依赖
RUN npm ci --only=production &amp;&amp; \
    npm cache clean --force

# 5. 复制源代码
COPY . .

# 6. 创建非root用户
RUN addgroup -g 1001 -S nodejs &amp;&amp; \
    adduser -S nodejs -u 1001 &amp;&amp; \
    chown -R nodejs:nodejs /app

# 7. 切换用户
USER nodejs

# 8. 暴露端口
EXPOSE 3000

# 9. 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

# 10. 启动命令
CMD ["node", "server.js"]
</code></pre>
<h3 id="102-生产环境检查清单"><a class="header" href="#102-生产环境检查清单">10.2 生产环境检查清单</a></h3>
<p><strong>镜像</strong>:</p>
<ul>
<li><input disabled="" type="checkbox"/>
使用官方基础镜像</li>
<li><input disabled="" type="checkbox"/>
启用多阶段构建</li>
<li><input disabled="" type="checkbox"/>
镜像体积尽可能小</li>
<li><input disabled="" type="checkbox"/>
使用固定版本标签</li>
<li><input disabled="" type="checkbox"/>
定期更新基础镜像</li>
<li><input disabled="" type="checkbox"/>
进行安全扫描</li>
<li><input disabled="" type="checkbox"/>
添加健康检查</li>
</ul>
<p><strong>容器</strong>:</p>
<ul>
<li><input disabled="" type="checkbox"/>
以非root用户运行</li>
<li><input disabled="" type="checkbox"/>
设置资源限制(CPU/内存)</li>
<li><input disabled="" type="checkbox"/>
使用只读文件系统(如适用)</li>
<li><input disabled="" type="checkbox"/>
配置重启策略</li>
<li><input disabled="" type="checkbox"/>
设置日志驱动和限制</li>
<li><input disabled="" type="checkbox"/>
使用数据卷持久化数据</li>
<li><input disabled="" type="checkbox"/>
配置健康检查</li>
</ul>
<p><strong>网络</strong>:</p>
<ul>
<li><input disabled="" type="checkbox"/>
使用自定义网络</li>
<li><input disabled="" type="checkbox"/>
最小化端口暴露</li>
<li><input disabled="" type="checkbox"/>
使用TLS加密通信</li>
<li><input disabled="" type="checkbox"/>
配置防火墙规则</li>
</ul>
<p><strong>监控和日志</strong>:</p>
<ul>
<li><input disabled="" type="checkbox"/>
集成Prometheus监控</li>
<li><input disabled="" type="checkbox"/>
配置日志收集(ELK/Loki)</li>
<li><input disabled="" type="checkbox"/>
设置告警规则</li>
<li><input disabled="" type="checkbox"/>
定期备份数据</li>
</ul>
<h3 id="103-常见生产问题"><a class="header" href="#103-常见生产问题">10.3 常见生产问题</a></h3>
<p><strong>问题1: 容器时区问题</strong></p>
<pre><code class="language-dockerfile"># 方案1: 设置环境变量
ENV TZ=Asia/Shanghai

# 方案2: 挂载时区文件
docker run -v /etc/localtime:/etc/localtime:ro app
</code></pre>
<p><strong>问题2: 容器内存溢出</strong></p>
<pre><code class="language-bash"># 设置内存限制
docker run -m 1g --memory-swap 1g app

# 监控内存使用
docker stats
</code></pre>
<p><strong>问题3: 镜像拉取慢</strong></p>
<pre><code class="language-bash"># 配置镜像加速器(见2.2节)
# 或使用私有仓库
</code></pre>
<p><strong>问题4: 日志占满磁盘</strong></p>
<pre><code class="language-json">{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
</code></pre>
<hr />
<h2 id="11-学习验证"><a class="header" href="#11-学习验证">11. 学习验证</a></h2>
<h3 id="验证任务1-镜像管理"><a class="header" href="#验证任务1-镜像管理">验证任务1: 镜像管理</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
拉取nginx镜像</li>
<li><input disabled="" type="checkbox"/>
编写Dockerfile构建自定义镜像</li>
<li><input disabled="" type="checkbox"/>
推送镜像到Docker Hub</li>
</ul>
<h3 id="验证任务2-容器操作"><a class="header" href="#验证任务2-容器操作">验证任务2: 容器操作</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
运行nginx容器并映射端口</li>
<li><input disabled="" type="checkbox"/>
进入容器修改配置</li>
<li><input disabled="" type="checkbox"/>
查看容器日志和资源使用</li>
</ul>
<h3 id="验证任务3-数据持久化"><a class="header" href="#验证任务3-数据持久化">验证任务3: 数据持久化</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
创建数据卷</li>
<li><input disabled="" type="checkbox"/>
运行MySQL容器并挂载数据卷</li>
<li><input disabled="" type="checkbox"/>
验证数据持久化</li>
</ul>
<h3 id="验证任务4-docker-compose"><a class="header" href="#验证任务4-docker-compose">验证任务4: Docker Compose</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
编写docker-compose.yml部署WordPress</li>
<li><input disabled="" type="checkbox"/>
使用docker-compose管理多容器应用</li>
<li><input disabled="" type="checkbox"/>
实现服务扩容</li>
</ul>
<h3 id="验证任务5-生产部署"><a class="header" href="#验证任务5-生产部署">验证任务5: 生产部署</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
构建优化后的生产镜像</li>
<li><input disabled="" type="checkbox"/>
配置资源限制和健康检查</li>
<li><input disabled="" type="checkbox"/>
部署到生产环境并监控</li>
</ul>
<hr />
<h2 id="12-扩展资源"><a class="header" href="#12-扩展资源">12. 扩展资源</a></h2>
<h3 id="官方文档"><a class="header" href="#官方文档">官方文档</a></h3>
<ul>
<li>Docker官方文档: https://docs.docker.com/</li>
<li>Docker Hub: https://hub.docker.com/</li>
<li>Dockerfile参考: https://docs.docker.com/engine/reference/builder/</li>
</ul>
<h3 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h3>
<ul>
<li>Docker从入门到实践: https://yeasy.gitbook.io/docker_practice/</li>
<li>Play with Docker: https://labs.play-with-docker.com/</li>
</ul>
<h3 id="工具推荐"><a class="header" href="#工具推荐">工具推荐</a></h3>
<ul>
<li>Portainer: Docker可视化管理</li>
<li>Dive: 镜像层分析工具</li>
<li>Hadolint: Dockerfile检查工具</li>
<li>ctop: 容器资源监控</li>
</ul>
<h3 id="常见问题faq"><a class="header" href="#常见问题faq">常见问题FAQ</a></h3>
<p><strong>Q1: Docker与虚拟机的选择？</strong>
A: Docker适合微服务、快速部署；虚拟机适合需要完全隔离、运行不同OS的场景。</p>
<p><strong>Q2: 如何清理Docker占用的磁盘空间？</strong>
A: <code>docker system prune -a --volumes</code> 可清理所有未使用的镜像、容器、网络、卷。</p>
<p><strong>Q3: 容器内修改会丢失吗？</strong>
A: 是的，容器重启后修改会丢失。需要使用数据卷持久化数据。</p>
<p><strong>Q4: 如何在容器间共享数据？</strong>
A: 使用数据卷，多个容器挂载同一个卷即可。</p>
<p><strong>Q5: 生产环境推荐使用Docker Compose吗？</strong>
A: 小规模可以，大规模推荐使用Kubernetes等编排工具。</p>
<hr />
<p><strong>学习建议</strong>: Docker是容器技术的基础,建议从基本命令开始,逐步掌握Dockerfile编写、网络配置、数据管理。实践是最好的学习方式,尝试容器化自己的项目。生产环境使用前务必关注安全和性能优化。祝学习愉快!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/paas/ceph.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/paas/k8s.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/paas/ceph.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/paas/k8s.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

