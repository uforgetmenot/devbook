<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>STM32åµŒå…¥å¼å¼€å‘å­¦ä¹ ç¬”è®° - å¼€å‘</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">å¼€å‘</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="æœç´¢æœ¬ä¹¦å†…å®¹..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="stm32åµŒå…¥å¼å¼€å‘å­¦ä¹ ç¬”è®°"><a class="header" href="#stm32åµŒå…¥å¼å¼€å‘å­¦ä¹ ç¬”è®°">STM32åµŒå…¥å¼å¼€å‘å­¦ä¹ ç¬”è®°</a></h1>
<h2 id="-æŠ€æœ¯æ¦‚è§ˆ"><a class="header" href="#-æŠ€æœ¯æ¦‚è§ˆ">ğŸ“‹ æŠ€æœ¯æ¦‚è§ˆ</a></h2>
<h3 id="ä»€ä¹ˆæ˜¯stm32"><a class="header" href="#ä»€ä¹ˆæ˜¯stm32">ä»€ä¹ˆæ˜¯STM32</a></h3>
<p>STM32æ˜¯æ„æ³•åŠå¯¼ä½“ï¼ˆSTMicroelectronicsï¼‰æ¨å‡ºçš„åŸºäºARM Cortex-Må†…æ ¸çš„32ä½å¾®æ§åˆ¶å™¨ç³»åˆ—ï¼Œå…·æœ‰é«˜æ€§èƒ½ã€ä½åŠŸè€—ã€ä¸°å¯Œå¤–è®¾ç­‰ç‰¹ç‚¹ï¼Œå¹¿æ³›åº”ç”¨äºå·¥ä¸šæ§åˆ¶ã€ç‰©è”ç½‘ã€æ¶ˆè´¹ç”µå­ã€åŒ»ç–—è®¾å¤‡ç­‰é¢†åŸŸã€‚</p>
<p><strong>æ ¸å¿ƒç‰¹æ€§ï¼š</strong></p>
<ul>
<li>ARM Cortex-M0/M3/M4/M7/M33å†…æ ¸</li>
<li>ä¸»é¢‘èŒƒå›´ï¼š24MHz - 480MHz</li>
<li>Flashå®¹é‡ï¼š16KB - 2MB</li>
<li>RAMå®¹é‡ï¼š6KB - 1MB</li>
<li>ä¸°å¯Œçš„é€šä¿¡æ¥å£ï¼šUSARTã€SPIã€I2Cã€CANã€USBã€Ethernet</li>
<li>å¤šç§å®šæ—¶å™¨ï¼šåŸºæœ¬å®šæ—¶å™¨ã€é€šç”¨å®šæ—¶å™¨ã€é«˜çº§å®šæ—¶å™¨</li>
<li>ADCã€DACã€DMAç­‰é«˜çº§å¤–è®¾</li>
</ul>
<h3 id="å­¦ä¹ è€…å®šä½"><a class="header" href="#å­¦ä¹ è€…å®šä½">å­¦ä¹ è€…å®šä½</a></h3>
<p><strong>ç›®æ ‡ç¾¤ä½“ï¼š</strong></p>
<ul>
<li>åµŒå…¥å¼å¼€å‘åˆå­¦è€…ï¼ˆæœ‰Cè¯­è¨€åŸºç¡€ï¼‰</li>
<li>å•ç‰‡æœºå¼€å‘è€…ï¼ˆ51ã€AVRè½¬å‹ï¼‰</li>
<li>ç”µå­å·¥ç¨‹ä¸“ä¸šå­¦ç”Ÿ</li>
<li>ç‰©è”ç½‘å¼€å‘å·¥ç¨‹å¸ˆ</li>
</ul>
<p><strong>é¢„å¤‡çŸ¥è¯†ï¼š</strong></p>
<ul>
<li>Cè¯­è¨€ç¼–ç¨‹åŸºç¡€</li>
<li>æ•°å­—ç”µè·¯åŸºç¡€çŸ¥è¯†</li>
<li>åŸºæœ¬çš„ç¡¬ä»¶ç”µè·¯çŸ¥è¯†</li>
</ul>
<h2 id="-å­¦ä¹ è·¯çº¿å›¾"><a class="header" href="#-å­¦ä¹ è·¯çº¿å›¾">ğŸ—ºï¸ å­¦ä¹ è·¯çº¿å›¾</a></h2>
<pre><code>é˜¶æ®µ1ï¼šåŸºç¡€å…¥é—¨ï¼ˆ2-3å‘¨ï¼‰
â”œâ”€â”€ å¼€å‘ç¯å¢ƒæ­å»º
â”œâ”€â”€ GPIOåŸºç¡€æ“ä½œ
â””â”€â”€ åŸºç¡€è°ƒè¯•æŠ€å·§

é˜¶æ®µ2ï¼šå¤–è®¾åº”ç”¨ï¼ˆ3-4å‘¨ï¼‰
â”œâ”€â”€ ä¸­æ–­ç³»ç»Ÿ
â”œâ”€â”€ å®šæ—¶å™¨åº”ç”¨
â”œâ”€â”€ ä¸²å£é€šä¿¡
â””â”€â”€ SPI/I2Cé€šä¿¡

é˜¶æ®µ3ï¼šé«˜çº§ç‰¹æ€§ï¼ˆ3-4å‘¨ï¼‰
â”œâ”€â”€ DMAåº”ç”¨
â”œâ”€â”€ ADC/DACåº”ç”¨
â”œâ”€â”€ PWMæ§åˆ¶
â””â”€â”€ ä½åŠŸè€—è®¾è®¡

é˜¶æ®µ4ï¼šç³»ç»Ÿé›†æˆï¼ˆ4-6å‘¨ï¼‰
â”œâ”€â”€ FreeRTOSç§»æ¤
â”œâ”€â”€ å¤šä»»åŠ¡ç®¡ç†
â”œâ”€â”€ é€šä¿¡åè®®æ ˆ
â””â”€â”€ å®æˆ˜é¡¹ç›®å¼€å‘
</code></pre>
<h2 id="-æ ¸å¿ƒæ¨¡å—"><a class="header" href="#-æ ¸å¿ƒæ¨¡å—">ğŸ“š æ ¸å¿ƒæ¨¡å—</a></h2>
<h3 id="æ¨¡å—ä¸€å¼€å‘ç¯å¢ƒä¸åŸºç¡€"><a class="header" href="#æ¨¡å—ä¸€å¼€å‘ç¯å¢ƒä¸åŸºç¡€">æ¨¡å—ä¸€ï¼šå¼€å‘ç¯å¢ƒä¸åŸºç¡€</a></h3>
<h4 id="11-å¼€å‘ç¯å¢ƒæ­å»º"><a class="header" href="#11-å¼€å‘ç¯å¢ƒæ­å»º">1.1 å¼€å‘ç¯å¢ƒæ­å»º</a></h4>
<p><strong>å¿…å¤‡å·¥å…·ï¼š</strong></p>
<pre><code class="language-plaintext">1. IDEé€‰æ‹©ï¼š
   - Keil MDK-ARMï¼ˆæ¨èåˆå­¦è€…ï¼‰
   - STM32CubeIDEï¼ˆå®˜æ–¹å…è´¹ï¼‰
   - IAR EWARMï¼ˆä¸“ä¸šå¼€å‘ï¼‰

2. è°ƒè¯•å·¥å…·ï¼š
   - ST-Link V2/V3ï¼ˆç¡¬ä»¶è°ƒè¯•å™¨ï¼‰
   - J-Linkï¼ˆé«˜çº§è°ƒè¯•ï¼‰
   - ä¸²å£è°ƒè¯•åŠ©æ‰‹

3. è¾…åŠ©å·¥å…·ï¼š
   - STM32CubeMXï¼ˆå›¾å½¢åŒ–é…ç½®ï¼‰
   - STM32CubeProgrammerï¼ˆçƒ§å½•å·¥å…·ï¼‰
   - Gitï¼ˆç‰ˆæœ¬ç®¡ç†ï¼‰
</code></pre>
<p><strong>ç¯å¢ƒæ­å»ºæ­¥éª¤ï¼š</strong></p>
<pre><code class="language-bash"># 1. å®‰è£…Keil MDK
# ä¸‹è½½åœ°å€ï¼šhttps://www.keil.com/download/product/
# å®‰è£…æ”¯æŒåŒ…ï¼šKeil.STM32F1xx_DFP.2.x.x.pack

# 2. å®‰è£…STM32CubeMX
# ä¸‹è½½åœ°å€ï¼šhttps://www.st.com/zh/development-tools/stm32cubemx.html

# 3. é…ç½®ST-Linké©±åŠ¨
# ä¸‹è½½åœ°å€ï¼šhttps://www.st.com/zh/development-tools/stsw-link009.html
</code></pre>
<p><strong>ç¬¬ä¸€ä¸ªç¨‹åºï¼šLEDé—ªçƒ</strong></p>
<pre><code class="language-c">/* main.c - LEDé—ªçƒç¤ºä¾‹ */
#include "stm32f1xx_hal.h"

void SystemClock_Config(void);
static void MX_GPIO_Init(void);

int main(void)
{
    /* åˆå§‹åŒ–HALåº“ */
    HAL_Init();

    /* é…ç½®ç³»ç»Ÿæ—¶é’Ÿ */
    SystemClock_Config();

    /* åˆå§‹åŒ–GPIO */
    MX_GPIO_Init();

    /* ä¸»å¾ªç¯ */
    while (1)
    {
        /* LEDåˆ‡æ¢çŠ¶æ€ */
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);

        /* å»¶æ—¶500ms */
        HAL_Delay(500);
    }
}

/* GPIOåˆå§‹åŒ–å‡½æ•° */
static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* ä½¿èƒ½GPIOCæ—¶é’Ÿ */
    __HAL_RCC_GPIOC_CLK_ENABLE();

    /* é…ç½®PC13ä¸ºè¾“å‡ºæ¨¡å¼ */
    GPIO_InitStruct.Pin = GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);
}

/* ç³»ç»Ÿæ—¶é’Ÿé…ç½® */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    /* é…ç½®å†…éƒ¨é«˜é€ŸæŒ¯è¡å™¨HSI */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
    HAL_RCC_OscConfig(&amp;RCC_OscInitStruct);

    /* é…ç½®ç³»ç»Ÿæ—¶é’Ÿ */
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                                |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2);
}
</code></pre>
<h4 id="12-gpioè¯¦è§£"><a class="header" href="#12-gpioè¯¦è§£">1.2 GPIOè¯¦è§£</a></h4>
<p><strong>GPIOå·¥ä½œæ¨¡å¼ï¼š</strong></p>
<div class="table-wrapper"><table><thead><tr><th>æ¨¡å¼</th><th>è¯´æ˜</th><th>åº”ç”¨åœºæ™¯</th></tr></thead><tbody>
<tr><td>è¾“å…¥æµ®ç©º</td><td>é«˜é˜»æ€è¾“å…¥</td><td>æŒ‰é”®æ£€æµ‹ã€å¤–éƒ¨ä¿¡å·è¯»å–</td></tr>
<tr><td>è¾“å…¥ä¸Šæ‹‰</td><td>å†…éƒ¨ä¸Šæ‹‰ç”µé˜»</td><td>æŒ‰é”®æ£€æµ‹ï¼ˆä½ç”µå¹³æœ‰æ•ˆï¼‰</td></tr>
<tr><td>è¾“å…¥ä¸‹æ‹‰</td><td>å†…éƒ¨ä¸‹æ‹‰ç”µé˜»</td><td>æŒ‰é”®æ£€æµ‹ï¼ˆé«˜ç”µå¹³æœ‰æ•ˆï¼‰</td></tr>
<tr><td>æ¨¡æ‹Ÿè¾“å…¥</td><td>æ¨¡æ‹Ÿä¿¡å·è¾“å…¥</td><td>ADCé‡‡æ ·</td></tr>
<tr><td>æ¨æŒ½è¾“å‡º</td><td>é«˜ä½ç”µå¹³é©±åŠ¨</td><td>é©±åŠ¨LEDã€èœ‚é¸£å™¨</td></tr>
<tr><td>å¼€æ¼è¾“å‡º</td><td>åªèƒ½è¾“å‡ºä½ç”µå¹³</td><td>I2Cé€šä¿¡</td></tr>
<tr><td>å¤ç”¨æ¨æŒ½</td><td>å¤–è®¾åŠŸèƒ½å¤ç”¨</td><td>ä¸²å£TXã€SPIç­‰</td></tr>
<tr><td>å¤ç”¨å¼€æ¼</td><td>å¤–è®¾åŠŸèƒ½å¤ç”¨</td><td>I2C SCL/SDA</td></tr>
</tbody></table>
</div>
<p><strong>GPIOå®æˆ˜æ¡ˆä¾‹ï¼šæŒ‰é”®æ§åˆ¶LED</strong></p>
<pre><code class="language-c">/* æŒ‰é”®æ‰«æå‡½æ•° */
uint8_t Key_Scan(void)
{
    static uint8_t key_state = 0;

    /* æ£€æµ‹æŒ‰é”®æŒ‰ä¸‹ */
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET)
    {
        /* å»¶æ—¶æ¶ˆæŠ– */
        HAL_Delay(10);

        if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET)
        {
            /* ç­‰å¾…æŒ‰é”®é‡Šæ”¾ */
            while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
            key_state = 1;
        }
    }
    else
    {
        key_state = 0;
    }

    return key_state;
}

/* ä¸»å‡½æ•°ä¸­ä½¿ç”¨ */
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();

    while (1)
    {
        if (Key_Scan())
        {
            /* æŒ‰é”®æŒ‰ä¸‹ï¼ŒLEDçŠ¶æ€ç¿»è½¬ */
            HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        }
    }
}
</code></pre>
<h3 id="æ¨¡å—äºŒä¸­æ–­ä¸å®šæ—¶å™¨"><a class="header" href="#æ¨¡å—äºŒä¸­æ–­ä¸å®šæ—¶å™¨">æ¨¡å—äºŒï¼šä¸­æ–­ä¸å®šæ—¶å™¨</a></h3>
<h4 id="21-ä¸­æ–­ç³»ç»Ÿ"><a class="header" href="#21-ä¸­æ–­ç³»ç»Ÿ">2.1 ä¸­æ–­ç³»ç»Ÿ</a></h4>
<p><strong>NVICä¸­æ–­ä¼˜å…ˆçº§ï¼š</strong></p>
<p>STM32ä½¿ç”¨åµŒå¥—å‘é‡ä¸­æ–­æ§åˆ¶å™¨ï¼ˆNVICï¼‰ç®¡ç†ä¸­æ–­ï¼Œæ”¯æŒå¯é…ç½®çš„ä¸­æ–­ä¼˜å…ˆçº§ã€‚</p>
<pre><code class="language-c">/* ä¸­æ–­ä¼˜å…ˆçº§é…ç½® */
#define PRIORITY_GROUP  NVIC_PRIORITYGROUP_2  // 2ä½æŠ¢å ä¼˜å…ˆçº§ï¼Œ2ä½å“åº”ä¼˜å…ˆçº§

/* é…ç½®å¤–éƒ¨ä¸­æ–­ */
void EXTI_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* ä½¿èƒ½GPIOAæ—¶é’Ÿ */
    __HAL_RCC_GPIOA_CLK_ENABLE();

    /* é…ç½®PA0ä¸ºä¸­æ–­è¾“å…¥ */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;  // ä¸Šå‡æ²¿è§¦å‘
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);

    /* é…ç½®ä¸­æ–­ä¼˜å…ˆçº§ */
    HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0);

    /* ä½¿èƒ½ä¸­æ–­ */
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
}

/* ä¸­æ–­æœåŠ¡å‡½æ•° */
void EXTI0_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
}

/* ä¸­æ–­å›è°ƒå‡½æ•° */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == GPIO_PIN_0)
    {
        /* å¤„ç†ä¸­æ–­äº‹ä»¶ */
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    }
}
</code></pre>
<h4 id="22-å®šæ—¶å™¨åº”ç”¨"><a class="header" href="#22-å®šæ—¶å™¨åº”ç”¨">2.2 å®šæ—¶å™¨åº”ç”¨</a></h4>
<p><strong>å®šæ—¶å™¨åˆ†ç±»ï¼š</strong></p>
<ol>
<li><strong>åŸºæœ¬å®šæ—¶å™¨ï¼ˆTIM6/TIM7ï¼‰</strong>ï¼šç®€å•çš„å®šæ—¶åŠŸèƒ½</li>
<li><strong>é€šç”¨å®šæ—¶å™¨ï¼ˆTIM2-TIM5ï¼‰</strong>ï¼šå®šæ—¶ã€è¾“å…¥æ•è·ã€è¾“å‡ºæ¯”è¾ƒã€PWM</li>
<li><strong>é«˜çº§å®šæ—¶å™¨ï¼ˆTIM1/TIM8ï¼‰</strong>ï¼šé€šç”¨åŠŸèƒ½+äº’è¡¥è¾“å‡º+æ­»åŒºæ§åˆ¶</li>
</ol>
<p><strong>å®šæ—¶å™¨å®æˆ˜ï¼šç²¾ç¡®å®šæ—¶</strong></p>
<pre><code class="language-c">/* å®šæ—¶å™¨é…ç½® - 1mså®šæ—¶ä¸­æ–­ */
TIM_HandleTypeDef htim2;

void TIM2_Init(void)
{
    TIM_ClockConfigTypeDef sClockSourceConfig = {0};
    TIM_MasterConfigTypeDef sMasterConfig = {0};

    /* å®šæ—¶å™¨åŸºç¡€é…ç½® */
    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 7200-1;      // é¢„åˆ†é¢‘ï¼š72MHz/7200=10KHz
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 10-1;           // è®¡æ•°å‘¨æœŸï¼š10KHz/10=1KHz (1ms)
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
    HAL_TIM_Base_Init(&amp;htim2);

    /* æ—¶é’Ÿæºé…ç½® */
    sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
    HAL_TIM_ConfigClockSource(&amp;htim2, &amp;sClockSourceConfig);

    /* å¯åŠ¨å®šæ—¶å™¨ä¸­æ–­ */
    HAL_TIM_Base_Start_IT(&amp;htim2);

    /* é…ç½®ä¸­æ–­ä¼˜å…ˆçº§ */
    HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

/* å®šæ—¶å™¨ä¸­æ–­æœåŠ¡å‡½æ•° */
void TIM2_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&amp;htim2);
}

/* å®šæ—¶å™¨ä¸­æ–­å›è°ƒå‡½æ•° */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim-&gt;Instance == TIM2)
    {
        static uint16_t count = 0;
        count++;

        /* æ¯1000msæ‰§è¡Œä¸€æ¬¡ */
        if (count &gt;= 1000)
        {
            count = 0;
            HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        }
    }
}
</code></pre>
<p><strong>PWMè¾“å‡ºç¤ºä¾‹ï¼š</strong></p>
<pre><code class="language-c">/* PWMé…ç½® - ç”¨äºLEDå‘¼å¸ç¯ */
TIM_HandleTypeDef htim3;

void TIM3_PWM_Init(void)
{
    TIM_OC_InitTypeDef sConfigOC = {0};

    /* å®šæ—¶å™¨åŸºç¡€é…ç½® */
    htim3.Instance = TIM3;
    htim3.Init.Prescaler = 72-1;        // é¢„åˆ†é¢‘ï¼š72MHz/72=1MHz
    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim3.Init.Period = 1000-1;         // PWMé¢‘ç‡ï¼š1MHz/1000=1KHz
    htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
    HAL_TIM_PWM_Init(&amp;htim3);

    /* PWMé€šé“é…ç½® */
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 0;                // åˆå§‹å ç©ºæ¯”0%
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    HAL_TIM_PWM_ConfigChannel(&amp;htim3, &amp;sConfigOC, TIM_CHANNEL_1);

    /* å¯åŠ¨PWMè¾“å‡º */
    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);
}

/* LEDå‘¼å¸ç¯æ•ˆæœ */
void LED_Breathing(void)
{
    static uint16_t pwm_value = 0;
    static int8_t direction = 1;

    pwm_value += direction * 10;

    if (pwm_value &gt;= 1000)
    {
        pwm_value = 1000;
        direction = -1;
    }
    else if (pwm_value &lt;= 0)
    {
        pwm_value = 0;
        direction = 1;
    }

    __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, pwm_value);
}
</code></pre>
<h3 id="æ¨¡å—ä¸‰ä¸²å£é€šä¿¡"><a class="header" href="#æ¨¡å—ä¸‰ä¸²å£é€šä¿¡">æ¨¡å—ä¸‰ï¼šä¸²å£é€šä¿¡</a></h3>
<h4 id="31-usartåŸºç¡€"><a class="header" href="#31-usartåŸºç¡€">3.1 USARTåŸºç¡€</a></h4>
<p><strong>ä¸²å£é€šä¿¡å‚æ•°ï¼š</strong></p>
<ul>
<li>æ³¢ç‰¹ç‡ï¼š9600ã€115200ç­‰</li>
<li>æ•°æ®ä½ï¼š8ä½</li>
<li>åœæ­¢ä½ï¼š1ä½</li>
<li>æ ¡éªŒä½ï¼šæ— æ ¡éªŒ</li>
<li>æµæ§ï¼šæ— </li>
</ul>
<p><strong>ä¸²å£é…ç½®ä¸ä½¿ç”¨ï¼š</strong></p>
<pre><code class="language-c">/* ä¸²å£é…ç½® */
UART_HandleTypeDef huart1;

void USART1_Init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    HAL_UART_Init(&amp;huart1);
}

/* ä¸²å£å‘é€å­—ç¬¦ä¸² */
void USART1_SendString(char *str)
{
    HAL_UART_Transmit(&amp;huart1, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);
}

/* ä¸²å£æ¥æ”¶ï¼ˆä¸­æ–­æ–¹å¼ï¼‰ */
uint8_t rx_buffer[256];
uint8_t rx_index = 0;

void USART1_IRQHandler(void)
{
    HAL_UART_IRQHandler(&amp;huart1);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart-&gt;Instance == USART1)
    {
        /* å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ® */
        if (rx_buffer[rx_index] == '\n')
        {
            /* æ¥æ”¶å®Œæˆï¼Œå¤„ç†å‘½ä»¤ */
            rx_buffer[rx_index] = '\0';
            ProcessCommand((char*)rx_buffer);
            rx_index = 0;
        }
        else
        {
            rx_index++;
            if (rx_index &gt;= sizeof(rx_buffer))
                rx_index = 0;
        }

        /* é‡æ–°å¯åŠ¨æ¥æ”¶ */
        HAL_UART_Receive_IT(&amp;huart1, &amp;rx_buffer[rx_index], 1);
    }
}
</code></pre>
<h4 id="32-ä¸²å£åº”ç”¨åè®®é€šä¿¡"><a class="header" href="#32-ä¸²å£åº”ç”¨åè®®é€šä¿¡">3.2 ä¸²å£åº”ç”¨ï¼šåè®®é€šä¿¡</a></h4>
<p><strong>ç®€å•åè®®è®¾è®¡ï¼š</strong></p>
<pre><code class="language-c">/* é€šä¿¡åè®®æ ¼å¼ï¼š
 * å¸§å¤´(1å­—èŠ‚) + å‘½ä»¤(1å­—èŠ‚) + é•¿åº¦(1å­—èŠ‚) + æ•°æ®(Nå­—èŠ‚) + æ ¡éªŒ(1å­—èŠ‚)
 */
#define FRAME_HEADER    0xAA
#define FRAME_TAIL      0x55

typedef struct {
    uint8_t header;
    uint8_t cmd;
    uint8_t length;
    uint8_t data[128];
    uint8_t checksum;
} Protocol_Frame_t;

/* è®¡ç®—æ ¡éªŒå’Œ */
uint8_t Calculate_Checksum(uint8_t *data, uint16_t length)
{
    uint8_t sum = 0;
    for (uint16_t i = 0; i &lt; length; i++)
    {
        sum += data[i];
    }
    return sum;
}

/* å‘é€åè®®å¸§ */
void Protocol_SendFrame(uint8_t cmd, uint8_t *data, uint8_t length)
{
    Protocol_Frame_t frame;

    frame.header = FRAME_HEADER;
    frame.cmd = cmd;
    frame.length = length;
    memcpy(frame.data, data, length);
    frame.checksum = Calculate_Checksum(data, length);

    /* å‘é€å¸§æ•°æ® */
    HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;frame, 3 + length + 1, HAL_MAX_DELAY);
}

/* è§£ææ¥æ”¶å¸§ */
uint8_t Protocol_ParseFrame(uint8_t *rx_data, uint16_t length)
{
    if (rx_data[0] != FRAME_HEADER)
        return 0;  // å¸§å¤´é”™è¯¯

    uint8_t cmd = rx_data[1];
    uint8_t data_length = rx_data[2];
    uint8_t checksum = Calculate_Checksum(&amp;rx_data[3], data_length);

    if (checksum != rx_data[3 + data_length])
        return 0;  // æ ¡éªŒå¤±è´¥

    /* æ ¹æ®å‘½ä»¤å¤„ç†æ•°æ® */
    switch (cmd)
    {
        case 0x01:  // LEDæ§åˆ¶å‘½ä»¤
            if (rx_data[3] == 0x01)
                HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
            else
                HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
            break;

        case 0x02:  // è¯»å–ä¼ æ„Ÿå™¨æ•°æ®
            // å¤„ç†ä¼ æ„Ÿå™¨æ•°æ®è¯·æ±‚
            break;

        default:
            break;
    }

    return 1;  // è§£ææˆåŠŸ
}
</code></pre>
<h3 id="æ¨¡å—å››spiä¸i2cé€šä¿¡"><a class="header" href="#æ¨¡å—å››spiä¸i2cé€šä¿¡">æ¨¡å—å››ï¼šSPIä¸I2Cé€šä¿¡</a></h3>
<h4 id="41-spié€šä¿¡"><a class="header" href="#41-spié€šä¿¡">4.1 SPIé€šä¿¡</a></h4>
<p><strong>SPIç‰¹ç‚¹ï¼š</strong></p>
<ul>
<li>å…¨åŒå·¥åŒæ­¥é€šä¿¡</li>
<li>ä¸»ä»æ¨¡å¼</li>
<li>é«˜é€Ÿä¼ è¾“ï¼ˆå¯è¾¾æ•°åMHzï¼‰</li>
<li>4çº¿åˆ¶ï¼šMOSIã€MISOã€SCKã€CS</li>
</ul>
<p><strong>SPIé…ç½®ä¸ä½¿ç”¨ï¼š</strong></p>
<pre><code class="language-c">/* SPIé…ç½® */
SPI_HandleTypeDef hspi1;

void SPI1_Init(void)
{
    hspi1.Instance = SPI1;
    hspi1.Init.Mode = SPI_MODE_MASTER;
    hspi1.Init.Direction = SPI_DIRECTION_2LINES;
    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi1.Init.NSS = SPI_NSS_SOFT;
    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
    hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
    hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    HAL_SPI_Init(&amp;hspi1);
}

/* SPIè¯»å†™å‡½æ•° */
uint8_t SPI1_ReadWriteByte(uint8_t TxData)
{
    uint8_t RxData = 0;
    HAL_SPI_TransmitReceive(&amp;hspi1, &amp;TxData, &amp;RxData, 1, HAL_MAX_DELAY);
    return RxData;
}

/* SPI Flashç¤ºä¾‹ï¼ˆW25Q128ï¼‰ */
#define W25Q128_WRITE_ENABLE    0x06
#define W25Q128_PAGE_PROGRAM    0x02
#define W25Q128_READ_DATA       0x03

void W25Q128_WriteEnable(void)
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);  // CS=0
    SPI1_ReadWriteByte(W25Q128_WRITE_ENABLE);
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);    // CS=1
}

void W25Q128_ReadData(uint32_t address, uint8_t *buffer, uint16_t length)
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);

    SPI1_ReadWriteByte(W25Q128_READ_DATA);
    SPI1_ReadWriteByte((address &gt;&gt; 16) &amp; 0xFF);
    SPI1_ReadWriteByte((address &gt;&gt; 8) &amp; 0xFF);
    SPI1_ReadWriteByte(address &amp; 0xFF);

    for (uint16_t i = 0; i &lt; length; i++)
    {
        buffer[i] = SPI1_ReadWriteByte(0xFF);
    }

    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
}
</code></pre>
<h4 id="42-i2cé€šä¿¡"><a class="header" href="#42-i2cé€šä¿¡">4.2 I2Cé€šä¿¡</a></h4>
<p><strong>I2Cç‰¹ç‚¹ï¼š</strong></p>
<ul>
<li>åŠåŒå·¥åŒæ­¥é€šä¿¡</li>
<li>å¤šä¸»å¤šä»</li>
<li>ä¸­ä½é€Ÿä¼ è¾“ï¼ˆ100kHzã€400kHzï¼‰</li>
<li>2çº¿åˆ¶ï¼šSCLã€SDA</li>
</ul>
<p><strong>I2Cé…ç½®ä¸ä½¿ç”¨ï¼š</strong></p>
<pre><code class="language-c">/* I2Cé…ç½® */
I2C_HandleTypeDef hi2c1;

void I2C1_Init(void)
{
    hi2c1.Instance = I2C1;
    hi2c1.Init.ClockSpeed = 400000;      // 400kHz
    hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
    hi2c1.Init.OwnAddress1 = 0;
    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
    hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
    hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
    HAL_I2C_Init(&amp;hi2c1);
}

/* I2C OLEDæ˜¾ç¤ºç¤ºä¾‹ï¼ˆSSD1306ï¼‰ */
#define OLED_ADDRESS    0x78

void OLED_WriteCmd(uint8_t cmd)
{
    uint8_t data[2] = {0x00, cmd};
    HAL_I2C_Master_Transmit(&amp;hi2c1, OLED_ADDRESS, data, 2, HAL_MAX_DELAY);
}

void OLED_WriteData(uint8_t dat)
{
    uint8_t data[2] = {0x40, dat};
    HAL_I2C_Master_Transmit(&amp;hi2c1, OLED_ADDRESS, data, 2, HAL_MAX_DELAY);
}

void OLED_Init(void)
{
    HAL_Delay(100);

    OLED_WriteCmd(0xAE); // å…³é—­æ˜¾ç¤º
    OLED_WriteCmd(0x20); // è®¾ç½®å†…å­˜åœ°å€æ¨¡å¼
    OLED_WriteCmd(0x10); // 00:åˆ—åœ°å€æ¨¡å¼;01:è¡Œåœ°å€æ¨¡å¼;10:é¡µåœ°å€æ¨¡å¼;11:æ— æ•ˆ
    OLED_WriteCmd(0xB0); // è®¾ç½®é¡µåœ°å€(0~7)
    OLED_WriteCmd(0xC8); // è®¾ç½®COMæ‰«ææ–¹å‘
    OLED_WriteCmd(0x00); // è®¾ç½®ä½åˆ—åœ°å€
    OLED_WriteCmd(0x10); // è®¾ç½®é«˜åˆ—åœ°å€
    OLED_WriteCmd(0x40); // è®¾ç½®èµ·å§‹è¡Œåœ°å€
    OLED_WriteCmd(0x81); // è®¾ç½®å¯¹æ¯”åº¦æ§åˆ¶
    OLED_WriteCmd(0xFF);
    OLED_WriteCmd(0xA1); // è®¾ç½®æ®µé‡æ˜ å°„
    OLED_WriteCmd(0xA6); // æ­£å¸¸æ˜¾ç¤º
    OLED_WriteCmd(0xA8); // è®¾ç½®å¤ç”¨ç‡
    OLED_WriteCmd(0x3F);
    OLED_WriteCmd(0xA4); // å…¨å±€æ˜¾ç¤ºå¼€å¯
    OLED_WriteCmd(0xD3); // è®¾ç½®æ˜¾ç¤ºåç§»
    OLED_WriteCmd(0x00);
    OLED_WriteCmd(0xD5); // è®¾ç½®æ—¶é’Ÿåˆ†é¢‘
    OLED_WriteCmd(0xF0);
    OLED_WriteCmd(0xD9); // è®¾ç½®é¢„å……ç”µå‘¨æœŸ
    OLED_WriteCmd(0x22);
    OLED_WriteCmd(0xDA); // è®¾ç½®comå¼•è„šé…ç½®
    OLED_WriteCmd(0x12);
    OLED_WriteCmd(0xDB); // è®¾ç½®vcomhç”µå‹å€ç‡
    OLED_WriteCmd(0x20);
    OLED_WriteCmd(0x8D); // ä½¿èƒ½å……ç”µæ³µ
    OLED_WriteCmd(0x14);
    OLED_WriteCmd(0xAF); // å¼€å¯æ˜¾ç¤º
}
</code></pre>
<h3 id="æ¨¡å—äº”dmaä¸adcdac"><a class="header" href="#æ¨¡å—äº”dmaä¸adcdac">æ¨¡å—äº”ï¼šDMAä¸ADC/DAC</a></h3>
<h4 id="51-dmaåº”ç”¨"><a class="header" href="#51-dmaåº”ç”¨">5.1 DMAåº”ç”¨</a></h4>
<p><strong>DMAä¼˜åŠ¿ï¼š</strong></p>
<ul>
<li>å‡è½»CPUè´Ÿæ‹…</li>
<li>æé«˜æ•°æ®ä¼ è¾“æ•ˆç‡</li>
<li>é€‚ç”¨äºå¤§é‡æ•°æ®ä¼ è¾“åœºæ™¯</li>
</ul>
<p><strong>DMAé…ç½®ç¤ºä¾‹ï¼šä¸²å£DMAæ¥æ”¶</strong></p>
<pre><code class="language-c">/* DMAé…ç½® */
DMA_HandleTypeDef hdma_usart1_rx;
uint8_t dma_rx_buffer[256];

void DMA_USART1_Init(void)
{
    /* ä½¿èƒ½DMAæ—¶é’Ÿ */
    __HAL_RCC_DMA1_CLK_ENABLE();

    /* DMAæ§åˆ¶å™¨é…ç½® */
    hdma_usart1_rx.Instance = DMA1_Channel5;
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&amp;hdma_usart1_rx);

    /* è¿æ¥DMAå’Œä¸²å£ */
    __HAL_LINKDMA(&amp;huart1, hdmarx, hdma_usart1_rx);

    /* å¯åŠ¨DMAæ¥æ”¶ */
    HAL_UART_Receive_DMA(&amp;huart1, dma_rx_buffer, sizeof(dma_rx_buffer));
}

/* DMAä¼ è¾“å®Œæˆå›è°ƒ */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart-&gt;Instance == USART1)
    {
        /* å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ® */
        ProcessReceivedData(dma_rx_buffer, sizeof(dma_rx_buffer));
    }
}
</code></pre>
<h4 id="52-adcåº”ç”¨"><a class="header" href="#52-adcåº”ç”¨">5.2 ADCåº”ç”¨</a></h4>
<p><strong>ADCç‰¹æ€§ï¼š</strong></p>
<ul>
<li>12ä½åˆ†è¾¨ç‡</li>
<li>å¤šé€šé“é‡‡é›†</li>
<li>è½¬æ¢æ—¶é—´ï¼š&lt;1Î¼s</li>
<li>æ”¯æŒDMAä¼ è¾“</li>
</ul>
<p><strong>ADCé…ç½®ä¸ä½¿ç”¨ï¼š</strong></p>
<pre><code class="language-c">/* ADCé…ç½® */
ADC_HandleTypeDef hadc1;

void ADC1_Init(void)
{
    ADC_ChannelConfTypeDef sConfig = {0};

    /* ADCåŸºç¡€é…ç½® */
    hadc1.Instance = ADC1;
    hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
    hadc1.Init.ContinuousConvMode = DISABLE;
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.NbrOfConversion = 1;
    HAL_ADC_Init(&amp;hadc1);

    /* é…ç½®ADCé€šé“ */
    sConfig.Channel = ADC_CHANNEL_0;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_55CYCLES_5;
    HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig);
}

/* è¯»å–ADCå€¼ */
uint16_t ADC1_Read(void)
{
    uint16_t adc_value = 0;

    /* å¯åŠ¨ADCè½¬æ¢ */
    HAL_ADC_Start(&amp;hadc1);

    /* ç­‰å¾…è½¬æ¢å®Œæˆ */
    if (HAL_ADC_PollForConversion(&amp;hadc1, 10) == HAL_OK)
    {
        adc_value = HAL_ADC_GetValue(&amp;hadc1);
    }

    return adc_value;
}

/* ç”µå‹è½¬æ¢ */
float ADC_ToVoltage(uint16_t adc_value)
{
    /* ADCå‚è€ƒç”µå‹3.3V, 12ä½åˆ†è¾¨ç‡ */
    return (float)adc_value * 3.3f / 4096.0f;
}

/* å¤šé€šé“ADC+DMAé‡‡é›† */
#define ADC_CHANNELS    4
uint16_t adc_dma_buffer[ADC_CHANNELS];

void ADC1_DMA_Init(void)
{
    ADC_ChannelConfTypeDef sConfig = {0};

    hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;       // æ‰«ææ¨¡å¼
    hadc1.Init.ContinuousConvMode = ENABLE;          // è¿ç»­è½¬æ¢
    hadc1.Init.NbrOfConversion = ADC_CHANNELS;
    HAL_ADC_Init(&amp;hadc1);

    /* é…ç½®å¤šä¸ªé€šé“ */
    uint32_t channels[] = {ADC_CHANNEL_0, ADC_CHANNEL_1,
                          ADC_CHANNEL_2, ADC_CHANNEL_3};
    for (int i = 0; i &lt; ADC_CHANNELS; i++)
    {
        sConfig.Channel = channels[i];
        sConfig.Rank = i + 1;
        sConfig.SamplingTime = ADC_SAMPLETIME_55CYCLES_5;
        HAL_ADC_ConfigChannel(&amp;hadc1, &amp;sConfig);
    }

    /* å¯åŠ¨ADC+DMA */
    HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t*)adc_dma_buffer, ADC_CHANNELS);
}
</code></pre>
<h3 id="æ¨¡å—å…­freertoså®æ—¶æ“ä½œç³»ç»Ÿ"><a class="header" href="#æ¨¡å—å…­freertoså®æ—¶æ“ä½œç³»ç»Ÿ">æ¨¡å—å…­ï¼šFreeRTOSå®æ—¶æ“ä½œç³»ç»Ÿ</a></h3>
<h4 id="61-freertosç§»æ¤"><a class="header" href="#61-freertosç§»æ¤">6.1 FreeRTOSç§»æ¤</a></h4>
<p><strong>FreeRTOSç‰¹ç‚¹ï¼š</strong></p>
<ul>
<li>æŠ¢å å¼è°ƒåº¦</li>
<li>ä½å†…å­˜å ç”¨</li>
<li>ä¸°å¯Œçš„API</li>
<li>å¹¿æ³›åº”ç”¨</li>
</ul>
<p><strong>FreeRTOSåŸºç¡€é…ç½®ï¼š</strong></p>
<pre><code class="language-c">/* FreeRTOSConfig.h å…³é”®é…ç½® */
#define configUSE_PREEMPTION            1           // ä½¿èƒ½æŠ¢å å¼è°ƒåº¦
#define configUSE_IDLE_HOOK             0           // ç©ºé—²ä»»åŠ¡é’©å­
#define configUSE_TICK_HOOK             0           // æ—¶é—´ç‰‡é’©å­
#define configCPU_CLOCK_HZ              72000000    // CPUé¢‘ç‡
#define configTICK_RATE_HZ              1000        // ç³»ç»ŸèŠ‚æ‹é¢‘ç‡1KHz
#define configMAX_PRIORITIES            5           // æœ€å¤§ä¼˜å…ˆçº§æ•°
#define configMINIMAL_STACK_SIZE        128         // æœ€å°ä»»åŠ¡æ ˆå¤§å°
#define configTOTAL_HEAP_SIZE           10240       // æ€»å †å¤§å°
#define configMAX_TASK_NAME_LEN         16          // ä»»åŠ¡åæœ€å¤§é•¿åº¦

/* ä¸»å‡½æ•° */
int main(void)
{
    HAL_Init();
    SystemClock_Config();

    /* åˆ›å»ºä»»åŠ¡ */
    xTaskCreate(Task_LED, "LED", 128, NULL, 1, NULL);
    xTaskCreate(Task_USART, "USART", 256, NULL, 2, NULL);

    /* å¯åŠ¨è°ƒåº¦å™¨ */
    vTaskStartScheduler();

    while(1);
}
</code></pre>
<h4 id="62-ä»»åŠ¡ç®¡ç†"><a class="header" href="#62-ä»»åŠ¡ç®¡ç†">6.2 ä»»åŠ¡ç®¡ç†</a></h4>
<p><strong>ä»»åŠ¡åˆ›å»ºä¸ç®¡ç†ï¼š</strong></p>
<pre><code class="language-c">/* LEDä»»åŠ¡ */
void Task_LED(void *pvParameters)
{
    while(1)
    {
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
        vTaskDelay(pdMS_TO_TICKS(1000));  // å»¶æ—¶1000ms
    }
}

/* ä¸²å£ä»»åŠ¡ */
void Task_USART(void *pvParameters)
{
    char msg[] = "FreeRTOS Running\r\n";

    while(1)
    {
        HAL_UART_Transmit(&amp;huart1, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

/* ä»»åŠ¡ä¼˜å…ˆçº§å’Œæ ˆå¤§å° */
TaskHandle_t TaskHandle_LED;
TaskHandle_t TaskHandle_Key;

void CreateTasks(void)
{
    /* åˆ›å»ºLEDä»»åŠ¡ - ä¼˜å…ˆçº§1 */
    xTaskCreate(Task_LED, "LED", 128, NULL, 1, &amp;TaskHandle_LED);

    /* åˆ›å»ºæŒ‰é”®ä»»åŠ¡ - ä¼˜å…ˆçº§2ï¼ˆæ›´é«˜ï¼‰ */
    xTaskCreate(Task_Key, "KEY", 128, NULL, 2, &amp;TaskHandle_Key);
}

/* ä»»åŠ¡æŒ‚èµ·å’Œæ¢å¤ */
void Task_Key(void *pvParameters)
{
    while(1)
    {
        if (Key_Scan())
        {
            /* æŒ‚èµ·LEDä»»åŠ¡ */
            vTaskSuspend(TaskHandle_LED);
            HAL_Delay(3000);
            /* æ¢å¤LEDä»»åŠ¡ */
            vTaskResume(TaskHandle_LED);
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}
</code></pre>
<h4 id="63-ä»»åŠ¡é—´é€šä¿¡"><a class="header" href="#63-ä»»åŠ¡é—´é€šä¿¡">6.3 ä»»åŠ¡é—´é€šä¿¡</a></h4>
<p><strong>æ¶ˆæ¯é˜Ÿåˆ—ï¼š</strong></p>
<pre><code class="language-c">/* æ¶ˆæ¯é˜Ÿåˆ— */
QueueHandle_t xQueue_Sensor;

typedef struct {
    uint16_t temperature;
    uint16_t humidity;
} SensorData_t;

void CreateQueue(void)
{
    /* åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—ï¼š10ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ å¤§å°ä¸ºSensorData_t */
    xQueue_Sensor = xQueueCreate(10, sizeof(SensorData_t));
}

/* ä¼ æ„Ÿå™¨é‡‡é›†ä»»åŠ¡ */
void Task_SensorRead(void *pvParameters)
{
    SensorData_t sensor_data;

    while(1)
    {
        /* è¯»å–ä¼ æ„Ÿå™¨æ•°æ® */
        sensor_data.temperature = ReadTemperature();
        sensor_data.humidity = ReadHumidity();

        /* å‘é€åˆ°é˜Ÿåˆ— */
        if (xQueueSend(xQueue_Sensor, &amp;sensor_data, pdMS_TO_TICKS(100)) != pdPASS)
        {
            /* é˜Ÿåˆ—æ»¡ï¼Œå‘é€å¤±è´¥ */
        }

        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

/* æ•°æ®å¤„ç†ä»»åŠ¡ */
void Task_DataProcess(void *pvParameters)
{
    SensorData_t sensor_data;

    while(1)
    {
        /* ä»é˜Ÿåˆ—æ¥æ”¶æ•°æ® */
        if (xQueueReceive(xQueue_Sensor, &amp;sensor_data, portMAX_DELAY) == pdPASS)
        {
            /* å¤„ç†æ•°æ® */
            printf("Temp: %d, Humi: %d\r\n",
                   sensor_data.temperature,
                   sensor_data.humidity);
        }
    }
}
</code></pre>
<p><strong>ä¿¡å·é‡ï¼š</strong></p>
<pre><code class="language-c">/* äºŒå€¼ä¿¡å·é‡ - ç”¨äºä»»åŠ¡åŒæ­¥ */
SemaphoreHandle_t xSemaphore_Binary;

void CreateSemaphore(void)
{
    xSemaphore_Binary = xSemaphoreCreateBinary();
}

/* ä¸­æ–­ä¸­é‡Šæ”¾ä¿¡å·é‡ */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (GPIO_Pin == GPIO_PIN_0)
    {
        /* é‡Šæ”¾ä¿¡å·é‡ */
        xSemaphoreGiveFromISR(xSemaphore_Binary, &amp;xHigherPriorityTaskWoken);

        /* å¦‚æœéœ€è¦ï¼Œè¿›è¡Œä»»åŠ¡åˆ‡æ¢ */
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}

/* ä»»åŠ¡ä¸­è·å–ä¿¡å·é‡ */
void Task_Process(void *pvParameters)
{
    while(1)
    {
        /* ç­‰å¾…ä¿¡å·é‡ */
        if (xSemaphoreTake(xSemaphore_Binary, portMAX_DELAY) == pdPASS)
        {
            /* å¤„ç†æŒ‰é”®äº‹ä»¶ */
            HandleKeyEvent();
        }
    }
}

/* äº’æ–¥é‡ - ç”¨äºèµ„æºä¿æŠ¤ */
SemaphoreHandle_t xMutex_UART;

void CreateMutex(void)
{
    xMutex_UART = xSemaphoreCreateMutex();
}

/* å®‰å…¨çš„ä¸²å£å‘é€ */
void UART_SendString_Safe(char *str)
{
    /* è·å–äº’æ–¥é‡ */
    if (xSemaphoreTake(xMutex_UART, pdMS_TO_TICKS(100)) == pdPASS)
    {
        /* å‘é€æ•°æ® */
        HAL_UART_Transmit(&amp;huart1, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);

        /* é‡Šæ”¾äº’æ–¥é‡ */
        xSemaphoreGive(xMutex_UART);
    }
}
</code></pre>
<h2 id="-å®æˆ˜é¡¹ç›®"><a class="header" href="#-å®æˆ˜é¡¹ç›®">ğŸ¯ å®æˆ˜é¡¹ç›®</a></h2>
<h3 id="é¡¹ç›®ä¸€æ™ºèƒ½æ¸©æ¹¿åº¦ç›‘æµ‹ç³»ç»Ÿ"><a class="header" href="#é¡¹ç›®ä¸€æ™ºèƒ½æ¸©æ¹¿åº¦ç›‘æµ‹ç³»ç»Ÿ">é¡¹ç›®ä¸€ï¼šæ™ºèƒ½æ¸©æ¹¿åº¦ç›‘æµ‹ç³»ç»Ÿ</a></h3>
<p><strong>é¡¹ç›®éœ€æ±‚ï¼š</strong></p>
<ul>
<li>å®æ—¶é‡‡é›†æ¸©æ¹¿åº¦æ•°æ®</li>
<li>OLEDå±å¹•æ˜¾ç¤º</li>
<li>è¶…é™æŠ¥è­¦ï¼ˆèœ‚é¸£å™¨ï¼‰</li>
<li>ä¸²å£ä¸Šä¼ æ•°æ®</li>
<li>ä½åŠŸè€—è®¾è®¡</li>
</ul>
<p><strong>ç³»ç»Ÿæ¶æ„ï¼š</strong></p>
<pre><code class="language-plaintext">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          STM32F103C8T6              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    FreeRTOSä»»åŠ¡è°ƒåº¦          â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ Task1: ä¼ æ„Ÿå™¨é‡‡é›† (1Hz)     â”‚  â”‚
â”‚  â”‚ Task2: æ•°æ®å¤„ç†ä¸æ˜¾ç¤º (2Hz) â”‚  â”‚
â”‚  â”‚ Task3: ä¸²å£ä¸Šä¼  (0.5Hz)     â”‚  â”‚
â”‚  â”‚ Task4: æŠ¥è­¦æ£€æµ‹ (5Hz)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚      â”‚      â”‚      â”‚
    DHT22  OLED  Buzzer USART
</code></pre>
<p><strong>æ ¸å¿ƒä»£ç æ¡†æ¶ï¼š</strong></p>
<pre><code class="language-c">/* å…¨å±€å˜é‡ */
SensorData_t g_sensor_data;
QueueHandle_t xQueue_Sensor;
SemaphoreHandle_t xMutex_Display;

/* ä»»åŠ¡1ï¼šä¼ æ„Ÿå™¨é‡‡é›† */
void Task_SensorRead(void *pvParameters)
{
    while(1)
    {
        /* è¯»å–DHT22 */
        g_sensor_data.temperature = DHT22_ReadTemperature();
        g_sensor_data.humidity = DHT22_ReadHumidity();
        g_sensor_data.timestamp = xTaskGetTickCount();

        /* å‘é€åˆ°é˜Ÿåˆ— */
        xQueueSend(xQueue_Sensor, &amp;g_sensor_data, 0);

        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

/* ä»»åŠ¡2ï¼šæ•°æ®æ˜¾ç¤º */
void Task_Display(void *pvParameters)
{
    SensorData_t data;
    char buffer[32];

    while(1)
    {
        if (xQueueReceive(xQueue_Sensor, &amp;data, portMAX_DELAY) == pdPASS)
        {
            /* è·å–æ˜¾ç¤ºäº’æ–¥é‡ */
            if (xSemaphoreTake(xMutex_Display, pdMS_TO_TICKS(100)) == pdPASS)
            {
                /* æ˜¾ç¤ºæ¸©åº¦ */
                sprintf(buffer, "Temp: %d.%d C",
                        data.temperature/10, data.temperature%10);
                OLED_ShowString(0, 0, buffer);

                /* æ˜¾ç¤ºæ¹¿åº¦ */
                sprintf(buffer, "Humi: %d.%d %%",
                        data.humidity/10, data.humidity%10);
                OLED_ShowString(0, 2, buffer);

                xSemaphoreGive(xMutex_Display);
            }
        }
    }
}

/* ä»»åŠ¡3ï¼šæŠ¥è­¦æ£€æµ‹ */
void Task_Alarm(void *pvParameters)
{
    const uint16_t TEMP_HIGH = 280;  // 28.0Â°C
    const uint16_t HUMI_HIGH = 800;  // 80.0%

    while(1)
    {
        if (g_sensor_data.temperature &gt; TEMP_HIGH ||
            g_sensor_data.humidity &gt; HUMI_HIGH)
        {
            /* è§¦å‘æŠ¥è­¦ */
            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);
        }
        else
        {
            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
        }

        vTaskDelay(pdMS_TO_TICKS(200));
    }
}

/* ä¸»å‡½æ•° */
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    I2C1_Init();
    USART1_Init();

    /* åˆ›å»ºé˜Ÿåˆ—å’Œäº’æ–¥é‡ */
    xQueue_Sensor = xQueueCreate(5, sizeof(SensorData_t));
    xMutex_Display = xSemaphoreCreateMutex();

    /* åˆ›å»ºä»»åŠ¡ */
    xTaskCreate(Task_SensorRead, "Sensor", 256, NULL, 3, NULL);
    xTaskCreate(Task_Display, "Display", 256, NULL, 2, NULL);
    xTaskCreate(Task_Alarm, "Alarm", 128, NULL, 2, NULL);

    /* å¯åŠ¨è°ƒåº¦å™¨ */
    vTaskStartScheduler();

    while(1);
}
</code></pre>
<h3 id="é¡¹ç›®äºŒå¤šåŠŸèƒ½æ™ºèƒ½å°è½¦"><a class="header" href="#é¡¹ç›®äºŒå¤šåŠŸèƒ½æ™ºèƒ½å°è½¦">é¡¹ç›®äºŒï¼šå¤šåŠŸèƒ½æ™ºèƒ½å°è½¦</a></h3>
<p><strong>é¡¹ç›®éœ€æ±‚ï¼š</strong></p>
<ul>
<li>è“ç‰™/WiFiè¿œç¨‹æ§åˆ¶</li>
<li>è¶…å£°æ³¢é¿éšœ</li>
<li>å¾ªè¿¹åŠŸèƒ½</li>
<li>é€Ÿåº¦PIDæ§åˆ¶</li>
<li>OLEDçŠ¶æ€æ˜¾ç¤º</li>
</ul>
<p><strong>æ ¸å¿ƒåŠŸèƒ½å®ç°ï¼š</strong></p>
<pre><code class="language-c">/* ç”µæœºPWMæ§åˆ¶ */
typedef struct {
    TIM_HandleTypeDef *htim;
    uint32_t channel_left;
    uint32_t channel_right;
    uint16_t speed;
} Motor_t;

void Motor_SetSpeed(Motor_t *motor, int16_t speed_left, int16_t speed_right)
{
    /* å·¦ç”µæœºæ§åˆ¶ */
    if (speed_left &gt;= 0)
    {
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
        __HAL_TIM_SET_COMPARE(motor-&gt;htim, motor-&gt;channel_left, speed_left);
    }
    else
    {
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_RESET);
        __HAL_TIM_SET_COMPARE(motor-&gt;htim, motor-&gt;channel_left, -speed_left);
    }

    /* å³ç”µæœºæ§åˆ¶ */
    if (speed_right &gt;= 0)
    {
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET);
        __HAL_TIM_SET_COMPARE(motor-&gt;htim, motor-&gt;channel_right, speed_right);
    }
    else
    {
        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);
        __HAL_TIM_SET_COMPARE(motor-&gt;htim, motor-&gt;channel_right, -speed_right);
    }
}

/* PIDé€Ÿåº¦æ§åˆ¶ */
typedef struct {
    float Kp;
    float Ki;
    float Kd;
    float error;
    float last_error;
    float integral;
} PID_t;

float PID_Calculate(PID_t *pid, float target, float current)
{
    pid-&gt;error = target - current;
    pid-&gt;integral += pid-&gt;error;

    /* ç§¯åˆ†é™å¹… */
    if (pid-&gt;integral &gt; 1000) pid-&gt;integral = 1000;
    if (pid-&gt;integral &lt; -1000) pid-&gt;integral = -1000;

    float output = pid-&gt;Kp * pid-&gt;error +
                   pid-&gt;Ki * pid-&gt;integral +
                   pid-&gt;Kd * (pid-&gt;error - pid-&gt;last_error);

    pid-&gt;last_error = pid-&gt;error;

    return output;
}

/* è¶…å£°æ³¢æµ‹è· */
uint16_t Ultrasonic_GetDistance(void)
{
    uint32_t time = 0;

    /* å‘é€è§¦å‘ä¿¡å· */
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_SET);
    delay_us(10);
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_RESET);

    /* ç­‰å¾…å›å“ä¿¡å· */
    while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_11) == GPIO_PIN_RESET);
    while(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_11) == GPIO_PIN_SET)
    {
        time++;
        delay_us(1);
    }

    /* è®¡ç®—è·ç¦»ï¼ˆcmï¼‰ */
    return time * 0.017;
}
</code></pre>
<h2 id="-å­¦ä¹ æ•ˆæœéªŒè¯"><a class="header" href="#-å­¦ä¹ æ•ˆæœéªŒè¯">ğŸ“Š å­¦ä¹ æ•ˆæœéªŒè¯</a></h2>
<h3 id="éªŒè¯æ ‡å‡†"><a class="header" href="#éªŒè¯æ ‡å‡†">éªŒè¯æ ‡å‡†</a></h3>
<p><strong>åŸºç¡€é˜¶æ®µéªŒè¯ï¼ˆ1-3å‘¨ï¼‰ï¼š</strong></p>
<ol>
<li>âœ… èƒ½ç‹¬ç«‹æ­å»ºå¼€å‘ç¯å¢ƒå¹¶å®Œæˆç¼–è¯‘ä¸‹è½½</li>
<li>âœ… ç†è§£GPIOçš„8ç§å·¥ä½œæ¨¡å¼å¹¶èƒ½æ­£ç¡®åº”ç”¨</li>
<li>âœ… å®ç°æŒ‰é”®æ¶ˆæŠ–å’ŒLEDå¤šç§é—ªçƒæ¨¡å¼</li>
<li>âœ… é…ç½®å¹¶ä½¿ç”¨è‡³å°‘ä¸€ç§å®šæ—¶å™¨å®ç°ç²¾ç¡®å®šæ—¶</li>
</ol>
<p><strong>è¿›é˜¶é˜¶æ®µéªŒè¯ï¼ˆ4-6å‘¨ï¼‰ï¼š</strong></p>
<ol>
<li>âœ… æŒæ¡ä¸²å£é€šä¿¡å¹¶å®ç°è‡ªå®šä¹‰åè®®</li>
<li>âœ… å®ŒæˆSPIæˆ–I2Cå¤–è®¾é©±åŠ¨ï¼ˆFlash/OLEDç­‰ï¼‰</li>
<li>âœ… ç†è§£ä¸­æ–­ä¼˜å…ˆçº§å¹¶èƒ½å¤„ç†å¤šä¸­æ–­åä½œ</li>
<li>âœ… ä½¿ç”¨DMAæé«˜æ•°æ®ä¼ è¾“æ•ˆç‡</li>
</ol>
<p><strong>é«˜çº§é˜¶æ®µéªŒè¯ï¼ˆ7-10å‘¨ï¼‰ï¼š</strong></p>
<ol>
<li>âœ… æˆåŠŸç§»æ¤FreeRTOSå¹¶åˆ›å»ºå¤šä»»åŠ¡</li>
<li>âœ… æŒæ¡ä»»åŠ¡é—´é€šä¿¡ï¼ˆé˜Ÿåˆ—ã€ä¿¡å·é‡ã€äº’æ–¥é‡ï¼‰</li>
<li>âœ… å®Œæˆä¸€ä¸ªç»¼åˆé¡¹ç›®ï¼ˆé›†æˆ3ç§ä»¥ä¸Šå¤–è®¾ï¼‰</li>
<li>âœ… èƒ½å¤Ÿåˆ†æå’Œä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½</li>
</ol>
<h3 id="å®æˆ˜è€ƒæ ¸é¡¹ç›®"><a class="header" href="#å®æˆ˜è€ƒæ ¸é¡¹ç›®">å®æˆ˜è€ƒæ ¸é¡¹ç›®</a></h3>
<p><strong>è€ƒæ ¸é¡¹ç›®ï¼šç‰©è”ç½‘æ•°æ®é‡‡é›†ç»ˆç«¯</strong></p>
<pre><code class="language-plaintext">åŠŸèƒ½è¦æ±‚ï¼š
1. é‡‡é›†æ¸©æ¹¿åº¦ã€å…‰ç…§ã€PM2.5æ•°æ®
2. OLEDå®æ—¶æ˜¾ç¤º
3. æ•°æ®å­˜å‚¨ï¼ˆSPI Flashï¼‰
4. WiFi/4Gä¸Šä¼ äº‘å¹³å°
5. ä½åŠŸè€—æ¨¡å¼ï¼ˆ&lt;100uAï¼‰
6. OTAè¿œç¨‹å‡çº§

æŠ€æœ¯è¦ç‚¹ï¼š
- å¤šä¼ æ„Ÿå™¨I2C/UARTé€šä¿¡
- FreeRTOSå¤šä»»åŠ¡ç®¡ç†
- é€šä¿¡åè®®è®¾è®¡ï¼ˆMQTTï¼‰
- Flashæ–‡ä»¶ç³»ç»Ÿ
- ä½åŠŸè€—è®¾è®¡
- Bootloaderè®¾è®¡
</code></pre>
<h2 id="-å¼€å‘æŠ€å·§ä¸æœ€ä½³å®è·µ"><a class="header" href="#-å¼€å‘æŠ€å·§ä¸æœ€ä½³å®è·µ">ğŸ”§ å¼€å‘æŠ€å·§ä¸æœ€ä½³å®è·µ</a></h2>
<h3 id="è°ƒè¯•æŠ€å·§"><a class="header" href="#è°ƒè¯•æŠ€å·§">è°ƒè¯•æŠ€å·§</a></h3>
<p><strong>1. ä¸²å£æ‰“å°è°ƒè¯•</strong></p>
<pre><code class="language-c">/* é‡å®šå‘printfåˆ°ä¸²å£ */
#ifdef __GNUC__
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif

PUTCHAR_PROTOTYPE
{
    HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, HAL_MAX_DELAY);
    return ch;
}

/* ä½¿ç”¨ç¤ºä¾‹ */
printf("ADC Value: %d, Voltage: %.2fV\r\n", adc_value, voltage);
</code></pre>
<p><strong>2. é€»è¾‘åˆ†æä»ªä½¿ç”¨</strong></p>
<pre><code class="language-c">/* GPIOç¿»è½¬æµ‹é‡å‡½æ•°æ‰§è¡Œæ—¶é—´ */
void Function_Test(void)
{
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);  // æ ‡è®°å¼€å§‹

    /* å¾…æµ‹è¯•å‡½æ•° */
    TestFunction();

    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); // æ ‡è®°ç»“æŸ
}
</code></pre>
<p><strong>3. SWDè°ƒè¯•æŠ€å·§</strong></p>
<pre><code class="language-c">/* æ–­ç‚¹è°ƒè¯•è¦ç‚¹ */
// 1. ä½¿ç”¨æ–­è¨€æ£€æŸ¥å‚æ•°
#define ASSERT(expr) if(!(expr)) while(1)

// 2. å…³é”®å˜é‡æ ‡è®°ä¸ºvolatileé˜²æ­¢ä¼˜åŒ–
volatile uint32_t debug_counter;

// 3. ä½¿ç”¨__attribute__((optimize("O0")))ç¦æ­¢å‡½æ•°ä¼˜åŒ–
__attribute__((optimize("O0")))
void DebugFunction(void)
{
    // è°ƒè¯•ä»£ç 
}
</code></pre>
<h3 id="å¸¸è§é”™è¯¯ä¸è§£å†³"><a class="header" href="#å¸¸è§é”™è¯¯ä¸è§£å†³">å¸¸è§é”™è¯¯ä¸è§£å†³</a></h3>
<p><strong>1. æ ˆæº¢å‡º</strong></p>
<pre><code class="language-c">/* æ£€æµ‹æ ˆæº¢å‡º */
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    printf("Stack overflow in task: %s\r\n", pcTaskName);
    while(1);  // åœæ­¢ç³»ç»Ÿ
}

/* è§£å†³æ–¹æ¡ˆ */
// 1. å¢åŠ ä»»åŠ¡æ ˆå¤§å°
xTaskCreate(Task, "Name", 512, NULL, 1, NULL);  // å¢åŠ æ ˆå¤§å°

// 2. å‡å°‘å±€éƒ¨å˜é‡ä½¿ç”¨
static uint8_t large_buffer[1024];  // ä½¿ç”¨staticé¿å…å ç”¨æ ˆ

// 3. ä½¿ç”¨åŠ¨æ€å†…å­˜
uint8_t *buffer = pvPortMalloc(1024);
</code></pre>
<p><strong>2. æ—¶é’Ÿé…ç½®é”™è¯¯</strong></p>
<pre><code class="language-c">/* æ£€æŸ¥æ—¶é’Ÿé…ç½® */
void SystemClock_Check(void)
{
    RCC_ClkInitTypeDef clkconfig;
    uint32_t pFLatency;

    HAL_RCC_GetClockConfig(&amp;clkconfig, &amp;pFLatency);

    printf("SYSCLK: %lu Hz\r\n", HAL_RCC_GetSysClockFreq());
    printf("HCLK:   %lu Hz\r\n", HAL_RCC_GetHCLKFreq());
    printf("PCLK1:  %lu Hz\r\n", HAL_RCC_GetPCLK1Freq());
    printf("PCLK2:  %lu Hz\r\n", HAL_RCC_GetPCLK2Freq());
}
</code></pre>
<p><strong>3. ä¸­æ–­ä¼˜å…ˆçº§å†²çª</strong></p>
<pre><code class="language-c">/* FreeRTOSä¸­æ–­ä¼˜å…ˆçº§è§„åˆ™ */
// configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY = 5
// ä¼˜å…ˆçº§0-4ï¼šä¸èƒ½è°ƒç”¨FreeRTOS API
// ä¼˜å…ˆçº§5-15ï¼šå¯ä»¥è°ƒç”¨FromISRå‡½æ•°

/* æ­£ç¡®é…ç½®ç¤ºä¾‹ */
HAL_NVIC_SetPriority(EXTI0_IRQn, 5, 0);      // å¯ä»¥è°ƒç”¨API
HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 3, 0);  // ä¸èƒ½è°ƒç”¨API
</code></pre>
<h3 id="æ€§èƒ½ä¼˜åŒ–"><a class="header" href="#æ€§èƒ½ä¼˜åŒ–">æ€§èƒ½ä¼˜åŒ–</a></h3>
<p><strong>1. ä»£ç ä¼˜åŒ–</strong></p>
<pre><code class="language-c">/* ä½¿ç”¨æŸ¥è¡¨æ³•æ›¿ä»£è®¡ç®— */
const uint16_t sin_table[360] = {0, 17, 35, 52, ...};  // é¢„è®¡ç®—

/* ä½æ“ä½œä¼˜åŒ– */
// ä¸æ¨è
if (value % 2 == 0)

// æ¨è
if ((value &amp; 0x01) == 0)

/* å‡å°‘å‡½æ•°è°ƒç”¨ */
// ä¸æ¨è
for (i = 0; i &lt; 1000; i++)
{
    result += CalculateValue(i);
}

// æ¨è
#define CALCULATE_VALUE(x) ((x) * 2 + 1)
for (i = 0; i &lt; 1000; i++)
{
    result += CALCULATE_VALUE(i);
}
</code></pre>
<p><strong>2. å†…å­˜ä¼˜åŒ–</strong></p>
<pre><code class="language-c">/* ä½¿ç”¨packedç»“æ„ä½“å‡å°‘å†…å­˜ */
typedef struct __attribute__((packed)) {
    uint8_t cmd;
    uint16_t data;
    uint8_t checksum;
} CompactFrame_t;  // 4å­—èŠ‚è€Œé8å­—èŠ‚

/* ä½¿ç”¨ä½åŸŸ */
typedef struct {
    uint8_t flag1 : 1;
    uint8_t flag2 : 1;
    uint8_t flag3 : 1;
    uint8_t reserved : 5;
} StatusFlags_t;  // 1å­—èŠ‚è€Œé3å­—èŠ‚
</code></pre>
<p><strong>3. åŠŸè€—ä¼˜åŒ–</strong></p>
<pre><code class="language-c">/* ç¡çœ æ¨¡å¼ */
void EnterSleepMode(void)
{
    /* å…³é—­ä¸å¿…è¦çš„å¤–è®¾ */
    HAL_SPI_DeInit(&amp;hspi1);
    HAL_I2C_DeInit(&amp;hi2c1);

    /* è¿›å…¥åœæ­¢æ¨¡å¼ */
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);

    /* å”¤é†’åé‡æ–°é…ç½®æ—¶é’Ÿ */
    SystemClock_Config();
}

/* ä½åŠŸè€—å®šæ—¶å™¨å”¤é†’ */
void LowPower_TimerWakeup(uint32_t seconds)
{
    __HAL_RCC_PWR_CLK_ENABLE();
    HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);

    HAL_RTCEx_SetWakeUpTimer_IT(&amp;hrtc, seconds, RTC_WAKEUPCLOCK_CK_SPRE_16BITS);
    HAL_PWR_EnterSTANDBYMode();
}
</code></pre>
<h2 id="-æ‰©å±•èµ„æº"><a class="header" href="#-æ‰©å±•èµ„æº">ğŸ“– æ‰©å±•èµ„æº</a></h2>
<h3 id="å®˜æ–¹èµ„æº"><a class="header" href="#å®˜æ–¹èµ„æº">å®˜æ–¹èµ„æº</a></h3>
<ol>
<li>
<p><strong>STå®˜æ–¹ç½‘ç«™</strong></p>
<ul>
<li>æ•°æ®æ‰‹å†Œï¼šhttps://www.st.com/zh/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html</li>
<li>å‚è€ƒæ‰‹å†Œï¼šhttps://www.st.com/resource/zh/reference_manual/</li>
<li>åº”ç”¨ç¬”è®°ï¼šhttps://www.st.com/zh/embedded-software/stm32cube-mcu-packages.html</li>
</ul>
</li>
<li>
<p><strong>å¼€å‘å·¥å…·</strong></p>
<ul>
<li>STM32CubeMXï¼šhttps://www.st.com/zh/development-tools/stm32cubemx.html</li>
<li>STM32CubeIDEï¼šhttps://www.st.com/zh/development-tools/stm32cubeide.html</li>
<li>ST-Linké©±åŠ¨ï¼šhttps://www.st.com/zh/development-tools/stsw-link009.html</li>
</ul>
</li>
</ol>
<h3 id="å­¦ä¹ ç½‘ç«™"><a class="header" href="#å­¦ä¹ ç½‘ç«™">å­¦ä¹ ç½‘ç«™</a></h3>
<ol>
<li>
<p><strong>å®˜æ–¹ç¤¾åŒº</strong></p>
<ul>
<li>STç¤¾åŒºï¼šhttps://community.st.com/</li>
<li>ST Wikiï¼šhttps://wiki.st.com/</li>
</ul>
</li>
<li>
<p><strong>ä¼˜ç§€åšå®¢ä¸è®ºå›</strong></p>
<ul>
<li>æ­£ç‚¹åŸå­ï¼šhttp://www.openedv.com/</li>
<li>é‡ç«ç”µå­ï¼šhttps://www.firebbs.cn/</li>
<li>CSDN STM32ä¸“é¢˜ï¼šhttps://blog.csdn.net/</li>
</ul>
</li>
<li>
<p><strong>å¼€æºé¡¹ç›®</strong></p>
<ul>
<li>GitHub STM32é¡¹ç›®ï¼šhttps://github.com/topics/stm32</li>
<li>RT-Threadï¼šhttps://www.rt-thread.org/</li>
</ul>
</li>
</ol>
<h3 id="æ¨èä¹¦ç±"><a class="header" href="#æ¨èä¹¦ç±">æ¨èä¹¦ç±</a></h3>
<ol>
<li>ã€ŠSTM32å¾®æ§åˆ¶å™¨åº”ç”¨ä¸å®è·µã€‹ - åŸºç¡€å…¥é—¨</li>
<li>ã€ŠSTM32 Cortex-M3æƒå¨æŒ‡å—ã€‹ - æ·±å…¥ç†è§£</li>
<li>ã€ŠåµŒå…¥å¼å®æ—¶æ“ä½œç³»ç»ŸFreeRTOSåŸç†ä¸å®è·µã€‹ - RTOSå­¦ä¹ </li>
<li>ã€ŠARM Cortex-M3ä¸Cortex-M4æƒå¨æŒ‡å—ã€‹ - å†…æ ¸æ·±å…¥</li>
</ol>
<h3 id="å­¦ä¹ è·¯çº¿å»ºè®®"><a class="header" href="#å­¦ä¹ è·¯çº¿å»ºè®®">å­¦ä¹ è·¯çº¿å»ºè®®</a></h3>
<p><strong>ç¬¬1-2å‘¨ï¼š</strong></p>
<ul>
<li>å®Œæˆå¼€å‘ç¯å¢ƒæ­å»º</li>
<li>å­¦ä¹ GPIOã€ä¸­æ–­ã€å®šæ—¶å™¨åŸºç¡€</li>
<li>å®ŒæˆLEDã€æŒ‰é”®ã€èœ‚é¸£å™¨åŸºç¡€å®éªŒ</li>
</ul>
<p><strong>ç¬¬3-4å‘¨ï¼š</strong></p>
<ul>
<li>å­¦ä¹ ä¸²å£é€šä¿¡å’Œåè®®è®¾è®¡</li>
<li>å­¦ä¹ SPI/I2Cé€šä¿¡</li>
<li>é©±åŠ¨OLEDæ˜¾ç¤ºå±æˆ–Flashå­˜å‚¨å™¨</li>
</ul>
<p><strong>ç¬¬5-6å‘¨ï¼š</strong></p>
<ul>
<li>å­¦ä¹ DMAå’ŒADC/DAC</li>
<li>å­¦ä¹ PWMå’Œè¾“å…¥æ•è·</li>
<li>å®Œæˆä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†é¡¹ç›®</li>
</ul>
<p><strong>ç¬¬7-8å‘¨ï¼š</strong></p>
<ul>
<li>å­¦ä¹ FreeRTOSåŸºç¡€</li>
<li>æŒæ¡ä»»åŠ¡ç®¡ç†å’Œè°ƒåº¦</li>
<li>å®Œæˆå¤šä»»åŠ¡ç»¼åˆé¡¹ç›®</li>
</ul>
<p><strong>ç¬¬9-10å‘¨ï¼š</strong></p>
<ul>
<li>å­¦ä¹ FreeRTOSé«˜çº§ç‰¹æ€§</li>
<li>å­¦ä¹ é€šä¿¡åè®®æ ˆï¼ˆMQTTç­‰ï¼‰</li>
<li>å®Œæˆç‰©è”ç½‘ç»ˆç«¯é¡¹ç›®</li>
</ul>
<p><strong>ç¬¬11-12å‘¨ï¼š</strong></p>
<ul>
<li>æ·±å…¥å­¦ä¹ ä½åŠŸè€—è®¾è®¡</li>
<li>å­¦ä¹ Bootloaderå’ŒOTA</li>
<li>å®Œæˆç»¼åˆæ¯•ä¸šè®¾è®¡é¡¹ç›®</li>
</ul>
<h2 id="-æ€»ç»“"><a class="header" href="#-æ€»ç»“">ğŸ“ æ€»ç»“</a></h2>
<p>STM32ä½œä¸ºç›®å‰æœ€æµè¡Œçš„32ä½å¾®æ§åˆ¶å™¨ä¹‹ä¸€ï¼Œå­¦ä¹ æ›²çº¿ç›¸å¯¹å¹³ç¼“ï¼Œä½†è¦çœŸæ­£æŒæ¡éœ€è¦å¤§é‡å®è·µã€‚æœ¬ç¬”è®°ä»åŸºç¡€åˆ°è¿›é˜¶ï¼Œæ¶µç›–äº†STM32å¼€å‘çš„æ ¸å¿ƒçŸ¥è¯†ç‚¹ï¼Œå¹¶æä¾›äº†ä¸°å¯Œçš„å®æˆ˜æ¡ˆä¾‹ã€‚</p>
<p><strong>å­¦ä¹ å»ºè®®ï¼š</strong></p>
<ol>
<li>å¾ªåºæ¸è¿›ï¼Œä¸è¦è·³è¿‡åŸºç¡€çŸ¥è¯†</li>
<li>å¤šåŠ¨æ‰‹å®è·µï¼Œæ¯ä¸ªçŸ¥è¯†ç‚¹éƒ½è¦äº²è‡ªéªŒè¯</li>
<li>å­¦ä¼šæŸ¥é˜…æ•°æ®æ‰‹å†Œå’Œå‚è€ƒæ‰‹å†Œ</li>
<li>ç§¯æå‚ä¸å¼€æºç¤¾åŒºï¼Œå­¦ä¹ ä»–äººä»£ç </li>
<li>å®Œæˆè‡³å°‘2-3ä¸ªç»¼åˆé¡¹ç›®</li>
</ol>
<p><strong>ä¸‹ä¸€æ­¥æ–¹å‘ï¼š</strong></p>
<ul>
<li>æ·±å…¥å­¦ä¹ ARM Cortex-Må†…æ ¸æ¶æ„</li>
<li>å­¦ä¹ åµŒå…¥å¼Linuxå¼€å‘</li>
<li>å­¦ä¹ æ— çº¿é€šä¿¡åè®®ï¼ˆè“ç‰™ã€WiFiã€LoRaï¼‰</li>
<li>å­¦ä¹ AIè¾¹ç¼˜è®¡ç®—ï¼ˆTensorFlow Liteï¼‰</li>
</ul>
<p>ç¥æ‚¨å­¦ä¹ é¡ºåˆ©ï¼æœ‰ä»»ä½•é—®é¢˜æ¬¢è¿äº¤æµæ¢è®¨ã€‚</p>
<hr />
<p><strong>æœ€åæ›´æ–°æ—¶é—´ï¼š</strong> 2025-11-01
<strong>é€‚ç”¨å¯¹è±¡ï¼š</strong> 0-5å¹´ç»éªŒçš„åµŒå…¥å¼å¼€å‘è€…
<strong>éš¾åº¦çº§åˆ«ï¼š</strong> â­â­â­ (ä¸­çº§)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../ç¼–ç¨‹/embbed/micropython.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../ç¼–ç¨‹/embbed/uboot.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../ç¼–ç¨‹/embbed/micropython.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../ç¼–ç¨‹/embbed/uboot.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

