<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GD32微控制器完整学习指南 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="gd32微控制器完整学习指南"><a class="header" href="#gd32微控制器完整学习指南">GD32微控制器完整学习指南</a></h1>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="#%E7%AC%AC1%E7%AB%A0-gd32%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8">第1章 GD32基础入门</a></li>
<li><a href="#%E7%AC%AC2%E7%AB%A0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">第2章 开发环境搭建</a></li>
<li><a href="#%E7%AC%AC3%E7%AB%A0-gpio%E6%8E%A7%E5%88%B6%E7%BC%96%E7%A8%8B">第3章 GPIO控制编程</a></li>
<li><a href="#%E7%AC%AC4%E7%AB%A0-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8Epwm">第4章 定时器与PWM</a></li>
<li><a href="#%E7%AC%AC5%E7%AB%A0-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1">第5章 串口通信</a></li>
<li><a href="#%E7%AC%AC6%E7%AB%A0-adc%E4%B8%8Edac">第6章 ADC与DAC</a></li>
<li><a href="#%E7%AC%AC7%E7%AB%A0-spi%E4%B8%8Ei2c">第7章 SPI与I2C</a></li>
<li><a href="#%E7%AC%AC8%E7%AB%A0-dma%E4%BC%A0%E8%BE%93">第8章 DMA传输</a></li>
<li><a href="#%E7%AC%AC9%E7%AB%A0-%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE">第9章 实战项目</a></li>
</ul>
<hr />
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<h3 id="学习目标"><a class="header" href="#学习目标">学习目标</a></h3>
<ul>
<li>掌握GD32系列MCU的特性和应用</li>
<li>熟练使用固件库进行开发</li>
<li>实现各类外设的控制编程</li>
<li>完成STM32到GD32的移植</li>
<li>掌握完整项目开发流程</li>
</ul>
<h3 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h3>
<ul>
<li>硬件: GD32开发板(GD32F103/GD32F407等)</li>
<li>软件: Keil MDK / GCC-ARM / System Workbench</li>
<li>调试器: J-Link / ST-Link / GD-Link</li>
<li>文档: GD32固件库和数据手册</li>
</ul>
<hr />
<h2 id="第1章-gd32基础入门"><a class="header" href="#第1章-gd32基础入门">第1章 GD32基础入门</a></h2>
<h3 id="11-gd32简介"><a class="header" href="#11-gd32简介">1.1 GD32简介</a></h3>
<h4 id="111-核心特性"><a class="header" href="#111-核心特性">1.1.1 核心特性</a></h4>
<p>GD32是兆易创新推出的32位ARM Cortex-M系列MCU。</p>
<p><strong>主要系列:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>系列</th><th>内核</th><th>主频</th><th>Flash</th><th>RAM</th><th>特点</th></tr></thead><tbody>
<tr><td>GD32F103</td><td>Cortex-M3</td><td>108MHz</td><td>64K-1M</td><td>10K-96K</td><td>兼容STM32F1</td></tr>
<tr><td>GD32F303</td><td>Cortex-M4F</td><td>120MHz</td><td>256K-3M</td><td>32K-512K</td><td>浮点运算</td></tr>
<tr><td>GD32F407</td><td>Cortex-M4F</td><td>168MHz</td><td>512K-3M</td><td>128K-512K</td><td>高性能</td></tr>
<tr><td>GD32E103</td><td>Cortex-M4F</td><td>120MHz</td><td>64K-512K</td><td>16K-128K</td><td>浮点增强</td></tr>
<tr><td>GD32E230</td><td>Cortex-M23</td><td>72MHz</td><td>16K-64K</td><td>4K-8K</td><td>超低功耗</td></tr>
</tbody></table>
</div>
<h4 id="112-gd32-vs-stm32对比"><a class="header" href="#112-gd32-vs-stm32对比">1.1.2 GD32 vs STM32对比</a></h4>
<pre><code class="language-c">// GD32与STM32的主要差异

// 1. 主频优势
// GD32F103: 108MHz vs STM32F103: 72MHz
// 运算性能提升50%

// 2. Flash零等待
// GD32: 零等待周期 @108MHz
// STM32: 需要2等待周期 @72MHz

// 3. API接口兼容
// GPIO配置命名
// STM32:
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

// GD32:
GPIO_InitStructure.GPIO_Speed = GPIO_SPEED_50MHZ; // 大写命名

// 4. 成本优势
// GD32提供更高性价比
// 引脚完全兼容便于替换
</code></pre>
<h3 id="12-芯片硬件架构"><a class="header" href="#12-芯片硬件架构">1.2 芯片硬件架构</a></h3>
<pre><code class="language-c">// gd32f103_board.h - 硬件配置定义
#ifndef GD32F103_BOARD_H
#define GD32F103_BOARD_H

#include "gd32f10x.h"

// LED定义
#define LED1_PIN                   GPIO_PIN_0
#define LED1_GPIO_PORT             GPIOA
#define LED1_GPIO_CLK              RCU_GPIOA

#define LED2_PIN                   GPIO_PIN_1
#define LED2_GPIO_PORT             GPIOA
#define LED2_GPIO_CLK              RCU_GPIOA

// 按键定义
#define KEY1_PIN                   GPIO_PIN_0
#define KEY1_GPIO_PORT             GPIOB
#define KEY1_GPIO_CLK              RCU_GPIOB
#define KEY1_EXTI_LINE             EXTI_0
#define KEY1_EXTI_PORT_SOURCE      GPIO_PORT_SOURCE_GPIOB
#define KEY1_EXTI_PIN_SOURCE       GPIO_PIN_SOURCE_0
#define KEY1_EXTI_IRQn             EXTI0_IRQn

// 串口定义
#define DEBUG_USART                USART0
#define DEBUG_USART_CLK            RCU_USART0
#define DEBUG_USART_TX_PIN         GPIO_PIN_9
#define DEBUG_USART_RX_PIN         GPIO_PIN_10
#define DEBUG_USART_GPIO_PORT      GPIOA
#define DEBUG_USART_GPIO_CLK       RCU_GPIOA

#endif
</code></pre>
<h3 id="13-时钟系统配置"><a class="header" href="#13-时钟系统配置">1.3 时钟系统配置</a></h3>
<pre><code class="language-c">// system_clock.c - 时钟配置
#include "gd32f10x.h"

/*!
    \brief      配置系统时钟为108MHz
    \param[in]  none
    \param[out] none
    \retval     none
*/
void system_clock_108m_hxtal(void)
{
    uint32_t timeout = 0U;
    uint32_t stab_flag = 0U;

    /* 使能外部高速晶振HXTAL (8MHz) */
    RCU_CTL |= RCU_CTL_HXTALEN;

    /* 等待HXTAL稳定 */
    do {
        timeout++;
        stab_flag = (RCU_CTL &amp; RCU_CTL_HXTALSTB);
    } while((0U == stab_flag) &amp;&amp; (HXTAL_STARTUP_TIMEOUT != timeout));

    if(0U != (RCU_CTL &amp; RCU_CTL_HXTALSTB)) {
        /* AHB = SYSCLK */
        RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;

        /* APB2 = AHB/1 */
        RCU_CFG0 |= RCU_APB2_CKAHB_DIV1;

        /* APB1 = AHB/2 */
        RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;

        /* 配置PLL: 8MHz * 27 / 2 = 108MHz */
        RCU_CFG0 &amp;= ~(RCU_CFG0_PLLMF | RCU_CFG0_PLLMF_4);
        RCU_CFG0 |= (RCU_PLLSRC_HXTAL | RCU_PLL_MUL27);

        /* 使能PLL */
        RCU_CTL |= RCU_CTL_PLLEN;

        /* 等待PLL稳定 */
        while(0U == (RCU_CTL &amp; RCU_CTL_PLLSTB));

        /* 选择PLL作为系统时钟 */
        RCU_CFG0 &amp;= ~RCU_CFG0_SCS;
        RCU_CFG0 |= RCU_CKSYSSRC_PLL;

        /* 等待PLL作为系统时钟 */
        while(0U == (RCU_CFG0 &amp; RCU_SCSS_PLL));
    } else {
        /* HXTAL启动失败，使用内部时钟 */
        while(1);
    }
}

// 获取系统时钟频率
uint32_t system_clock_get(void)
{
    uint32_t sysclk = 0U;
    uint32_t pll_mul = 0U;

    uint32_t scss = (RCU_CFG0 &amp; RCU_CFG0_SCSS) &gt;&gt; 2;

    switch(scss) {
    case 0:  // IRC8M
        sysclk = IRC8M_VALUE;
        break;
    case 1:  // HXTAL
        sysclk = HXTAL_VALUE;
        break;
    case 2:  // PLL
        pll_mul = GET_BITS(RCU_CFG0, 18, 21);
        sysclk = HXTAL_VALUE * (pll_mul + 2) / 2;
        break;
    default:
        sysclk = IRC8M_VALUE;
        break;
    }

    return sysclk;
}
</code></pre>
<hr />
<h2 id="第2章-开发环境搭建"><a class="header" href="#第2章-开发环境搭建">第2章 开发环境搭建</a></h2>
<h3 id="21-keil-mdk配置"><a class="header" href="#21-keil-mdk配置">2.1 Keil MDK配置</a></h3>
<h4 id="211-安装配置"><a class="header" href="#211-安装配置">2.1.1 安装配置</a></h4>
<pre><code class="language-bash"># 1. 安装Keil MDK-ARM
# 下载地址: https://www.keil.com/download/product/

# 2. 安装GD32芯片包
# 下载: GigaDevice.GD32F10x_DFP.x.x.x.pack
# 双击安装或通过Pack Installer安装

# 3. 创建工程
# File -&gt; New Project
# 选择芯片: GD32F103VET6

# 4. 配置工程选项
# Project -&gt; Options for Target
# - C/C++: 添加Include路径
# - Debug: 选择调试器(J-Link/ST-Link)
# - Utilities: 配置下载算法
</code></pre>
<h4 id="212-hello-world"><a class="header" href="#212-hello-world">2.1.2 Hello World</a></h4>
<pre><code class="language-c">// main.c - GD32 Hello World
#include "gd32f10x.h"
#include "systick.h"

// LED初始化
void led_init(void)
{
    // 使能GPIO时钟
    rcu_periph_clock_enable(RCU_GPIOA);

    // 配置GPIO为推挽输出
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // LED初始状态为熄灭
    gpio_bit_set(GPIOA, GPIO_PIN_0);
}

int main(void)
{
    // 配置系统时钟
    systick_config();

    // 初始化LED
    led_init();

    while(1) {
        // LED闪烁
        gpio_bit_toggle(GPIOA, GPIO_PIN_0);
        delay_1ms(500);
    }
}
</code></pre>
<h3 id="22-gcc开发环境"><a class="header" href="#22-gcc开发环境">2.2 GCC开发环境</a></h3>
<pre><code class="language-makefile"># Makefile - GCC编译配置
TARGET = gd32f103_app

# 编译工具定义
CROSS_COMPILE = arm-none-eabi-
CC = $(CROSS_COMPILE)gcc
AS = $(CROSS_COMPILE)as
LD = $(CROSS_COMPILE)ld
OBJCOPY = $(CROSS_COMPILE)objcopy
SIZE = $(CROSS_COMPILE)size

# MCU定义
MCU = -mcpu=cortex-m3 -mthumb

# 编译选项
CFLAGS = $(MCU)
CFLAGS += -Wall -Wextra
CFLAGS += -O2 -g
CFLAGS += -ffunction-sections -fdata-sections

# 链接选项
LDFLAGS = $(MCU)
LDFLAGS += -specs=nano.specs
LDFLAGS += -Wl,--gc-sections
LDFLAGS += -Wl,-Map=$(TARGET).map

# 源文件
SOURCES = main.c
SOURCES += system_gd32f10x.c
SOURCES += startup_gd32f10x_hd.s

# 固件库源文件
FIRMWARE_DIR = Firmware
SOURCES += $(FIRMWARE_DIR)/Source/gd32f10x_gpio.c
SOURCES += $(FIRMWARE_DIR)/Source/gd32f10x_rcu.c
SOURCES += $(FIRMWARE_DIR)/Source/gd32f10x_usart.c

# 包含路径
INCLUDES = -I.
INCLUDES += -I$(FIRMWARE_DIR)/Include
INCLUDES += -ICMSIS

# 构建目标
all: $(TARGET).bin $(TARGET).hex
	$(SIZE) $(TARGET).elf

$(TARGET).bin: $(TARGET).elf
	$(OBJCOPY) -O binary $&lt; $@

$(TARGET).hex: $(TARGET).elf
	$(OBJCOPY) -O ihex $&lt; $@

$(TARGET).elf: $(SOURCES)
	$(CC) $(CFLAGS) $(LDFLAGS) $(INCLUDES) $^ -o $@

clean:
	rm -f *.o *.elf *.bin *.hex *.map

# 烧录
flash: $(TARGET).bin
	openocd -f interface/jlink.cfg -f target/stm32f1x.cfg \
		-c "program $(TARGET).bin 0x08000000 verify reset exit"

.PHONY: all clean flash
</code></pre>
<h3 id="23-固件库结构"><a class="header" href="#23-固件库结构">2.3 固件库结构</a></h3>
<pre><code class="language-c">// firmware_structure.c - 固件库结构说明

/*
GD32F10x固件库目录结构:

GD32F10x_Firmware_Library/
├── CMSIS/                    # ARM CMSIS标准接口
│   ├── core_cm3.h           # Cortex-M3核心定义
│   ├── system_gd32f10x.c    # 系统初始化
│   └── gd32f10x.h           # 芯片寄存器定义
│
├── GD32F10x_standard_peripheral/
│   ├── Include/             # 外设驱动头文件
│   │   ├── gd32f10x_gpio.h  # GPIO驱动
│   │   ├── gd32f10x_rcu.h   # 时钟驱动
│   │   ├── gd32f10x_usart.h # 串口驱动
│   │   ├── gd32f10x_adc.h   # ADC驱动
│   │   ├── gd32f10x_timer.h # 定时器驱动
│   │   ├── gd32f10x_dma.h   # DMA驱动
│   │   └── ...
│   │
│   └── Source/              # 外设驱动实现
│       ├── gd32f10x_gpio.c
│       ├── gd32f10x_rcu.c
│       └── ...
│
└── Examples/                # 例程代码
    ├── GPIO/
    ├── USART/
    ├── TIMER/
    └── ...

主要API命名规则:
- rcu_xxxx:  时钟控制函数
- gpio_xxxx: GPIO控制函数
- timer_xxxx: 定时器函数
- usart_xxxx: 串口函数
- adc_xxxx:   ADC函数
- spi_xxxx:   SPI函数
- i2c_xxxx:   I2C函数
*/
</code></pre>
<hr />
<h2 id="第3章-gpio控制编程"><a class="header" href="#第3章-gpio控制编程">第3章 GPIO控制编程</a></h2>
<h3 id="31-gpio基本操作"><a class="header" href="#31-gpio基本操作">3.1 GPIO基本操作</a></h3>
<pre><code class="language-c">// gpio_example.c - GPIO基础示例
#include "gd32f10x.h"

// GPIO初始化
void gpio_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_GPIOB);

    // 配置PA0为推挽输出(LED)
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 配置PB0为上拉输入(按键)
    gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 配置PA8为复用推挽(PWM)
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);
}

// GPIO基本操作
void gpio_operations(void)
{
    // 设置引脚为高电平
    gpio_bit_set(GPIOA, GPIO_PIN_0);

    // 设置引脚为低电平
    gpio_bit_reset(GPIOA, GPIO_PIN_0);

    // 翻转引脚
    gpio_bit_toggle(GPIOA, GPIO_PIN_0);

    // 读取输入状态
    FlagStatus key_state = gpio_input_bit_get(GPIOB, GPIO_PIN_0);
    if(SET == key_state) {
        // 按键按下
    }

    // 读取整个端口
    uint16_t port_value = gpio_input_port_get(GPIOB);
}
</code></pre>
<h3 id="32-外部中断"><a class="header" href="#32-外部中断">3.2 外部中断</a></h3>
<pre><code class="language-c">// exti_example.c - 外部中断示例
#include "gd32f10x.h"

// 外部中断配置
void exti_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOB);
    rcu_periph_clock_enable(RCU_AF);

    // 配置GPIO为输入
    gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 连接EXTI线到GPIO
    gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOB, GPIO_PIN_SOURCE_0);

    // 配置EXTI线
    exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);
    exti_interrupt_flag_clear(EXTI_0);

    // 配置NVIC
    nvic_irq_enable(EXTI0_IRQn, 2, 0);
}

// EXTI中断处理函数
void EXTI0_IRQHandler(void)
{
    if(RESET != exti_interrupt_flag_get(EXTI_0)) {
        // 中断处理
        gpio_bit_toggle(GPIOA, GPIO_PIN_0);

        // 清除中断标志
        exti_interrupt_flag_clear(EXTI_0);
    }
}
</code></pre>
<h3 id="33-按键消抖"><a class="header" href="#33-按键消抖">3.3 按键消抖</a></h3>
<pre><code class="language-c">// key_debounce.c - 按键消抖
#include "gd32f10x.h"
#include "systick.h"

#define KEY_PIN  GPIO_PIN_0
#define KEY_PORT GPIOB

typedef enum {
    KEY_RELEASED = 0,
    KEY_PRESSED = 1
} key_state_t;

// 按键扫描(软件消抖)
key_state_t key_scan(void)
{
    static uint8_t key_filter = 0;
    static key_state_t key_state = KEY_RELEASED;

    // 读取按键
    if(RESET == gpio_input_bit_get(KEY_PORT, KEY_PIN)) {
        // 按键按下
        key_filter++;
        if(key_filter &gt;= 3) {  // 连续3次检测到低电平
            key_filter = 3;
            if(key_state == KEY_RELEASED) {
                key_state = KEY_PRESSED;
                return KEY_PRESSED;
            }
        }
    } else {
        // 按键释放
        key_filter = 0;
        key_state = KEY_RELEASED;
    }

    return KEY_RELEASED;
}

// 使用示例
int main(void)
{
    systick_config();
    gpio_config();

    while(1) {
        if(key_scan() == KEY_PRESSED) {
            // 按键动作
            gpio_bit_toggle(GPIOA, GPIO_PIN_0);
        }
        delay_1ms(10);  // 扫描周期10ms
    }
}
</code></pre>
<hr />
<h2 id="第4章-定时器与pwm"><a class="header" href="#第4章-定时器与pwm">第4章 定时器与PWM</a></h2>
<h3 id="41-基本定时器"><a class="header" href="#41-基本定时器">4.1 基本定时器</a></h3>
<pre><code class="language-c">// timer_example.c - 定时器示例
#include "gd32f10x.h"

// 定时器配置(1ms中断)
void timer_config(void)
{
    timer_parameter_struct timer_initpara;

    // 使能定时器时钟
    rcu_periph_clock_enable(RCU_TIMER1);

    // 复位定时器
    timer_deinit(TIMER1);

    // 配置定时器参数
    timer_initpara.prescaler = 10800 - 1;  // 108MHz / 10800 = 10kHz
    timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
    timer_initpara.counterdirection = TIMER_COUNTER_UP;
    timer_initpara.period = 10 - 1;  // 10kHz / 10 = 1kHz (1ms)
    timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
    timer_init(TIMER1, &amp;timer_initpara);

    // 使能定时器中断
    timer_interrupt_enable(TIMER1, TIMER_INT_UP);

    // 配置NVIC
    nvic_irq_enable(TIMER1_IRQn, 1, 0);

    // 启动定时器
    timer_enable(TIMER1);
}

// 定时器中断处理函数
void TIMER1_IRQHandler(void)
{
    if(SET == timer_interrupt_flag_get(TIMER1, TIMER_INT_FLAG_UP)) {
        // 清除中断标志
        timer_interrupt_flag_clear(TIMER1, TIMER_INT_FLAG_UP);

        // 1ms定时任务
        static uint32_t count = 0;
        count++;
        if(count &gt;= 1000) {  // 1秒
            count = 0;
            gpio_bit_toggle(GPIOA, GPIO_PIN_0);
        }
    }
}
</code></pre>
<h3 id="42-pwm输出"><a class="header" href="#42-pwm输出">4.2 PWM输出</a></h3>
<pre><code class="language-c">// pwm_example.c - PWM输出示例
#include "gd32f10x.h"

// PWM配置(1kHz, 50%占空比)
void pwm_config(void)
{
    timer_oc_parameter_struct timer_ocintpara;
    timer_parameter_struct timer_initpara;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_TIMER0);

    // 配置GPIO为复用推挽
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);

    // 配置定时器
    timer_deinit(TIMER0);
    timer_initpara.prescaler = 108 - 1;  // 108MHz / 108 = 1MHz
    timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
    timer_initpara.counterdirection = TIMER_COUNTER_UP;
    timer_initpara.period = 1000 - 1;  // 1MHz / 1000 = 1kHz
    timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
    timer_init(TIMER0, &amp;timer_initpara);

    // 配置PWM模式
    timer_ocintpara.outputstate = TIMER_CCX_ENABLE;
    timer_ocintpara.outputnstate = TIMER_CCXN_DISABLE;
    timer_ocintpara.ocpolarity = TIMER_OC_POLARITY_HIGH;
    timer_ocintpara.ocnpolarity = TIMER_OCN_POLARITY_HIGH;
    timer_ocintpara.ocidlestate = TIMER_OC_IDLE_STATE_LOW;
    timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
    timer_channel_output_config(TIMER0, TIMER_CH_0, &amp;timer_ocintpara);

    timer_channel_output_pulse_value_config(TIMER0, TIMER_CH_0, 500); // 50%占空比
    timer_channel_output_mode_config(TIMER0, TIMER_CH_0, TIMER_OC_MODE_PWM0);
    timer_channel_output_shadow_config(TIMER0, TIMER_CH_0, TIMER_OC_SHADOW_DISABLE);

    timer_primary_output_config(TIMER0, ENABLE);
    timer_auto_reload_shadow_enable(TIMER0);
    timer_enable(TIMER0);
}

// 设置占空比(0-1000)
void pwm_set_duty(uint16_t duty)
{
    timer_channel_output_pulse_value_config(TIMER0, TIMER_CH_0, duty);
}

// 呼吸灯效果
void breathing_led_demo(void)
{
    uint16_t duty = 0;
    int8_t direction = 1;

    while(1) {
        pwm_set_duty(duty);

        duty += direction * 10;

        if(duty &gt;= 1000) {
            direction = -1;
        } else if(duty &lt;= 0) {
            direction = 1;
        }

        delay_1ms(20);
    }
}
</code></pre>
<h3 id="43-输入捕获"><a class="header" href="#43-输入捕获">4.3 输入捕获</a></h3>
<pre><code class="language-c">// input_capture.c - 输入捕获测量频率
#include "gd32f10x.h"

volatile uint32_t captured_value = 0;
volatile uint32_t frequency = 0;

// 输入捕获配置
void input_capture_config(void)
{
    timer_ic_parameter_struct timer_icinitpara;
    timer_parameter_struct timer_initpara;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_TIMER1);

    // 配置GPIO为浮空输入
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 配置定时器
    timer_deinit(TIMER1);
    timer_initpara.prescaler = 108 - 1;  // 1MHz计数频率
    timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
    timer_initpara.counterdirection = TIMER_COUNTER_UP;
    timer_initpara.period = 65535;
    timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
    timer_init(TIMER1, &amp;timer_initpara);

    // 配置输入捕获
    timer_icinitpara.icpolarity = TIMER_IC_POLARITY_RISING;
    timer_icinitpara.icselection = TIMER_IC_SELECTION_DIRECTTI;
    timer_icinitpara.icprescaler = TIMER_IC_PSC_DIV1;
    timer_icinitpara.icfilter = 0x0;
    timer_input_capture_config(TIMER1, TIMER_CH_0, &amp;timer_icinitpara);

    // 使能捕获中断
    timer_interrupt_enable(TIMER1, TIMER_INT_CH0);
    nvic_irq_enable(TIMER1_IRQn, 1, 0);

    // 启动定时器
    timer_enable(TIMER1);
}

// 定时器中断处理
void TIMER1_IRQHandler(void)
{
    if(SET == timer_interrupt_flag_get(TIMER1, TIMER_INT_FLAG_CH0)) {
        timer_interrupt_flag_clear(TIMER1, TIMER_INT_FLAG_CH0);

        static uint32_t last_captured = 0;
        captured_value = timer_channel_capture_value_register_read(TIMER1, TIMER_CH_0);

        if(captured_value &gt; last_captured) {
            uint32_t delta = captured_value - last_captured;
            frequency = 1000000 / delta;  // 计数频率1MHz
        }

        last_captured = captured_value;
    }
}
</code></pre>
<hr />
<h2 id="第5章-串口通信"><a class="header" href="#第5章-串口通信">第5章 串口通信</a></h2>
<h3 id="51-usart基本配置"><a class="header" href="#51-usart基本配置">5.1 USART基本配置</a></h3>
<pre><code class="language-c">// usart_example.c - 串口示例
#include "gd32f10x.h"
#include &lt;stdio.h&gt;

// USART配置
void usart_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_USART0);

    // 配置GPIO
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);  // TX
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_10);  // RX

    // 配置USART参数
    usart_deinit(USART0);
    usart_baudrate_set(USART0, 115200);
    usart_word_length_set(USART0, USART_WL_8BIT);
    usart_stop_bit_set(USART0, USART_STB_1BIT);
    usart_parity_config(USART0, USART_PM_NONE);
    usart_hardware_flow_rts_config(USART0, USART_RTS_DISABLE);
    usart_hardware_flow_cts_config(USART0, USART_CTS_DISABLE);
    usart_receive_config(USART0, USART_RECEIVE_ENABLE);
    usart_transmit_config(USART0, USART_TRANSMIT_ENABLE);

    // 使能USART
    usart_enable(USART0);
}

// 发送单字节
void usart_send_byte(uint8_t data)
{
    usart_data_transmit(USART0, data);
    while(RESET == usart_flag_get(USART0, USART_FLAG_TBE));
}

// 接收单字节
uint8_t usart_receive_byte(void)
{
    while(RESET == usart_flag_get(USART0, USART_FLAG_RBNE));
    return (uint8_t)usart_data_receive(USART0);
}

// 发送字符串
void usart_send_string(char *str)
{
    while(*str) {
        usart_send_byte(*str++);
    }
}

// 重定向printf到USART
int fputc(int ch, FILE *f)
{
    usart_send_byte((uint8_t)ch);
    return ch;
}
</code></pre>
<h3 id="52-usart中断接收"><a class="header" href="#52-usart中断接收">5.2 USART中断接收</a></h3>
<pre><code class="language-c">// usart_interrupt.c - 串口中断接收
#include "gd32f10x.h"

#define BUFFER_SIZE 128
uint8_t rx_buffer[BUFFER_SIZE];
volatile uint16_t rx_index = 0;

// USART中断配置
void usart_interrupt_config(void)
{
    usart_config();  // 基本配置

    // 使能接收中断
    usart_interrupt_enable(USART0, USART_INT_RBNE);

    // 配置NVIC
    nvic_irq_enable(USART0_IRQn, 0, 0);
}

// USART中断处理函数
void USART0_IRQHandler(void)
{
    if(RESET != usart_interrupt_flag_get(USART0, USART_INT_FLAG_RBNE)) {
        // 读取数据
        uint8_t data = (uint8_t)usart_data_receive(USART0);

        // 存入缓冲区
        rx_buffer[rx_index++] = data;
        if(rx_index &gt;= BUFFER_SIZE) {
            rx_index = 0;
        }

        // 回显
        usart_data_transmit(USART0, data);
    }
}
</code></pre>
<h3 id="53-usartdma高速传输"><a class="header" href="#53-usartdma高速传输">5.3 USART+DMA高速传输</a></h3>
<pre><code class="language-c">// usart_dma.c - USART DMA传输
#include "gd32f10x.h"

uint8_t tx_buffer[256];
uint8_t rx_buffer[256];

// USART DMA配置
void usart_dma_config(void)
{
    dma_parameter_struct dma_init_struct;

    // 使能DMA时钟
    rcu_periph_clock_enable(RCU_DMA0);

    // 配置USART
    usart_config();

    // 配置DMA发送通道
    dma_deinit(DMA0, DMA_CH3);
    dma_init_struct.direction = DMA_MEMORY_TO_PERIPHERAL;
    dma_init_struct.memory_addr = (uint32_t)tx_buffer;
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.memory_width = DMA_MEMORY_WIDTH_8BIT;
    dma_init_struct.number = sizeof(tx_buffer);
    dma_init_struct.periph_addr = (uint32_t)&amp;USART_DATA(USART0);
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;
    dma_init_struct.priority = DMA_PRIORITY_HIGH;
    dma_init(DMA0, DMA_CH3, &amp;dma_init_struct);

    // 配置DMA接收通道
    dma_deinit(DMA0, DMA_CH4);
    dma_init_struct.direction = DMA_PERIPHERAL_TO_MEMORY;
    dma_init_struct.memory_addr = (uint32_t)rx_buffer;
    dma_init_struct.number = sizeof(rx_buffer);
    dma_init(DMA0, DMA_CH4, &amp;dma_init_struct);

    // 使能USART DMA
    usart_dma_transmit_config(USART0, USART_TRANSMIT_DMA_ENABLE);
    usart_dma_receive_config(USART0, USART_RECEIVE_DMA_ENABLE);

    // 启动DMA接收
    dma_channel_enable(DMA0, DMA_CH4);
}

// 启动DMA发送
void usart_dma_transmit(uint16_t length)
{
    dma_channel_disable(DMA0, DMA_CH3);
    dma_transfer_number_config(DMA0, DMA_CH3, length);
    dma_channel_enable(DMA0, DMA_CH3);
}
</code></pre>
<hr />
<h2 id="第6章-adc与dac"><a class="header" href="#第6章-adc与dac">第6章 ADC与DAC</a></h2>
<h3 id="61-adc配置"><a class="header" href="#61-adc配置">6.1 ADC配置</a></h3>
<pre><code class="language-c">// adc_example.c - ADC示例
#include "gd32f10x.h"

// ADC配置
void adc_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_ADC0);
    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV8);  // ADC时钟

    // 配置GPIO为模拟输入
    gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 复位ADC
    adc_deinit(ADC0);

    // 配置ADC模式
    adc_mode_config(ADC_MODE_FREE);
    adc_special_function_config(ADC0, ADC_SCAN_MODE, DISABLE);
    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);
    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);
    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 1);

    // 配置通道
    adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_0, ADC_SAMPLETIME_55POINT5);

    // 配置触发源
    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE);
    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);

    // 使能ADC
    adc_enable(ADC0);
    delay_1ms(1);

    // ADC校准
    adc_calibration_enable(ADC0);

    // 启动转换
    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
}

// 读取ADC值
uint16_t adc_read(void)
{
    while(!adc_flag_get(ADC0, ADC_FLAG_EOC));
    return adc_regular_data_read(ADC0);
}

// 读取电压值(mV)
uint32_t adc_read_voltage(void)
{
    uint16_t adc_value = adc_read();
    return (uint32_t)(adc_value * 3300 / 4096);
}
</code></pre>
<h3 id="62-多通道adc"><a class="header" href="#62-多通道adc">6.2 多通道ADC</a></h3>
<pre><code class="language-c">// adc_multi_channel.c - 多通道ADC
#include "gd32f10x.h"

#define ADC_CHANNEL_NUM 4
uint16_t adc_value[ADC_CHANNEL_NUM];

// 多通道ADC配置
void adc_multi_channel_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_ADC0);
    rcu_periph_clock_enable(RCU_DMA0);
    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV8);

    // 配置GPIO
    gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ,
              GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3);

    // 配置DMA
    dma_parameter_struct dma_init_struct;
    dma_deinit(DMA0, DMA_CH0);
    dma_init_struct.direction = DMA_PERIPHERAL_TO_MEMORY;
    dma_init_struct.memory_addr = (uint32_t)adc_value;
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;
    dma_init_struct.number = ADC_CHANNEL_NUM;
    dma_init_struct.periph_addr = (uint32_t)&amp;ADC_RDATA(ADC0);
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;
    dma_init_struct.priority = DMA_PRIORITY_HIGH;
    dma_init(DMA0, DMA_CH0, &amp;dma_init_struct);
    dma_circulation_enable(DMA0, DMA_CH0);
    dma_channel_enable(DMA0, DMA_CH0);

    // 配置ADC
    adc_deinit(ADC0);
    adc_mode_config(ADC_MODE_FREE);
    adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE);
    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);
    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);
    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, ADC_CHANNEL_NUM);

    // 配置通道
    adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_0, ADC_SAMPLETIME_55POINT5);
    adc_regular_channel_config(ADC0, 1, ADC_CHANNEL_1, ADC_SAMPLETIME_55POINT5);
    adc_regular_channel_config(ADC0, 2, ADC_CHANNEL_2, ADC_SAMPLETIME_55POINT5);
    adc_regular_channel_config(ADC0, 3, ADC_CHANNEL_3, ADC_SAMPLETIME_55POINT5);

    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE);
    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);

    // 使能ADC DMA
    adc_dma_mode_enable(ADC0);

    // 使能ADC
    adc_enable(ADC0);
    delay_1ms(1);
    adc_calibration_enable(ADC0);

    // 启动转换
    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
}
</code></pre>
<h3 id="63-dac配置"><a class="header" href="#63-dac配置">6.3 DAC配置</a></h3>
<pre><code class="language-c">// dac_example.c - DAC示例
#include "gd32f10x.h"

// DAC配置
void dac_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_DAC);

    // 配置GPIO为模拟输出
    gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_4);

    // 配置DAC
    dac_deinit();
    dac_trigger_disable(DAC0);
    dac_wave_mode_config(DAC0, DAC_WAVE_DISABLE);
    dac_output_buffer_enable(DAC0);

    // 使能DAC
    dac_enable(DAC0);
}

// 设置DAC输出值(0-4095)
void dac_set_value(uint16_t value)
{
    dac_data_set(DAC0, DAC_ALIGN_12B_R, value);
}

// 设置DAC输出电压(mV)
void dac_set_voltage(uint32_t voltage_mv)
{
    uint16_t value = (uint16_t)(voltage_mv * 4096 / 3300);
    dac_set_value(value);
}

// 产生正弦波
void dac_sine_wave(void)
{
    const uint16_t sine_table[256] = {
        2048, 2098, 2148, 2198, 2248, 2298, 2348, 2398,
        // ... 正弦表数据
    };

    uint8_t index = 0;
    while(1) {
        dac_set_value(sine_table[index++]);
        delay_1ms(1);
    }
}
</code></pre>
<hr />
<h2 id="第7章-spi与i2c"><a class="header" href="#第7章-spi与i2c">第7章 SPI与I2C</a></h2>
<h3 id="71-spi通信"><a class="header" href="#71-spi通信">7.1 SPI通信</a></h3>
<pre><code class="language-c">// spi_example.c - SPI示例
#include "gd32f10x.h"

// SPI配置
void spi_config(void)
{
    spi_parameter_struct spi_init_struct;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_SPI0);

    // 配置GPIO
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_5 | GPIO_PIN_7);  // SCK, MOSI
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);  // MISO
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_4);  // CS
    gpio_bit_set(GPIOA, GPIO_PIN_4);  // CS拉高

    // 配置SPI参数
    spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
    spi_init_struct.device_mode = SPI_MASTER;
    spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
    spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;
    spi_init_struct.nss = SPI_NSS_SOFT;
    spi_init_struct.prescale = SPI_PSC_8;
    spi_init_struct.endian = SPI_ENDIAN_MSB;
    spi_init(SPI0, &amp;spi_init_struct);

    // 使能SPI
    spi_enable(SPI0);
}

// SPI收发单字节
uint8_t spi_transmit_receive(uint8_t data)
{
    while(RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_TBE));
    spi_i2s_data_transmit(SPI0, data);

    while(RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_RBNE));
    return spi_i2s_data_receive(SPI0);
}

// SPI写数据
void spi_write(uint8_t *data, uint16_t len)
{
    gpio_bit_reset(GPIOA, GPIO_PIN_4);  // CS拉低

    for(uint16_t i = 0; i &lt; len; i++) {
        spi_transmit_receive(data[i]);
    }

    gpio_bit_set(GPIOA, GPIO_PIN_4);  // CS拉高
}

// SPI读数据
void spi_read(uint8_t *data, uint16_t len)
{
    gpio_bit_reset(GPIOA, GPIO_PIN_4);  // CS拉低

    for(uint16_t i = 0; i &lt; len; i++) {
        data[i] = spi_transmit_receive(0xFF);
    }

    gpio_bit_set(GPIOA, GPIO_PIN_4);  // CS拉高
}
</code></pre>
<h3 id="72-i2c通信"><a class="header" href="#72-i2c通信">7.2 I2C通信</a></h3>
<pre><code class="language-c">// i2c_example.c - I2C示例
#include "gd32f10x.h"

#define I2C_SPEED 100000  // 100kHz

// I2C配置
void i2c_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOB);
    rcu_periph_clock_enable(RCU_I2C0);

    // 配置GPIO
    gpio_init(GPIOB, GPIO_MODE_AF_OD, GPIO_OSPEED_50MHZ, GPIO_PIN_6 | GPIO_PIN_7);

    // 配置I2C
    i2c_clock_config(I2C0, I2C_SPEED, I2C_DTCY_2);
    i2c_mode_addr_config(I2C0, I2C_I2CMODE_ENABLE, I2C_ADDFORMAT_7BITS, 0x00);
    i2c_enable(I2C0);
    i2c_ack_config(I2C0, I2C_ACK_ENABLE);
}

// I2C写数据
void i2c_write(uint8_t addr, uint8_t reg, uint8_t *data, uint16_t len)
{
    // 等待I2C总线空闲
    while(i2c_flag_get(I2C0, I2C_FLAG_I2CBSY));

    // 发送起始位
    i2c_start_on_bus(I2C0);
    while(!i2c_flag_get(I2C0, I2C_FLAG_SBSEND));

    // 发送设备地址
    i2c_master_addressing(I2C0, addr, I2C_TRANSMITTER);
    while(!i2c_flag_get(I2C0, I2C_FLAG_ADDSEND));
    i2c_flag_clear(I2C0, I2C_FLAG_ADDSEND);

    // 发送寄存器地址
    i2c_data_transmit(I2C0, reg);
    while(!i2c_flag_get(I2C0, I2C_FLAG_TBE));

    // 写数据
    for(uint16_t i = 0; i &lt; len; i++) {
        i2c_data_transmit(I2C0, data[i]);
        while(!i2c_flag_get(I2C0, I2C_FLAG_TBE));
    }

    // 发送停止位
    i2c_stop_on_bus(I2C0);
    while(I2C_CTL0(I2C0) &amp; 0x0200);
}

// I2C读数据
void i2c_read(uint8_t addr, uint8_t reg, uint8_t *data, uint16_t len)
{
    // 等待I2C总线空闲
    while(i2c_flag_get(I2C0, I2C_FLAG_I2CBSY));

    // 发送起始位
    i2c_start_on_bus(I2C0);
    while(!i2c_flag_get(I2C0, I2C_FLAG_SBSEND));

    // 发送设备地址(写)
    i2c_master_addressing(I2C0, addr, I2C_TRANSMITTER);
    while(!i2c_flag_get(I2C0, I2C_FLAG_ADDSEND));
    i2c_flag_clear(I2C0, I2C_FLAG_ADDSEND);

    // 发送寄存器地址
    i2c_data_transmit(I2C0, reg);
    while(!i2c_flag_get(I2C0, I2C_FLAG_TBE));

    // 重启
    i2c_start_on_bus(I2C0);
    while(!i2c_flag_get(I2C0, I2C_FLAG_SBSEND));

    // 发送设备地址(读)
    i2c_master_addressing(I2C0, addr, I2C_RECEIVER);
    while(!i2c_flag_get(I2C0, I2C_FLAG_ADDSEND));
    i2c_flag_clear(I2C0, I2C_FLAG_ADDSEND);

    // 读取数据
    for(uint16_t i = 0; i &lt; len; i++) {
        if(i == len - 1) {
            i2c_ack_config(I2C0, I2C_ACK_DISABLE);
        }
        while(!i2c_flag_get(I2C0, I2C_FLAG_RBNE));
        data[i] = i2c_data_receive(I2C0);
    }

    // 发送停止位
    i2c_stop_on_bus(I2C0);
    while(I2C_CTL0(I2C0) &amp; 0x0200);
    i2c_ack_config(I2C0, I2C_ACK_ENABLE);
}
</code></pre>
<hr />
<h2 id="第8章-dma传输"><a class="header" href="#第8章-dma传输">第8章 DMA传输</a></h2>
<pre><code class="language-c">// dma_example.c - DMA传输示例
#include "gd32f10x.h"

#define BUFFER_SIZE 32
uint8_t src_buffer[BUFFER_SIZE];
uint8_t dst_buffer[BUFFER_SIZE];

// DMA配置(内存到内存)
void dma_config(void)
{
    dma_parameter_struct dma_init_struct;

    // 使能DMA时钟
    rcu_periph_clock_enable(RCU_DMA0);

    // 复位DMA通道
    dma_deinit(DMA0, DMA_CH0);

    dma_init_struct.direction = DMA_MEMORY_TO_MEMORY;
    dma_init_struct.memory_addr = (uint32_t)dst_buffer;
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.memory_width = DMA_MEMORY_WIDTH_8BIT;
    dma_init_struct.number = BUFFER_SIZE;
    dma_init_struct.periph_addr = (uint32_t)src_buffer;
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_ENABLE;
    dma_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;
    dma_init_struct.priority = DMA_PRIORITY_ULTRA_HIGH;
    dma_init(DMA0, DMA_CH0, &amp;dma_init_struct);

    // 配置DMA模式
    dma_circulation_disable(DMA0, DMA_CH0);
    dma_memory_to_memory_enable(DMA0, DMA_CH0);
}

// 启动DMA传输
void dma_transfer_start(void)
{
    // 重新配置传输数量
    dma_channel_disable(DMA0, DMA_CH0);
    dma_transfer_number_config(DMA0, DMA_CH0, BUFFER_SIZE);
    dma_channel_enable(DMA0, DMA_CH0);

    // 等待传输完成
    while(!dma_flag_get(DMA0, DMA_CH0, DMA_FLAG_FTF));
    dma_flag_clear(DMA0, DMA_CH0, DMA_FLAG_FTF);
}

// DMA中断方式
void dma_interrupt_config(void)
{
    dma_config();

    // 使能传输完成中断
    dma_interrupt_enable(DMA0, DMA_CH0, DMA_INT_FTF);
    nvic_irq_enable(DMA0_Channel0_IRQn, 0, 0);

    dma_channel_enable(DMA0, DMA_CH0);
}

// DMA中断处理
void DMA0_Channel0_IRQHandler(void)
{
    if(dma_interrupt_flag_get(DMA0, DMA_CH0, DMA_INT_FLAG_FTF)) {
        dma_interrupt_flag_clear(DMA0, DMA_CH0, DMA_INT_FLAG_FTF);

        // 传输完成处理
        printf("DMA transfer complete\r\n");
    }
}
</code></pre>
<hr />
<h2 id="第9章-实战项目"><a class="header" href="#第9章-实战项目">第9章 实战项目</a></h2>
<h3 id="91-智能温控风扇系统"><a class="header" href="#91-智能温控风扇系统">9.1 智能温控风扇系统</a></h3>
<pre><code class="language-c">// temp_fan_control.c - 温控风扇系统
#include "gd32f10x.h"

#define TEMP_THRESHOLD_LOW   25  // 低温阈值
#define TEMP_THRESHOLD_HIGH  30  // 高温阈值

uint16_t current_temp = 0;
uint16_t fan_speed = 0;  // 0-1000

// 系统初始化
void system_init(void)
{
    systick_config();
    usart_config();
    adc_config();   // 温度传感器ADC
    pwm_config();   // 风扇PWM控制
}

// 温度读取(假设使用LM35温度传感器)
uint16_t read_temperature(void)
{
    uint32_t voltage_mv = adc_read_voltage();
    // LM35温度传感器:10mV/°C
    return (uint16_t)(voltage_mv / 10);
}

// 风扇控制
void fan_control(uint16_t temp)
{
    if(temp &lt; TEMP_THRESHOLD_LOW) {
        // 低温关闭风扇
        fan_speed = 0;
    } else if(temp &gt; TEMP_THRESHOLD_HIGH) {
        // 高温风扇全速
        fan_speed = 1000;
    } else {
        // 中温风扇调速
        fan_speed = (temp - TEMP_THRESHOLD_LOW) * 1000 /
                   (TEMP_THRESHOLD_HIGH - TEMP_THRESHOLD_LOW);
    }

    pwm_set_duty(fan_speed);
}

int main(void)
{
    system_init();

    printf("Temperature Fan Control System\r\n");

    while(1) {
        // 读取温度
        current_temp = read_temperature();

        // 控制风扇
        fan_control(current_temp);

        // 串口输出
        printf("Temp: %d C, Fan: %d%%\r\n",
               current_temp, fan_speed / 10);

        delay_1ms(1000);
    }
}
</code></pre>
<h3 id="92-stm32到gd32移植指南"><a class="header" href="#92-stm32到gd32移植指南">9.2 STM32到GD32移植指南</a></h3>
<pre><code class="language-c">// migration_guide.c - STM32到GD32移植

/*
移植步骤:

1. 替换头文件
   STM32: #include "stm32f10x.h"
   GD32:  #include "gd32f10x.h"

2. 修改命名大小写
   STM32: GPIO_InitTypeDef GPIO_InitStructure;
   GD32:  GPIO_InitTypeDef GPIO_InitStructure;  // 类型定义相同

   STM32: GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   GD32:  GPIO_InitStructure.GPIO_Speed = GPIO_SPEED_50MHZ;  // 枚举值大写

3. 时钟配置调整
   STM32: 最高72MHz
   GD32:  最高108MHz，需要调整PLL倍频系数

4. 固件库函数差异
   STM32: RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   GD32:  rcu_periph_clock_enable(RCU_GPIOA);  // 函数名简化

5. 中断优先级配置
   基本相同，但要注意GD32有4位优先级

6. Flash操作
   GD32支持零等待周期，性能更好

7. 特殊外设差异
   - USB: GD32有增强
   - CAN: 基本相同
   - Ethernet: 仅部分型号支持
*/

// 移植示例: LED闪烁
// STM32代码
void STM32_LED_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);
}

// GD32代码
void GD32_LED_Init(void)
{
    // 使能时钟(函数名简化)
    rcu_periph_clock_enable(RCU_GPIOA);

    // 配置GPIO(函数参数顺序不同)
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);
}
</code></pre>
<h3 id="93-学习效果验证"><a class="header" href="#93-学习效果验证">9.3 学习效果验证</a></h3>
<p><strong>验证标准:</strong></p>
<ol>
<li>
<p><strong>基础知识(20分)</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
掌握GD32系列MCU特性</li>
<li><input disabled="" type="checkbox"/>
理解固件库架构</li>
<li><input disabled="" type="checkbox"/>
熟悉开发工具</li>
</ul>
</li>
<li>
<p><strong>外设编程(40分)</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
掌握GPIO、定时器、串口</li>
<li><input disabled="" type="checkbox"/>
掌握ADC、DAC、SPI、I2C</li>
<li><input disabled="" type="checkbox"/>
掌握DMA传输</li>
</ul>
</li>
<li>
<p><strong>实战项目(30分)</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
完成完整项目开发</li>
<li><input disabled="" type="checkbox"/>
实现STM32迁移</li>
<li><input disabled="" type="checkbox"/>
调试优化</li>
</ul>
</li>
<li>
<p><strong>进阶应用(10分)</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
掌握RTOS集成</li>
<li><input disabled="" type="checkbox"/>
USB通信</li>
<li><input disabled="" type="checkbox"/>
CAN总线</li>
</ul>
</li>
</ol>
<h3 id="94-进阶学习资源"><a class="header" href="#94-进阶学习资源">9.4 进阶学习资源</a></h3>
<p><strong>官方资源:</strong></p>
<ul>
<li>GD32官网: http://www.gigadevice.com</li>
<li>技术论坛: http://www.gd32mcu.com</li>
<li>固件库下载和例程</li>
</ul>
<p><strong>推荐文档:</strong></p>
<ul>
<li>GD32F10x数据手册</li>
<li>GD32F10x固件库手册</li>
<li>应用笔记</li>
</ul>
<p><strong>进阶方向:</strong></p>
<ul>
<li>RTOS集成(FreeRTOS/RT-Thread)</li>
<li>USB设备开发</li>
<li>CAN总线通信</li>
<li>Ethernet网络应用</li>
</ul>
<hr />
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>通过本指南学习，您已掌握:</p>
<ol>
<li>GD32系列MCU的特性和应用</li>
<li>开发环境的搭建和配置</li>
<li>GPIO、定时器、串口等基本外设</li>
<li>ADC、DAC、SPI、I2C等接口</li>
<li>DMA数据传输</li>
<li>完整项目开发流程</li>
</ol>
<p><strong>进阶方向建议:</strong></p>
<ul>
<li>深入学习RTOS应用</li>
<li>掌握USB和网络通信</li>
<li>了解电机控制和电源管理</li>
<li>参与开源项目实践</li>
</ul>
<p>祝学习愉快！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/embbed/fpga.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/embbed/linux-kernel.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/embbed/fpga.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/embbed/linux-kernel.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

