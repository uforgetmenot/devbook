<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JavaScript 异步编程教程(第3部分) - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="javascript-异步编程教程第3部分"><a class="header" href="#javascript-异步编程教程第3部分">JavaScript 异步编程教程(第3部分)</a></h1>
<h2 id="课程概览"><a class="header" href="#课程概览">课程概览</a></h2>
<ul>
<li><strong>难度级别</strong>: 进阶</li>
<li><strong>学习时长</strong>: 2-3周</li>
<li><strong>前置知识</strong>: JavaScript基础、ES6特性</li>
<li><strong>课程目标</strong>: 掌握JavaScript异步编程核心技术</li>
</ul>
<h2 id="学习路线"><a class="header" href="#学习路线">学习路线</a></h2>
<pre><code>第一周：异步基础 → 回调函数 → Promise基础 → Promise链式调用
第二周：async/await → 并发控制 → 错误处理 → 事件循环
第三周：定时器 → 异步模式 → 实战项目
</code></pre>
<hr />
<h2 id="第一章异步编程基础"><a class="header" href="#第一章异步编程基础">第一章：异步编程基础</a></h2>
<h3 id="11-同步vs异步"><a class="header" href="#11-同步vs异步">1.1 同步vs异步</a></h3>
<pre><code class="language-javascript">// 同步代码:按顺序执行,阻塞后续代码
console.log('开始');
let result = 10 + 20; // 立即执行
console.log('结果:', result);
console.log('结束');
// 输出:
// 开始
// 结果: 30
// 结束

// 异步代码:不阻塞后续代码
console.log('开始');
setTimeout(() =&gt; {
    console.log('异步操作完成');
}, 1000);
console.log('结束');
// 输出:
// 开始
// 结束
// 异步操作完成(1秒后)

// 为什么需要异步?
// 1. 网络请求
fetch('https://api.example.com/data')
    .then(response =&gt; response.json())
    .then(data =&gt; console.log(data));

// 2. 文件读取(Node.js)
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) =&gt; {
    if (err) throw err;
    console.log(data);
});

// 3. 定时器
setTimeout(() =&gt; {
    console.log('延迟执行');
}, 1000);

// 4. 用户交互
button.addEventListener('click', () =&gt; {
    console.log('按钮被点击');
});

// 5. 数据库查询
db.query('SELECT * FROM users', (err, results) =&gt; {
    if (err) throw err;
    console.log(results);
});
</code></pre>
<h3 id="12-javascript单线程模型"><a class="header" href="#12-javascript单线程模型">1.2 JavaScript单线程模型</a></h3>
<pre><code class="language-javascript">// JavaScript是单线程的
console.log('1');
setTimeout(() =&gt; console.log('2'), 0);
console.log('3');
// 输出: 1 3 2(即使延迟0ms)

// 原因:事件循环机制
// 1. 执行栈(Call Stack)
// 2. 任务队列(Task Queue)
// 3. 微任务队列(Microtask Queue)

// 执行顺序示例
console.log('script start');

setTimeout(() =&gt; {
    console.log('setTimeout');
}, 0);

Promise.resolve()
    .then(() =&gt; {
        console.log('promise1');
    })
    .then(() =&gt; {
        console.log('promise2');
    });

console.log('script end');

// 输出顺序:
// script start
// script end
// promise1
// promise2
// setTimeout

// 解释:
// 1. 同步代码先执行
// 2. 微任务(Promise)先于宏任务(setTimeout)
// 3. 微任务队列清空后才执行宏任务
</code></pre>
<hr />
<h2 id="第二章回调函数"><a class="header" href="#第二章回调函数">第二章：回调函数</a></h2>
<h3 id="21-回调函数基础"><a class="header" href="#21-回调函数基础">2.1 回调函数基础</a></h3>
<pre><code class="language-javascript">// 回调函数:作为参数传递的函数
function doSomething(callback) {
    console.log('执行操作...');
    callback();
}

doSomething(() =&gt; {
    console.log('操作完成!');
});

// 异步回调
function fetchData(callback) {
    setTimeout(() =&gt; {
        const data = {id: 1, name: 'John'};
        callback(data);
    }, 1000);
}

fetchData((data) =&gt; {
    console.log('收到数据:', data);
});

// 错误优先回调(Node.js风格)
function readFile(filename, callback) {
    setTimeout(() =&gt; {
        const error = null; // 或者 new Error('文件不存在')
        const data = '文件内容';
        callback(error, data);
    }, 1000);
}

readFile('test.txt', (err, data) =&gt; {
    if (err) {
        console.error('错误:', err);
        return;
    }
    console.log('数据:', data);
});

// 多个回调
function processData(data, onSuccess, onError) {
    try {
        // 处理数据
        let result = data.toUpperCase();
        onSuccess(result);
    } catch (error) {
        onError(error);
    }
}

processData('hello',
    (result) =&gt; console.log('成功:', result),
    (error) =&gt; console.error('失败:', error)
);
</code></pre>
<h3 id="22-回调地狱"><a class="header" href="#22-回调地狱">2.2 回调地狱</a></h3>
<pre><code class="language-javascript">// 回调地狱(Callback Hell)
getUserData(userId, (err, user) =&gt; {
    if (err) {
        handleError(err);
        return;
    }

    getUserPosts(user.id, (err, posts) =&gt; {
        if (err) {
            handleError(err);
            return;
        }

        getPostComments(posts[0].id, (err, comments) =&gt; {
            if (err) {
                handleError(err);
                return;
            }

            getUserProfile(comments[0].userId, (err, profile) =&gt; {
                if (err) {
                    handleError(err);
                    return;
                }

                // 终于得到想要的数据
                console.log(profile);
            });
        });
    });
});

// 回调地狱的问题:
// 1. 代码难以阅读(金字塔形)
// 2. 错误处理重复
// 3. 难以维护
// 4. 难以调试

// 改进:命名函数
function handleUser(err, user) {
    if (err) return handleError(err);
    getUserPosts(user.id, handlePosts);
}

function handlePosts(err, posts) {
    if (err) return handleError(err);
    getPostComments(posts[0].id, handleComments);
}

function handleComments(err, comments) {
    if (err) return handleError(err);
    getUserProfile(comments[0].userId, handleProfile);
}

function handleProfile(err, profile) {
    if (err) return handleError(err);
    console.log(profile);
}

getUserData(userId, handleUser);

// 更好的解决方案:Promise(下一节)
</code></pre>
<hr />
<h2 id="第三章promise详解"><a class="header" href="#第三章promise详解">第三章：Promise详解</a></h2>
<h3 id="31-promise基础"><a class="header" href="#31-promise基础">3.1 Promise基础</a></h3>
<pre><code class="language-javascript">// Promise构造函数
const promise = new Promise((resolve, reject) =&gt; {
    // 异步操作
    setTimeout(() =&gt; {
        const success = true;
        if (success) {
            resolve('操作成功!'); // 成功
        } else {
            reject('操作失败!'); // 失败
        }
    }, 1000);
});

// 使用Promise
promise
    .then(result =&gt; {
        console.log('成功:', result);
    })
    .catch(error =&gt; {
        console.error('失败:', error);
    });

// Promise的三种状态
// 1. pending(进行中)
// 2. fulfilled(已成功)
// 3. rejected(已失败)

// 状态一旦改变就不会再变
let p = new Promise((resolve, reject) =&gt; {
    resolve('success');
    reject('error'); // 不会执行
});

// 简化的Promise创建
const successPromise = Promise.resolve('成功');
const failurePromise = Promise.reject('失败');

successPromise.then(val =&gt; console.log(val));
failurePromise.catch(err =&gt; console.log(err));

// then方法返回新的Promise
const p1 = Promise.resolve(1);
const p2 = p1.then(val =&gt; val + 1);
const p3 = p2.then(val =&gt; val + 1);

p3.then(val =&gt; console.log(val)); // 3
</code></pre>
<h3 id="32-promise链式调用"><a class="header" href="#32-promise链式调用">3.2 Promise链式调用</a></h3>
<pre><code class="language-javascript">// 链式调用
fetch('/api/user')
    .then(response =&gt; response.json())
    .then(user =&gt; {
        console.log('用户:', user);
        return fetch(`/api/posts/${user.id}`);
    })
    .then(response =&gt; response.json())
    .then(posts =&gt; {
        console.log('文章:', posts);
    })
    .catch(error =&gt; {
        console.error('错误:', error);
    });

// then返回值的传递
Promise.resolve(1)
    .then(val =&gt; {
        console.log(val); // 1
        return val + 1;
    })
    .then(val =&gt; {
        console.log(val); // 2
        return val + 1;
    })
    .then(val =&gt; {
        console.log(val); // 3
    });

// then返回Promise
Promise.resolve(1)
    .then(val =&gt; {
        return new Promise(resolve =&gt; {
            setTimeout(() =&gt; resolve(val * 2), 1000);
        });
    })
    .then(val =&gt; {
        console.log(val); // 2(1秒后)
    });

// 错误会向下传递
Promise.resolve()
    .then(() =&gt; {
        throw new Error('出错了!');
    })
    .then(() =&gt; {
        console.log('不会执行');
    })
    .then(() =&gt; {
        console.log('也不会执行');
    })
    .catch(error =&gt; {
        console.error('捕获错误:', error.message);
    });

// catch后继续链式调用
Promise.reject('错误')
    .catch(err =&gt; {
        console.log('处理错误:', err);
        return '恢复';
    })
    .then(val =&gt; {
        console.log('继续执行:', val);
    });

// finally:无论成功失败都执行
fetch('/api/data')
    .then(response =&gt; response.json())
    .catch(error =&gt; console.error(error))
    .finally(() =&gt; {
        console.log('请求结束');
        hideLoadingSpinner();
    });
</code></pre>
<h3 id="33-promise静态方法"><a class="header" href="#33-promise静态方法">3.3 Promise静态方法</a></h3>
<pre><code class="language-javascript">// Promise.all():所有成功才成功
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3])
    .then(results =&gt; {
        console.log(results); // [1, 2, 3]
    });

// 任意一个失败则失败
const p4 = Promise.reject('错误');
Promise.all([p1, p2, p4])
    .catch(error =&gt; {
        console.log(error); // "错误"
    });

// 实际应用:并发请求
Promise.all([
    fetch('/api/user'),
    fetch('/api/posts'),
    fetch('/api/comments')
])
.then(responses =&gt; {
    return Promise.all(responses.map(r =&gt; r.json()));
})
.then(([user, posts, comments]) =&gt; {
    console.log(user, posts, comments);
});

// Promise.race():最快的决定结果
const slow = new Promise(resolve =&gt; setTimeout(() =&gt; resolve('慢'), 1000));
const fast = new Promise(resolve =&gt; setTimeout(() =&gt; resolve('快'), 100));

Promise.race([slow, fast])
    .then(result =&gt; {
        console.log(result); // "快"
    });

// 应用:超时控制
function fetchWithTimeout(url, timeout = 5000) {
    return Promise.race([
        fetch(url),
        new Promise((_, reject) =&gt; {
            setTimeout(() =&gt; reject('超时'), timeout);
        })
    ]);
}

// Promise.allSettled():等待所有Promise完成(ES2020)
const promises = [
    Promise.resolve(1),
    Promise.reject('错误'),
    Promise.resolve(3)
];

Promise.allSettled(promises)
    .then(results =&gt; {
        console.log(results);
        // [
        //   {status: 'fulfilled', value: 1},
        //   {status: 'rejected', reason: '错误'},
        //   {status: 'fulfilled', value: 3}
        // ]
    });

// Promise.any():任意一个成功即成功(ES2021)
Promise.any([
    Promise.reject('错误1'),
    Promise.resolve('成功'),
    Promise.reject('错误2')
])
.then(result =&gt; {
    console.log(result); // "成功"
})
.catch(errors =&gt; {
    console.log(errors); // AggregateError
});

// 所有都失败才失败
Promise.any([
    Promise.reject('错误1'),
    Promise.reject('错误2')
])
.catch(error =&gt; {
    console.log(error); // AggregateError: All promises were rejected
});
</code></pre>
<h3 id="34-promise实战应用"><a class="header" href="#34-promise实战应用">3.4 Promise实战应用</a></h3>
<pre><code class="language-javascript">// 1. 封装异步操作
function delay(ms) {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

delay(1000).then(() =&gt; console.log('1秒后执行'));

// 2. 封装AJAX
function ajax(url, options = {}) {
    return new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open(options.method || 'GET', url);

        xhr.onload = () =&gt; {
            if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {
                resolve(JSON.parse(xhr.responseText));
            } else {
                reject(new Error(xhr.statusText));
            }
        };

        xhr.onerror = () =&gt; reject(new Error('网络错误'));
        xhr.send(options.body);
    });
}

ajax('/api/users')
    .then(users =&gt; console.log(users))
    .catch(error =&gt; console.error(error));

// 3. 图片加载
function loadImage(url) {
    return new Promise((resolve, reject) =&gt; {
        const img = new Image();
        img.onload = () =&gt; resolve(img);
        img.onerror = () =&gt; reject(new Error('图片加载失败'));
        img.src = url;
    });
}

loadImage('photo.jpg')
    .then(img =&gt; document.body.appendChild(img))
    .catch(error =&gt; console.error(error));

// 4. 顺序执行
function sequence(promises) {
    return promises.reduce((prev, current) =&gt; {
        return prev.then(() =&gt; current());
    }, Promise.resolve());
}

const tasks = [
    () =&gt; delay(1000).then(() =&gt; console.log('任务1')),
    () =&gt; delay(1000).then(() =&gt; console.log('任务2')),
    () =&gt; delay(1000).then(() =&gt; console.log('任务3'))
];

sequence(tasks); // 依次执行

// 5. 重试机制
function retry(fn, times = 3, delay = 1000) {
    return new Promise((resolve, reject) =&gt; {
        function attempt(n) {
            fn()
                .then(resolve)
                .catch(error =&gt; {
                    if (n === 1) {
                        reject(error);
                    } else {
                        console.log(`重试...剩余${n-1}次`);
                        setTimeout(() =&gt; attempt(n - 1), delay);
                    }
                });
        }
        attempt(times);
    });
}

retry(() =&gt; fetch('/api/data'), 3, 1000);

// 6. 并发限制
async function parallelLimit(tasks, limit) {
    const results = [];
    const executing = [];

    for (const task of tasks) {
        const p = task().then(result =&gt; {
            executing.splice(executing.indexOf(p), 1);
            return result;
        });

        results.push(p);
        executing.push(p);

        if (executing.length &gt;= limit) {
            await Promise.race(executing);
        }
    }

    return Promise.all(results);
}

// 最多同时执行2个任务
const tasks = [
    () =&gt; delay(1000).then(() =&gt; 1),
    () =&gt; delay(1000).then(() =&gt; 2),
    () =&gt; delay(1000).then(() =&gt; 3),
    () =&gt; delay(1000).then(() =&gt; 4)
];

parallelLimit(tasks, 2).then(console.log);
</code></pre>
<hr />
<h2 id="第四章asyncawait"><a class="header" href="#第四章asyncawait">第四章：async/await</a></h2>
<h3 id="41-asyncawait基础"><a class="header" href="#41-asyncawait基础">4.1 async/await基础</a></h3>
<pre><code class="language-javascript">// async函数返回Promise
async function fetchData() {
    return 'data';
}

fetchData().then(data =&gt; console.log(data)); // "data"

// 等价于
function fetchDataPromise() {
    return Promise.resolve('data');
}

// await等待Promise完成
async function getData() {
    const result = await Promise.resolve('data');
    console.log(result); // "data"
}

getData();

// await只能在async函数中使用
// await Promise.resolve('data'); // 错误

// 实际应用
async function fetchUser() {
    const response = await fetch('/api/user');
    const user = await response.json();
    console.log(user);
    return user;
}

// 多个await按顺序执行
async function sequential() {
    const user = await fetchUser();
    const posts = await fetchPosts(user.id);
    const comments = await fetchComments(posts[0].id);
    return {user, posts, comments};
}

// 并行执行
async function parallel() {
    const [user, posts, comments] = await Promise.all([
        fetchUser(),
        fetchPosts(),
        fetchComments()
    ]);
    return {user, posts, comments};
}

// 条件await
async function conditionalFetch(useCache) {
    let data;
    if (useCache) {
        data = getCachedData();
    } else {
        data = await fetchData();
    }
    return data;
}
</code></pre>
<h3 id="42-错误处理"><a class="header" href="#42-错误处理">4.2 错误处理</a></h3>
<pre><code class="language-javascript">// try-catch错误处理
async function fetchData() {
    try {
        const response = await fetch('/api/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('获取数据失败:', error);
        throw error; // 重新抛出
    }
}

// 多个try-catch
async function processData() {
    let user, posts;

    try {
        user = await fetchUser();
    } catch (error) {
        console.error('获取用户失败:', error);
        user = getDefaultUser();
    }

    try {
        posts = await fetchPosts(user.id);
    } catch (error) {
        console.error('获取文章失败:', error);
        posts = [];
    }

    return {user, posts};
}

// 统一错误处理
async function safeAsync(fn) {
    try {
        return await fn();
    } catch (error) {
        console.error('错误:', error);
        return null;
    }
}

const data = await safeAsync(() =&gt; fetchData());

// Promise.catch vs try-catch
// 方式1: try-catch
async function method1() {
    try {
        const data = await fetch('/api/data');
        return data;
    } catch (error) {
        console.error(error);
    }
}

// 方式2: .catch()
async function method2() {
    const data = await fetch('/api/data')
        .catch(error =&gt; {
            console.error(error);
            return null;
        });
    return data;
}

// finally
async function fetchWithCleanup() {
    try {
        showLoadingSpinner();
        const data = await fetchData();
        return data;
    } catch (error) {
        showError(error);
    } finally {
        hideLoadingSpinner(); // 总是执行
    }
}
</code></pre>
<h3 id="43-asyncawait模式"><a class="header" href="#43-asyncawait模式">4.3 async/await模式</a></h3>
<pre><code class="language-javascript">// 1. 顺序执行
async function sequential() {
    const a = await task1(); // 等待
    const b = await task2(); // 等待
    const c = await task3(); // 等待
    return [a, b, c];
}

// 2. 并行执行
async function parallel() {
    const [a, b, c] = await Promise.all([
        task1(),
        task2(),
        task3()
    ]);
    return [a, b, c];
}

// 3. 串行执行数组
async function processArray(items) {
    for (const item of items) {
        await processItem(item);
    }
}

// 4. 并行执行数组
async function processArrayParallel(items) {
    await Promise.all(items.map(item =&gt; processItem(item)));
}

// 5. 条件执行
async function conditionalProcess(condition) {
    if (condition) {
        return await expensiveOperation();
    }
    return cheapOperation();
}

// 6. 循环中的async/await
async function fetchMultiple(ids) {
    const results = [];
    for (const id of ids) {
        const data = await fetchData(id);
        results.push(data);
    }
    return results;
}

// 7. map + Promise.all
async function fetchMultipleParallel(ids) {
    return Promise.all(ids.map(id =&gt; fetchData(id)));
}

// 8. reduce模式
async function sequentialReduce(items) {
    return items.reduce(async (prevPromise, item) =&gt; {
        const prev = await prevPromise;
        const result = await processItem(item);
        return [...prev, result];
    }, Promise.resolve([]));
}

// 9. 超时控制
async function withTimeout(promise, ms) {
    return Promise.race([
        promise,
        new Promise((_, reject) =&gt;
            setTimeout(() =&gt; reject(new Error('超时')), ms)
        )
    ]);
}

const data = await withTimeout(fetchData(), 5000);

// 10. 重试机制
async function retry(fn, times = 3, delay = 1000) {
    for (let i = 0; i &lt; times; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === times - 1) throw error;
            await new Promise(resolve =&gt; setTimeout(resolve, delay));
        }
    }
}
</code></pre>
<h3 id="44-asyncawait实战"><a class="header" href="#44-asyncawait实战">4.4 async/await实战</a></h3>
<pre><code class="language-javascript">// 1. 数据获取和处理
async function getUserData(userId) {
    try {
        // 获取用户信息
        const user = await fetch(`/api/users/${userId}`)
            .then(r =&gt; r.json());

        // 并行获取相关数据
        const [posts, comments, followers] = await Promise.all([
            fetch(`/api/posts?userId=${userId}`).then(r =&gt; r.json()),
            fetch(`/api/comments?userId=${userId}`).then(r =&gt; r.json()),
            fetch(`/api/followers/${userId}`).then(r =&gt; r.json())
        ]);

        return {
            user,
            posts,
            comments,
            followers
        };
    } catch (error) {
        console.error('获取用户数据失败:', error);
        throw error;
    }
}

// 2. 表单提交
async function handleSubmit(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const data = Object.fromEntries(formData);

    try {
        setLoading(true);

        const response = await fetch('/api/submit', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });

        if (!response.ok) {
            throw new Error('提交失败');
        }

        const result = await response.json();
        showSuccess('提交成功!');
        return result;

    } catch (error) {
        showError(error.message);
    } finally {
        setLoading(false);
    }
}

// 3. 分页加载
async function loadMoreData(page = 1) {
    const loadingIndicator = document.getElementById('loading');

    try {
        loadingIndicator.style.display = 'block';

        const response = await fetch(`/api/data?page=${page}`);
        const {data, hasMore} = await response.json();

        appendData(data);

        if (hasMore) {
            // 滚动到底部时加载下一页
            await loadMoreData(page + 1);
        }

    } catch (error) {
        console.error('加载数据失败:', error);
    } finally {
        loadingIndicator.style.display = 'none';
    }
}

// 4. 文件上传
async function uploadFile(file) {
    const formData = new FormData();
    formData.append('file', file);

    try {
        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData,
            // 上传进度
            onUploadProgress: (progressEvent) =&gt; {
                const percent = Math.round(
                    (progressEvent.loaded * 100) / progressEvent.total
                );
                updateProgress(percent);
            }
        });

        if (!response.ok) {
            throw new Error('上传失败');
        }

        const result = await response.json();
        return result.url;

    } catch (error) {
        console.error('文件上传失败:', error);
        throw error;
    }
}

// 5. 数据缓存
class DataCache {
    constructor(ttl = 60000) {
        this.cache = new Map();
        this.ttl = ttl;
    }

    async get(key, fetcher) {
        const cached = this.cache.get(key);

        if (cached &amp;&amp; Date.now() - cached.time &lt; this.ttl) {
            return cached.data;
        }

        const data = await fetcher();
        this.cache.set(key, {data, time: Date.now()});
        return data;
    }

    clear() {
        this.cache.clear();
    }
}

const cache = new DataCache(60000); // 1分钟缓存

async function getUser(id) {
    return cache.get(`user_${id}`, async () =&gt; {
        const response = await fetch(`/api/users/${id}`);
        return response.json();
    });
}
</code></pre>
<hr />
<h2 id="第五章事件循环"><a class="header" href="#第五章事件循环">第五章：事件循环</a></h2>
<h3 id="51-事件循环机制"><a class="header" href="#51-事件循环机制">5.1 事件循环机制</a></h3>
<pre><code class="language-javascript">// 事件循环(Event Loop)组成:
// 1. 调用栈(Call Stack)
// 2. Web APIs
// 3. 宏任务队列(Macro Task Queue)
// 4. 微任务队列(Micro Task Queue)

// 执行顺序示例
console.log('1'); // 同步代码

setTimeout(() =&gt; {
    console.log('2'); // 宏任务
}, 0);

Promise.resolve().then(() =&gt; {
    console.log('3'); // 微任务
});

console.log('4'); // 同步代码

// 输出: 1 4 3 2

// 详细示例
console.log('script start');

setTimeout(() =&gt; {
    console.log('setTimeout1');
    Promise.resolve().then(() =&gt; {
        console.log('promise1');
    });
}, 0);

setTimeout(() =&gt; {
    console.log('setTimeout2');
}, 0);

Promise.resolve().then(() =&gt; {
    console.log('promise2');
}).then(() =&gt; {
    console.log('promise3');
});

console.log('script end');

// 输出:
// script start
// script end
// promise2
// promise3
// setTimeout1
// promise1
// setTimeout2

// 宏任务(Macro Tasks):
// - setTimeout
// - setInterval
// - setImmediate(Node.js)
// - I/O
// - UI rendering

// 微任务(Micro Tasks):
// - Promise.then/catch/finally
// - MutationObserver
// - process.nextTick(Node.js)
// - queueMicrotask()

// 执行流程:
// 1. 执行同步代码
// 2. 执行所有微任务
// 3. 执行一个宏任务
// 4. 重复2-3
</code></pre>
<h3 id="52-任务优先级"><a class="header" href="#52-任务优先级">5.2 任务优先级</a></h3>
<pre><code class="language-javascript">// 微任务优先级高于宏任务
console.log('1');

setTimeout(() =&gt; console.log('2'), 0);

Promise.resolve()
    .then(() =&gt; console.log('3'))
    .then(() =&gt; console.log('4'));

console.log('5');

// 输出: 1 5 3 4 2

// process.nextTick(Node.js最高优先级)
console.log('1');

setImmediate(() =&gt; console.log('2'));

process.nextTick(() =&gt; console.log('3'));

Promise.resolve().then(() =&gt; console.log('4'));

console.log('5');

// 输出: 1 5 3 4 2

// queueMicrotask(ES标准)
queueMicrotask(() =&gt; {
    console.log('microtask');
});

Promise.resolve().then(() =&gt; {
    console.log('promise');
});

// 输出: microtask promise

// 混合示例
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}

async function async2() {
    console.log('async2');
}

console.log('script start');

setTimeout(() =&gt; {
    console.log('setTimeout');
}, 0);

async1();

new Promise(resolve =&gt; {
    console.log('promise1');
    resolve();
}).then(() =&gt; {
    console.log('promise2');
});

console.log('script end');

// 输出:
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
</code></pre>
<hr />
<h2 id="第六章定时器"><a class="header" href="#第六章定时器">第六章：定时器</a></h2>
<h3 id="61-settimeout和setinterval"><a class="header" href="#61-settimeout和setinterval">6.1 setTimeout和setInterval</a></h3>
<pre><code class="language-javascript">// setTimeout:延迟执行一次
const timerId = setTimeout(() =&gt; {
    console.log('1秒后执行');
}, 1000);

// 取消定时器
clearTimeout(timerId);

// 传递参数
setTimeout((name, age) =&gt; {
    console.log(`${name}, ${age}`);
}, 1000, 'John', 30);

// setInterval:重复执行
const intervalId = setInterval(() =&gt; {
    console.log('每秒执行');
}, 1000);

// 取消
clearInterval(intervalId);

// 使用setTimeout模拟setInterval
function mySetInterval(callback, delay) {
    function repeat() {
        callback();
        setTimeout(repeat, delay);
    }
    setTimeout(repeat, delay);
}

mySetInterval(() =&gt; {
    console.log('重复执行');
}, 1000);

// 递归setTimeout vs setInterval
// setInterval可能会叠加执行
setInterval(() =&gt; {
    // 如果执行时间超过间隔,会立即再次执行
    heavyOperation(); // 耗时操作
}, 1000);

// 递归setTimeout保证间隔
function schedule() {
    setTimeout(() =&gt; {
        heavyOperation();
        schedule(); // 执行完后再设置下一次
    }, 1000);
}

// 倒计时
let countdown = 10;
const timer = setInterval(() =&gt; {
    console.log(countdown);
    countdown--;

    if (countdown &lt; 0) {
        clearInterval(timer);
        console.log('倒计时结束!');
    }
}, 1000);

// 防抖(Debounce)
function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() =&gt; {
            fn.apply(this, args);
        }, delay);
    };
}

// 使用
const handleSearch = debounce((query) =&gt; {
    console.log('搜索:', query);
}, 500);

input.addEventListener('input', (e) =&gt; {
    handleSearch(e.target.value);
});

// 节流(Throttle)
function throttle(fn, delay) {
    let lastTime = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastTime &gt;= delay) {
            fn.apply(this, args);
            lastTime = now;
        }
    };
}

// 使用
const handleScroll = throttle(() =&gt; {
    console.log('滚动位置:', window.scrollY);
}, 200);

window.addEventListener('scroll', handleScroll);
</code></pre>
<h3 id="62-requestanimationframe"><a class="header" href="#62-requestanimationframe">6.2 requestAnimationFrame</a></h3>
<pre><code class="language-javascript">// requestAnimationFrame:浏览器下一次重绘前执行
function animate() {
    // 动画逻辑
    element.style.left = (parseInt(element.style.left) || 0) + 1 + 'px';

    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

// 取消动画
const animationId = requestAnimationFrame(animate);
cancelAnimationFrame(animationId);

// 平滑滚动
function smoothScroll(target, duration) {
    const start = window.scrollY;
    const distance = target - start;
    const startTime = Date.now();

    function scroll() {
        const currentTime = Date.now();
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        window.scrollTo(0, start + distance * progress);

        if (progress &lt; 1) {
            requestAnimationFrame(scroll);
        }
    }

    requestAnimationFrame(scroll);
}

smoothScroll(1000, 500); // 滚动到1000px,耗时500ms

// FPS计算
let lastTime = Date.now();
let frames = 0;

function calculateFPS() {
    frames++;
    const currentTime = Date.now();

    if (currentTime - lastTime &gt;= 1000) {
        const fps = frames;
        console.log(`FPS: ${fps}`);
        frames = 0;
        lastTime = currentTime;
    }

    requestAnimationFrame(calculateFPS);
}

requestAnimationFrame(calculateFPS);
</code></pre>
<hr />
<h2 id="第七章实战项目"><a class="header" href="#第七章实战项目">第七章：实战项目</a></h2>
<h3 id="71-异步数据加载器"><a class="header" href="#71-异步数据加载器">7.1 异步数据加载器</a></h3>
<pre><code class="language-javascript">class AsyncDataLoader {
    constructor() {
        this.cache = new Map();
        this.loading = new Map();
    }

    async load(url, options = {}) {
        const {
            cache = true,
            timeout = 10000,
            retry = 3
        } = options;

        // 检查缓存
        if (cache &amp;&amp; this.cache.has(url)) {
            return this.cache.get(url);
        }

        // 防止重复请求
        if (this.loading.has(url)) {
            return this.loading.get(url);
        }

        // 创建请求Promise
        const promise = this._fetchWithRetry(url, retry, timeout);
        this.loading.set(url, promise);

        try {
            const data = await promise;

            if (cache) {
                this.cache.set(url, data);
            }

            return data;

        } finally {
            this.loading.delete(url);
        }
    }

    async _fetchWithRetry(url, times, timeout) {
        for (let i = 0; i &lt; times; i++) {
            try {
                return await this._fetchWithTimeout(url, timeout);
            } catch (error) {
                if (i === times - 1) throw error;
                await new Promise(r =&gt; setTimeout(r, 1000 * (i + 1)));
            }
        }
    }

    async _fetchWithTimeout(url, timeout) {
        return Promise.race([
            fetch(url).then(r =&gt; r.json()),
            new Promise((_, reject) =&gt;
                setTimeout(() =&gt; reject(new Error('超时')), timeout)
            )
        ]);
    }

    clearCache() {
        this.cache.clear();
    }
}

// 使用
const loader = new AsyncDataLoader();

async function loadUserData(userId) {
    try {
        const user = await loader.load(`/api/users/${userId}`, {
            cache: true,
            timeout: 5000,
            retry: 3
        });
        console.log(user);
    } catch (error) {
        console.error('加载失败:', error);
    }
}
</code></pre>
<h3 id="72-并发控制器"><a class="header" href="#72-并发控制器">7.2 并发控制器</a></h3>
<pre><code class="language-javascript">class ConcurrencyController {
    constructor(limit) {
        this.limit = limit;
        this.running = 0;
        this.queue = [];
    }

    async run(task) {
        while (this.running &gt;= this.limit) {
            await new Promise(resolve =&gt; this.queue.push(resolve));
        }

        this.running++;

        try {
            return await task();
        } finally {
            this.running--;
            const resolve = this.queue.shift();
            if (resolve) resolve();
        }
    }

    async runAll(tasks) {
        return Promise.all(tasks.map(task =&gt; this.run(task)));
    }
}

// 使用
const controller = new ConcurrencyController(3);

const urls = [
    '/api/data1',
    '/api/data2',
    '/api/data3',
    '/api/data4',
    '/api/data5'
];

const tasks = urls.map(url =&gt; () =&gt; fetch(url).then(r =&gt; r.json()));

controller.runAll(tasks).then(results =&gt; {
    console.log('所有请求完成:', results);
});
</code></pre>
<hr />
<h2 id="学习验证标准"><a class="header" href="#学习验证标准">学习验证标准</a></h2>
<h3 id="异步基础40分"><a class="header" href="#异步基础40分">异步基础(40分)</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
理解同步vs异步</li>
<li><input disabled="" type="checkbox"/>
掌握Promise基础</li>
<li><input disabled="" type="checkbox"/>
熟练使用async/await</li>
<li><input disabled="" type="checkbox"/>
理解事件循环</li>
</ul>
<h3 id="异步模式30分"><a class="header" href="#异步模式30分">异步模式(30分)</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
掌握并发控制</li>
<li><input disabled="" type="checkbox"/>
理解错误处理</li>
<li><input disabled="" type="checkbox"/>
熟悉异步模式</li>
</ul>
<h3 id="实战能力30分"><a class="header" href="#实战能力30分">实战能力(30分)</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
能够封装异步操作</li>
<li><input disabled="" type="checkbox"/>
实现异步工具函数</li>
<li><input disabled="" type="checkbox"/>
解决实际异步问题</li>
</ul>
<hr />
<h2 id="推荐学习资源"><a class="header" href="#推荐学习资源">推荐学习资源</a></h2>
<h3 id="文档和文章"><a class="header" href="#文档和文章">文档和文章</a></h3>
<ul>
<li>MDN异步JavaScript: https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous</li>
<li>Promise/A+规范: https://promisesaplus.com/</li>
</ul>
<h3 id="工具推荐"><a class="header" href="#工具推荐">工具推荐</a></h3>
<ol>
<li><strong>Chrome DevTools</strong> - 异步调试</li>
<li><strong>async/await支持检测</strong> - Can I use</li>
</ol>
<h3 id="学习建议"><a class="header" href="#学习建议">学习建议</a></h3>
<ol>
<li>理解事件循环机制</li>
<li>多写异步代码</li>
<li>学习错误处理</li>
<li>实践并发控制</li>
</ol>
<hr />
<p><strong>注意事项</strong>:</p>
<p>异步编程是JavaScript的核心特性,掌握它需要:</p>
<ul>
<li><strong>理解原理</strong>: 深入理解事件循环</li>
<li><strong>多练习</strong>: 写各种异步场景</li>
<li><strong>重视错误处理</strong>: 异步代码容易出错</li>
<li><strong>性能优化</strong>: 合理使用并发</li>
</ul>
<p>掌握异步编程是成为JavaScript高手的必经之路!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/language/30-Javascript-02-ES6特性.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/language/30-Javascript-04-DOM和BOM.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/language/30-Javascript-02-ES6特性.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/language/30-Javascript-04-DOM和BOM.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

