<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Qt 5.15 核心技术深度学习笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="qt-515-核心技术深度学习笔记"><a class="header" href="#qt-515-核心技术深度学习笔记">Qt 5.15 核心技术深度学习笔记</a></h1>
<h2 id="学习目标定位"><a class="header" href="#学习目标定位">学习目标定位</a></h2>
<ul>
<li><strong>目标群体</strong>: 有C++基础的开发者，希望深入理解Qt核心机制</li>
<li><strong>学习周期</strong>: 10-14周</li>
<li><strong>前置要求</strong>: 扎实的C++基础、面向对象编程、模板、智能指针</li>
<li><strong>学习成果</strong>: 深入理解Qt元对象系统、精通信号槽机制、掌握Qt高级特性</li>
</ul>
<h2 id="学习路径图"><a class="header" href="#学习路径图">学习路径图</a></h2>
<pre><code>Qt基础架构(Week 1-2) → 元对象系统深度剖析(Week 3-4) → 信号槽机制原理(Week 5-6)
→ 事件系统与过滤器(Week 7) → 内存管理与对象树(Week 8) → 多线程编程(Week 9-10)
→ 网络与IO(Week 11) → 数据库与SQL(Week 12) → 高级特性与性能优化(Week 13-14)
</code></pre>
<hr />
<h2 id="第一模块qt核心架构与环境搭建"><a class="header" href="#第一模块qt核心架构与环境搭建">第一模块：Qt核心架构与环境搭建</a></h2>
<h3 id="11-qt框架架构深度解析"><a class="header" href="#11-qt框架架构深度解析">1.1 Qt框架架构深度解析</a></h3>
<h4 id="qt的模块化设计"><a class="header" href="#qt的模块化设计">Qt的模块化设计</a></h4>
<p>Qt采用模块化设计，核心模块包括：</p>
<p><strong>Qt Core模块</strong> - 核心非GUI功能</p>
<pre><code class="language-cpp">// Qt Core提供的核心类
QObject          // 对象模型基类
QString          // Unicode字符串
QVariant         // 类型安全的联合体
QList/QVector    // 容器类
QFile/QIODevice  // IO抽象
QThread          // 线程支持
</code></pre>
<p><strong>重要模块划分：</strong></p>
<pre><code>QtCore     - 核心非GUI类（本笔记重点）
QtNetwork  - 网络编程
QtSql      - 数据库集成
QtXml      - XML处理
QtTest     - 单元测试框架
QtConcurrent - 高级多线程API
</code></pre>
<h4 id="qt的设计理念"><a class="header" href="#qt的设计理念">Qt的设计理念</a></h4>
<p><strong>1. 信号槽机制 (Signal-Slot)</strong></p>
<pre><code class="language-cpp">// 传统回调方式的问题
class Button {
    void (*callback)(void*);  // 类型不安全，难以维护
    void* data;
};

// Qt的解决方案：类型安全的信号槽
class Button : public QObject {
    Q_OBJECT
signals:
    void clicked();  // 编译期类型检查
};
</code></pre>
<p><strong>2. 元对象系统 (Meta-Object System)</strong></p>
<pre><code class="language-cpp">// 提供运行时类型信息(RTTI)增强
QObject *obj = new QPushButton;
QString className = obj-&gt;metaObject()-&gt;className();  // "QPushButton"
</code></pre>
<h3 id="12-开发环境搭建"><a class="header" href="#12-开发环境搭建">1.2 开发环境搭建</a></h3>
<h4 id="linux环境完整配置"><a class="header" href="#linux环境完整配置">Linux环境完整配置</a></h4>
<pre><code class="language-bash"># Ubuntu/Debian系统
sudo apt-get update

# 安装Qt 5.15开发包
sudo apt-get install qt5-default
sudo apt-get install qtbase5-dev qtbase5-dev-tools
sudo apt-get install qttools5-dev qttools5-dev-tools

# 网络模块
sudo apt-get install libqt5network5 qtbase5-private-dev

# SQL模块
sudo apt-get install libqt5sql5 libqt5sql5-mysql libqt5sql5-sqlite

# 安装Qt Creator
sudo apt-get install qtcreator

# 验证安装
qmake --version
# 输出: QMake version 3.1, Using Qt version 5.15.x
</code></pre>
<h4 id="项目构建系统详解"><a class="header" href="#项目构建系统详解">项目构建系统详解</a></h4>
<p><strong>方法1: qmake (.pro文件)</strong></p>
<pre><code class="language-pro"># myproject.pro
QT       += core network sql
QT       -= gui  # 不使用GUI模块

TARGET = myapp
TEMPLATE = app
CONFIG += c++17

SOURCES += \
    main.cpp \
    myclass.cpp

HEADERS += \
    myclass.h

# 指定输出目录
DESTDIR = bin
OBJECTS_DIR = obj
MOC_DIR = moc
</code></pre>
<pre><code class="language-bash"># 构建流程
qmake myproject.pro
make
./bin/myapp
</code></pre>
<p><strong>方法2: CMake (推荐用于大型项目)</strong></p>
<pre><code class="language-cmake"># CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(MyQtApp)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_AUTOMOC ON)  # 自动MOC处理

find_package(Qt5 REQUIRED COMPONENTS Core Network Sql)

add_executable(myapp
    main.cpp
    myclass.cpp
)

target_link_libraries(myapp
    Qt5::Core
    Qt5::Network
    Qt5::Sql
)
</code></pre>
<pre><code class="language-bash"># 构建流程
mkdir build &amp;&amp; cd build
cmake ..
make
./myapp
</code></pre>
<h3 id="13-第一个qt非gui程序"><a class="header" href="#13-第一个qt非gui程序">1.3 第一个Qt非GUI程序</a></h3>
<pre><code class="language-cpp">// main.cpp
#include &lt;QCoreApplication&gt;
#include &lt;QDebug&gt;
#include &lt;QTimer&gt;

int main(int argc, char *argv[]) {
    QCoreApplication app(argc, argv);

    qDebug() &lt;&lt; "Qt Version:" &lt;&lt; QT_VERSION_STR;
    qDebug() &lt;&lt; "Application starting...";

    // 2秒后退出程序
    QTimer::singleShot(2000, &amp;app, &amp;QCoreApplication::quit);

    return app.exec();  // 进入事件循环
}
</code></pre>
<p><strong>编译运行：</strong></p>
<pre><code class="language-bash"># 方法1: 手动编译
g++ main.cpp -o myapp \
    -I/usr/include/x86_64-linux-gnu/qt5 \
    -I/usr/include/x86_64-linux-gnu/qt5/QtCore \
    -lQt5Core -fPIC

./myapp

# 方法2: qmake
qmake -project
echo "QT -= gui" &gt;&gt; *.pro
qmake
make
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>Qt Version: 5.15.2
Application starting...
</code></pre>
<hr />
<h2 id="第二模块qt元对象系统深度剖析"><a class="header" href="#第二模块qt元对象系统深度剖析">第二模块：Qt元对象系统深度剖析</a></h2>
<h3 id="21-元对象系统核心概念"><a class="header" href="#21-元对象系统核心概念">2.1 元对象系统核心概念</a></h3>
<p>Qt的元对象系统是Qt最核心的特性之一，它提供了：</p>
<ol>
<li>信号槽机制</li>
<li>运行时类型信息(RTTI)</li>
<li>动态属性系统</li>
<li>对象反射能力</li>
</ol>
<h4 id="moc-meta-object-compiler-工作原理"><a class="header" href="#moc-meta-object-compiler-工作原理">MOC (Meta-Object Compiler) 工作原理</a></h4>
<p><strong>MOC的作用：</strong></p>
<pre><code class="language-cpp">// 源代码 myclass.h
class MyClass : public QObject {
    Q_OBJECT  // 这个宏触发MOC处理
public:
    MyClass();
signals:
    void mySignal(int value);
};
</code></pre>
<p><strong>MOC生成的代码 (moc_myclass.cpp)：</strong></p>
<pre><code class="language-cpp">// MOC自动生成，包含元对象信息
static const uint qt_meta_data_MyClass[] = {
    // 版本、类名、信号、槽等元信息
    7,       // revision
    0,       // classname
    0, 0,    // classinfo
    1, 14,   // methods (信号/槽数量)
    // ... 更多元数据
};

const QMetaObject MyClass::staticMetaObject = {
    { &amp;QObject::staticMetaObject, qt_meta_stringdata_MyClass.data,
      qt_meta_data_MyClass, qt_static_metacall, nullptr, nullptr }
};
</code></pre>
<h4 id="q_object宏深度解析"><a class="header" href="#q_object宏深度解析">Q_OBJECT宏深度解析</a></h4>
<pre><code class="language-cpp">// Q_OBJECT宏展开后的代码（简化版）
#define Q_OBJECT \
public: \
    Q_OBJECT_CHECK \
    static const QMetaObject staticMetaObject; \
    virtual const QMetaObject *metaObject() const; \
    virtual void *qt_metacast(const char *); \
    virtual int qt_metacall(QMetaObject::Call, int, void **); \
    QT_TR_FUNCTIONS \
private: \
    Q_DECL_HIDDEN static void qt_static_metacall(QObject *, \
        QMetaObject::Call, int, void **);
</code></pre>
<p><strong>关键点：</strong></p>
<ol>
<li><code>staticMetaObject</code>: 存储类的元信息（静态成员）</li>
<li><code>metaObject()</code>: 返回运行时元对象信息</li>
<li><code>qt_metacall()</code>: 信号槽调用的核心函数</li>
</ol>
<h3 id="22-qobject深度剖析"><a class="header" href="#22-qobject深度剖析">2.2 QObject深度剖析</a></h3>
<h4 id="qobject的核心功能"><a class="header" href="#qobject的核心功能">QObject的核心功能</a></h4>
<pre><code class="language-cpp">class QObject {
public:
    // 1. 对象树（父子关系）
    QObject(QObject *parent = nullptr);
    QObject *parent() const;
    QList&lt;QObject*&gt; children() const;
    void setParent(QObject *parent);

    // 2. 对象名称
    QString objectName() const;
    void setObjectName(const QString &amp;name);

    // 3. 动态属性
    void setProperty(const char *name, const QVariant &amp;value);
    QVariant property(const char *name) const;

    // 4. 信号槽连接
    static QMetaObject::Connection connect(
        const QObject *sender, const char *signal,
        const QObject *receiver, const char *method,
        Qt::ConnectionType type = Qt::AutoConnection);

    // 5. 事件处理
    virtual bool event(QEvent *event);

    // 6. 线程亲和性
    QThread *thread() const;
    void moveToThread(QThread *thread);
};
</code></pre>
<h4 id="qobject的内存布局"><a class="header" href="#qobject的内存布局">QObject的内存布局</a></h4>
<pre><code class="language-cpp">// QObject内部数据结构（简化）
class QObjectPrivate {
public:
    QObject *parent;                    // 父对象指针
    QList&lt;QObject*&gt; children;           // 子对象列表
    QObjectConnectionListVector *connectionLists;  // 信号槽连接
    QList&lt;QByteArray&gt; propertyNames;    // 动态属性名
    QList&lt;QVariant&gt; propertyValues;     // 动态属性值
    QString objectName;                 // 对象名称
    QThread *threadData;                // 所属线程
};

class QObject {
private:
    QObjectPrivate *d_ptr;  // d指针模式
};
</code></pre>
<p><strong>重点：d指针（d-pointer）模式</strong></p>
<pre><code class="language-cpp">// 为什么使用d指针？
// 1. 二进制兼容性：可以修改私有成员而不破坏ABI
// 2. 减少编译依赖：头文件不暴露实现细节
// 3. 更好的封装性

// 使用示例
class MyClass : public QObject {
    Q_OBJECT
    Q_DECLARE_PRIVATE(MyClass)  // 声明私有实现类
private:
    MyClassPrivate * const d_ptr;
};

class MyClassPrivate {
public:
    int value;
    QString data;
    // 所有私有成员放这里
};
</code></pre>
<h3 id="23-运行时类型信息与反射"><a class="header" href="#23-运行时类型信息与反射">2.3 运行时类型信息与反射</a></h3>
<h4 id="类型信息查询"><a class="header" href="#类型信息查询">类型信息查询</a></h4>
<pre><code class="language-cpp">#include &lt;QCoreApplication&gt;
#include &lt;QDebug&gt;
#include &lt;QMetaObject&gt;
#include &lt;QMetaMethod&gt;
#include &lt;QMetaProperty&gt;

class Person : public QObject {
    Q_OBJECT
    Q_PROPERTY(QString name READ name WRITE setName)
    Q_PROPERTY(int age READ age WRITE setAge)

private:
    QString m_name;
    int m_age;

public:
    Person(QObject *parent = nullptr) : QObject(parent), m_age(0) {}

    QString name() const { return m_name; }
    void setName(const QString &amp;name) { m_name = name; }

    int age() const { return m_age; }
    void setAge(int age) { m_age = age; }

public slots:
    void sayHello() {
        qDebug() &lt;&lt; "Hello, I'm" &lt;&lt; m_name &lt;&lt; "age" &lt;&lt; m_age;
    }

signals:
    void nameChanged(const QString &amp;newName);
};

void introspectionDemo() {
    Person person;
    person.setObjectName("personObject");

    // 获取元对象
    const QMetaObject *metaObj = person.metaObject();

    // 1. 类名
    qDebug() &lt;&lt; "Class name:" &lt;&lt; metaObj-&gt;className();

    // 2. 父类信息
    const QMetaObject *superClass = metaObj-&gt;superClass();
    qDebug() &lt;&lt; "Super class:" &lt;&lt; superClass-&gt;className();

    // 3. 枚举所有方法
    qDebug() &lt;&lt; "\nMethods:";
    for (int i = metaObj-&gt;methodOffset(); i &lt; metaObj-&gt;methodCount(); ++i) {
        QMetaMethod method = metaObj-&gt;method(i);
        qDebug() &lt;&lt; "  " &lt;&lt; method.methodSignature()
                 &lt;&lt; "Type:" &lt;&lt; method.methodType();
    }

    // 4. 枚举所有属性
    qDebug() &lt;&lt; "\nProperties:";
    for (int i = metaObj-&gt;propertyOffset(); i &lt; metaObj-&gt;propertyCount(); ++i) {
        QMetaProperty prop = metaObj-&gt;property(i);
        qDebug() &lt;&lt; "  " &lt;&lt; prop.name() &lt;&lt; "Type:" &lt;&lt; prop.typeName();
    }

    // 5. 动态调用方法
    QMetaObject::invokeMethod(&amp;person, "sayHello");

    // 6. 动态设置属性
    person.setProperty("name", "张三");
    person.setProperty("age", 25);
    QMetaObject::invokeMethod(&amp;person, "sayHello");

    // 7. 动态读取属性
    qDebug() &lt;&lt; "\nReading properties:";
    QVariant nameValue = person.property("name");
    QVariant ageValue = person.property("age");
    qDebug() &lt;&lt; "Name:" &lt;&lt; nameValue.toString();
    qDebug() &lt;&lt; "Age:" &lt;&lt; ageValue.toInt();
}
</code></pre>
<p><strong>输出结果：</strong></p>
<pre><code>Class name: Person
Super class: QObject

Methods:
   sayHello() Type: Slot
   nameChanged(QString) Type: Signal

Properties:
   name Type: QString
   age Type: int

Hello, I'm "" age 0
Hello, I'm "张三" age 25

Reading properties:
Name: "张三"
Age: 25
</code></pre>
<h4 id="q_property宏详解"><a class="header" href="#q_property宏详解">Q_PROPERTY宏详解</a></h4>
<pre><code class="language-cpp">// Q_PROPERTY完整语法
class MyClass : public QObject {
    Q_OBJECT

    // READ/WRITE - 必须指定至少一个
    Q_PROPERTY(QString name READ name WRITE setName)

    // NOTIFY - 属性变化时发射的信号
    Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged)

    // RESET - 重置到默认值
    Q_PROPERTY(QColor color READ color WRITE setColor RESET resetColor)

    // MEMBER - 直接绑定成员变量（Qt 5.0+）
    Q_PROPERTY(bool enabled MEMBER m_enabled)

    // CONSTANT - 常量属性，无需WRITE
    Q_PROPERTY(int id READ id CONSTANT)

    // FINAL - 不可在子类中重写
    Q_PROPERTY(QString type READ type FINAL)

private:
    QString m_name;
    int m_value;
    QColor m_color;
    bool m_enabled;
    const int m_id = 123;

public:
    QString name() const { return m_name; }
    void setName(const QString &amp;n) { m_name = n; }

    int value() const { return m_value; }
    void setValue(int v) {
        if (m_value != v) {
            m_value = v;
            emit valueChanged(v);
        }
    }

    QColor color() const { return m_color; }
    void setColor(const QColor &amp;c) { m_color = c; }
    void resetColor() { m_color = Qt::white; }

    int id() const { return m_id; }
    QString type() const { return "MyClass"; }

signals:
    void valueChanged(int newValue);
};
</code></pre>
<h3 id="24-动态属性系统"><a class="header" href="#24-动态属性系统">2.4 动态属性系统</a></h3>
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QDebug&gt;

void dynamicPropertyDemo() {
    QObject obj;

    // 设置各种类型的动态属性
    obj.setProperty("intValue", 42);
    obj.setProperty("stringValue", "Hello");
    obj.setProperty("doubleValue", 3.14);
    obj.setProperty("boolValue", true);

    // 读取动态属性
    int intVal = obj.property("intValue").toInt();
    QString strVal = obj.property("stringValue").toString();
    double dblVal = obj.property("doubleValue").toDouble();
    bool boolVal = obj.property("boolValue").toBool();

    qDebug() &lt;&lt; "Int:" &lt;&lt; intVal;
    qDebug() &lt;&lt; "String:" &lt;&lt; strVal;
    qDebug() &lt;&lt; "Double:" &lt;&lt; dblVal;
    qDebug() &lt;&lt; "Bool:" &lt;&lt; boolVal;

    // 检查属性是否存在
    if (obj.property("nonExistent").isValid()) {
        qDebug() &lt;&lt; "Property exists";
    } else {
        qDebug() &lt;&lt; "Property does not exist";
    }

    // 删除动态属性（设置为invalid QVariant）
    obj.setProperty("intValue", QVariant());

    // 列出所有动态属性
    QList&lt;QByteArray&gt; propNames = obj.dynamicPropertyNames();
    qDebug() &lt;&lt; "Dynamic properties:" &lt;&lt; propNames;
}
</code></pre>
<p><strong>动态属性的高级应用：</strong></p>
<pre><code class="language-cpp">// 场景1：对象标记
void tagObjectsDemo() {
    QList&lt;QObject*&gt; objects;
    for (int i = 0; i &lt; 10; ++i) {
        QObject *obj = new QObject();
        obj-&gt;setProperty("priority", i % 3);  // 优先级：0,1,2
        obj-&gt;setProperty("category", i &lt; 5 ? "TypeA" : "TypeB");
        objects.append(obj);
    }

    // 筛选高优先级对象
    for (QObject *obj : objects) {
        if (obj-&gt;property("priority").toInt() == 2) {
            qDebug() &lt;&lt; "High priority object:" &lt;&lt; obj;
        }
    }

    qDeleteAll(objects);
}

// 场景2：配置数据存储
class Configuration : public QObject {
public:
    void loadConfig(const QString &amp;key, const QVariant &amp;value) {
        setProperty(key.toUtf8(), value);
    }

    QVariant getConfig(const QString &amp;key) const {
        return property(key.toUtf8());
    }
};
</code></pre>
<hr />
<h2 id="第三模块信号槽机制原理深度剖析"><a class="header" href="#第三模块信号槽机制原理深度剖析">第三模块：信号槽机制原理深度剖析</a></h2>
<h3 id="31-信号槽的本质"><a class="header" href="#31-信号槽的本质">3.1 信号槽的本质</a></h3>
<h4 id="传统观察者模式-vs-qt信号槽"><a class="header" href="#传统观察者模式-vs-qt信号槽">传统观察者模式 vs Qt信号槽</a></h4>
<pre><code class="language-cpp">// 传统观察者模式的问题
class Subject {
    vector&lt;Observer*&gt; observers;  // 1. 类型耦合
public:
    void attach(Observer* obs) { observers.push_back(obs); }
    void notify() {
        for (auto obs : observers) {
            obs-&gt;update();  // 2. 方法名硬编码
        }
    }
};

// Qt信号槽的优势
class Sender : public QObject {
    Q_OBJECT
signals:
    void dataChanged(int value);  // 1. 类型安全
                                  // 2. 编译期检查
                                  // 3. 自动断开连接
                                  // 4. 支持跨线程
};
</code></pre>
<h3 id="32-信号槽连接方式详解"><a class="header" href="#32-信号槽连接方式详解">3.2 信号槽连接方式详解</a></h3>
<h4 id="五种连接语法"><a class="header" href="#五种连接语法">五种连接语法</a></h4>
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QDebug&gt;

class Sender : public QObject {
    Q_OBJECT
signals:
    void valueChanged(int value);
    void complexSignal(const QString &amp;str, int num);
};

class Receiver : public QObject {
    Q_OBJECT
public slots:
    void onValueChanged(int value) {
        qDebug() &lt;&lt; "Received value:" &lt;&lt; value;
    }
    void handleComplex(const QString &amp;s, int n) {
        qDebug() &lt;&lt; "String:" &lt;&lt; s &lt;&lt; "Number:" &lt;&lt; n;
    }
};

void connectionSyntaxDemo() {
    Sender sender;
    Receiver receiver;

    // 方式1: SIGNAL/SLOT宏 (Qt 4 风格，运行时检查)
    QObject::connect(&amp;sender, SIGNAL(valueChanged(int)),
                     &amp;receiver, SLOT(onValueChanged(int)));

    // 方式2: 函数指针 (Qt 5 推荐，编译期检查)
    QObject::connect(&amp;sender, &amp;Sender::valueChanged,
                     &amp;receiver, &amp;Receiver::onValueChanged);

    // 方式3: Lambda表达式 (Qt 5.0+)
    QObject::connect(&amp;sender, &amp;Sender::valueChanged,
                     [](int value) {
                         qDebug() &lt;&lt; "Lambda received:" &lt;&lt; value;
                     });

    // 方式4: Lambda捕获上下文
    int multiplier = 10;
    QObject::connect(&amp;sender, &amp;Sender::valueChanged,
                     [multiplier](int value) {
                         qDebug() &lt;&lt; "Multiplied:" &lt;&lt; value * multiplier;
                     });

    // 方式5: 成员函数指针（需要完整签名）
    QObject::connect(&amp;sender, &amp;Sender::complexSignal,
                     &amp;receiver, &amp;Receiver::handleComplex);

    // 测试发射信号
    emit sender.valueChanged(42);
    emit sender.complexSignal("Test", 100);
}
</code></pre>
<h4 id="连接类型详解"><a class="header" href="#连接类型详解">连接类型详解</a></h4>
<pre><code class="language-cpp">enum ConnectionType {
    AutoConnection,      // 自动选择（默认）
    DirectConnection,    // 直接调用（同线程）
    QueuedConnection,    // 队列调用（跨线程）
    BlockingQueuedConnection,  // 阻塞队列调用
    UniqueConnection     // 唯一连接（避免重复）
};

void connectionTypeDemo() {
    Sender sender;
    Receiver receiver;

    // 1. DirectConnection - 同步调用，直接执行槽函数
    connect(&amp;sender, &amp;Sender::valueChanged,
            &amp;receiver, &amp;Receiver::onValueChanged,
            Qt::DirectConnection);
    // emit后立即执行槽函数，阻塞发送者

    // 2. QueuedConnection - 异步调用，通过事件队列
    connect(&amp;sender, &amp;Sender::valueChanged,
            &amp;receiver, &amp;Receiver::onValueChanged,
            Qt::QueuedConnection);
    // emit后将事件放入队列，不阻塞发送者

    // 3. BlockingQueuedConnection - 阻塞队列调用
    connect(&amp;sender, &amp;Sender::valueChanged,
            &amp;receiver, &amp;Receiver::onValueChanged,
            Qt::BlockingQueuedConnection);
    // emit后阻塞等待槽函数执行完成（禁止同线程使用）

    // 4. UniqueConnection - 避免重复连接
    connect(&amp;sender, &amp;Sender::valueChanged,
            &amp;receiver, &amp;Receiver::onValueChanged,
            Qt::UniqueConnection);
    connect(&amp;sender, &amp;Sender::valueChanged,
            &amp;receiver, &amp;Receiver::onValueChanged,
            Qt::UniqueConnection);
    // 只会建立一次连接
}
</code></pre>
<h3 id="33-信号槽底层实现机制"><a class="header" href="#33-信号槽底层实现机制">3.3 信号槽底层实现机制</a></h3>
<h4 id="连接的内部数据结构"><a class="header" href="#连接的内部数据结构">连接的内部数据结构</a></h4>
<pre><code class="language-cpp">// Qt内部的连接数据结构（简化版）
struct Connection {
    QObject *sender;        // 发送者对象
    QObject *receiver;      // 接收者对象
    int signal_index;       // 信号在元对象中的索引
    int slot_index;         // 槽在元对象中的索引
    Qt::ConnectionType type;// 连接类型
};

class QObjectPrivate {
    // 每个QObject内部维护的连接列表
    QVector&lt;Connection*&gt; senderConnections;    // 作为发送者的连接
    QVector&lt;Connection*&gt; receiverConnections;  // 作为接收者的连接
};
</code></pre>
<h4 id="信号发射的完整流程"><a class="header" href="#信号发射的完整流程">信号发射的完整流程</a></h4>
<pre><code class="language-cpp">// 假设有这样的信号定义
class MyClass : public QObject {
    Q_OBJECT
signals:
    void mySignal(int value);
};

// MOC生成的信号实现（简化版）
void MyClass::mySignal(int value) {
    // 1. 获取信号索引
    static const int signal_index = staticMetaObject.indexOfSignal("mySignal(int)");

    // 2. 准备参数数组
    void *args[] = { nullptr, &amp;value };

    // 3. 调用元对象系统的activate函数
    QMetaObject::activate(this, &amp;staticMetaObject, signal_index, args);
}

// QMetaObject::activate的核心逻辑（简化）
void QMetaObject::activate(QObject *sender, const QMetaObject *m,
                           int signal_index, void **argv) {
    // 1. 获取该信号的所有连接
    QObjectPrivate *senderPrivate = sender-&gt;d_func();
    ConnectionList &amp;connections = senderPrivate-&gt;connectionLists[signal_index];

    // 2. 遍历所有连接
    for (Connection *c : connections) {
        // 3. 根据连接类型调用槽函数
        if (c-&gt;connectionType == Qt::DirectConnection) {
            // 直接调用槽函数
            c-&gt;receiver-&gt;qt_metacall(QMetaObject::InvokeMetaMethod,
                                     c-&gt;slot_index, argv);
        }
        else if (c-&gt;connectionType == Qt::QueuedConnection) {
            // 创建事件并投递到事件队列
            QMetaCallEvent *event = new QMetaCallEvent(c-&gt;slot_index, argv);
            QCoreApplication::postEvent(c-&gt;receiver, event);
        }
        // ... 其他连接类型处理
    }
}
</code></pre>
<h4 id="自己实现一个简化版信号槽"><a class="header" href="#自己实现一个简化版信号槽">自己实现一个简化版信号槽</a></h4>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

// 简化版信号类
template&lt;typename... Args&gt;
class Signal {
private:
    using SlotType = std::function&lt;void(Args...)&gt;;
    std::vector&lt;SlotType&gt; slots;

public:
    // 连接槽函数
    void connect(SlotType slot) {
        slots.push_back(slot);
    }

    // 发射信号
    void emit(Args... args) {
        for (auto &amp;slot : slots) {
            slot(args...);
        }
    }

    // 断开所有连接
    void disconnectAll() {
        slots.clear();
    }
};

// 使用示例
#include &lt;iostream&gt;

class Button {
public:
    Signal&lt;int, int&gt; clicked;  // 信号：鼠标点击(x, y)

    void simulateClick(int x, int y) {
        clicked.emit(x, y);
    }
};

void simpleSignalSlotDemo() {
    Button button;

    // 连接Lambda槽
    button.clicked.connect([](int x, int y) {
        std::cout &lt;&lt; "Clicked at (" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")" &lt;&lt; std::endl;
    });

    // 连接普通函数
    button.clicked.connect([](int x, int y) {
        std::cout &lt;&lt; "Another handler: distance = "
                  &lt;&lt; std::sqrt(x*x + y*y) &lt;&lt; std::endl;
    });

    // 模拟点击
    button.simulateClick(10, 20);
}
</code></pre>
<h3 id="34-信号槽高级技巧"><a class="header" href="#34-信号槽高级技巧">3.4 信号槽高级技巧</a></h3>
<h4 id="信号转发与链式连接"><a class="header" href="#信号转发与链式连接">信号转发与链式连接</a></h4>
<pre><code class="language-cpp">class DataProcessor : public QObject {
    Q_OBJECT
signals:
    void rawDataReceived(const QByteArray &amp;data);
    void processedDataReady(const QString &amp;result);

public slots:
    void processData(const QByteArray &amp;data) {
        // 处理数据
        QString result = QString::fromUtf8(data).toUpper();
        emit processedDataReady(result);
    }
};

class DataLogger : public QObject {
    Q_OBJECT
public slots:
    void logData(const QString &amp;data) {
        qDebug() &lt;&lt; "Logging:" &lt;&lt; data;
    }
};

void signalChainingDemo() {
    DataProcessor processor;
    DataLogger logger;

    // 信号到槽的链式连接
    connect(&amp;processor, &amp;DataProcessor::rawDataReceived,
            &amp;processor, &amp;DataProcessor::processData);

    connect(&amp;processor, &amp;DataProcessor::processedDataReady,
            &amp;logger, &amp;DataLogger::logData);

    // 测试
    emit processor.rawDataReceived("hello world");
    // 输出: Logging: HELLO WORLD
}
</code></pre>
<h4 id="信号重载的处理"><a class="header" href="#信号重载的处理">信号重载的处理</a></h4>
<pre><code class="language-cpp">class Notifier : public QObject {
    Q_OBJECT
signals:
    void notify();              // 重载1
    void notify(int value);     // 重载2
    void notify(const QString &amp;msg);  // 重载3
};

class Handler : public QObject {
    Q_OBJECT
public slots:
    void onNotify() { qDebug() &lt;&lt; "No args"; }
    void onNotify(int v) { qDebug() &lt;&lt; "Int:" &lt;&lt; v; }
    void onNotify(const QString &amp;s) { qDebug() &lt;&lt; "String:" &lt;&lt; s; }
};

void overloadedSignalsDemo() {
    Notifier notifier;
    Handler handler;

    // Qt 5方式：使用qOverload指定重载版本
    connect(&amp;notifier, qOverload&lt;&gt;(&amp;Notifier::notify),
            &amp;handler, qOverload&lt;&gt;(&amp;Handler::onNotify));

    connect(&amp;notifier, qOverload&lt;int&gt;(&amp;Notifier::notify),
            &amp;handler, qOverload&lt;int&gt;(&amp;Handler::onNotify));

    connect(&amp;notifier, qOverload&lt;const QString&amp;&gt;(&amp;Notifier::notify),
            &amp;handler, qOverload&lt;const QString&amp;&gt;(&amp;Handler::onNotify));

    // 测试
    emit notifier.notify();
    emit notifier.notify(42);
    emit notifier.notify("Hello");
}
</code></pre>
<h4 id="连接管理与自动断开"><a class="header" href="#连接管理与自动断开">连接管理与自动断开</a></h4>
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QDebug&gt;

class Sender : public QObject {
    Q_OBJECT
signals:
    void dataReady(int value);
};

class Receiver : public QObject {
    Q_OBJECT
public slots:
    void handleData(int value) {
        qDebug() &lt;&lt; "Received:" &lt;&lt; value;
    }
};

void connectionManagementDemo() {
    Sender sender;
    Receiver *receiver = new Receiver();

    // 1. 保存连接对象，用于后续断开
    QMetaObject::Connection conn = connect(&amp;sender, &amp;Sender::dataReady,
                                           receiver, &amp;Receiver::handleData);

    emit sender.dataReady(1);  // 输出: Received: 1

    // 2. 手动断开连接
    QObject::disconnect(conn);
    emit sender.dataReady(2);  // 无输出

    // 3. 重新连接
    conn = connect(&amp;sender, &amp;Sender::dataReady,
                   receiver, &amp;Receiver::handleData);

    emit sender.dataReady(3);  // 输出: Received: 3

    // 4. 删除接收者会自动断开所有相关连接
    delete receiver;
    emit sender.dataReady(4);  // 无输出（连接已自动断开）
}
</code></pre>
<h4 id="上下文对象与生命周期管理"><a class="header" href="#上下文对象与生命周期管理">上下文对象与生命周期管理</a></h4>
<pre><code class="language-cpp">// Qt 5.2+ 引入的上下文对象参数
void contextObjectDemo() {
    Sender sender;
    Receiver *receiver = new Receiver();
    QObject *context = new QObject();

    // 使用上下文对象：当context被销毁时，连接自动断开
    connect(&amp;sender, &amp;Sender::dataReady,
            context,  // 上下文对象
            [receiver](int value) {
                receiver-&gt;handleData(value);
            });

    emit sender.dataReady(1);  // 正常工作

    delete context;  // 删除上下文对象
    emit sender.dataReady(2);  // Lambda不再被调用

    delete receiver;
}
</code></pre>
<hr />
<h2 id="第四模块qt对象模型与内存管理"><a class="header" href="#第四模块qt对象模型与内存管理">第四模块：Qt对象模型与内存管理</a></h2>
<h3 id="41-qt对象树机制"><a class="header" href="#41-qt对象树机制">4.1 Qt对象树机制</a></h3>
<h4 id="父子关系的核心原理"><a class="header" href="#父子关系的核心原理">父子关系的核心原理</a></h4>
<pre><code class="language-cpp">// Qt对象树的核心：父对象销毁时自动删除所有子对象
class QObject {
private:
    QObject *m_parent;
    QList&lt;QObject*&gt; m_children;

public:
    void setParent(QObject *parent) {
        if (m_parent) {
            m_parent-&gt;m_children.removeOne(this);
        }
        m_parent = parent;
        if (m_parent) {
            m_parent-&gt;m_children.append(this);
        }
    }

    ~QObject() {
        // 1. 删除所有子对象
        qDeleteAll(m_children);

        // 2. 从父对象中移除自己
        if (m_parent) {
            m_parent-&gt;m_children.removeOne(this);
        }
    }
};
</code></pre>
<h4 id="对象树实战示例"><a class="header" href="#对象树实战示例">对象树实战示例</a></h4>
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QDebug&gt;

class Component : public QObject {
    Q_OBJECT
public:
    Component(const QString &amp;name, QObject *parent = nullptr)
        : QObject(parent) {
        setObjectName(name);
        qDebug() &lt;&lt; "Component created:" &lt;&lt; name;
    }

    ~Component() {
        qDebug() &lt;&lt; "Component destroyed:" &lt;&lt; objectName();
    }
};

void objectTreeDemo() {
    qDebug() &lt;&lt; "=== Creating object tree ===";

    // 根对象
    Component *root = new Component("Root");

    // 第一层子对象
    Component *child1 = new Component("Child1", root);
    Component *child2 = new Component("Child2", root);

    // 第二层子对象
    Component *grandChild1 = new Component("GrandChild1", child1);
    Component *grandChild2 = new Component("GrandChild2", child1);
    Component *grandChild3 = new Component("GrandChild3", child2);

    qDebug() &lt;&lt; "\n=== Object tree structure ===";
    qDebug() &lt;&lt; "Root children:" &lt;&lt; root-&gt;children().size();
    qDebug() &lt;&lt; "Child1 children:" &lt;&lt; child1-&gt;children().size();
    qDebug() &lt;&lt; "Child2 children:" &lt;&lt; child2-&gt;children().size();

    qDebug() &lt;&lt; "\n=== Deleting root (all children auto-deleted) ===";
    delete root;  // 自动删除所有子对象

    // 不需要手动delete child1, child2, grandChild1等
}
</code></pre>
<p><strong>输出：</strong></p>
<pre><code>=== Creating object tree ===
Component created: Root
Component created: Child1
Component created: Child2
Component created: GrandChild1
Component created: GrandChild2
Component created: GrandChild3

=== Object tree structure ===
Root children: 2
Child1 children: 2
Child2 children: 1

=== Deleting root (all children auto-deleted) ===
Component destroyed: GrandChild1
Component destroyed: GrandChild2
Component destroyed: Child1
Component destroyed: GrandChild3
Component destroyed: Child2
Component destroyed: Root
</code></pre>
<h3 id="42-qt内存管理最佳实践"><a class="header" href="#42-qt内存管理最佳实践">4.2 Qt内存管理最佳实践</a></h3>
<h4 id="规则1qobject派生类优先使用对象树"><a class="header" href="#规则1qobject派生类优先使用对象树">规则1：QObject派生类优先使用对象树</a></h4>
<pre><code class="language-cpp">// ❌ 错误：容易内存泄漏
void badPractice() {
    QTimer *timer = new QTimer();  // 没有父对象，必须手动delete
    // ... 使用timer
    // 忘记delete timer; // 内存泄漏！
}

// ✅ 正确：使用父对象
void goodPractice(QObject *parent) {
    QTimer *timer = new QTimer(parent);  // 父对象销毁时自动删除
    // 无需手动delete
}

// ✅ 或者使用栈对象
void stackObjectPractice() {
    QTimer timer;  // 栈对象，自动销毁
    // ...
}  // timer自动销毁
</code></pre>
<h4 id="规则2智能指针的正确使用"><a class="header" href="#规则2智能指针的正确使用">规则2：智能指针的正确使用</a></h4>
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QSharedPointer&gt;
#include &lt;QWeakPointer&gt;
#include &lt;QScopedPointer&gt;

// 场景1：QScopedPointer - 独占所有权
class MyClass {
private:
    QScopedPointer&lt;QObject&gt; m_resource;

public:
    MyClass() : m_resource(new QObject()) {
        // QScopedPointer自动管理生命周期
    }
    // 析构时自动delete m_resource
};

// 场景2：QSharedPointer - 共享所有权
void sharedOwnershipDemo() {
    QSharedPointer&lt;QObject&gt; shared1(new QObject());
    qDebug() &lt;&lt; "Ref count:" &lt;&lt; shared1.count();  // 1

    {
        QSharedPointer&lt;QObject&gt; shared2 = shared1;
        qDebug() &lt;&lt; "Ref count:" &lt;&lt; shared1.count();  // 2
    }

    qDebug() &lt;&lt; "Ref count:" &lt;&lt; shared1.count();  // 1
}  // 退出作用域时自动delete

// 场景3：QWeakPointer - 弱引用，避免循环引用
class Parent;
class Child;

class Parent : public QObject {
public:
    QSharedPointer&lt;Child&gt; child;
};

class Child : public QObject {
public:
    QWeakPointer&lt;Parent&gt; parent;  // 使用弱引用避免循环
};

void weakPointerDemo() {
    QSharedPointer&lt;Parent&gt; p(new Parent());
    QSharedPointer&lt;Child&gt; c(new Child());

    p-&gt;child = c;
    c-&gt;parent = p;  // 弱引用，不增加引用计数

    // p和c都能正常销毁，无内存泄漏
}
</code></pre>
<h4 id="规则3小心deletelater的使用"><a class="header" href="#规则3小心deletelater的使用">规则3：小心deleteLater()的使用</a></h4>
<pre><code class="language-cpp">class Worker : public QObject {
    Q_OBJECT
public slots:
    void doWork() {
        qDebug() &lt;&lt; "Working...";
        // 工作完成后延迟删除自己
        deleteLater();  // 在当前事件循环迭代结束后删除
    }
};

void deleteLaterDemo() {
    Worker *worker = new Worker();

    // 连接信号
    QTimer::singleShot(1000, worker, &amp;Worker::doWork);

    // ❌ 错误：立即删除
    // delete worker;  // worker还在使用中！

    // ✅ 正确：让doWork()槽函数调用deleteLater()
}

// deleteLater()的原理
void QObject::deleteLater() {
    // 1. 向事件队列投递DeferredDelete事件
    QCoreApplication::postEvent(this, new QEvent(QEvent::DeferredDelete));

    // 2. 事件循环处理该事件时会delete对象
}
</code></pre>
<h3 id="43-常见内存泄漏场景"><a class="header" href="#43-常见内存泄漏场景">4.3 常见内存泄漏场景</a></h3>
<h4 id="场景1忘记设置父对象"><a class="header" href="#场景1忘记设置父对象">场景1：忘记设置父对象</a></h4>
<pre><code class="language-cpp">// ❌ 内存泄漏示例
void leakExample1() {
    for (int i = 0; i &lt; 1000; ++i) {
        QObject *obj = new QObject();  // 没有父对象，没有delete
        // 每次循环泄漏一个QObject
    }
}

// ✅ 修复方法1：使用父对象
void fixExample1(QObject *parent) {
    for (int i = 0; i &lt; 1000; ++i) {
        QObject *obj = new QObject(parent);  // 父对象管理
    }
}

// ✅ 修复方法2：使用容器管理
void fixExample2() {
    QList&lt;QObject*&gt; objects;
    for (int i = 0; i &lt; 1000; ++i) {
        objects.append(new QObject());
    }
    qDeleteAll(objects);  // 统一删除
}
</code></pre>
<h4 id="场景2信号槽连接导致的泄漏"><a class="header" href="#场景2信号槽连接导致的泄漏">场景2：信号槽连接导致的泄漏</a></h4>
<pre><code class="language-cpp">// ❌ 潜在泄漏：Lambda捕获this但对象提前销毁
class MyClass : public QObject {
    Q_OBJECT
private:
    QTimer *timer;

public:
    MyClass() {
        timer = new QTimer();

        // 危险：如果MyClass被delete，但timer还存活
        connect(timer, &amp;QTimer::timeout, [this]() {
            // this可能已经被delete了！
            doSomething();  // 未定义行为
        });

        timer-&gt;start(1000);
    }
};

// ✅ 修复：使用上下文对象
class MyClassFixed : public QObject {
    Q_OBJECT
private:
    QTimer *timer;

public:
    MyClassFixed() {
        timer = new QTimer(this);  // 设置父对象

        // 使用this作为上下文对象
        connect(timer, &amp;QTimer::timeout, this, [this]() {
            doSomething();  // 如果this被delete，连接自动断开
        });

        timer-&gt;start(1000);
    }

    void doSomething() {
        qDebug() &lt;&lt; "Timer fired";
    }
};
</code></pre>
<h4 id="场景3循环引用"><a class="header" href="#场景3循环引用">场景3：循环引用</a></h4>
<pre><code class="language-cpp">// ❌ 循环引用导致内存泄漏
class NodeA;
class NodeB;

class NodeA {
public:
    QSharedPointer&lt;NodeB&gt; ptrB;
};

class NodeB {
public:
    QSharedPointer&lt;NodeA&gt; ptrA;  // 循环引用！
};

void cyclicReferenceDemo() {
    QSharedPointer&lt;NodeA&gt; a(new NodeA());
    QSharedPointer&lt;NodeB&gt; b(new NodeB());

    a-&gt;ptrB = b;  // a持有b的强引用
    b-&gt;ptrA = a;  // b持有a的强引用

    // a和b都无法释放，内存泄漏！
}

// ✅ 使用弱引用打破循环
class NodeAFixed {
public:
    QSharedPointer&lt;NodeB&gt; ptrB;
};

class NodeBFixed {
public:
    QWeakPointer&lt;NodeA&gt; ptrA;  // 使用弱引用
};

void fixedCyclicReference() {
    QSharedPointer&lt;NodeAFixed&gt; a(new NodeAFixed());
    QSharedPointer&lt;NodeBFixed&gt; b(new NodeBFixed());

    a-&gt;ptrB = b;
    b-&gt;ptrA = a;  // 弱引用，不增加引用计数

    // 正常释放
}
</code></pre>
<hr />
<h2 id="第五模块qt事件系统深度剖析"><a class="header" href="#第五模块qt事件系统深度剖析">第五模块：Qt事件系统深度剖析</a></h2>
<h3 id="51-事件机制核心概念"><a class="header" href="#51-事件机制核心概念">5.1 事件机制核心概念</a></h3>
<h4 id="qt事件系统架构"><a class="header" href="#qt事件系统架构">Qt事件系统架构</a></h4>
<pre><code>用户操作/系统事件 → 事件生成 → 事件队列 → 事件分发 → 事件处理
                                ↓
                          event() → 特定事件处理器
                                ↓
                          eventFilter() 拦截
</code></pre>
<h4 id="qevent类型体系"><a class="header" href="#qevent类型体系">QEvent类型体系</a></h4>
<pre><code class="language-cpp">// Qt定义了100+种事件类型
enum QEvent::Type {
    None = 0,
    Timer = 1,                  // 定时器事件
    MouseButtonPress = 2,       // 鼠标按下
    MouseButtonRelease = 3,     // 鼠标释放
    MouseMove = 5,              // 鼠标移动
    KeyPress = 6,               // 键盘按下
    KeyRelease = 7,             // 键盘释放
    Paint = 12,                 // 绘制事件
    Close = 19,                 // 窗口关闭
    Show = 17,                  // 窗口显示
    Hide = 18,                  // 窗口隐藏
    User = 1000,                // 用户自定义事件起始
    MaxUser = 65535             // 用户事件最大值
};

// 自定义事件
class MyCustomEvent : public QEvent {
public:
    static const QEvent::Type EventType;

    MyCustomEvent(const QString &amp;data)
        : QEvent(EventType), m_data(data) {}

    QString data() const { return m_data; }

private:
    QString m_data;
};

// 分配自定义事件类型
const QEvent::Type MyCustomEvent::EventType =
    static_cast&lt;QEvent::Type&gt;(QEvent::User + 1);
</code></pre>
<h3 id="52-事件处理机制"><a class="header" href="#52-事件处理机制">5.2 事件处理机制</a></h3>
<h4 id="event函数重写"><a class="header" href="#event函数重写">event()函数重写</a></h4>
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QEvent&gt;
#include &lt;QTimerEvent&gt;
#include &lt;QDebug&gt;

class EventHandler : public QObject {
    Q_OBJECT

public:
    EventHandler(QObject *parent = nullptr) : QObject(parent) {
        // 启动定时器
        startTimer(1000);  // 每秒触发一次
    }

protected:
    // 核心：重写event()函数
    bool event(QEvent *e) override {
        // 根据事件类型分发处理
        switch (e-&gt;type()) {
            case QEvent::Timer: {
                QTimerEvent *timerEvent = static_cast&lt;QTimerEvent*&gt;(e);
                qDebug() &lt;&lt; "Timer event, ID:" &lt;&lt; timerEvent-&gt;timerId();
                return true;  // 事件已处理
            }

            case MyCustomEvent::EventType: {
                MyCustomEvent *customEvent = static_cast&lt;MyCustomEvent*&gt;(e);
                qDebug() &lt;&lt; "Custom event:" &lt;&lt; customEvent-&gt;data();
                return true;
            }

            default:
                // 未处理的事件传递给基类
                return QObject::event(e);
        }
    }

    // 特定事件处理器
    void timerEvent(QTimerEvent *event) override {
        qDebug() &lt;&lt; "Timer ID:" &lt;&lt; event-&gt;timerId();
    }
};
</code></pre>
<h4 id="事件分发流程"><a class="header" href="#事件分发流程">事件分发流程</a></h4>
<pre><code class="language-cpp">// Qt事件分发的完整流程（简化）
bool QObject::event(QEvent *e) {
    switch (e-&gt;type()) {
    case QEvent::Timer:
        timerEvent((QTimerEvent*)e);
        break;

    case QEvent::ChildAdded:
    case QEvent::ChildPolished:
    case QEvent::ChildRemoved:
        childEvent((QChildEvent*)e);
        break;

    case QEvent::DeferredDelete:
        delete this;  // deleteLater()的实现
        break;

    // ... 其他事件类型

    default:
        return false;  // 未处理
    }

    return true;  // 已处理
}
</code></pre>
<h3 id="53-事件过滤器"><a class="header" href="#53-事件过滤器">5.3 事件过滤器</a></h3>
<h4 id="事件过滤器原理"><a class="header" href="#事件过滤器原理">事件过滤器原理</a></h4>
<pre><code class="language-cpp">// 事件过滤器接口
class QObject {
public:
    // 安装事件过滤器
    void installEventFilter(QObject *filterObj);

    // 移除事件过滤器
    void removeEventFilter(QObject *filterObj);

protected:
    // 事件过滤器函数
    virtual bool eventFilter(QObject *watched, QEvent *event);
};

// 事件传递顺序
事件产生 → eventFilter(多个，按安装顺序) → event() → 特定处理器
</code></pre>
<h4 id="事件过滤器实战"><a class="header" href="#事件过滤器实战">事件过滤器实战</a></h4>
<pre><code class="language-cpp">#include &lt;QObject&gt;
#include &lt;QEvent&gt;
#include &lt;QKeyEvent&gt;
#include &lt;QDebug&gt;

// 场景1：键盘事件过滤器
class KeyPressFilter : public QObject {
    Q_OBJECT

protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        if (event-&gt;type() == QEvent::KeyPress) {
            QKeyEvent *keyEvent = static_cast&lt;QKeyEvent*&gt;(event);

            // 拦截ESC键
            if (keyEvent-&gt;key() == Qt::Key_Escape) {
                qDebug() &lt;&lt; "ESC key blocked by filter";
                return true;  // 阻止事件继续传递
            }

            // 记录所有按键
            qDebug() &lt;&lt; "Key pressed:" &lt;&lt; keyEvent-&gt;text();
        }

        // 传递给下一个处理器
        return QObject::eventFilter(watched, event);
    }
};

// 场景2：鼠标点击统计
class ClickCounter : public QObject {
    Q_OBJECT

private:
    int m_clickCount = 0;

protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        if (event-&gt;type() == QEvent::MouseButtonPress) {
            m_clickCount++;
            qDebug() &lt;&lt; "Total clicks:" &lt;&lt; m_clickCount
                     &lt;&lt; "on object:" &lt;&lt; watched-&gt;objectName();
        }

        return false;  // 不拦截，继续传递
    }

public:
    int clickCount() const { return m_clickCount; }
    void resetCount() { m_clickCount = 0; }
};

// 使用示例
void eventFilterDemo() {
    QObject targetObject;
    targetObject.setObjectName("target");

    // 安装过滤器
    KeyPressFilter *keyFilter = new KeyPressFilter();
    ClickCounter *clickCounter = new ClickCounter();

    targetObject.installEventFilter(keyFilter);
    targetObject.installEventFilter(clickCounter);

    // 模拟事件
    QKeyEvent *keyEvent = new QKeyEvent(QEvent::KeyPress, Qt::Key_A, Qt::NoModifier, "A");
    QCoreApplication::sendEvent(&amp;targetObject, keyEvent);

    // 移除过滤器
    targetObject.removeEventFilter(keyFilter);

    delete keyEvent;
    delete keyFilter;
    delete clickCounter;
}
</code></pre>
<h4 id="全局事件过滤器"><a class="header" href="#全局事件过滤器">全局事件过滤器</a></h4>
<pre><code class="language-cpp">class GlobalEventFilter : public QObject {
    Q_OBJECT

protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        // 记录所有事件
        static int eventCount = 0;
        eventCount++;

        if (eventCount % 100 == 0) {
            qDebug() &lt;&lt; "Total events processed:" &lt;&lt; eventCount;
        }

        return false;  // 不拦截任何事件
    }
};

// 安装到QCoreApplication
void installGlobalFilter() {
    GlobalEventFilter *globalFilter = new GlobalEventFilter();
    qApp-&gt;installEventFilter(globalFilter);
    // 现在globalFilter会收到应用程序的所有事件
}
</code></pre>
<h3 id="54-自定义事件"><a class="header" href="#54-自定义事件">5.4 自定义事件</a></h3>
<h4 id="完整的自定义事件示例"><a class="header" href="#完整的自定义事件示例">完整的自定义事件示例</a></h4>
<pre><code class="language-cpp">#include &lt;QCoreApplication&gt;
#include &lt;QObject&gt;
#include &lt;QEvent&gt;
#include &lt;QDebug&gt;

// 1. 定义自定义事件类
class DataEvent : public QEvent {
public:
    static const QEvent::Type EventType;

    DataEvent(const QByteArray &amp;data)
        : QEvent(EventType)
        , m_data(data)
        , m_timestamp(QDateTime::currentDateTime()) {}

    QByteArray data() const { return m_data; }
    QDateTime timestamp() const { return m_timestamp; }

private:
    QByteArray m_data;
    QDateTime m_timestamp;
};

// 分配事件类型ID
const QEvent::Type DataEvent::EventType =
    static_cast&lt;QEvent::Type&gt;(QEvent::registerEventType());

// 2. 事件接收者
class DataReceiver : public QObject {
    Q_OBJECT

protected:
    bool event(QEvent *e) override {
        if (e-&gt;type() == DataEvent::EventType) {
            DataEvent *dataEvent = static_cast&lt;DataEvent*&gt;(e);

            qDebug() &lt;&lt; "Received data:" &lt;&lt; dataEvent-&gt;data();
            qDebug() &lt;&lt; "Timestamp:" &lt;&lt; dataEvent-&gt;timestamp();

            emit dataProcessed(dataEvent-&gt;data());
            return true;
        }

        return QObject::event(e);
    }

signals:
    void dataProcessed(const QByteArray &amp;data);
};

// 3. 事件发送者
class DataSender : public QObject {
    Q_OBJECT

private:
    DataReceiver *m_receiver;

public:
    DataSender(DataReceiver *receiver) : m_receiver(receiver) {}

public slots:
    void sendData(const QByteArray &amp;data) {
        // 创建并发送事件
        DataEvent *event = new DataEvent(data);
        QCoreApplication::postEvent(m_receiver, event);
        // 注意：postEvent后不要delete event，Qt会自动管理
    }

    void sendDataSync(const QByteArray &amp;data) {
        // 同步发送事件
        DataEvent event(data);
        QCoreApplication::sendEvent(m_receiver, &amp;event);
        // sendEvent是同步的，立即返回
    }
};

// 使用示例
void customEventDemo() {
    QCoreApplication app(argc, argv);

    DataReceiver receiver;
    DataSender sender(&amp;receiver);

    // 异步发送
    sender.sendData("Async message");

    // 同步发送
    sender.sendDataSync("Sync message");

    return app.exec();
}
</code></pre>
<h3 id="55-事件循环机制"><a class="header" href="#55-事件循环机制">5.5 事件循环机制</a></h3>
<h4 id="事件循环核心原理"><a class="header" href="#事件循环核心原理">事件循环核心原理</a></h4>
<pre><code class="language-cpp">// QCoreApplication::exec()的简化实现
int QCoreApplication::exec() {
    while (!qApp-&gt;shouldQuit()) {
        // 1. 处理所有待处理的事件
        processEvents(QEventLoop::AllEvents);

        // 2. 如果没有事件，等待新事件到来
        if (noMoreEvents()) {
            waitForEvents();  // 阻塞等待
        }
    }

    return qApp-&gt;exitCode();
}

// processEvents的实现
void QCoreApplication::processEvents() {
    while (!eventQueue.isEmpty()) {
        QEvent *event = eventQueue.dequeue();
        QObject *receiver = event-&gt;receiver();

        // 分发事件
        receiver-&gt;event(event);

        // 自动删除某些事件
        if (event-&gt;type() == QEvent::DeferredDelete) {
            delete receiver;
        }

        delete event;
    }
}
</code></pre>
<h4 id="局部事件循环"><a class="header" href="#局部事件循环">局部事件循环</a></h4>
<pre><code class="language-cpp">#include &lt;QEventLoop&gt;
#include &lt;QTimer&gt;
#include &lt;QDebug&gt;

// 场景1：等待异步操作完成
class AsyncOperation : public QObject {
    Q_OBJECT

public:
    bool waitForFinished(int timeout = 30000) {
        QEventLoop loop;
        QTimer timer;

        // 操作完成时退出循环
        connect(this, &amp;AsyncOperation::finished, &amp;loop, &amp;QEventLoop::quit);

        // 超时退出
        connect(&amp;timer, &amp;QTimer::timeout, &amp;loop, &amp;QEventLoop::quit);
        timer.start(timeout);

        // 进入局部事件循环
        loop.exec();

        return timer.isActive();  // 如果定时器还在运行，说明没超时
    }

signals:
    void finished();
};

// 场景2：嵌套事件循环
void nestedEventLoopDemo() {
    qDebug() &lt;&lt; "Entering main event loop";

    QTimer::singleShot(1000, []() {
        qDebug() &lt;&lt; "Creating nested event loop";

        QEventLoop nestedLoop;
        QTimer::singleShot(2000, &amp;nestedLoop, &amp;QEventLoop::quit);

        qDebug() &lt;&lt; "Nested loop started";
        nestedLoop.exec();  // 嵌套循环
        qDebug() &lt;&lt; "Nested loop finished";
    });

    qDebug() &lt;&lt; "Main event loop continues";
}
</code></pre>
<hr />
<h2 id="第六模块qt多线程编程深度剖析"><a class="header" href="#第六模块qt多线程编程深度剖析">第六模块：Qt多线程编程深度剖析</a></h2>
<h3 id="61-qthread核心机制"><a class="header" href="#61-qthread核心机制">6.1 QThread核心机制</a></h3>
<h4 id="qthread的两种使用方式"><a class="header" href="#qthread的两种使用方式">QThread的两种使用方式</a></h4>
<pre><code class="language-cpp">#include &lt;QThread&gt;
#include &lt;QDebug&gt;

// 方式1：继承QThread（不推荐）
class WorkerThread : public QThread {
    Q_OBJECT

protected:
    void run() override {
        qDebug() &lt;&lt; "Thread ID:" &lt;&lt; QThread::currentThreadId();

        for (int i = 0; i &lt; 5; ++i) {
            qDebug() &lt;&lt; "Working..." &lt;&lt; i;
            QThread::msleep(500);
        }

        qDebug() &lt;&lt; "Work finished";
    }
};

// 方式2：moveToThread（推荐）
class Worker : public QObject {
    Q_OBJECT

public slots:
    void doWork() {
        qDebug() &lt;&lt; "Worker thread ID:" &lt;&lt; QThread::currentThreadId();

        for (int i = 0; i &lt; 5; ++i) {
            qDebug() &lt;&lt; "Processing..." &lt;&lt; i;
            QThread::msleep(500);
            emit progress(i * 20);
        }

        emit finished();
    }

signals:
    void progress(int percent);
    void finished();
};

// 使用示例
void threadingDemo() {
    qDebug() &lt;&lt; "Main thread ID:" &lt;&lt; QThread::currentThreadId();

    // 方式1
    WorkerThread *thread1 = new WorkerThread();
    thread1-&gt;start();

    // 方式2（推荐）
    QThread *thread2 = new QThread();
    Worker *worker = new Worker();
    worker-&gt;moveToThread(thread2);

    // 连接信号槽
    QObject::connect(thread2, &amp;QThread::started, worker, &amp;Worker::doWork);
    QObject::connect(worker, &amp;Worker::finished, thread2, &amp;QThread::quit);
    QObject::connect(worker, &amp;Worker::finished, worker, &amp;Worker::deleteLater);
    QObject::connect(thread2, &amp;QThread::finished, thread2, &amp;QThread::deleteLater);

    thread2-&gt;start();
}
</code></pre>
<h4 id="为什么推荐movetothread方式"><a class="header" href="#为什么推荐movetothread方式">为什么推荐moveToThread方式？</a></h4>
<pre><code class="language-cpp">// 问题：继承QThread的陷阱
class BadThread : public QThread {
    Q_OBJECT

public slots:
    // ⚠️ 警告：这个槽函数在哪个线程执行？
    void processData() {
        // 答案：在主线程！因为QThread对象在主线程创建
        qDebug() &lt;&lt; "Thread ID:" &lt;&lt; QThread::currentThreadId();
    }

protected:
    void run() override {
        // 只有run()在新线程执行
        qDebug() &lt;&lt; "run() thread ID:" &lt;&lt; QThread::currentThreadId();
    }
};

// 正确方式：Worker对象在工作线程
class GoodWorker : public QObject {
    Q_OBJECT

public slots:
    void processData() {
        // ✅ 在工作线程执行，因为Worker对象move到了工作线程
        qDebug() &lt;&lt; "Thread ID:" &lt;&lt; QThread::currentThreadId();
    }
};

void comparisonDemo() {
    // 错误方式
    BadThread *badThread = new BadThread();
    badThread-&gt;start();

    QMetaObject::invokeMethod(badThread, "processData");
    // processData()在主线程执行！

    // 正确方式
    QThread *goodThread = new QThread();
    GoodWorker *worker = new GoodWorker();
    worker-&gt;moveToThread(goodThread);
    goodThread-&gt;start();

    QMetaObject::invokeMethod(worker, "processData");
    // processData()在工作线程执行！
}
</code></pre>
<h3 id="62-线程间通信"><a class="header" href="#62-线程间通信">6.2 线程间通信</a></h3>
<h4 id="信号槽的线程安全性"><a class="header" href="#信号槽的线程安全性">信号槽的线程安全性</a></h4>
<pre><code class="language-cpp">// Qt的信号槽自动处理线程安全
class DataProducer : public QObject {
    Q_OBJECT

signals:
    void dataReady(const QByteArray &amp;data);

public:
    void produceData() {
        QByteArray data = "Some data";
        // 即使在不同线程，emit也是线程安全的
        emit dataReady(data);
    }
};

class DataConsumer : public QObject {
    Q_OBJECT

public slots:
    void consumeData(const QByteArray &amp;data) {
        qDebug() &lt;&lt; "Consumer thread:" &lt;&lt; QThread::currentThreadId();
        qDebug() &lt;&lt; "Received:" &lt;&lt; data;
    }
};

void crossThreadSignalDemo() {
    QThread *producerThread = new QThread();
    QThread *consumerThread = new QThread();

    DataProducer *producer = new DataProducer();
    DataConsumer *consumer = new DataConsumer();

    producer-&gt;moveToThread(producerThread);
    consumer-&gt;moveToThread(consumerThread);

    // 跨线程连接（Qt自动使用QueuedConnection）
    QObject::connect(producer, &amp;DataProducer::dataReady,
                     consumer, &amp;DataConsumer::consumeData);

    producerThread-&gt;start();
    consumerThread-&gt;start();

    // 触发数据生产
    QMetaObject::invokeMethod(producer, "produceData");
}
</code></pre>
<h4 id="线程同步机制"><a class="header" href="#线程同步机制">线程同步机制</a></h4>
<pre><code class="language-cpp">#include &lt;QMutex&gt;
#include &lt;QMutexLocker&gt;
#include &lt;QWaitCondition&gt;
#include &lt;QSemaphore&gt;
#include &lt;QReadWriteLock&gt;

// 1. QMutex - 互斥锁
class Counter {
private:
    int m_value = 0;
    QMutex m_mutex;

public:
    void increment() {
        QMutexLocker locker(&amp;m_mutex);  // RAII锁
        m_value++;
    }  // locker析构时自动解锁

    int value() const {
        QMutexLocker locker(&amp;m_mutex);
        return m_value;
    }
};

// 2. QWaitCondition - 条件变量
class ProducerConsumer {
private:
    QQueue&lt;int&gt; m_queue;
    QMutex m_mutex;
    QWaitCondition m_dataAvailable;
    const int MAX_SIZE = 10;

public:
    void produce(int value) {
        QMutexLocker locker(&amp;m_mutex);

        while (m_queue.size() &gt;= MAX_SIZE) {
            m_dataAvailable.wait(&amp;m_mutex);  // 队列满，等待消费
        }

        m_queue.enqueue(value);
        qDebug() &lt;&lt; "Produced:" &lt;&lt; value;

        m_dataAvailable.wakeOne();  // 唤醒一个消费者
    }

    int consume() {
        QMutexLocker locker(&amp;m_mutex);

        while (m_queue.isEmpty()) {
            m_dataAvailable.wait(&amp;m_mutex);  // 队列空，等待生产
        }

        int value = m_queue.dequeue();
        qDebug() &lt;&lt; "Consumed:" &lt;&lt; value;

        m_dataAvailable.wakeOne();  // 唤醒一个生产者
        return value;
    }
};

// 3. QSemaphore - 信号量
class ResourcePool {
private:
    QSemaphore m_semaphore;

public:
    ResourcePool(int maxResources) : m_semaphore(maxResources) {}

    bool acquire(int count = 1, int timeout = -1) {
        return m_semaphore.tryAcquire(count, timeout);
    }

    void release(int count = 1) {
        m_semaphore.release(count);
    }
};

// 4. QReadWriteLock - 读写锁
class SharedData {
private:
    QString m_data;
    mutable QReadWriteLock m_lock;

public:
    QString read() const {
        QReadLocker locker(&amp;m_lock);  // 读锁（多个读者可并发）
        return m_data;
    }

    void write(const QString &amp;data) {
        QWriteLocker locker(&amp;m_lock);  // 写锁（独占）
        m_data = data;
    }
};
</code></pre>
<h3 id="63-qt-concurrent高级api"><a class="header" href="#63-qt-concurrent高级api">6.3 Qt Concurrent高级API</a></h3>
<h4 id="qtconcurrentrun---简单异步执行"><a class="header" href="#qtconcurrentrun---简单异步执行">QtConcurrent::run - 简单异步执行</a></h4>
<pre><code class="language-cpp">#include &lt;QtConcurrent&gt;
#include &lt;QFuture&gt;
#include &lt;QFutureWatcher&gt;

// 耗时计算函数
int fibonacci(int n) {
    if (n &lt;= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}

void qtConcurrentRunDemo() {
    // 异步执行函数
    QFuture&lt;int&gt; future = QtConcurrent::run(fibonacci, 40);

    // 方法1：阻塞等待结果
    int result = future.result();  // 阻塞
    qDebug() &lt;&lt; "Fibonacci(40) =" &lt;&lt; result;

    // 方法2：使用Watcher监听完成
    QFuture&lt;int&gt; future2 = QtConcurrent::run(fibonacci, 35);
    QFutureWatcher&lt;int&gt; *watcher = new QFutureWatcher&lt;int&gt;();

    QObject::connect(watcher, &amp;QFutureWatcher&lt;int&gt;::finished, [watcher]() {
        int result = watcher-&gt;result();
        qDebug() &lt;&lt; "Async result:" &lt;&lt; result;
        watcher-&gt;deleteLater();
    });

    watcher-&gt;setFuture(future2);
}
</code></pre>
<h4 id="qtconcurrentmapped---并行映射"><a class="header" href="#qtconcurrentmapped---并行映射">QtConcurrent::mapped - 并行映射</a></h4>
<pre><code class="language-cpp">#include &lt;QtConcurrent&gt;

// 映射函数
int square(int x) {
    return x * x;
}

void qtConcurrentMappedDemo() {
    QList&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 并行计算每个元素的平方
    QFuture&lt;int&gt; future = QtConcurrent::mapped(numbers, square);

    // 等待所有任务完成
    future.waitForFinished();

    // 获取结果
    QList&lt;int&gt; results = future.results();
    qDebug() &lt;&lt; "Original:" &lt;&lt; numbers;
    qDebug() &lt;&lt; "Squared:" &lt;&lt; results;
}

// 使用Lambda
void qtConcurrentMappedLambda() {
    QList&lt;QString&gt; strings = {"hello", "world", "qt", "concurrent"};

    // 并行转换为大写
    QFuture&lt;QString&gt; future = QtConcurrent::mapped(strings, [](const QString &amp;s) {
        return s.toUpper();
    });

    qDebug() &lt;&lt; "Uppercase:" &lt;&lt; future.results();
}
</code></pre>
<h4 id="qtconcurrentfilter---并行过滤"><a class="header" href="#qtconcurrentfilter---并行过滤">QtConcurrent::filter - 并行过滤</a></h4>
<pre><code class="language-cpp">// 过滤函数
bool isEven(int x) {
    return x % 2 == 0;
}

void qtConcurrentFilterDemo() {
    QList&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 方法1：filter（修改原容器）
    QList&lt;int&gt; numbersCopy = numbers;
    QFuture&lt;void&gt; future = QtConcurrent::filter(numbersCopy, isEven);
    future.waitForFinished();
    qDebug() &lt;&lt; "Even numbers:" &lt;&lt; numbersCopy;  // {2, 4, 6, 8, 10}

    // 方法2：filtered（返回新容器）
    QFuture&lt;int&gt; future2 = QtConcurrent::filtered(numbers, isEven);
    QList&lt;int&gt; evenNumbers = future2.results();
    qDebug() &lt;&lt; "Filtered:" &lt;&lt; evenNumbers;
}
</code></pre>
<h4 id="qtconcurrentreduce---并行规约"><a class="header" href="#qtconcurrentreduce---并行规约">QtConcurrent::reduce - 并行规约</a></h4>
<pre><code class="language-cpp">// 规约函数
void reduceSum(int &amp;result, int value) {
    result += value;
}

void qtConcurrentReduceDemo() {
    QList&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Map-Reduce：计算所有平方和
    QFuture&lt;int&gt; future = QtConcurrent::mappedReduced(
        numbers,
        square,      // map函数
        reduceSum    // reduce函数
    );

    int sumOfSquares = future.result();
    qDebug() &lt;&lt; "Sum of squares:" &lt;&lt; sumOfSquares;  // 385
}
</code></pre>
<h3 id="64-线程池"><a class="header" href="#64-线程池">6.4 线程池</a></h3>
<pre><code class="language-cpp">#include &lt;QThreadPool&gt;
#include &lt;QRunnable&gt;

// 自定义任务
class Task : public QRunnable {
private:
    int m_taskId;

public:
    Task(int id) : m_taskId(id) {
        setAutoDelete(true);  // 任务完成后自动删除
    }

    void run() override {
        qDebug() &lt;&lt; "Task" &lt;&lt; m_taskId &lt;&lt; "running in thread"
                 &lt;&lt; QThread::currentThreadId();

        // 模拟耗时操作
        QThread::msleep(1000);

        qDebug() &lt;&lt; "Task" &lt;&lt; m_taskId &lt;&lt; "finished";
    }
};

void threadPoolDemo() {
    QThreadPool *pool = QThreadPool::globalInstance();

    qDebug() &lt;&lt; "Max thread count:" &lt;&lt; pool-&gt;maxThreadCount();
    qDebug() &lt;&lt; "Active thread count:" &lt;&lt; pool-&gt;activeThreadCount();

    // 提交10个任务到线程池
    for (int i = 0; i &lt; 10; ++i) {
        pool-&gt;start(new Task(i));
    }

    // 等待所有任务完成
    pool-&gt;waitForDone();
    qDebug() &lt;&lt; "All tasks finished";
}

// 自定义线程池
void customThreadPoolDemo() {
    QThreadPool customPool;
    customPool.setMaxThreadCount(4);  // 限制为4个线程

    for (int i = 0; i &lt; 20; ++i) {
        customPool.start(new Task(i));
    }

    customPool.waitForDone();
}
</code></pre>
<h3 id="65-线程安全的单例模式"><a class="header" href="#65-线程安全的单例模式">6.5 线程安全的单例模式</a></h3>
<pre><code class="language-cpp">// Qt提供的线程安全单例
class Singleton {
private:
    Singleton() = default;
    ~Singleton() = default;
    Singleton(const Singleton&amp;) = delete;
    Singleton&amp; operator=(const Singleton&amp;) = delete;

public:
    static Singleton&amp; instance() {
        static Singleton instance;  // C++11保证线程安全
        return instance;
    }

    void doSomething() {
        qDebug() &lt;&lt; "Singleton method called";
    }
};

// 使用Q_GLOBAL_STATIC宏
class MyManager {
public:
    void manage() {
        qDebug() &lt;&lt; "Managing...";
    }
};

Q_GLOBAL_STATIC(MyManager, manager)

void singletonDemo() {
    // 方式1：传统单例
    Singleton::instance().doSomething();

    // 方式2：Q_GLOBAL_STATIC
    manager()-&gt;manage();
}
</code></pre>
<hr />
<h2 id="第七模块qt网络编程"><a class="header" href="#第七模块qt网络编程">第七模块：Qt网络编程</a></h2>
<h3 id="71-tcp编程"><a class="header" href="#71-tcp编程">7.1 TCP编程</a></h3>
<h4 id="tcp服务器"><a class="header" href="#tcp服务器">TCP服务器</a></h4>
<pre><code class="language-cpp">#include &lt;QTcpServer&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QDebug&gt;

class TcpServer : public QObject {
    Q_OBJECT

private:
    QTcpServer *m_server;
    QList&lt;QTcpSocket*&gt; m_clients;

public:
    TcpServer(QObject *parent = nullptr) : QObject(parent) {
        m_server = new QTcpServer(this);

        connect(m_server, &amp;QTcpServer::newConnection,
                this, &amp;TcpServer::onNewConnection);
    }

    bool start(quint16 port) {
        if (!m_server-&gt;listen(QHostAddress::Any, port)) {
            qDebug() &lt;&lt; "Failed to start server:" &lt;&lt; m_server-&gt;errorString();
            return false;
        }

        qDebug() &lt;&lt; "Server started on port" &lt;&lt; port;
        return true;
    }

private slots:
    void onNewConnection() {
        QTcpSocket *client = m_server-&gt;nextPendingConnection();
        m_clients.append(client);

        qDebug() &lt;&lt; "New client connected:" &lt;&lt; client-&gt;peerAddress().toString();

        connect(client, &amp;QTcpSocket::readyRead,
                this, &amp;TcpServer::onDataReceived);

        connect(client, &amp;QTcpSocket::disconnected,
                this, &amp;TcpServer::onClientDisconnected);
    }

    void onDataReceived() {
        QTcpSocket *client = qobject_cast&lt;QTcpSocket*&gt;(sender());
        if (!client) return;

        QByteArray data = client-&gt;readAll();
        qDebug() &lt;&lt; "Received from" &lt;&lt; client-&gt;peerAddress().toString()
                 &lt;&lt; ":" &lt;&lt; data;

        // 回显数据
        client-&gt;write("Echo: " + data);
    }

    void onClientDisconnected() {
        QTcpSocket *client = qobject_cast&lt;QTcpSocket*&gt;(sender());
        if (!client) return;

        qDebug() &lt;&lt; "Client disconnected:" &lt;&lt; client-&gt;peerAddress().toString();

        m_clients.removeOne(client);
        client-&gt;deleteLater();
    }
};
</code></pre>
<h4 id="tcp客户端"><a class="header" href="#tcp客户端">TCP客户端</a></h4>
<pre><code class="language-cpp">class TcpClient : public QObject {
    Q_OBJECT

private:
    QTcpSocket *m_socket;

public:
    TcpClient(QObject *parent = nullptr) : QObject(parent) {
        m_socket = new QTcpSocket(this);

        connect(m_socket, &amp;QTcpSocket::connected,
                this, &amp;TcpClient::onConnected);

        connect(m_socket, &amp;QTcpSocket::disconnected,
                this, &amp;TcpClient::onDisconnected);

        connect(m_socket, &amp;QTcpSocket::readyRead,
                this, &amp;TcpClient::onDataReceived);

        connect(m_socket, QOverload&lt;QAbstractSocket::SocketError&gt;::of(&amp;QAbstractSocket::error),
                this, &amp;TcpClient::onError);
    }

    void connectToHost(const QString &amp;host, quint16 port) {
        qDebug() &lt;&lt; "Connecting to" &lt;&lt; host &lt;&lt; ":" &lt;&lt; port;
        m_socket-&gt;connectToHost(host, port);
    }

    void sendData(const QByteArray &amp;data) {
        if (m_socket-&gt;state() == QAbstractSocket::ConnectedState) {
            m_socket-&gt;write(data);
        } else {
            qDebug() &lt;&lt; "Socket not connected";
        }
    }

private slots:
    void onConnected() {
        qDebug() &lt;&lt; "Connected to server";
    }

    void onDisconnected() {
        qDebug() &lt;&lt; "Disconnected from server";
    }

    void onDataReceived() {
        QByteArray data = m_socket-&gt;readAll();
        qDebug() &lt;&lt; "Received:" &lt;&lt; data;
    }

    void onError(QAbstractSocket::SocketError error) {
        qDebug() &lt;&lt; "Socket error:" &lt;&lt; m_socket-&gt;errorString();
    }
};
</code></pre>
<h3 id="72-http编程"><a class="header" href="#72-http编程">7.2 HTTP编程</a></h3>
<pre><code class="language-cpp">#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QJsonDocument&gt;
#include &lt;QJsonObject&gt;

class HttpClient : public QObject {
    Q_OBJECT

private:
    QNetworkAccessManager *m_manager;

public:
    HttpClient(QObject *parent = nullptr) : QObject(parent) {
        m_manager = new QNetworkAccessManager(this);
    }

    // GET请求
    void get(const QString &amp;url) {
        QNetworkRequest request(url);
        request.setHeader(QNetworkRequest::UserAgentHeader, "QtApp/1.0");

        QNetworkReply *reply = m_manager-&gt;get(request);

        connect(reply, &amp;QNetworkReply::finished, [this, reply]() {
            handleResponse(reply);
            reply-&gt;deleteLater();
        });
    }

    // POST请求
    void post(const QString &amp;url, const QJsonObject &amp;json) {
        QNetworkRequest request(url);
        request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");

        QJsonDocument doc(json);
        QByteArray data = doc.toJson();

        QNetworkReply *reply = m_manager-&gt;post(request, data);

        connect(reply, &amp;QNetworkReply::finished, [this, reply]() {
            handleResponse(reply);
            reply-&gt;deleteLater();
        });
    }

    // 文件下载
    void downloadFile(const QString &amp;url, const QString &amp;savePath) {
        QNetworkRequest request(url);
        QNetworkReply *reply = m_manager-&gt;get(request);

        // 监听下载进度
        connect(reply, &amp;QNetworkReply::downloadProgress,
                [](qint64 received, qint64 total) {
                    if (total &gt; 0) {
                        int percent = (received * 100) / total;
                        qDebug() &lt;&lt; "Download progress:" &lt;&lt; percent &lt;&lt; "%";
                    }
                });

        connect(reply, &amp;QNetworkReply::finished, [reply, savePath]() {
            if (reply-&gt;error() == QNetworkReply::NoError) {
                QFile file(savePath);
                if (file.open(QIODevice::WriteOnly)) {
                    file.write(reply-&gt;readAll());
                    file.close();
                    qDebug() &lt;&lt; "File downloaded to" &lt;&lt; savePath;
                }
            }
            reply-&gt;deleteLater();
        });
    }

private:
    void handleResponse(QNetworkReply *reply) {
        if (reply-&gt;error() == QNetworkReply::NoError) {
            int statusCode = reply-&gt;attribute(
                QNetworkRequest::HttpStatusCodeAttribute).toInt();

            qDebug() &lt;&lt; "Status code:" &lt;&lt; statusCode;

            QByteArray data = reply-&gt;readAll();
            qDebug() &lt;&lt; "Response:" &lt;&lt; data;

            // 解析JSON响应
            QJsonDocument doc = QJsonDocument::fromJson(data);
            if (doc.isObject()) {
                QJsonObject obj = doc.object();
                // 处理JSON数据
            }
        } else {
            qDebug() &lt;&lt; "Error:" &lt;&lt; reply-&gt;errorString();
        }
    }
};
</code></pre>
<hr />
<h2 id="第八模块qt数据库编程"><a class="header" href="#第八模块qt数据库编程">第八模块：Qt数据库编程</a></h2>
<h3 id="81-sql数据库操作"><a class="header" href="#81-sql数据库操作">8.1 SQL数据库操作</a></h3>
<pre><code class="language-cpp">#include &lt;QSqlDatabase&gt;
#include &lt;QSqlQuery&gt;
#include &lt;QSqlError&gt;
#include &lt;QSqlRecord&gt;
#include &lt;QDebug&gt;

class DatabaseManager {
private:
    QSqlDatabase m_db;

public:
    bool initialize(const QString &amp;dbPath) {
        m_db = QSqlDatabase::addDatabase("QSQLITE");
        m_db.setDatabaseName(dbPath);

        if (!m_db.open()) {
            qDebug() &lt;&lt; "Database error:" &lt;&lt; m_db.lastError().text();
            return false;
        }

        qDebug() &lt;&lt; "Database opened successfully";
        return true;
    }

    bool createTables() {
        QSqlQuery query(m_db);

        QString createTableSQL =
            "CREATE TABLE IF NOT EXISTS users ("
            "id INTEGER PRIMARY KEY AUTOINCREMENT, "
            "username TEXT NOT NULL UNIQUE, "
            "email TEXT NOT NULL, "
            "age INTEGER, "
            "created_at DATETIME DEFAULT CURRENT_TIMESTAMP"
            ")";

        if (!query.exec(createTableSQL)) {
            qDebug() &lt;&lt; "Create table error:" &lt;&lt; query.lastError().text();
            return false;
        }

        return true;
    }

    bool insertUser(const QString &amp;username, const QString &amp;email, int age) {
        QSqlQuery query(m_db);

        // 使用预处理语句防止SQL注入
        query.prepare("INSERT INTO users (username, email, age) VALUES (:username, :email, :age)");
        query.bindValue(":username", username);
        query.bindValue(":email", email);
        query.bindValue(":age", age);

        if (!query.exec()) {
            qDebug() &lt;&lt; "Insert error:" &lt;&lt; query.lastError().text();
            return false;
        }

        qDebug() &lt;&lt; "User inserted, last ID:" &lt;&lt; query.lastInsertId().toInt();
        return true;
    }

    QList&lt;QVariantMap&gt; queryUsers(const QString &amp;condition = QString()) {
        QList&lt;QVariantMap&gt; results;

        QString sql = "SELECT * FROM users";
        if (!condition.isEmpty()) {
            sql += " WHERE " + condition;
        }

        QSqlQuery query(m_db);
        if (!query.exec(sql)) {
            qDebug() &lt;&lt; "Query error:" &lt;&lt; query.lastError().text();
            return results;
        }

        while (query.next()) {
            QVariantMap row;
            QSqlRecord record = query.record();

            for (int i = 0; i &lt; record.count(); ++i) {
                row[record.fieldName(i)] = query.value(i);
            }

            results.append(row);
        }

        return results;
    }

    bool updateUser(int id, const QString &amp;email) {
        QSqlQuery query(m_db);
        query.prepare("UPDATE users SET email = :email WHERE id = :id");
        query.bindValue(":email", email);
        query.bindValue(":id", id);

        if (!query.exec()) {
            qDebug() &lt;&lt; "Update error:" &lt;&lt; query.lastError().text();
            return false;
        }

        qDebug() &lt;&lt; "Rows affected:" &lt;&lt; query.numRowsAffected();
        return true;
    }

    bool deleteUser(int id) {
        QSqlQuery query(m_db);
        query.prepare("DELETE FROM users WHERE id = :id");
        query.bindValue(":id", id);

        if (!query.exec()) {
            qDebug() &lt;&lt; "Delete error:" &lt;&lt; query.lastError().text();
            return false;
        }

        return true;
    }

    bool transaction() {
        if (!m_db.transaction()) {
            qDebug() &lt;&lt; "Begin transaction failed";
            return false;
        }

        QSqlQuery query(m_db);

        // 批量操作
        query.prepare("INSERT INTO users (username, email, age) VALUES (?, ?, ?)");

        QVariantList usernames = {"user1", "user2", "user3"};
        QVariantList emails = {"user1@test.com", "user2@test.com", "user3@test.com"};
        QVariantList ages = {25, 30, 28};

        query.addBindValue(usernames);
        query.addBindValue(emails);
        query.addBindValue(ages);

        if (!query.execBatch()) {
            qDebug() &lt;&lt; "Batch insert failed:" &lt;&lt; query.lastError().text();
            m_db.rollback();
            return false;
        }

        if (!m_db.commit()) {
            qDebug() &lt;&lt; "Commit failed";
            m_db.rollback();
            return false;
        }

        qDebug() &lt;&lt; "Transaction committed successfully";
        return true;
    }
};

// 使用示例
void databaseDemo() {
    DatabaseManager dbManager;

    if (!dbManager.initialize("test.db")) {
        return;
    }

    dbManager.createTables();
    dbManager.insertUser("alice", "alice@example.com", 25);
    dbManager.insertUser("bob", "bob@example.com", 30);

    QList&lt;QVariantMap&gt; users = dbManager.queryUsers();
    for (const QVariantMap &amp;user : users) {
        qDebug() &lt;&lt; "User:" &lt;&lt; user;
    }

    dbManager.updateUser(1, "newemail@example.com");
    dbManager.deleteUser(2);

    dbManager.transaction();
}
</code></pre>
<hr />
<h2 id="第九模块qt高级特性"><a class="header" href="#第九模块qt高级特性">第九模块：Qt高级特性</a></h2>
<h3 id="91-qvariant深度解析"><a class="header" href="#91-qvariant深度解析">9.1 QVariant深度解析</a></h3>
<pre><code class="language-cpp">#include &lt;QVariant&gt;
#include &lt;QDebug&gt;

void qvariantDemo() {
    // 基本类型
    QVariant v1 = 42;
    QVariant v2 = 3.14;
    QVariant v3 = QString("Hello");
    QVariant v4 = true;

    // 类型检查
    qDebug() &lt;&lt; "v1 type:" &lt;&lt; v1.typeName();  // "int"
    qDebug() &lt;&lt; "v1 is int:" &lt;&lt; v1.canConvert&lt;int&gt;();

    // 类型转换
    int intVal = v1.toInt();
    double doubleVal = v1.toDouble();  // 自动转换
    QString strVal = v1.toString();    // "42"

    // 复杂类型
    QVariant v5 = QStringList{"a", "b", "c"};
    QVariant v6 = QDateTime::currentDateTime();

    QMap&lt;QString, QVariant&gt; map;
    map["name"] = "Alice";
    map["age"] = 25;
    map["scores"] = QList&lt;int&gt;{85, 90, 95};
    QVariant v7 = map;

    // 自定义类型
    struct Person {
        QString name;
        int age;
    };

    Q_DECLARE_METATYPE(Person)  // 注册到元类型系统

    Person p{"Bob", 30};
    QVariant v8 = QVariant::fromValue(p);

    if (v8.canConvert&lt;Person&gt;()) {
        Person extracted = v8.value&lt;Person&gt;();
        qDebug() &lt;&lt; extracted.name &lt;&lt; extracted.age;
    }
}
</code></pre>
<h3 id="92-qmetatype系统"><a class="header" href="#92-qmetatype系统">9.2 QMetaType系统</a></h3>
<pre><code class="language-cpp">#include &lt;QMetaType&gt;

// 注册自定义类型
class MyClass {
public:
    QString name;
    int value;

    MyClass() : value(0) {}
    MyClass(const QString &amp;n, int v) : name(n), value(v) {}
};

// 注册到元类型系统
Q_DECLARE_METATYPE(MyClass)

// 在使用前注册（通常在main函数开始处）
void registerMetaTypes() {
    qRegisterMetaType&lt;MyClass&gt;("MyClass");

    // 注册后可以用于信号槽
    qRegisterMetaType&lt;QList&lt;MyClass&gt;&gt;("QList&lt;MyClass&gt;");
}

// 在信号槽中使用自定义类型
class CustomSignalEmitter : public QObject {
    Q_OBJECT
signals:
    void customDataReady(const MyClass &amp;data);
    void customListReady(const QList&lt;MyClass&gt; &amp;list);
};
</code></pre>
<h3 id="93-插件系统"><a class="header" href="#93-插件系统">9.3 插件系统</a></h3>
<pre><code class="language-cpp">// 定义插件接口
class PluginInterface {
public:
    virtual ~PluginInterface() {}
    virtual QString name() const = 0;
    virtual void execute() = 0;
};

#define PluginInterface_iid "com.example.PluginInterface/1.0"
Q_DECLARE_INTERFACE(PluginInterface, PluginInterface_iid)

// 实现插件
class MyPlugin : public QObject, public PluginInterface {
    Q_OBJECT
    Q_PLUGIN_METADATA(IID PluginInterface_iid)
    Q_INTERFACES(PluginInterface)

public:
    QString name() const override {
        return "My Plugin";
    }

    void execute() override {
        qDebug() &lt;&lt; "Plugin executing...";
    }
};

// 加载插件
void loadPlugin(const QString &amp;pluginPath) {
    QPluginLoader loader(pluginPath);
    QObject *plugin = loader.instance();

    if (plugin) {
        PluginInterface *interface = qobject_cast&lt;PluginInterface*&gt;(plugin);
        if (interface) {
            qDebug() &lt;&lt; "Loaded plugin:" &lt;&lt; interface-&gt;name();
            interface-&gt;execute();
        }
    } else {
        qDebug() &lt;&lt; "Failed to load plugin:" &lt;&lt; loader.errorString();
    }
}
</code></pre>
<hr />
<h2 id="学习验证标准"><a class="header" href="#学习验证标准">学习验证标准</a></h2>
<h3 id="核心模块验证week-1-4"><a class="header" href="#核心模块验证week-1-4">核心模块验证（Week 1-4）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
理解Qt元对象系统的实现原理</li>
<li><input disabled="" type="checkbox"/>
掌握MOC的作用和工作流程</li>
<li><input disabled="" type="checkbox"/>
能够熟练使用Q_OBJECT、Q_PROPERTY等宏</li>
<li><input disabled="" type="checkbox"/>
理解d指针模式及其应用</li>
<li><input disabled="" type="checkbox"/>
掌握Qt的RTTI和反射机制</li>
</ul>
<h3 id="信号槽验证week-5-6"><a class="header" href="#信号槽验证week-5-6">信号槽验证（Week 5-6）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
深入理解信号槽的底层实现</li>
<li><input disabled="" type="checkbox"/>
掌握5种连接语法及应用场景</li>
<li><input disabled="" type="checkbox"/>
理解不同连接类型的区别</li>
<li><input disabled="" type="checkbox"/>
能够处理信号槽的内存管理</li>
<li><input disabled="" type="checkbox"/>
掌握跨线程信号槽通信</li>
</ul>
<h3 id="内存与事件验证week-7-8"><a class="header" href="#内存与事件验证week-7-8">内存与事件验证（Week 7-8）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
理解Qt对象树机制</li>
<li><input disabled="" type="checkbox"/>
掌握Qt内存管理最佳实践</li>
<li><input disabled="" type="checkbox"/>
理解事件系统的完整流程</li>
<li><input disabled="" type="checkbox"/>
能够自定义事件和事件过滤器</li>
<li><input disabled="" type="checkbox"/>
掌握事件循环机制</li>
</ul>
<h3 id="多线程验证week-9-10"><a class="header" href="#多线程验证week-9-10">多线程验证（Week 9-10）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
掌握QThread的正确使用方式</li>
<li><input disabled="" type="checkbox"/>
理解线程间信号槽通信机制</li>
<li><input disabled="" type="checkbox"/>
熟练使用互斥锁、条件变量等同步原语</li>
<li><input disabled="" type="checkbox"/>
掌握QtConcurrent高级API</li>
<li><input disabled="" type="checkbox"/>
能够设计线程安全的类</li>
</ul>
<h3 id="网络与数据库验证week-11-12"><a class="header" href="#网络与数据库验证week-11-12">网络与数据库验证（Week 11-12）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
实现TCP服务器和客户端</li>
<li><input disabled="" type="checkbox"/>
掌握HTTP请求处理</li>
<li><input disabled="" type="checkbox"/>
熟练使用Qt SQL模块</li>
<li><input disabled="" type="checkbox"/>
理解数据库事务处理</li>
<li><input disabled="" type="checkbox"/>
掌握网络异步编程</li>
</ul>
<h3 id="综合项目验证week-13-14"><a class="header" href="#综合项目验证week-13-14">综合项目验证（Week 13-14）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
完成至少一个包含以下特性的项目：
<ul>
<li>多线程架构设计</li>
<li>网络通信功能</li>
<li>数据库持久化</li>
<li>自定义事件系统</li>
<li>插件化架构</li>
</ul>
</li>
</ul>
<hr />
<h2 id="常见陷阱与最佳实践"><a class="header" href="#常见陷阱与最佳实践">常见陷阱与最佳实践</a></h2>
<h3 id="1-信号槽连接陷阱"><a class="header" href="#1-信号槽连接陷阱">1. 信号槽连接陷阱</a></h3>
<pre><code class="language-cpp">// ❌ 错误：忘记Q_OBJECT宏
class MyClass : public QObject {
    // 缺少Q_OBJECT
signals:
    void mySignal();
};
// 编译错误：undefined reference to vtable

// ✅ 正确
class MyClass : public QObject {
    Q_OBJECT  // 必须添加
signals:
    void mySignal();
};
</code></pre>
<h3 id="2-线程使用陷阱"><a class="header" href="#2-线程使用陷阱">2. 线程使用陷阱</a></h3>
<pre><code class="language-cpp">// ❌ 错误：在非UI线程更新UI
void workerThread() {
    label-&gt;setText("Updated");  // 崩溃！
}

// ✅ 正确：使用信号槽
class Worker : public QObject {
    Q_OBJECT
signals:
    void updateText(QString text);
};
// 在主线程连接
connect(worker, &amp;Worker::updateText, label, &amp;QLabel::setText);
</code></pre>
<h3 id="3-内存管理陷阱"><a class="header" href="#3-内存管理陷阱">3. 内存管理陷阱</a></h3>
<pre><code class="language-cpp">// ❌ 错误：重复删除
QObject *obj = new QObject(parent);
delete obj;  // parent析构时会再次delete，double free！

// ✅ 正确：让父对象管理
QObject *obj = new QObject(parent);
// 不手动delete，或使用deleteLater()
</code></pre>
<hr />
<h2 id="推荐学习资源"><a class="header" href="#推荐学习资源">推荐学习资源</a></h2>
<h3 id="官方资源"><a class="header" href="#官方资源">官方资源</a></h3>
<ul>
<li>Qt官方文档: https://doc.qt.io/qt-5/</li>
<li>Qt源码: https://code.qt.io/cgit/qt/qtbase.git/</li>
<li>Qt示例代码: Qt Creator → Examples</li>
</ul>
<h3 id="深度学习"><a class="header" href="#深度学习">深度学习</a></h3>
<ol>
<li><strong>《C++ GUI Programming with Qt 5》</strong> - 官方教程</li>
<li><strong>《Advanced Qt Programming》</strong> - 高级主题</li>
<li><strong>《Qt5 Cadaques》</strong> - 在线免费教程</li>
</ol>
<h3 id="源码阅读建议"><a class="header" href="#源码阅读建议">源码阅读建议</a></h3>
<ol>
<li>从QObject开始，理解对象模型</li>
<li>研究信号槽的MOC生成代码</li>
<li>阅读QThread和QEventLoop实现</li>
<li>学习Qt容器类的实现技巧</li>
</ol>
<hr />
<p><strong>核心学习建议</strong>:</p>
<ol>
<li>重点理解Qt的元对象系统，这是Qt的灵魂</li>
<li>深入研究信号槽机制的实现原理</li>
<li>掌握Qt的内存管理和对象生命周期</li>
<li>重视多线程编程的正确使用方式</li>
<li>阅读Qt源码，学习优秀的C++编程实践</li>
<li>多做实战项目，理论结合实践</li>
</ol>
<hr />
<h2 id="附录qt-515新特性"><a class="header" href="#附录qt-515新特性">附录：Qt 5.15新特性</a></h2>
<h3 id="qt-515重要改进"><a class="header" href="#qt-515重要改进">Qt 5.15重要改进</a></h3>
<ol>
<li><strong>CMake构建系统成为默认</strong></li>
<li><strong>QCalendar API改进</strong></li>
<li><strong>QColorSpace支持</strong></li>
<li><strong>改进的正则表达式引擎（QRegularExpression）</strong></li>
<li><strong>更好的HiDPI支持</strong></li>
</ol>
<h3 id="qt-515性能优化技巧"><a class="header" href="#qt-515性能优化技巧">Qt 5.15性能优化技巧</a></h3>
<pre><code class="language-cpp">// 1. 使用QStringLiteral避免动态分配
QString s1 = "Hello";  // 运行时分配
QString s2 = QStringLiteral("Hello");  // 编译期常量

// 2. 使用reserve()预分配容器内存
QList&lt;int&gt; list;
list.reserve(1000);  // 避免多次重新分配

// 3. 使用move语义
QString createString() {
    QString s = "Large string data...";
    return s;  // 自动move，无拷贝
}

// 4. 避免隐式共享的分离
const QString &amp;getString();  // 返回const引用避免分离
</code></pre>
<p>本笔记将持续更新，欢迎反馈和建议！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/language/01-C++.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/language/10-flet.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/language/01-C++.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/language/10-flet.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

