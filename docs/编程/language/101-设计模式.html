<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>设计模式完整学习笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="设计模式完整学习笔记"><a class="header" href="#设计模式完整学习笔记">设计模式完整学习笔记</a></h1>
<h2 id="学习目标定位"><a class="header" href="#学习目标定位">学习目标定位</a></h2>
<ul>
<li><strong>目标群体</strong>: 有面向对象编程基础的开发者</li>
<li><strong>学习周期</strong>: 6-8周</li>
<li><strong>前置要求</strong>: 熟悉Python或Java等面向对象语言</li>
<li><strong>学习成果</strong>: 掌握23种经典设计模式，能在实际项目中灵活应用</li>
</ul>
<h2 id="学习路径"><a class="header" href="#学习路径">学习路径</a></h2>
<pre><code>设计原则(Week 1) → 创建型模式(Week 2-3) → 结构型模式(Week 4-5)
→ 行为型模式(Week 6-7) → 实战项目(Week 8)
</code></pre>
<hr />
<h2 id="第一模块设计模式基础"><a class="header" href="#第一模块设计模式基础">第一模块：设计模式基础</a></h2>
<h3 id="11-什么是设计模式"><a class="header" href="#11-什么是设计模式">1.1 什么是设计模式</a></h3>
<p><strong>定义</strong>：</p>
<ul>
<li>在软件设计中针对特定问题的经典解决方案</li>
<li>可复用的代码结构和设计思想</li>
<li>前人经验的总结和提炼</li>
</ul>
<p><strong>设计模式的三要素</strong>：</p>
<ol>
<li><strong>问题</strong>：在什么情况下使用这个模式</li>
<li><strong>解决方案</strong>：模式的组成部分、结构和协作方式</li>
<li><strong>效果</strong>：使用模式的优缺点和权衡</li>
</ol>
<p><strong>GOF 23种设计模式分类</strong>：</p>
<pre><code>创建型模式（5种）
├─ 单例模式（Singleton）
├─ 工厂方法（Factory Method）
├─ 抽象工厂（Abstract Factory）
├─ 建造者模式（Builder）
└─ 原型模式（Prototype）

结构型模式（7种）
├─ 适配器模式（Adapter）
├─ 桥接模式（Bridge）
├─ 组合模式（Composite）
├─ 装饰器模式（Decorator）
├─ 外观模式（Facade）
├─ 享元模式（Flyweight）
└─ 代理模式（Proxy）

行为型模式（11种）
├─ 责任链模式（Chain of Responsibility）
├─ 命令模式（Command）
├─ 解释器模式（Interpreter）
├─ 迭代器模式（Iterator）
├─ 中介者模式（Mediator）
├─ 备忘录模式（Memento）
├─ 观察者模式（Observer）
├─ 状态模式（State）
├─ 策略模式（Strategy）
├─ 模板方法（Template Method）
└─ 访问者模式（Visitor）
</code></pre>
<h3 id="12-solid设计原则"><a class="header" href="#12-solid设计原则">1.2 SOLID设计原则</a></h3>
<h4 id="单一职责原则srp"><a class="header" href="#单一职责原则srp">单一职责原则（SRP）</a></h4>
<p><strong>定义</strong>：一个类应该只有一个引起它变化的原因</p>
<pre><code class="language-python"># ❌ 违反SRP：一个类负责多个职责
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def save_to_database(self):
        # 数据库操作
        pass

    def send_email(self):
        # 邮件发送
        pass

# ✅ 遵循SRP：职责分离
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user):
        # 数据库操作
        pass

class EmailService:
    def send(self, email, message):
        # 邮件发送
        pass
</code></pre>
<h4 id="开闭原则ocp"><a class="header" href="#开闭原则ocp">开闭原则（OCP）</a></h4>
<p><strong>定义</strong>：软件实体应该对扩展开放，对修改关闭</p>
<pre><code class="language-python"># ❌ 违反OCP：每次新增形状都要修改
class AreaCalculator:
    def calculate(self, shapes):
        total = 0
        for shape in shapes:
            if isinstance(shape, Circle):
                total += 3.14 * shape.radius ** 2
            elif isinstance(shape, Rectangle):
                total += shape.width * shape.height
        return total

# ✅ 遵循OCP：使用多态
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class AreaCalculator:
    def calculate(self, shapes):
        return sum(shape.area() for shape in shapes)
</code></pre>
<h4 id="里氏替换原则lsp"><a class="header" href="#里氏替换原则lsp">里氏替换原则（LSP）</a></h4>
<p><strong>定义</strong>：子类必须能够替换其基类</p>
<pre><code class="language-python"># ❌ 违反LSP：正方形不能完全替代矩形
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def set_width(self, width):
        self.width = width

    def set_height(self, height):
        self.height = height

    def area(self):
        return self.width * self.height

class Square(Rectangle):
    def set_width(self, width):
        self.width = width
        self.height = width  # 强制宽高一致

    def set_height(self, height):
        self.width = height
        self.height = height

# ✅ 遵循LSP：分离接口
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side ** 2
</code></pre>
<h4 id="接口隔离原则isp"><a class="header" href="#接口隔离原则isp">接口隔离原则（ISP）</a></h4>
<p><strong>定义</strong>：不应该强迫客户依赖它们不使用的方法</p>
<pre><code class="language-python"># ❌ 违反ISP：接口过于庞大
from abc import ABC, abstractmethod

class Worker(ABC):
    @abstractmethod
    def work(self):
        pass

    @abstractmethod
    def eat(self):
        pass

class HumanWorker(Worker):
    def work(self):
        print("工作中...")

    def eat(self):
        print("吃饭中...")

class RobotWorker(Worker):
    def work(self):
        print("工作中...")

    def eat(self):
        pass  # 机器人不需要吃饭

# ✅ 遵循ISP：接口细分
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class HumanWorker(Workable, Eatable):
    def work(self):
        print("工作中...")

    def eat(self):
        print("吃饭中...")

class RobotWorker(Workable):
    def work(self):
        print("工作中...")
</code></pre>
<h4 id="依赖倒置原则dip"><a class="header" href="#依赖倒置原则dip">依赖倒置原则（DIP）</a></h4>
<p><strong>定义</strong>：高层模块不应该依赖低层模块，两者都应该依赖抽象</p>
<pre><code class="language-python"># ❌ 违反DIP：高层模块直接依赖低层模块
class MySQLDatabase:
    def save(self, data):
        print("保存到MySQL")

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # 紧耦合

    def create_user(self, user):
        self.db.save(user)

# ✅ 遵循DIP：依赖抽象
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        print("保存到MySQL")

class MongoDatabase(Database):
    def save(self, data):
        print("保存到MongoDB")

class UserService:
    def __init__(self, database: Database):
        self.db = database  # 依赖抽象

    def create_user(self, user):
        self.db.save(user)

# 使用
mysql_db = MySQLDatabase()
user_service = UserService(mysql_db)
</code></pre>
<hr />
<h2 id="第二模块创建型模式"><a class="header" href="#第二模块创建型模式">第二模块：创建型模式</a></h2>
<h3 id="21-单例模式singleton"><a class="header" href="#21-单例模式singleton">2.1 单例模式（Singleton）</a></h3>
<h4 id="模式意图"><a class="header" href="#模式意图">模式意图</a></h4>
<p>确保一个类只有一个实例，并提供全局访问点。</p>
<h4 id="适用场景"><a class="header" href="#适用场景">适用场景</a></h4>
<ul>
<li>需要全局唯一的配置对象</li>
<li>数据库连接池</li>
<li>日志记录器</li>
<li>线程池</li>
</ul>
<h4 id="python实现方式"><a class="header" href="#python实现方式">Python实现方式</a></h4>
<p><strong>方法1：使用<code>__new__</code>方法</strong></p>
<pre><code class="language-python">class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        self.value = None

# 测试
s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True

s1.value = 100
print(s2.value)  # 100
</code></pre>
<p><strong>方法2：装饰器实现</strong></p>
<pre><code class="language-python">def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class DatabaseConnection:
    def __init__(self):
        self.connection = "Connected"

# 测试
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(db1 is db2)  # True
</code></pre>
<p><strong>方法3：元类实现（最Pythonic）</strong></p>
<pre><code class="language-python">class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Logger(metaclass=SingletonMeta):
    def __init__(self):
        self.logs = []

    def log(self, message):
        self.logs.append(message)
        print(f"[LOG] {message}")

# 测试
logger1 = Logger()
logger2 = Logger()
print(logger1 is logger2)  # True

logger1.log("系统启动")
logger2.log("用户登录")
print(logger1.logs)  # ['系统启动', '用户登录']
</code></pre>
<p><strong>方法4：模块级单例（推荐）</strong></p>
<pre><code class="language-python"># config.py
class Config:
    def __init__(self):
        self.database_url = "localhost:5432"
        self.debug = True

config = Config()  # 模块级单例

# 使用
from config import config
print(config.database_url)
</code></pre>
<h4 id="线程安全的单例"><a class="header" href="#线程安全的单例">线程安全的单例</a></h4>
<pre><code class="language-python">import threading

class ThreadSafeSingleton:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            with cls._lock:
                # 双重检查锁定
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
</code></pre>
<h3 id="22-工厂方法模式factory-method"><a class="header" href="#22-工厂方法模式factory-method">2.2 工厂方法模式（Factory Method）</a></h3>
<h4 id="模式意图-1"><a class="header" href="#模式意图-1">模式意图</a></h4>
<p>定义创建对象的接口，让子类决定实例化哪个类。</p>
<h4 id="适用场景-1"><a class="header" href="#适用场景-1">适用场景</a></h4>
<ul>
<li>不知道确切需要创建哪个类的实例</li>
<li>希望子类指定创建对象</li>
<li>将创建逻辑委托给子类</li>
</ul>
<h4 id="python实现"><a class="header" href="#python实现">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 产品接口
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

# 具体产品
class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class Cow(Animal):
    def speak(self):
        return "Moo!"

# 工厂接口
class AnimalFactory(ABC):
    @abstractmethod
    def create_animal(self) -&gt; Animal:
        pass

    def interact(self):
        animal = self.create_animal()
        print(f"Animal says: {animal.speak()}")

# 具体工厂
class DogFactory(AnimalFactory):
    def create_animal(self):
        return Dog()

class CatFactory(AnimalFactory):
    def create_animal(self):
        return Cat()

# 使用
def client_code(factory: AnimalFactory):
    factory.interact()

print("Using Dog Factory:")
client_code(DogFactory())

print("\nUsing Cat Factory:")
client_code(CatFactory())
</code></pre>
<h4 id="简化版工厂静态工厂方法"><a class="header" href="#简化版工厂静态工厂方法">简化版工厂（静态工厂方法）</a></h4>
<pre><code class="language-python">class ShapeFactory:
    @staticmethod
    def create_shape(shape_type):
        shapes = {
            'circle': Circle,
            'rectangle': Rectangle,
            'triangle': Triangle
        }

        shape_class = shapes.get(shape_type.lower())
        if shape_class:
            return shape_class()
        raise ValueError(f"Unknown shape: {shape_type}")

# 使用
shape = ShapeFactory.create_shape('circle')
</code></pre>
<h3 id="23-抽象工厂模式abstract-factory"><a class="header" href="#23-抽象工厂模式abstract-factory">2.3 抽象工厂模式（Abstract Factory）</a></h3>
<h4 id="模式意图-2"><a class="header" href="#模式意图-2">模式意图</a></h4>
<p>提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。</p>
<h4 id="适用场景-2"><a class="header" href="#适用场景-2">适用场景</a></h4>
<ul>
<li>需要创建一系列相关对象</li>
<li>系统需要独立于产品创建、组合和表示</li>
<li>强调产品家族的一致性</li>
</ul>
<h4 id="python实现-1"><a class="header" href="#python实现-1">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 抽象产品：按钮
class Button(ABC):
    @abstractmethod
    def render(self):
        pass

# 抽象产品：输入框
class Input(ABC):
    @abstractmethod
    def render(self):
        pass

# 具体产品：Windows风格
class WindowsButton(Button):
    def render(self):
        return "Rendering Windows Button"

class WindowsInput(Input):
    def render(self):
        return "Rendering Windows Input"

# 具体产品：Mac风格
class MacButton(Button):
    def render(self):
        return "Rendering Mac Button"

class MacInput(Input):
    def render(self):
        return "Rendering Mac Input"

# 抽象工厂
class GUIFactory(ABC):
    @abstractmethod
    def create_button(self) -&gt; Button:
        pass

    @abstractmethod
    def create_input(self) -&gt; Input:
        pass

# 具体工厂
class WindowsFactory(GUIFactory):
    def create_button(self):
        return WindowsButton()

    def create_input(self):
        return WindowsInput()

class MacFactory(GUIFactory):
    def create_button(self):
        return MacButton()

    def create_input(self):
        return MacInput()

# 客户端代码
def create_ui(factory: GUIFactory):
    button = factory.create_button()
    input_field = factory.create_input()

    print(button.render())
    print(input_field.render())

# 使用
import platform

if platform.system() == "Windows":
    factory = WindowsFactory()
else:
    factory = MacFactory()

create_ui(factory)
</code></pre>
<h3 id="24-建造者模式builder"><a class="header" href="#24-建造者模式builder">2.4 建造者模式（Builder）</a></h3>
<h4 id="模式意图-3"><a class="header" href="#模式意图-3">模式意图</a></h4>
<p>将复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h4 id="适用场景-3"><a class="header" href="#适用场景-3">适用场景</a></h4>
<ul>
<li>需要创建复杂对象（多个步骤、多个参数）</li>
<li>希望构建过程独立于组成部分</li>
<li>需要生成不同表示的产品</li>
</ul>
<h4 id="python实现-2"><a class="header" href="#python实现-2">Python实现</a></h4>
<pre><code class="language-python"># 产品
class Computer:
    def __init__(self):
        self.cpu = None
        self.memory = None
        self.storage = None
        self.gpu = None

    def __str__(self):
        return f"""Computer Configuration:
- CPU: {self.cpu}
- Memory: {self.memory}
- Storage: {self.storage}
- GPU: {self.gpu}"""

# 建造者接口
from abc import ABC, abstractmethod

class ComputerBuilder(ABC):
    def __init__(self):
        self.computer = Computer()

    @abstractmethod
    def build_cpu(self):
        pass

    @abstractmethod
    def build_memory(self):
        pass

    @abstractmethod
    def build_storage(self):
        pass

    @abstractmethod
    def build_gpu(self):
        pass

    def get_computer(self):
        return self.computer

# 具体建造者：游戏电脑
class GamingComputerBuilder(ComputerBuilder):
    def build_cpu(self):
        self.computer.cpu = "Intel i9-13900K"
        return self

    def build_memory(self):
        self.computer.memory = "32GB DDR5"
        return self

    def build_storage(self):
        self.computer.storage = "2TB NVMe SSD"
        return self

    def build_gpu(self):
        self.computer.gpu = "NVIDIA RTX 4090"
        return self

# 具体建造者：办公电脑
class OfficeComputerBuilder(ComputerBuilder):
    def build_cpu(self):
        self.computer.cpu = "Intel i5-12400"
        return self

    def build_memory(self):
        self.computer.memory = "16GB DDR4"
        return self

    def build_storage(self):
        self.computer.storage = "512GB SSD"
        return self

    def build_gpu(self):
        self.computer.gpu = "Integrated Graphics"
        return self

# 指挥者（可选）
class ComputerDirector:
    def __init__(self, builder: ComputerBuilder):
        self.builder = builder

    def construct(self):
        return (self.builder
                .build_cpu()
                .build_memory()
                .build_storage()
                .build_gpu()
                .get_computer())

# 使用示例1：使用指挥者
director = ComputerDirector(GamingComputerBuilder())
gaming_pc = director.construct()
print(gaming_pc)

# 使用示例2：链式调用（更Pythonic）
office_pc = (OfficeComputerBuilder()
             .build_cpu()
             .build_memory()
             .build_storage()
             .build_gpu()
             .get_computer())
print(office_pc)
</code></pre>
<h3 id="25-原型模式prototype"><a class="header" href="#25-原型模式prototype">2.5 原型模式（Prototype）</a></h3>
<h4 id="模式意图-4"><a class="header" href="#模式意图-4">模式意图</a></h4>
<p>通过复制现有实例来创建新对象，而不是通过new关键字。</p>
<h4 id="适用场景-4"><a class="header" href="#适用场景-4">适用场景</a></h4>
<ul>
<li>创建对象成本较大</li>
<li>需要避免创建与产品类层次平行的工厂类</li>
<li>对象的类在运行时确定</li>
</ul>
<h4 id="python实现-3"><a class="header" href="#python实现-3">Python实现</a></h4>
<pre><code class="language-python">import copy
from abc import ABC, abstractmethod

class Prototype(ABC):
    @abstractmethod
    def clone(self):
        pass

class Person(Prototype):
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address  # 假设address是可变对象

    def clone(self):
        # 浅拷贝
        return copy.copy(self)

    def deep_clone(self):
        # 深拷贝
        return copy.deepcopy(self)

    def __str__(self):
        return f"Person(name={self.name}, age={self.age}, address={self.address})"

# 使用
original = Person("Alice", 25, {"city": "Beijing", "street": "Main St"})
print(f"Original: {original}")

# 浅拷贝
shallow_copy = original.clone()
shallow_copy.name = "Bob"
shallow_copy.address["city"] = "Shanghai"  # 会影响原对象
print(f"Original after shallow copy: {original}")
print(f"Shallow copy: {shallow_copy}")

# 深拷贝
deep_copy = original.deep_clone()
deep_copy.name = "Charlie"
deep_copy.address["city"] = "Guangzhou"  # 不影响原对象
print(f"Original after deep copy: {original}")
print(f"Deep copy: {deep_copy}")
</code></pre>
<h4 id="原型管理器"><a class="header" href="#原型管理器">原型管理器</a></h4>
<pre><code class="language-python">class PrototypeManager:
    def __init__(self):
        self._prototypes = {}

    def register(self, name, prototype):
        self._prototypes[name] = prototype

    def unregister(self, name):
        del self._prototypes[name]

    def clone(self, name):
        prototype = self._prototypes.get(name)
        if prototype:
            return copy.deepcopy(prototype)
        raise ValueError(f"Prototype '{name}' not found")

# 使用
manager = PrototypeManager()
manager.register("default_person", Person("Default", 20, {"city": "Beijing"}))

# 克隆并修改
person1 = manager.clone("default_person")
person1.name = "Alice"

person2 = manager.clone("default_person")
person2.name = "Bob"
</code></pre>
<hr />
<h2 id="第三模块结构型模式"><a class="header" href="#第三模块结构型模式">第三模块：结构型模式</a></h2>
<h3 id="31-适配器模式adapter"><a class="header" href="#31-适配器模式adapter">3.1 适配器模式（Adapter）</a></h3>
<h4 id="模式意图-5"><a class="header" href="#模式意图-5">模式意图</a></h4>
<p>将一个类的接口转换为客户期望的另一个接口，使原本不兼容的类可以一起工作。</p>
<h4 id="适用场景-5"><a class="header" href="#适用场景-5">适用场景</a></h4>
<ul>
<li>想使用现有类，但接口不符合需求</li>
<li>创建可复用的类，与不相关的类协作</li>
<li>需要使用多个子类，但不能逐个适配接口</li>
</ul>
<h4 id="python实现-4"><a class="header" href="#python实现-4">Python实现</a></h4>
<p><strong>类适配器（使用继承）</strong></p>
<pre><code class="language-python"># 目标接口
class Target:
    def request(self):
        return "Target: Default behavior"

# 需要适配的类
class Adaptee:
    def specific_request(self):
        return "Adaptee: Specific behavior"

# 类适配器
class Adapter(Target, Adaptee):
    def request(self):
        return f"Adapter: {self.specific_request()}"

# 使用
def client_code(target: Target):
    print(target.request())

print("Client can work with Target objects:")
target = Target()
client_code(target)

print("\nAdaptee has incompatible interface:")
adaptee = Adaptee()
print(f"Adaptee: {adaptee.specific_request()}")

print("\nAdapter makes Adaptee compatible:")
adapter = Adapter()
client_code(adapter)
</code></pre>
<p><strong>对象适配器（使用组合，推荐）</strong></p>
<pre><code class="language-python">class ObjectAdapter(Target):
    def __init__(self, adaptee: Adaptee):
        self.adaptee = adaptee

    def request(self):
        return f"Adapter: {self.adaptee.specific_request()}"

# 使用
adaptee = Adaptee()
adapter = ObjectAdapter(adaptee)
client_code(adapter)
</code></pre>
<h4 id="实际应用数据库适配器"><a class="header" href="#实际应用数据库适配器">实际应用：数据库适配器</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 统一数据库接口
class Database(ABC):
    @abstractmethod
    def connect(self):
        pass

    @abstractmethod
    def query(self, sql):
        pass

# MySQL原始实现
class MySQLDatabase:
    def mysql_connect(self, host, user, password):
        return f"MySQL connected to {host}"

    def execute_sql(self, sql):
        return f"MySQL executed: {sql}"

# PostgreSQL原始实现
class PostgreSQLDatabase:
    def pg_connect(self, connection_string):
        return f"PostgreSQL connected: {connection_string}"

    def run_query(self, query):
        return f"PostgreSQL executed: {query}"

# MySQL适配器
class MySQLAdapter(Database):
    def __init__(self, mysql_db: MySQLDatabase):
        self.mysql_db = mysql_db

    def connect(self):
        return self.mysql_db.mysql_connect("localhost", "root", "password")

    def query(self, sql):
        return self.mysql_db.execute_sql(sql)

# PostgreSQL适配器
class PostgreSQLAdapter(Database):
    def __init__(self, pg_db: PostgreSQLDatabase):
        self.pg_db = pg_db

    def connect(self):
        return self.pg_db.pg_connect("postgresql://localhost:5432")

    def query(self, sql):
        return self.pg_db.run_query(sql)

# 使用统一接口
def database_operations(db: Database):
    print(db.connect())
    print(db.query("SELECT * FROM users"))

# 测试
mysql = MySQLAdapter(MySQLDatabase())
postgres = PostgreSQLAdapter(PostgreSQLDatabase())

database_operations(mysql)
database_operations(postgres)
</code></pre>
<h3 id="32-装饰器模式decorator"><a class="header" href="#32-装饰器模式decorator">3.2 装饰器模式（Decorator）</a></h3>
<h4 id="模式意图-6"><a class="header" href="#模式意图-6">模式意图</a></h4>
<p>动态地给对象添加额外的职责，而不改变其结构。</p>
<h4 id="适用场景-6"><a class="header" href="#适用场景-6">适用场景</a></h4>
<ul>
<li>需要动态、透明地给对象添加职责</li>
<li>职责可以撤销</li>
<li>不能使用子类扩展（类定义被隐藏或不能生成子类）</li>
</ul>
<h4 id="python实现-5"><a class="header" href="#python实现-5">Python实现</a></h4>
<p><strong>基础装饰器模式</strong></p>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    @abstractmethod
    def operation(self) -&gt; str:
        pass

# 具体组件
class ConcreteComponent(Component):
    def operation(self):
        return "ConcreteComponent"

# 装饰器基类
class Decorator(Component):
    def __init__(self, component: Component):
        self._component = component

    def operation(self):
        return self._component.operation()

# 具体装饰器A
class ConcreteDecoratorA(Decorator):
    def operation(self):
        return f"ConcreteDecoratorA({self._component.operation()})"

# 具体装饰器B
class ConcreteDecoratorB(Decorator):
    def operation(self):
        return f"ConcreteDecoratorB({self._component.operation()})"

# 使用
component = ConcreteComponent()
print(f"Client: {component.operation()}")

decorator1 = ConcreteDecoratorA(component)
print(f"Client: {decorator1.operation()}")

decorator2 = ConcreteDecoratorB(decorator1)
print(f"Client: {decorator2.operation()}")
</code></pre>
<h4 id="python装饰器语法实现"><a class="header" href="#python装饰器语法实现">Python装饰器语法实现</a></h4>
<pre><code class="language-python">from functools import wraps
import time

# 计时装饰器
def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f}s")
        return result
    return wrapper

# 日志装饰器
def logger(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper

# 缓存装饰器
def memoize(func):
    cache = {}

    @wraps(func)
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

# 使用多个装饰器
@timer
@logger
@memoize
def fibonacci(n):
    if n &lt; 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 测试
print(fibonacci(10))
</code></pre>
<h4 id="实际应用web路由装饰器"><a class="header" href="#实际应用web路由装饰器">实际应用：Web路由装饰器</a></h4>
<pre><code class="language-python">class WebApp:
    def __init__(self):
        self.routes = {}

    def route(self, path):
        def decorator(func):
            self.routes[path] = func
            return func
        return decorator

    def handle_request(self, path):
        handler = self.routes.get(path)
        if handler:
            return handler()
        return "404 Not Found"

app = WebApp()

@app.route("/")
def home():
    return "Home Page"

@app.route("/about")
def about():
    return "About Page"

# 测试
print(app.handle_request("/"))      # Home Page
print(app.handle_request("/about"))  # About Page
print(app.handle_request("/404"))    # 404 Not Found
</code></pre>
<h3 id="33-外观模式facade"><a class="header" href="#33-外观模式facade">3.3 外观模式（Facade）</a></h3>
<h4 id="模式意图-7"><a class="header" href="#模式意图-7">模式意图</a></h4>
<p>为子系统中的一组接口提供统一的高层接口，使子系统更易用。</p>
<h4 id="适用场景-7"><a class="header" href="#适用场景-7">适用场景</a></h4>
<ul>
<li>需要为复杂子系统提供简单接口</li>
<li>客户程序与抽象类的实现部分之间存在很大依赖性</li>
<li>需要构建分层系统</li>
</ul>
<h4 id="python实现-6"><a class="header" href="#python实现-6">Python实现</a></h4>
<pre><code class="language-python"># 子系统类
class CPU:
    def freeze(self):
        print("CPU: Freezing processor")

    def jump(self, position):
        print(f"CPU: Jumping to position {position}")

    def execute(self):
        print("CPU: Executing instructions")

class Memory:
    def load(self, position, data):
        print(f"Memory: Loading data '{data}' at position {position}")

class HardDrive:
    def read(self, lba, size):
        return f"Data from sector {lba}, size {size}"

# 外观类
class ComputerFacade:
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.hard_drive = HardDrive()

    def start(self):
        """简化的启动过程"""
        print("Starting computer...")
        self.cpu.freeze()

        # 从硬盘读取启动扇区
        boot_data = self.hard_drive.read(lba=0, size=1024)
        self.memory.load(position=0, data=boot_data)

        self.cpu.jump(position=0)
        self.cpu.execute()
        print("Computer started!\n")

# 客户端代码
computer = ComputerFacade()
computer.start()  # 一行代码完成复杂启动过程
</code></pre>
<h4 id="实际应用多媒体转换外观"><a class="header" href="#实际应用多媒体转换外观">实际应用：多媒体转换外观</a></h4>
<pre><code class="language-python">class VideoFile:
    def __init__(self, filename):
        self.filename = filename

    def decode(self):
        return f"Decoded video: {self.filename}"

class AudioMixer:
    def mix(self, audio_data):
        return f"Mixed audio: {audio_data}"

class BitrateReader:
    def read(self, file):
        return f"Bitrate data from {file}"

class VideoConverter:
    def convert(self, filename):
        return f"Converted: {filename}"

# 外观
class MediaConversionFacade:
    def __init__(self):
        self.video_file = None
        self.audio_mixer = AudioMixer()
        self.bitrate_reader = BitrateReader()
        self.converter = VideoConverter()

    def convert_video(self, input_file, output_format):
        """简化的视频转换流程"""
        print(f"Converting {input_file} to {output_format}...")

        # 复杂的内部处理
        self.video_file = VideoFile(input_file)
        decoded = self.video_file.decode()

        bitrate = self.bitrate_reader.read(input_file)
        audio = self.audio_mixer.mix(decoded)

        result = self.converter.convert(input_file)

        print(f"Conversion complete: {result}\n")
        return result

# 使用
facade = MediaConversionFacade()
facade.convert_video("movie.mp4", "avi")
</code></pre>
<h3 id="34-代理模式proxy"><a class="header" href="#34-代理模式proxy">3.4 代理模式（Proxy）</a></h3>
<h4 id="模式意图-8"><a class="header" href="#模式意图-8">模式意图</a></h4>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<h4 id="适用场景-8"><a class="header" href="#适用场景-8">适用场景</a></h4>
<ul>
<li><strong>远程代理</strong>：为远程对象提供本地代表</li>
<li><strong>虚拟代理</strong>：延迟创建开销大的对象</li>
<li><strong>保护代理</strong>：控制对原对象的访问权限</li>
<li><strong>智能引用</strong>：在访问对象时执行额外操作</li>
</ul>
<h4 id="python实现-7"><a class="header" href="#python实现-7">Python实现</a></h4>
<p><strong>虚拟代理（延迟加载）</strong></p>
<pre><code class="language-python">from abc import ABC, abstractmethod

class Image(ABC):
    @abstractmethod
    def display(self):
        pass

class RealImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self.load_from_disk()

    def load_from_disk(self):
        print(f"Loading image: {self.filename}")

    def display(self):
        print(f"Displaying image: {self.filename}")

class ProxyImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self.real_image = None

    def display(self):
        if self.real_image is None:
            self.real_image = RealImage(self.filename)
        self.real_image.display()

# 使用
print("Creating proxy...")
image = ProxyImage("photo.jpg")

print("\nFirst display (loads image):")
image.display()

print("\nSecond display (uses cached image):")
image.display()
</code></pre>
<p><strong>保护代理（权限控制）</strong></p>
<pre><code class="language-python">from abc import ABC, abstractmethod

class Subject(ABC):
    @abstractmethod
    def request(self):
        pass

class RealSubject(Subject):
    def request(self):
        return "RealSubject: Handling request"

class ProtectionProxy(Subject):
    def __init__(self, real_subject: RealSubject, access_level):
        self.real_subject = real_subject
        self.access_level = access_level

    def check_access(self):
        return self.access_level &gt;= 5

    def request(self):
        if self.check_access():
            return self.real_subject.request()
        return "Access Denied: Insufficient permissions"

# 使用
real_subject = RealSubject()

print("With high access level:")
proxy_allowed = ProtectionProxy(real_subject, access_level=10)
print(proxy_allowed.request())

print("\nWith low access level:")
proxy_denied = ProtectionProxy(real_subject, access_level=1)
print(proxy_denied.request())
</code></pre>
<p><strong>智能引用代理（引用计数）</strong></p>
<pre><code class="language-python">class RealObject:
    def operation(self):
        return "Performing operation"

class SmartProxy:
    _ref_count = 0

    def __init__(self, real_object):
        self.real_object = real_object
        SmartProxy._ref_count += 1
        print(f"Proxy created. Reference count: {SmartProxy._ref_count}")

    def __del__(self):
        SmartProxy._ref_count -= 1
        print(f"Proxy destroyed. Reference count: {SmartProxy._ref_count}")

    def operation(self):
        return self.real_object.operation()

# 使用
real_obj = RealObject()
proxy1 = SmartProxy(real_obj)
proxy2 = SmartProxy(real_obj)

print(proxy1.operation())
del proxy1
del proxy2
</code></pre>
<h3 id="35-组合模式composite"><a class="header" href="#35-组合模式composite">3.5 组合模式（Composite）</a></h3>
<h4 id="模式意图-9"><a class="header" href="#模式意图-9">模式意图</a></h4>
<p>将对象组合成树形结构以表示"部分-整体"的层次结构，使客户对单个对象和组合对象的使用具有一致性。</p>
<h4 id="适用场景-9"><a class="header" href="#适用场景-9">适用场景</a></h4>
<ul>
<li>表示对象的部分-整体层次结构</li>
<li>希望客户忽略组合对象与单个对象的差异</li>
<li>需要统一处理集合中的所有对象</li>
</ul>
<h4 id="python实现-8"><a class="header" href="#python实现-8">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    def __init__(self, name):
        self.name = name

    @abstractmethod
    def operation(self, indent=0):
        pass

    def add(self, component):
        pass

    def remove(self, component):
        pass

# 叶子节点
class Leaf(Component):
    def operation(self, indent=0):
        print("  " * indent + f"Leaf: {self.name}")

# 组合节点
class Composite(Component):
    def __init__(self, name):
        super().__init__(name)
        self.children = []

    def add(self, component):
        self.children.append(component)

    def remove(self, component):
        self.children.remove(component)

    def operation(self, indent=0):
        print("  " * indent + f"Composite: {self.name}")
        for child in self.children:
            child.operation(indent + 1)

# 使用：构建文件系统树
root = Composite("root")

home = Composite("home")
root.add(home)

user1 = Composite("user1")
home.add(user1)

user1.add(Leaf("file1.txt"))
user1.add(Leaf("file2.txt"))

documents = Composite("documents")
user1.add(documents)
documents.add(Leaf("report.pdf"))

etc = Composite("etc")
root.add(etc)
etc.add(Leaf("config.conf"))

# 统一处理
root.operation()
</code></pre>
<h4 id="实际应用ui组件树"><a class="header" href="#实际应用ui组件树">实际应用：UI组件树</a></h4>
<pre><code class="language-python">class UIComponent(ABC):
    def __init__(self, name):
        self.name = name

    @abstractmethod
    def render(self, indent=0):
        pass

class Button(UIComponent):
    def render(self, indent=0):
        print("  " * indent + f"&lt;Button&gt;{self.name}&lt;/Button&gt;")

class TextInput(UIComponent):
    def render(self, indent=0):
        print("  " * indent + f"&lt;Input&gt;{self.name}&lt;/Input&gt;")

class Container(UIComponent):
    def __init__(self, name):
        super().__init__(name)
        self.children = []

    def add(self, component):
        self.children.append(component)

    def render(self, indent=0):
        print("  " * indent + f"&lt;Container name='{self.name}'&gt;")
        for child in self.children:
            child.render(indent + 1)
        print("  " * indent + "&lt;/Container&gt;")

# 构建UI
window = Container("MainWindow")

header = Container("Header")
header.add(Button("Logo"))
header.add(Button("Menu"))
window.add(header)

content = Container("Content")
content.add(TextInput("Username"))
content.add(TextInput("Password"))
content.add(Button("Login"))
window.add(content)

window.render()
</code></pre>
<h3 id="36-桥接模式bridge"><a class="header" href="#36-桥接模式bridge">3.6 桥接模式（Bridge）</a></h3>
<h4 id="模式意图-10"><a class="header" href="#模式意图-10">模式意图</a></h4>
<p>将抽象部分与实现部分分离，使它们都可以独立变化。</p>
<h4 id="适用场景-10"><a class="header" href="#适用场景-10">适用场景</a></h4>
<ul>
<li>不希望抽象和实现之间有固定的绑定关系</li>
<li>抽象和实现都应该可以通过子类扩展</li>
<li>对抽象的实现修改不应影响客户代码</li>
</ul>
<h4 id="python实现-9"><a class="header" href="#python实现-9">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 实现接口
class DrawingAPI(ABC):
    @abstractmethod
    def draw_circle(self, x, y, radius):
        pass

# 具体实现A
class DrawingAPI1(DrawingAPI):
    def draw_circle(self, x, y, radius):
        print(f"API1: Drawing circle at ({x}, {y}) with radius {radius}")

# 具体实现B
class DrawingAPI2(DrawingAPI):
    def draw_circle(self, x, y, radius):
        print(f"API2: Drawing circle at ({x}, {y}) with radius {radius}")

# 抽象部分
class Shape(ABC):
    def __init__(self, drawing_api: DrawingAPI):
        self.drawing_api = drawing_api

    @abstractmethod
    def draw(self):
        pass

# 扩展抽象部分
class Circle(Shape):
    def __init__(self, x, y, radius, drawing_api: DrawingAPI):
        super().__init__(drawing_api)
        self.x = x
        self.y = y
        self.radius = radius

    def draw(self):
        self.drawing_api.draw_circle(self.x, self.y, self.radius)

# 使用
shapes = [
    Circle(1, 2, 3, DrawingAPI1()),
    Circle(5, 7, 11, DrawingAPI2())
]

for shape in shapes:
    shape.draw()
</code></pre>
<h4 id="实际应用跨平台消息发送"><a class="header" href="#实际应用跨平台消息发送">实际应用：跨平台消息发送</a></h4>
<pre><code class="language-python"># 实现接口：消息发送方式
class MessageSender(ABC):
    @abstractmethod
    def send(self, message):
        pass

class EmailSender(MessageSender):
    def send(self, message):
        print(f"Sending via Email: {message}")

class SMSSender(MessageSender):
    def send(self, message):
        print(f"Sending via SMS: {message}")

class PushNotificationSender(MessageSender):
    def send(self, message):
        print(f"Sending via Push Notification: {message}")

# 抽象部分：消息类型
class Message(ABC):
    def __init__(self, sender: MessageSender):
        self.sender = sender

    @abstractmethod
    def send(self):
        pass

class TextMessage(Message):
    def __init__(self, content, sender: MessageSender):
        super().__init__(sender)
        self.content = content

    def send(self):
        self.sender.send(f"Text: {self.content}")

class UrgentMessage(Message):
    def __init__(self, content, sender: MessageSender):
        super().__init__(sender)
        self.content = content

    def send(self):
        self.sender.send(f"URGENT: {self.content}")

# 使用：消息类型和发送方式可以独立变化
messages = [
    TextMessage("Hello", EmailSender()),
    UrgentMessage("Server down!", SMSSender()),
    TextMessage("New feature", PushNotificationSender())
]

for msg in messages:
    msg.send()
</code></pre>
<h3 id="37-享元模式flyweight"><a class="header" href="#37-享元模式flyweight">3.7 享元模式（Flyweight）</a></h3>
<h4 id="模式意图-11"><a class="header" href="#模式意图-11">模式意图</a></h4>
<p>运用共享技术有效地支持大量细粒度对象的复用。</p>
<h4 id="适用场景-11"><a class="header" href="#适用场景-11">适用场景</a></h4>
<ul>
<li>程序使用大量对象</li>
<li>多数对象状态可变为外部状态</li>
<li>去除外部状态后，可用较少共享对象替代多组对象</li>
</ul>
<h4 id="python实现-10"><a class="header" href="#python实现-10">Python实现</a></h4>
<pre><code class="language-python">class Flyweight:
    """享元类：存储内部状态"""
    def __init__(self, shared_state):
        self.shared_state = shared_state

    def operation(self, unique_state):
        shared = ", ".join(self.shared_state)
        unique = ", ".join(unique_state)
        print(f"Flyweight: Shared ({shared}) | Unique ({unique})")

class FlyweightFactory:
    """享元工厂：管理享元对象池"""
    def __init__(self):
        self._flyweights = {}

    def get_flyweight(self, shared_state):
        key = "".join(sorted(shared_state))

        if key not in self._flyweights:
            print(f"Creating new flyweight for: {shared_state}")
            self._flyweights[key] = Flyweight(shared_state)
        else:
            print(f"Reusing existing flyweight for: {shared_state}")

        return self._flyweights[key]

    def list_flyweights(self):
        count = len(self._flyweights)
        print(f"\nFlyweightFactory: I have {count} flyweights:")
        for key in self._flyweights:
            print(key)

# 使用
factory = FlyweightFactory()

# 添加汽车到数据库
def add_car(factory, plates, owner, brand, model, color):
    flyweight = factory.get_flyweight([brand, model, color])
    flyweight.operation([plates, owner])

add_car(factory, "CL234IR", "James", "Chevrolet", "Camaro", "pink")
add_car(factory, "CL234IR", "James", "Chevrolet", "Camaro", "pink")
add_car(factory, "EA123CX", "Alice", "BMW", "M5", "red")
add_car(factory, "EA123CX", "Alice", "BMW", "M5", "red")

factory.list_flyweights()
</code></pre>
<h4 id="实际应用文本编辑器字符对象"><a class="header" href="#实际应用文本编辑器字符对象">实际应用：文本编辑器字符对象</a></h4>
<pre><code class="language-python">class CharacterFlyweight:
    """字符享元：共享字体、大小、样式"""
    def __init__(self, font, size, style):
        self.font = font
        self.size = size
        self.style = style

    def render(self, char, position):
        print(f"Rendering '{char}' at {position} "
              f"(font={self.font}, size={self.size}, style={self.style})")

class CharacterFactory:
    def __init__(self):
        self._characters = {}

    def get_character(self, font, size, style):
        key = (font, size, style)
        if key not in self._characters:
            self._characters[key] = CharacterFlyweight(font, size, style)
        return self._characters[key]

# 使用
factory = CharacterFactory()

# 渲染文本：大部分字符共享相同格式
text = "Hello World"
positions = [(i, 0) for i in range(len(text))]

for char, pos in zip(text, positions):
    character = factory.get_character("Arial", 12, "normal")
    character.render(char, pos)

print(f"\nTotal flyweight objects: {len(factory._characters)}")  # 只有1个
</code></pre>
<hr />
<h2 id="第四模块行为型模式"><a class="header" href="#第四模块行为型模式">第四模块：行为型模式</a></h2>
<h3 id="41-观察者模式observer"><a class="header" href="#41-观察者模式observer">4.1 观察者模式（Observer）</a></h3>
<h4 id="模式意图-12"><a class="header" href="#模式意图-12">模式意图</a></h4>
<p>定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会收到通知并自动更新。</p>
<h4 id="适用场景-12"><a class="header" href="#适用场景-12">适用场景</a></h4>
<ul>
<li>一个对象改变需要同时改变其他对象</li>
<li>一个对象必须通知其他对象，但不知道对方具体是谁</li>
<li>需要事件驱动的系统</li>
</ul>
<h4 id="python实现-11"><a class="header" href="#python实现-11">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 观察者接口
class Observer(ABC):
    @abstractmethod
    def update(self, subject):
        pass

# 主题（被观察者）
class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, observer: Observer):
        print(f"Subject: Attached an observer")
        self._observers.append(observer)

    def detach(self, observer: Observer):
        self._observers.remove(observer)

    def notify(self):
        print("Subject: Notifying observers...")
        for observer in self._observers:
            observer.update(self)

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        print(f"Subject: My state has changed to: {value}")
        self._state = value
        self.notify()

# 具体观察者
class ConcreteObserverA(Observer):
    def update(self, subject: Subject):
        if subject.state &lt; 3:
            print("ConcreteObserverA: Reacted to the event")

class ConcreteObserverB(Observer):
    def update(self, subject: Subject):
        if subject.state &gt;= 3:
            print("ConcreteObserverB: Reacted to the event")

# 使用
subject = Subject()

observer_a = ConcreteObserverA()
subject.attach(observer_a)

observer_b = ConcreteObserverB()
subject.attach(observer_b)

subject.state = 2
subject.state = 5
</code></pre>
<h4 id="实际应用新闻订阅系统"><a class="header" href="#实际应用新闻订阅系统">实际应用：新闻订阅系统</a></h4>
<pre><code class="language-python">class NewsPublisher:
    """新闻发布者"""
    def __init__(self):
        self._subscribers = []
        self._news = []

    def subscribe(self, subscriber):
        self._subscribers.append(subscriber)

    def unsubscribe(self, subscriber):
        self._subscribers.remove(subscriber)

    def publish_news(self, news):
        print(f"\nPublishing news: {news}")
        self._news.append(news)
        self._notify_subscribers(news)

    def _notify_subscribers(self, news):
        for subscriber in self._subscribers:
            subscriber.receive_news(news)

class Subscriber:
    """订阅者"""
    def __init__(self, name):
        self.name = name

    def receive_news(self, news):
        print(f"{self.name} received: {news}")

# 使用
publisher = NewsPublisher()

alice = Subscriber("Alice")
bob = Subscriber("Bob")
charlie = Subscriber("Charlie")

publisher.subscribe(alice)
publisher.subscribe(bob)

publisher.publish_news("Python 3.12 Released!")

publisher.subscribe(charlie)
publisher.publish_news("New Framework Announced!")

publisher.unsubscribe(bob)
publisher.publish_news("Important Update!")
</code></pre>
<h3 id="42-策略模式strategy"><a class="header" href="#42-策略模式strategy">4.2 策略模式（Strategy）</a></h3>
<h4 id="模式意图-13"><a class="header" href="#模式意图-13">模式意图</a></h4>
<p>定义算法家族，分别封装，使它们可以互相替换。策略模式使算法变化独立于使用算法的客户。</p>
<h4 id="适用场景-13"><a class="header" href="#适用场景-13">适用场景</a></h4>
<ul>
<li>需要使用一个算法的不同变体</li>
<li>有许多相关类仅行为有差异</li>
<li>算法使用客户不应知道的数据</li>
</ul>
<h4 id="python实现-12"><a class="header" href="#python实现-12">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 策略接口
class Strategy(ABC):
    @abstractmethod
    def execute(self, data):
        pass

# 具体策略
class BubbleSortStrategy(Strategy):
    def execute(self, data):
        print("Sorting using bubble sort")
        return sorted(data)  # 简化实现

class QuickSortStrategy(Strategy):
    def execute(self, data):
        print("Sorting using quick sort")
        return sorted(data)

class MergeSortStrategy(Strategy):
    def execute(self, data):
        print("Sorting using merge sort")
        return sorted(data)

# 上下文
class Sorter:
    def __init__(self, strategy: Strategy):
        self._strategy = strategy

    def set_strategy(self, strategy: Strategy):
        self._strategy = strategy

    def sort(self, data):
        return self._strategy.execute(data)

# 使用
data = [5, 2, 9, 1, 7]

sorter = Sorter(BubbleSortStrategy())
print(sorter.sort(data))

sorter.set_strategy(QuickSortStrategy())
print(sorter.sort(data))
</code></pre>
<h4 id="python函数作为策略更pythonic"><a class="header" href="#python函数作为策略更pythonic">Python函数作为策略（更Pythonic）</a></h4>
<pre><code class="language-python">def bubble_sort(data):
    print("Bubble sort")
    return sorted(data)

def quick_sort(data):
    print("Quick sort")
    return sorted(data)

class Sorter:
    def __init__(self, strategy):
        self.strategy = strategy

    def sort(self, data):
        return self.strategy(data)

# 使用
sorter = Sorter(bubble_sort)
print(sorter.sort([5, 2, 9, 1, 7]))

sorter.strategy = quick_sort
print(sorter.sort([5, 2, 9, 1, 7]))
</code></pre>
<h4 id="实际应用支付策略"><a class="header" href="#实际应用支付策略">实际应用：支付策略</a></h4>
<pre><code class="language-python">class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number):
        self.card_number = card_number

    def pay(self, amount):
        print(f"Paid ${amount} using Credit Card {self.card_number}")

class PayPalPayment(PaymentStrategy):
    def __init__(self, email):
        self.email = email

    def pay(self, amount):
        print(f"Paid ${amount} using PayPal account {self.email}")

class CryptoPayment(PaymentStrategy):
    def __init__(self, wallet_address):
        self.wallet_address = wallet_address

    def pay(self, amount):
        print(f"Paid ${amount} using Crypto wallet {self.wallet_address}")

class ShoppingCart:
    def __init__(self):
        self.items = []
        self.payment_strategy = None

    def add_item(self, item, price):
        self.items.append((item, price))

    def set_payment_strategy(self, strategy: PaymentStrategy):
        self.payment_strategy = strategy

    def checkout(self):
        total = sum(price for _, price in self.items)

        if self.payment_strategy:
            self.payment_strategy.pay(total)
        else:
            print("Please set a payment method")

# 使用
cart = ShoppingCart()
cart.add_item("Book", 29.99)
cart.add_item("Pen", 5.99)

cart.set_payment_strategy(CreditCardPayment("1234-5678-9012-3456"))
cart.checkout()

cart.set_payment_strategy(PayPalPayment("user@example.com"))
cart.checkout()
</code></pre>
<h3 id="43-命令模式command"><a class="header" href="#43-命令模式command">4.3 命令模式（Command）</a></h3>
<h4 id="模式意图-14"><a class="header" href="#模式意图-14">模式意图</a></h4>
<p>将请求封装为对象，从而可用不同的请求对客户进行参数化；对请求排队或记录日志；支持可撤销的操作。</p>
<h4 id="适用场景-14"><a class="header" href="#适用场景-14">适用场景</a></h4>
<ul>
<li>需要参数化对象执行的动作</li>
<li>需要在不同时间指定、排列和执行请求</li>
<li>需要支持撤销操作</li>
<li>需要支持日志记录</li>
</ul>
<h4 id="python实现-13"><a class="header" href="#python实现-13">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 命令接口
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass

    @abstractmethod
    def undo(self):
        pass

# 接收者
class Light:
    def on(self):
        print("Light is ON")

    def off(self):
        print("Light is OFF")

# 具体命令
class LightOnCommand(Command):
    def __init__(self, light: Light):
        self.light = light

    def execute(self):
        self.light.on()

    def undo(self):
        self.light.off()

class LightOffCommand(Command):
    def __init__(self, light: Light):
        self.light = light

    def execute(self):
        self.light.off()

    def undo(self):
        self.light.on()

# 调用者
class RemoteControl:
    def __init__(self):
        self.command = None
        self.history = []

    def set_command(self, command: Command):
        self.command = command

    def press_button(self):
        if self.command:
            self.command.execute()
            self.history.append(self.command)

    def press_undo(self):
        if self.history:
            command = self.history.pop()
            command.undo()

# 使用
light = Light()
light_on = LightOnCommand(light)
light_off = LightOffCommand(light)

remote = RemoteControl()

remote.set_command(light_on)
remote.press_button()  # Light is ON

remote.set_command(light_off)
remote.press_button()  # Light is OFF

remote.press_undo()  # Light is ON (撤销off命令)
remote.press_undo()  # Light is OFF (撤销on命令)
</code></pre>
<h4 id="实际应用文本编辑器"><a class="header" href="#实际应用文本编辑器">实际应用：文本编辑器</a></h4>
<pre><code class="language-python">class TextEditor:
    """接收者"""
    def __init__(self):
        self.content = ""

    def insert(self, text):
        self.content += text
        print(f"Content: '{self.content}'")

    def delete(self, length):
        self.content = self.content[:-length]
        print(f"Content: '{self.content}'")

class InsertCommand(Command):
    def __init__(self, editor: TextEditor, text):
        self.editor = editor
        self.text = text

    def execute(self):
        self.editor.insert(self.text)

    def undo(self):
        self.editor.delete(len(self.text))

class DeleteCommand(Command):
    def __init__(self, editor: TextEditor, length):
        self.editor = editor
        self.length = length
        self.deleted_text = ""

    def execute(self):
        self.deleted_text = self.editor.content[-self.length:]
        self.editor.delete(self.length)

    def undo(self):
        self.editor.insert(self.deleted_text)

class CommandManager:
    """命令管理器：支持撤销/重做"""
    def __init__(self):
        self.history = []
        self.current = -1

    def execute_command(self, command: Command):
        # 清除当前位置之后的历史
        self.history = self.history[:self.current + 1]

        command.execute()
        self.history.append(command)
        self.current += 1

    def undo(self):
        if self.current &gt;= 0:
            command = self.history[self.current]
            command.undo()
            self.current -= 1

    def redo(self):
        if self.current &lt; len(self.history) - 1:
            self.current += 1
            command = self.history[self.current]
            command.execute()

# 使用
editor = TextEditor()
manager = CommandManager()

manager.execute_command(InsertCommand(editor, "Hello"))
manager.execute_command(InsertCommand(editor, " World"))
manager.execute_command(DeleteCommand(editor, 6))

print("\nUndo:")
manager.undo()

print("\nRedo:")
manager.redo()
</code></pre>
<h3 id="44-模板方法模式template-method"><a class="header" href="#44-模板方法模式template-method">4.4 模板方法模式（Template Method）</a></h3>
<h4 id="模式意图-15"><a class="header" href="#模式意图-15">模式意图</a></h4>
<p>在一个方法中定义算法骨架，将某些步骤延迟到子类。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。</p>
<h4 id="适用场景-15"><a class="header" href="#适用场景-15">适用场景</a></h4>
<ul>
<li>一次性实现算法不变部分，可变部分由子类实现</li>
<li>各子类中公共行为应被提取出来集中到公共父类，避免代码重复</li>
<li>控制子类扩展</li>
</ul>
<h4 id="python实现-14"><a class="header" href="#python实现-14">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

class DataMiner(ABC):
    """模板方法类"""

    def mine(self, path):
        """模板方法：定义算法骨架"""
        self.open_file(path)
        raw_data = self.extract_data()
        processed_data = self.analyze_data(raw_data)
        self.send_report(processed_data)
        self.close_file()

    @abstractmethod
    def open_file(self, path):
        pass

    @abstractmethod
    def extract_data(self):
        pass

    def analyze_data(self, raw_data):
        """默认实现（钩子方法）"""
        return f"Analyzed: {raw_data}"

    @abstractmethod
    def send_report(self, data):
        pass

    def close_file(self):
        """具体实现"""
        print("File closed\n")

# 具体类：PDF数据挖掘
class PDFDataMiner(DataMiner):
    def open_file(self, path):
        print(f"Opening PDF file: {path}")

    def extract_data(self):
        print("Extracting data from PDF")
        return "PDF Data"

    def send_report(self, data):
        print(f"Sending PDF report: {data}")

# 具体类：CSV数据挖掘
class CSVDataMiner(DataMiner):
    def open_file(self, path):
        print(f"Opening CSV file: {path}")

    def extract_data(self):
        print("Extracting data from CSV")
        return "CSV Data"

    def analyze_data(self, raw_data):
        # 重写分析方法
        return f"Custom CSV Analysis: {raw_data}"

    def send_report(self, data):
        print(f"Sending CSV report: {data}")

# 使用
print("Mining PDF:")
pdf_miner = PDFDataMiner()
pdf_miner.mine("data.pdf")

print("Mining CSV:")
csv_miner = CSVDataMiner()
csv_miner.mine("data.csv")
</code></pre>
<h4 id="实际应用web框架视图处理"><a class="header" href="#实际应用web框架视图处理">实际应用：Web框架视图处理</a></h4>
<pre><code class="language-python">class View(ABC):
    """视图模板"""

    def dispatch(self, request):
        """模板方法"""
        # 请求预处理
        if not self.check_permissions(request):
            return "Permission Denied"

        # 根据HTTP方法分发
        if request.method == "GET":
            response = self.get(request)
        elif request.method == "POST":
            response = self.post(request)
        else:
            response = "Method Not Allowed"

        # 响应后处理
        return self.finalize_response(response)

    def check_permissions(self, request):
        """钩子：权限检查"""
        return True

    @abstractmethod
    def get(self, request):
        pass

    @abstractmethod
    def post(self, request):
        pass

    def finalize_response(self, response):
        """钩子：响应最终处理"""
        return response

class UserListView(View):
    def get(self, request):
        return "User List"

    def post(self, request):
        return "User Created"

    def check_permissions(self, request):
        # 自定义权限检查
        return request.get("is_authenticated", False)

# 模拟请求
class Request:
    def __init__(self, method, **kwargs):
        self.method = method
        self.__dict__.update(kwargs)

    def get(self, key, default=None):
        return self.__dict__.get(key, default)

# 使用
view = UserListView()

print(view.dispatch(Request("GET", is_authenticated=True)))
print(view.dispatch(Request("POST", is_authenticated=False)))
</code></pre>
<h3 id="45-状态模式state"><a class="header" href="#45-状态模式state">4.5 状态模式（State）</a></h3>
<h4 id="模式意图-16"><a class="header" href="#模式意图-16">模式意图</a></h4>
<p>允许对象在内部状态改变时改变其行为，对象看起来好像修改了它的类。</p>
<h4 id="适用场景-16"><a class="header" href="#适用场景-16">适用场景</a></h4>
<ul>
<li>对象行为取决于它的状态，并且必须在运行时根据状态改变行为</li>
<li>操作中含有庞大的多分支条件语句，且这些分支依赖于对象状态</li>
</ul>
<h4 id="python实现-15"><a class="header" href="#python实现-15">Python实现</a></h4>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 状态接口
class State(ABC):
    @abstractmethod
    def handle(self, context):
        pass

# 具体状态
class ConcreteStateA(State):
    def handle(self, context):
        print("State A handling request")
        print("State A changing context state to B")
        context.state = ConcreteStateB()

class ConcreteStateB(State):
    def handle(self, context):
        print("State B handling request")
        print("State B changing context state to A")
        context.state = ConcreteStateA()

# 上下文
class Context:
    def __init__(self, state: State):
        self._state = state

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, state: State):
        print(f"Context: Transitioning to {state.__class__.__name__}")
        self._state = state

    def request(self):
        self._state.handle(self)

# 使用
context = Context(ConcreteStateA())
context.request()
context.request()
context.request()
</code></pre>
<h4 id="实际应用tcp连接状态"><a class="header" href="#实际应用tcp连接状态">实际应用：TCP连接状态</a></h4>
<pre><code class="language-python">class TCPConnection:
    """TCP连接上下文"""
    def __init__(self):
        self._state = ClosedState()

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, state):
        print(f"Transitioning to {state.__class__.__name__}")
        self._state = state

    def open(self):
        self._state.open(self)

    def close(self):
        self._state.close(self)

    def acknowledge(self):
        self._state.acknowledge(self)

class TCPState(ABC):
    @abstractmethod
    def open(self, connection):
        pass

    @abstractmethod
    def close(self, connection):
        pass

    @abstractmethod
    def acknowledge(self, connection):
        pass

class ClosedState(TCPState):
    def open(self, connection):
        print("Opening connection...")
        connection.state = ListenState()

    def close(self, connection):
        print("Already closed")

    def acknowledge(self, connection):
        print("Cannot acknowledge: connection closed")

class ListenState(TCPState):
    def open(self, connection):
        print("Already open")

    def close(self, connection):
        print("Closing connection...")
        connection.state = ClosedState()

    def acknowledge(self, connection):
        print("Acknowledgement received")
        connection.state = EstablishedState()

class EstablishedState(TCPState):
    def open(self, connection):
        print("Connection already established")

    def close(self, connection):
        print("Closing established connection...")
        connection.state = ClosedState()

    def acknowledge(self, connection):
        print("Data transfer in progress")

# 使用
connection = TCPConnection()
connection.open()
connection.acknowledge()
connection.close()
connection.acknowledge()
</code></pre>
<hr />
<h2 id="第五模块python特有实现技巧"><a class="header" href="#第五模块python特有实现技巧">第五模块：Python特有实现技巧</a></h2>
<h3 id="51-使用装饰器实现单例"><a class="header" href="#51-使用装饰器实现单例">5.1 使用装饰器实现单例</a></h3>
<pre><code class="language-python">def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class Database:
    def __init__(self):
        self.connection = "Connected"

db1 = Database()
db2 = Database()
print(db1 is db2)  # True
</code></pre>
<h3 id="52-使用上下文管理器实现资源管理"><a class="header" href="#52-使用上下文管理器实现资源管理">5.2 使用上下文管理器实现资源管理</a></h3>
<pre><code class="language-python">from contextlib import contextmanager

@contextmanager
def managed_resource(*args, **kwargs):
    resource = acquire_resource(*args, **kwargs)
    try:
        yield resource
    finally:
        release_resource(resource)

# 使用
with managed_resource() as resource:
    use_resource(resource)
</code></pre>
<h3 id="53-使用描述符实现观察者模式"><a class="header" href="#53-使用描述符实现观察者模式">5.3 使用描述符实现观察者模式</a></h3>
<pre><code class="language-python">class Observable:
    def __init__(self, initial_value):
        self.value = initial_value
        self.observers = []

    def __get__(self, obj, objtype=None):
        return self.value

    def __set__(self, obj, value):
        self.value = value
        for observer in self.observers:
            observer(value)

    def add_observer(self, observer):
        self.observers.append(observer)

class MyClass:
    temperature = Observable(20)

    def __init__(self):
        self.temperature.add_observer(self.on_temperature_change)

    def on_temperature_change(self, new_temp):
        print(f"Temperature changed to {new_temp}")

obj = MyClass()
obj.temperature = 25  # 触发观察者
</code></pre>
<h3 id="54-使用生成器实现迭代器模式"><a class="header" href="#54-使用生成器实现迭代器模式">5.4 使用生成器实现迭代器模式</a></h3>
<pre><code class="language-python">class Range:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        current = self.start
        while current &lt; self.end:
            yield current
            current += 1

# 使用
for i in Range(0, 5):
    print(i)
</code></pre>
<hr />
<h2 id="第六模块实战项目"><a class="header" href="#第六模块实战项目">第六模块：实战项目</a></h2>
<h3 id="61-简易计算器策略命令模式"><a class="header" href="#61-简易计算器策略命令模式">6.1 简易计算器（策略+命令模式）</a></h3>
<pre><code class="language-python">from abc import ABC, abstractmethod

# 策略模式：操作策略
class OperationStrategy(ABC):
    @abstractmethod
    def execute(self, a, b):
        pass

class AddStrategy(OperationStrategy):
    def execute(self, a, b):
        return a + b

class SubtractStrategy(OperationStrategy):
    def execute(self, a, b):
        return a - b

class MultiplyStrategy(OperationStrategy):
    def execute(self, a, b):
        return a * b

class DivideStrategy(OperationStrategy):
    def execute(self, a, b):
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b

# 命令模式：可撤销的计算命令
class CalculatorCommand:
    def __init__(self, strategy: OperationStrategy, a, b):
        self.strategy = strategy
        self.a = a
        self.b = b
        self.result = None

    def execute(self):
        self.result = self.strategy.execute(self.a, self.b)
        return self.result

    def undo(self):
        # 简化：返回操作数
        return self.a

# 计算器（使用命令模式管理历史）
class Calculator:
    def __init__(self):
        self.history = []
        self.current_value = 0

    def calculate(self, strategy: OperationStrategy, b):
        command = CalculatorCommand(strategy, self.current_value, b)
        self.current_value = command.execute()
        self.history.append(command)
        return self.current_value

    def undo(self):
        if self.history:
            command = self.history.pop()
            self.current_value = command.undo()
        return self.current_value

    def get_value(self):
        return self.current_value

# 使用
calc = Calculator()
print(calc.calculate(AddStrategy(), 5))       # 5
print(calc.calculate(MultiplyStrategy(), 3))  # 15
print(calc.calculate(SubtractStrategy(), 5))  # 10
print(calc.undo())                             # 15
print(calc.undo())                             # 5
</code></pre>
<h3 id="62-简易日志系统单例责任链模式"><a class="header" href="#62-简易日志系统单例责任链模式">6.2 简易日志系统（单例+责任链模式）</a></h3>
<pre><code class="language-python">from abc import ABC, abstractmethod
import time

# 单例模式：日志管理器
class LoggerSingleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

# 责任链模式：日志级别处理
class LogLevel:
    DEBUG = 1
    INFO = 2
    WARNING = 3
    ERROR = 4

class LogHandler(ABC):
    def __init__(self, level):
        self.level = level
        self.next_handler = None

    def set_next(self, handler):
        self.next_handler = handler
        return handler

    def handle(self, level, message):
        if level &gt;= self.level:
            self.write(message)

        if self.next_handler:
            self.next_handler.handle(level, message)

    @abstractmethod
    def write(self, message):
        pass

class ConsoleHandler(LogHandler):
    def write(self, message):
        print(f"[CONSOLE] {message}")

class FileHandler(LogHandler):
    def __init__(self, level, filename):
        super().__init__(level)
        self.filename = filename

    def write(self, message):
        with open(self.filename, 'a') as f:
            f.write(f"{message}\n")
        print(f"[FILE] Written to {self.filename}")

class EmailHandler(LogHandler):
    def write(self, message):
        print(f"[EMAIL] Sending email: {message}")

# 日志系统
class Logger(metaclass=LoggerSingleton):
    def __init__(self):
        # 构建责任链
        self.console = ConsoleHandler(LogLevel.DEBUG)
        self.file = FileHandler(LogLevel.WARNING, "app.log")
        self.email = EmailHandler(LogLevel.ERROR)

        self.console.set_next(self.file).set_next(self.email)

    def log(self, level, message):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        formatted = f"[{timestamp}] {message}"
        self.console.handle(level, formatted)

    def debug(self, message):
        self.log(LogLevel.DEBUG, f"DEBUG: {message}")

    def info(self, message):
        self.log(LogLevel.INFO, f"INFO: {message}")

    def warning(self, message):
        self.log(LogLevel.WARNING, f"WARNING: {message}")

    def error(self, message):
        self.log(LogLevel.ERROR, f"ERROR: {message}")

# 使用
logger1 = Logger()
logger2 = Logger()

print(logger1 is logger2)  # True (单例)

logger1.debug("This is a debug message")
logger1.info("This is an info message")
logger1.warning("This is a warning")
logger1.error("This is an error!")
</code></pre>
<hr />
<h2 id="学习验证标准"><a class="header" href="#学习验证标准">学习验证标准</a></h2>
<h3 id="基础验证week-1-2"><a class="header" href="#基础验证week-1-2">基础验证（Week 1-2）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
理解SOLID五大设计原则</li>
<li><input disabled="" type="checkbox"/>
掌握创建型模式中的单例、工厂方法</li>
<li><input disabled="" type="checkbox"/>
能够识别代码中的设计模式</li>
</ul>
<h3 id="中级验证week-3-5"><a class="header" href="#中级验证week-3-5">中级验证（Week 3-5）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
熟练使用7种结构型模式</li>
<li><input disabled="" type="checkbox"/>
理解装饰器、适配器、代理的区别</li>
<li><input disabled="" type="checkbox"/>
能够在实际项目中应用合适的模式</li>
</ul>
<h3 id="高级验证week-6-7"><a class="header" href="#高级验证week-6-7">高级验证（Week 6-7）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
掌握11种行为型模式</li>
<li><input disabled="" type="checkbox"/>
理解观察者、策略、命令的应用场景</li>
<li><input disabled="" type="checkbox"/>
能够重构现有代码使用设计模式</li>
</ul>
<h3 id="项目验证week-8"><a class="header" href="#项目验证week-8">项目验证（Week 8）</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
完成至少一个综合项目，应用3种以上设计模式</li>
<li><input disabled="" type="checkbox"/>
能够说明为什么选择这些模式</li>
<li><input disabled="" type="checkbox"/>
代码符合SOLID原则</li>
</ul>
<hr />
<h2 id="常见错误与解决"><a class="header" href="#常见错误与解决">常见错误与解决</a></h2>
<h3 id="1-过度设计"><a class="header" href="#1-过度设计">1. 过度设计</a></h3>
<pre><code class="language-python"># ❌ 错误：为简单场景引入复杂模式
class SimpleMath:
    def add(self, a, b):
        strategy = AdditionStrategy()
        factory = OperationFactory()
        # 过度复杂
        return factory.create(strategy).execute(a, b)

# ✅ 正确：保持简单
class SimpleMath:
    def add(self, a, b):
        return a + b
</code></pre>
<h3 id="2-滥用单例"><a class="header" href="#2-滥用单例">2. 滥用单例</a></h3>
<pre><code class="language-python"># ❌ 错误：所有类都用单例
@singleton
class User:  # 用户对象不应该是单例
    pass

# ✅ 正确：只在真正需要全局唯一时使用
@singleton
class DatabaseConnection:
    pass
</code></pre>
<h3 id="3-忘记考虑python特性"><a class="header" href="#3-忘记考虑python特性">3. 忘记考虑Python特性</a></h3>
<pre><code class="language-python"># ❌ 错误：用Java风格写装饰器模式
class Decorator:
    def __init__(self, component):
        self.component = component

    def operation(self):
        return self.component.operation()

# ✅ 正确：使用Python装饰器语法
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"Time: {time.time() - start}")
        return result
    return wrapper
</code></pre>
<hr />
<h2 id="推荐学习资源"><a class="header" href="#推荐学习资源">推荐学习资源</a></h2>
<h3 id="经典书籍"><a class="header" href="#经典书籍">经典书籍</a></h3>
<ol>
<li><strong>《设计模式：可复用面向对象软件的基础》</strong> - GOF四人组</li>
<li><strong>《Head First 设计模式》</strong> - 适合初学者</li>
<li><strong>《重构：改善既有代码的设计》</strong> - Martin Fowler</li>
<li><strong>《代码整洁之道》</strong> - Robert C. Martin</li>
</ol>
<h3 id="在线资源"><a class="header" href="#在线资源">在线资源</a></h3>
<ul>
<li><strong>Refactoring Guru</strong>: https://refactoring.guru/design-patterns</li>
<li><strong>SourceMaking</strong>: https://sourcemaking.com/design_patterns</li>
<li><strong>Python Design Patterns</strong>: https://python-patterns.guide/</li>
</ul>
<h3 id="实践建议"><a class="header" href="#实践建议">实践建议</a></h3>
<ol>
<li>先理解问题，再选择模式</li>
<li>优先考虑简单解决方案</li>
<li>重构时引入设计模式</li>
<li>阅读优秀开源项目代码（Django、Flask等）</li>
<li>参与代码评审，学习他人的设计</li>
</ol>
<hr />
<p><strong>最后总结</strong>：</p>
<p>设计模式不是银弹，而是经验总结：</p>
<ul>
<li><strong>不要为了模式而模式</strong>：首先解决问题，然后优化设计</li>
<li><strong>适度使用</strong>：Python的动态特性使许多模式可以更简洁地实现</li>
<li><strong>持续学习</strong>：设计模式是手段，面向对象设计原则是核心</li>
<li><strong>实践出真知</strong>：在真实项目中应用，从错误中学习</li>
</ul>
<p>通过系统学习和大量实践，你将能够：</p>
<ol>
<li>快速识别代码中的设计模式</li>
<li>选择合适的模式解决设计问题</li>
<li>编写可维护、可扩展的代码</li>
<li>与团队有效沟通设计决策</li>
</ol>
<p>祝学习进步！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/language/100-数据结构.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/language/Python爬虫-分布式与性能优化.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/language/100-数据结构.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/language/Python爬虫-分布式与性能优化.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

