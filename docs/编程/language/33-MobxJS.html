<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MobX（v6）实战学习笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="mobxv6实战学习笔记"><a class="header" href="#mobxv6实战学习笔记">MobX（v6）实战学习笔记</a></h1>
<p>适用版本：MobX v6.x、mobx-react-lite v4.x、TypeScript 5、React 18</p>
<p>目标读者：0-5 年前端开发者、正在从 Redux/Zustand 转向响应式模型的学习者</p>
<p>学习产出：能用 MobX 设计与实现中小型前端应用的状态层，掌握 observable/computed/action/reaction、在 React 中高性能集成、异步与副作用处理、测试与调试、SSR 适配与工程化实践。</p>
<p>先修要求：ES6/TS 基础、React 组件化，建议了解不可变数据思想（便于对比）。</p>
<hr />
<h2 id="学习路径总览循序渐进"><a class="header" href="#学习路径总览循序渐进">学习路径总览（循序渐进）</a></h2>
<ul>
<li>核心概念：响应式依赖跟踪、observable/computed/action</li>
<li>React 集成：observer、useLocalObservable、Context + RootStore</li>
<li>异步与副作用：runInAction、flow、reaction/when</li>
<li>状态建模与架构：领域 Store、依赖与边界、持久化</li>
<li>性能与调试：观察粒度、计算属性、trace/spy</li>
<li>测试与工程化：单测、组件测试、类型与持久化、SSR（Next.js）</li>
</ul>
<p>注：本笔记融合原提纲要点并以实战为导向重组内容。</p>
<hr />
<h2 id="模块一核心概念与基础observablecomputedaction"><a class="header" href="#模块一核心概念与基础observablecomputedaction">模块一：核心概念与基础（observable、computed、action）</a></h2>
<p>你将学到：</p>
<ul>
<li>观察-推导-动作三要素：state（observable）、derived（computed）、effects（action/reaction）</li>
<li>依赖跟踪：读取 observable 的函数在首次执行时被追踪，后续变更将触发重跑</li>
<li>注解方式：<code>makeObservable</code> 与 <code>makeAutoObservable</code> 的适用场景</li>
</ul>
<p>最小可用示例（TypeScript）：</p>
<pre><code class="language-ts">import { makeAutoObservable } from 'mobx'

export class CounterStore {
  count = 0
  constructor() {
    makeAutoObservable(this, {}, { autoBind: true }) // 自动注解并绑定 this
  }
  get double() { return this.count * 2 }            // computed
  inc() { this.count++ }                             // action
}
</code></pre>
<p>核心 API 速览：</p>
<ul>
<li>observable：可观察数据（对象/数组/Map/Set/box）</li>
<li>computed：纯函数派生值，缓存并按依赖更新</li>
<li>action/runInAction：在动作中修改状态，自动批量变更</li>
<li>reactions：<code>autorun</code>、<code>reaction</code>、<code>when</code> 用于副作用与条件触发</li>
</ul>
<p>易错点与对策：</p>
<ul>
<li>方法 <code>this</code> 绑定丢失：<code>makeAutoObservable(..., { autoBind: true })</code> 或使用箭头函数</li>
<li>在非 action 中修改状态：开启 <code>configure({ enforceActions: 'never' | 'observed' })</code> 并用 action 包裹</li>
</ul>
<hr />
<h2 id="模块二在-react-中使用mobx-react-lite"><a class="header" href="#模块二在-react-中使用mobx-react-lite">模块二：在 React 中使用（mobx-react-lite）</a></h2>
<p>你将学到：</p>
<ul>
<li>函数组件通过 <code>observer</code> 订阅可观察数据</li>
<li>组件内 <code>useLocalObservable</code> 管理局部复杂状态</li>
<li>RootStore + Context 注入全局 store（避免 prop drilling）</li>
</ul>
<p>安装：</p>
<pre><code class="language-bash">npm i mobx mobx-react-lite
</code></pre>
<p>示例：RootStore + Context</p>
<pre><code class="language-tsx">// store/root.ts
import { createContext, useContext } from 'react'
import { makeAutoObservable } from 'mobx'

class TodoStore {
  todos: { id: number; title: string; done: boolean }[] = []
  constructor() { makeAutoObservable(this, {}, { autoBind: true }) }
  get doneCount() { return this.todos.filter(t =&gt; t.done).length }
  add(title: string) { this.todos.push({ id: Date.now(), title, done: false }) }
  toggle(id: number) { const t = this.todos.find(t =&gt; t.id === id); if (t) t.done = !t.done }
}

export class RootStore {
  todo = new TodoStore()
}

const Ctx = createContext&lt;RootStore | null&gt;(null)
export const RootStoreProvider = ({ children }: { children: React.ReactNode }) =&gt; (
  &lt;Ctx.Provider value={new RootStore()}&gt;{children}&lt;/Ctx.Provider&gt;
)
export const useStore = () =&gt; { const s = useContext(Ctx); if (!s) throw new Error('Missing RootStore'); return s }
</code></pre>
<pre><code class="language-tsx">// components/TodoList.tsx
import { observer } from 'mobx-react-lite'
import { useStore } from '../store/root'

export const TodoList = observer(function TodoList() {
  const { todo } = useStore()
  return (
    &lt;div&gt;
      &lt;form onSubmit={e =&gt; { e.preventDefault(); const f = new FormData(e.currentTarget); const title = String(f.get('title')||''); if (title) todo.add(title); e.currentTarget.reset() }}&gt;
        &lt;input name="title" placeholder="新任务" /&gt;
        &lt;button&gt;添加&lt;/button&gt;
      &lt;/form&gt;
      &lt;p&gt;已完成：{todo.doneCount}&lt;/p&gt;
      &lt;ul&gt;
        {todo.todos.map(t =&gt; (
          &lt;li key={t.id}&gt;
            &lt;label&gt;
              &lt;input type="checkbox" checked={t.done} onChange={() =&gt; todo.toggle(t.id)} /&gt;
              {t.title}
            &lt;/label&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
})
</code></pre>
<p>局部复杂状态：</p>
<pre><code class="language-tsx">import { useLocalObservable, observer } from 'mobx-react-lite'

export const SearchBox = observer(function SearchBox() {
  const state = useLocalObservable(() =&gt; ({ q: '', setQ(q: string){ this.q = q }}))
  return &lt;input value={state.q} onChange={e =&gt; state.setQ(e.target.value)} placeholder="搜索" /&gt;
})
</code></pre>
<hr />
<h2 id="模块三异步与副作用runinactionflowreactions"><a class="header" href="#模块三异步与副作用runinactionflowreactions">模块三：异步与副作用（runInAction、flow、reactions）</a></h2>
<p>你将学到：</p>
<ul>
<li>在网络请求/定时/订阅中安全更新状态</li>
<li><code>runInAction</code> 与 <code>flow</code> 的选择与类型化</li>
<li><code>autorun</code>/<code>reaction</code>/<code>when</code> 的使用边界与释放</li>
</ul>
<p>示例：runInAction</p>
<pre><code class="language-ts">import { makeAutoObservable, runInAction } from 'mobx'
import axios from 'axios'

class UserStore {
  loading = false
  users: { id: number; name: string }[] = []
  error: string | null = null
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  async fetch() {
    this.loading = true; this.error = null
    try {
      const { data } = await axios.get('/api/users')
      runInAction(() =&gt; { this.users = data })
    } catch (e: any) {
      runInAction(() =&gt; { this.error = e?.message ?? '请求失败' })
    } finally {
      runInAction(() =&gt; { this.loading = false })
    }
  }
}
</code></pre>
<p>示例：flow（取消友好、类型直观）</p>
<pre><code class="language-ts">import { flow, makeAutoObservable } from 'mobx'
class ProductStore {
  loading = false; list: any[] = []
  constructor(){ makeAutoObservable(this, { load: flow }, { autoBind: true }) }
  *load() { // Generator
    this.loading = true
    try { const res: any = yield fetch('/api/products').then(r =&gt; r.json()); this.list = res }
    finally { this.loading = false }
  }
}
</code></pre>
<p>副作用与清理：</p>
<pre><code class="language-ts">import { autorun, reaction, when } from 'mobx'
const dispose = autorun(() =&gt; console.log('count changed'))
const disposeR = reaction(() =&gt; store.count, (c) =&gt; console.log('now', c))
when(() =&gt; store.ready, () =&gt; console.log('ready!'))
// 组件卸载或场景结束时调用 dispose()/disposeR() 释放
</code></pre>
<p>经验法则：</p>
<ul>
<li>UI 更新放在 observer 组件中；业务副作用放在 reactions 中</li>
<li>批量状态更新优先放 action/runInAction 内，减少多次通知</li>
<li>flow 可被取消；避免将长链请求写在 autorun 内</li>
</ul>
<hr />
<h2 id="模块四状态建模与架构domain-stores边界与持久化"><a class="header" href="#模块四状态建模与架构domain-stores边界与持久化">模块四：状态建模与架构（Domain Stores、边界与持久化）</a></h2>
<p>你将学到：</p>
<ul>
<li>UI 局部状态 vs 领域全局状态的切分</li>
<li>Domain Store 之间的依赖与组合（RootStore/依赖注入）</li>
<li>规范：派生优先、引用用 id、可变集合用 Map/Set</li>
<li>持久化与水合：localStorage/IndexedDB、以及黑名单/白名单字段</li>
</ul>
<p>Store 结构建议：</p>
<pre><code>src/
  store/
    root.ts        # RootStore 聚合
    todo.ts        # 领域状态 A
    user.ts        # 领域状态 B
    persist.ts     # 持久化适配器（可选）
</code></pre>
<p>持久化示例（mobx-persist-store）：</p>
<pre><code class="language-bash">npm i mobx-persist-store
</code></pre>
<pre><code class="language-ts">import { makePersistable, stopPersisting } from 'mobx-persist-store'
class AuthStore {
  token: string | null = null
  constructor(){
    makeAutoObservable(this, {}, { autoBind: true })
    makePersistable(this, { name: 'auth', properties: ['token'], storage: window.localStorage })
  }
  login(t: string){ this.token = t }
  logout(){ this.token = null; stopPersisting(this) }
}
</code></pre>
<hr />
<h2 id="模块五性能优化与调试观察粒度computedtracespy"><a class="header" href="#模块五性能优化与调试观察粒度computedtracespy">模块五：性能优化与调试（观察粒度、computed、trace/spy）</a></h2>
<p>你将学到：</p>
<ul>
<li>observer 边界：用小组件包裹可变区域，减少无关重渲染</li>
<li>computed 的缓存与等价策略；避免在 render 中大量 <code>toJS</code></li>
<li><code>untracked</code> 与 <code>keepAlive</code> 的适用场景</li>
<li>调试：<code>trace()</code>、<code>spy()</code> 定位依赖与通知链路</li>
</ul>
<p>经验法则：</p>
<ul>
<li>避免将大对象 <code>toJS</code> 传入子组件（破坏依赖颗粒度）</li>
<li>高频更新集合优先使用 <code>observable.map</code>/<code>set</code></li>
<li>昂贵派生抽成 <code>computed</code>，必要时 <code>({ equals: comparer.structural })</code></li>
</ul>
<p>调试示例：</p>
<pre><code class="language-ts">import { trace, spy } from 'mobx'
autorun(() =&gt; { trace(true); void store.count }) // 打印依赖追踪
spy(ev =&gt; { if (ev.type === 'action') console.log('action:', ev.name) })
</code></pre>
<hr />
<h2 id="模块六测试与质量保障"><a class="header" href="#模块六测试与质量保障">模块六：测试与质量保障</a></h2>
<p>你将学到：</p>
<ul>
<li>Store 单元测试与组件观察渲染测试</li>
<li>副作用（reaction/when）的可测试性与清理</li>
</ul>
<p>Store 单测（Vitest/Jest）：</p>
<pre><code class="language-ts">import { describe, it, expect } from 'vitest'
import { CounterStore } from './counter'

describe('CounterStore', () =&gt; {
  it('inc &amp; computed', () =&gt; {
    const s = new CounterStore()
    s.inc(); s.inc()
    expect(s.count).toBe(2)
    expect(s.double).toBe(4)
  })
})
</code></pre>
<p>组件测试（React Testing Library）：</p>
<pre><code class="language-tsx">import { render, screen, fireEvent } from '@testing-library/react'
import { RootStoreProvider } from '../store/root'
import { TodoList } from './TodoList'

test('add todo', () =&gt; {
  render(&lt;RootStoreProvider&gt;&lt;TodoList /&gt;&lt;/RootStoreProvider&gt;)
  fireEvent.change(screen.getByPlaceholderText('新任务'), { target: { value: '学习 MobX' } })
  fireEvent.click(screen.getByText('添加'))
  expect(screen.getByText('学习 MobX')).toBeInTheDocument()
})
</code></pre>
<hr />
<h2 id="模块七ssr-与-nextjs-集成"><a class="header" href="#模块七ssr-与-nextjs-集成">模块七：SSR 与 Next.js 集成</a></h2>
<p>你将学到：</p>
<ul>
<li>在服务端禁用响应式副作用：<code>enableStaticRendering(true)</code></li>
<li>每次请求实例化独立 RootStore，避免泄漏</li>
</ul>
<p>示例（App Router 思路相近）：</p>
<pre><code class="language-ts">// pages/_app.tsx
import type { AppProps } from 'next/app'
import { enableStaticRendering } from 'mobx-react-lite'
enableStaticRendering(typeof window === 'undefined')

export default function MyApp({ Component, pageProps }: AppProps){
  return &lt;Component {...pageProps} /&gt;
}
</code></pre>
<pre><code class="language-ts">// lib/store.ts — 每次请求创建
import { RootStore } from '../store/root'
export function initStore(snapshot?: Partial&lt;RootStore&gt;){ return new RootStore() }
</code></pre>
<p>避坑：</p>
<ul>
<li>Hydration mismatch：组件初始渲染不要使用非确定性值影响 DOM（如 <code>Date.now()</code>）</li>
<li>使用 <code>makeAutoObservable</code> 而非装饰器（Next 默认 TS 配置更友好）</li>
</ul>
<hr />
<h2 id="模块八与-redux-toolkit--zustand-的对比取舍建议"><a class="header" href="#模块八与-redux-toolkit--zustand-的对比取舍建议">模块八：与 Redux Toolkit / Zustand 的对比（取舍建议）</a></h2>
<ul>
<li>Redux Toolkit：不可变更新、时间旅行、生态完善；更适合大型协作与严格可追踪性诉求</li>
<li>Zustand：极简 API、选择器订阅粒度精细；适合中小规模与 hooks 化思维</li>
<li>MobX：响应式、面向对象/范式中立、心智简单；更快上手，派生表达力强</li>
</ul>
<p>选择建议：</p>
<ul>
<li>需要严格时光回溯/中间件生态 → RTK</li>
<li>需要最小 API 与选择器订阅 → Zustand</li>
<li>需要强派生表达力与响应式副作用 → MobX</li>
</ul>
<hr />
<h2 id="模块九typescript-集成与技巧"><a class="header" href="#模块九typescript-集成与技巧">模块九：TypeScript 集成与技巧</a></h2>
<ul>
<li>Store API 明确：对外只暴露方法与只读派生（<code>get</code>）</li>
<li>事件回调中的 <code>this</code>：<code>autoBind: true</code> 或箭头函数</li>
<li>使用 <code>as const</code> 与枚举管理枚举状态；<code>Map&lt;number, Entity&gt;</code> 存储可变集合</li>
<li><code>flow</code> 的类型：<code>*load(): Generator&lt;Promise&lt;any&gt;, void, Response&gt;</code> 可简化为 <code>any</code> 或封装返回 Promise</li>
</ul>
<hr />
<h2 id="实战案例迷你看板任务列拖拽--筛选"><a class="header" href="#实战案例迷你看板任务列拖拽--筛选">实战案例：迷你看板（任务列拖拽 + 筛选）</a></h2>
<p>目标：实现「待办/进行中/已完成」三列看板，支持添加任务、拖拽移动、标题搜索与统计。</p>
<p>数据结构：</p>
<pre><code class="language-ts">type Task = { id: string; title: string; status: 'todo' | 'doing' | 'done' }
class KanbanStore {
  tasks: Map&lt;string, Task&gt; = new Map()
  q = ''
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  get filtered(){ const q = this.q.toLowerCase(); return [...this.tasks.values()].filter(t =&gt; t.title.toLowerCase().includes(q)) }
  lane(s: Task['status']){ return this.filtered.filter(t =&gt; t.status === s) }
  add(title: string){ const id = String(Date.now()); this.tasks.set(id, { id, title, status: 'todo' }) }
  move(id: string, s: Task['status']){ const t = this.tasks.get(id); if (t) t.status = s }
  setQ(q: string){ this.q = q }
}
</code></pre>
<p>UI 要点：</p>
<ul>
<li><code>observer</code> 包裹列组件，列只观察对应 <code>lane(status)</code></li>
<li>拖拽库（如 <code>dnd-kit</code>）触发时调用 <code>store.move(id, status)</code></li>
<li>顶部 <code>SearchBox</code> 绑定 <code>q</code>，统计区用 <code>computed</code> 计算数量</li>
</ul>
<hr />
<h2 id="常见错误与解决方案速查"><a class="header" href="#常见错误与解决方案速查">常见错误与解决方案（速查）</a></h2>
<ul>
<li>修改状态不生效：未在 action 中修改；或未通过 observer 订阅导致视图不更新</li>
<li>组件频繁重渲染：observer 边界过大；在父组件中解构/生成新对象传递到子组件</li>
<li>computed 不更新：内部读取的字段不是 observable；或被 <code>untracked</code> 包裹</li>
<li>内存泄漏：创建了 autorun/reaction 未在卸载时 dispose</li>
<li>this 丢失：事件回调中方法未绑定；开启 <code>autoBind</code> 或使用箭头函数</li>
<li>滥用 <code>toJS</code>：大数据结构深拷贝昂贵且破坏依赖；仅在调试或序列化需要时使用</li>
</ul>
<hr />
<h2 id="学习成果验证标准量化"><a class="header" href="#学习成果验证标准量化">学习成果验证标准（量化）</a></h2>
<ol>
<li>能实现一个含增删改查、筛选与统计的 MobX Store，并通过 observer 正确驱动 UI</li>
<li>能使用 runInAction/flow 正确处理网络请求与错误态，避免竞态带来的 UI 反复跳变</li>
<li>能用 reaction/when 构建至少 2 处业务副作用，并在组件卸载时正确清理</li>
<li>组件边界优化：将高频变动区域拆到独立 observer 组件，渲染次数下降明显（Profiler 可见）</li>
<li>至少 5 个单元/组件测试用例覆盖核心状态变更与渲染</li>
</ol>
<hr />
<h2 id="扩展资源与工具清单"><a class="header" href="#扩展资源与工具清单">扩展资源与工具清单</a></h2>
<ul>
<li>官方文档：mobx.js.org、mobx-react-lite 文档</li>
<li>生态库：mobx-persist-store、mobx-keystone、mobx-state-tree（建模与快照）</li>
<li>调试：trace/spy、React Profiler、why-did-you-render（观察父子重渲染）</li>
<li>示例工程：TodoMVC（MobX 版本）、看板/电商案例</li>
</ul>
<hr />
<p>【版本与维护说明】</p>
<ul>
<li>最近更新：2025-11-02</li>
<li>适配版本：MobX v6、mobx-react-lite v4、TypeScript 5、React 18</li>
<li>建议每季度回顾：对比 Zustand/RTK 的新特性、SSR 改动与生态库演进</li>
</ul>
<hr />
<h2 id="深入原理响应式依赖图与调度"><a class="header" href="#深入原理响应式依赖图与调度">深入原理：响应式依赖图与调度</a></h2>
<p>为什么 MobX 简单且高效？核心在于“依赖图 + 细粒度订阅”。当一个派生（render、computed、autorun 的跟踪函数）第一次执行时，MobX 会记录它读取的每个 observable。后续这些 observable 的变更，会精准地通知到依赖该数据的派生，而非广播整棵树。</p>
<p>关键术语：</p>
<ul>
<li>Observable（可观察数据）：状态源头，读写都会被 MobX 捕捉。</li>
<li>Derivation（派生）：从状态推导出的值或副作用，如 computed、autorun、observer 包裹的 React 渲染。</li>
<li>Dependency Graph（依赖图）：observable → derivation 的有向图，指导通知与重算。</li>
<li>Transaction/Batch（事务/批量）：action 和 runInAction 会把多次变动合并成一次通知，降低抖动。</li>
</ul>
<p>更新流程（简化）：</p>
<ol>
<li>写入 observable → 标记“脏”。</li>
<li>进入批量阶段（若在 action 中） → 推迟派生重算。</li>
<li>批量结束 → 自底向上重算受影响的 derivations（computed 优先）。</li>
<li>推送变化到观察者（observer 组件触发重新渲染）。</li>
</ol>
<p>可视化技巧：</p>
<ul>
<li>在关键 render/autorun 内调用 <code>trace(true)</code>，观察哪些 observable 触发了重跑。</li>
<li>使用 <code>spy</code> 捕捉 action、reaction 等生命周期事件，定位过多通知的来源。</li>
</ul>
<hr />
<h2 id="注解体系全览makeautoobservable-与-makeobservable"><a class="header" href="#注解体系全览makeautoobservable-与-makeobservable">注解体系全览：makeAutoObservable 与 makeObservable</a></h2>
<p>选择建议：</p>
<ul>
<li>新项目优先 <code>makeAutoObservable</code>：默认深度 observable、自动绑定 this、最少样板代码。</li>
<li>需要精细控制字段注解或性能/语义边界 → 使用 <code>makeObservable</code> 显式注解。</li>
</ul>
<p>示例：makeObservable 精确标注</p>
<pre><code class="language-ts">import { makeObservable, observable, action, computed } from 'mobx'
class CartStore {
  items: Map&lt;string, { price: number; qty: number }&gt; = new Map()
  currency = 'CNY'
  constructor(){
    makeObservable(this, {
      items: observable.ref,   // 引用级变化（对 Map 本身引用变化才通知）
      currency: observable,    // 深度可观察
      total: computed,         // 纯派生
      add: action,             // 动作
      setCurrency: action.bound// 绑定 this 的动作
    })
  }
  get total(){
    let sum = 0
    for (const v of this.items.values()) sum += v.price * v.qty
    return sum
  }
  add(id: string, price: number, qty = 1){
    const cur = this.items.get(id)
    this.items.set(id, { price, qty: (cur?.qty ?? 0) + qty })
  }
  setCurrency(c: string){ this.currency = c }
}
</code></pre>
<p>常用注解模式：</p>
<ul>
<li><code>observable</code>（深度）：对象/数组字段内的嵌套也会被转为 observable。</li>
<li><code>observable.ref</code>：只在引用变化时通知（避免深度递归，适合大型不可变快照）。</li>
<li><code>observable.shallow</code>：一层可观察（集合内元素不深度代理）。</li>
<li><code>computed</code>：纯函数、无副作用、可缓存。</li>
<li><code>action</code>/<code>action.bound</code>：封装写操作并绑定 this。</li>
</ul>
<p>在 <code>makeAutoObservable</code> 中剔除字段：</p>
<pre><code class="language-ts">class VM {
  temp = new Map()
  constructor(){
    makeAutoObservable(this, { temp: false }) // 完全忽略 temp，不做 observable
  }
}
</code></pre>
<hr />
<h2 id="集合与数据结构mapsetarray-的最佳实践"><a class="header" href="#集合与数据结构mapsetarray-的最佳实践">集合与数据结构：Map/Set/Array 的最佳实践</a></h2>
<p>选择指南：</p>
<ul>
<li>频繁插入/删除/按 id 访问 → <code>observable.map</code> 优于对象字典。</li>
<li>需要唯一集合 → <code>observable.set</code>。</li>
<li>有序列表、排序/分页 → <code>observable.array</code>；重排时注意只改变必要位置。</li>
</ul>
<p>示例：以 Map 管理实体与索引</p>
<pre><code class="language-ts">import { makeAutoObservable } from 'mobx'
type User = { id: number; name: string; deptId: number }
class UserStore {
  byId = new Map&lt;number, User&gt;()
  byDept = new Map&lt;number, Set&lt;number&gt;&gt;()
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  add(u: User){
    this.byId.set(u.id, u)
    if (!this.byDept.has(u.deptId)) this.byDept.set(u.deptId, new Set())
    this.byDept.get(u.deptId)!.add(u.id)
  }
  usersOfDept(deptId: number){
    const ids = this.byDept.get(deptId)
    return ids ? [...ids].map(id =&gt; this.byId.get(id)!).filter(Boolean) : []
  }
}
</code></pre>
<p>等价性与派生刷新：</p>
<ul>
<li>对昂贵派生可使用 <code>computed(() =&gt; expr, { equals: comparer.structural })</code> 做结构等价。</li>
<li>注意结构等价会带来额外比较成本，须权衡数据体量与更新频率。</li>
</ul>
<hr />
<h2 id="响应控制interceptobserveuntrackedkeepalive"><a class="header" href="#响应控制interceptobserveuntrackedkeepalive">响应控制：intercept/observe、untracked、keepAlive</a></h2>
<p>精细化钩子：</p>
<ul>
<li><code>observe(target, listener)</code>: 监听集合/对象变化，适合日志、桥接外部系统。</li>
<li><code>intercept(target, handler)</code>: 拦截变更（可取消），用于约束不合法写入或审计。</li>
</ul>
<p>示例：阻止负库存</p>
<pre><code class="language-ts">import { intercept } from 'mobx'
intercept(stock.byId, change =&gt; {
  if (change.type === 'update' &amp;&amp; change.newValue.qty &lt; 0) return null // 取消
  return change
})
</code></pre>
<p>依赖边界：</p>
<ul>
<li><code>untracked(fn)</code>：在 fn 内的读取不被收集为依赖，防止无意订阅。</li>
<li><code>keepAlive(computedValue)</code>：保持某个 computed 即使无观察者也不被丢弃缓存，适合昂贵计算的热缓存。</li>
</ul>
<hr />
<h2 id="高级-react-集成observer-组件与边界划分"><a class="header" href="#高级-react-集成observer-组件与边界划分">高级 React 集成：Observer 组件与边界划分</a></h2>
<p>两种写法：</p>
<ul>
<li><code>observer(MyComp)</code>：高阶组件包装，最常用。</li>
<li><code>&lt;Observer&gt;{() =&gt; JSX}&lt;/Observer&gt;</code>：在大组件内只观察部分子树，控制重渲染范围。</li>
</ul>
<p>示例：大组件中仅观察表格区域</p>
<pre><code class="language-tsx">import { Observer } from 'mobx-react-lite'
function Page(){
  return (
    &lt;div&gt;
      &lt;Toolbar/&gt; {/* 非观察部分 */}
      &lt;Observer&gt;{() =&gt; &lt;DataTable data={store.filteredRows}/&gt;}&lt;/Observer&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>避免无关重渲染：</p>
<ul>
<li>不要在父组件 render 中 <code>toJS</code> 大对象传给子组件；改为在子组件内直接读取 store。</li>
<li>使用稳定引用的回调与数据；必要时将 <code>selector</code> 写成 computed。</li>
</ul>
<hr />
<h2 id="复杂异步并发取消与竞态收敛"><a class="header" href="#复杂异步并发取消与竞态收敛">复杂异步：并发、取消与竞态收敛</a></h2>
<p>问题：快速切换查询条件时，多次请求返回顺序不可控，容易“后到的旧结果覆盖新结果”。</p>
<p>方案一：请求序号/时间戳收敛</p>
<pre><code class="language-ts">class SearchStore {
  q = ''; seq = 0; result: any = null
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  async search(q: string){
    this.q = q
    const mySeq = ++this.seq
    const data = await api.search(q)
    if (mySeq === this.seq) this.result = data // 只有最新序号写入
  }
}
</code></pre>
<p>方案二：AbortController 取消</p>
<pre><code class="language-ts">class SearchStore2 {
  ctrl: AbortController | null = null
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  async search(q: string){
    this.ctrl?.abort(); this.ctrl = new AbortController()
    try {
      const data = await fetch(`/api?q=${encodeURIComponent(q)}`, { signal: this.ctrl.signal }).then(r =&gt; r.json())
      runInAction(() =&gt; this.result = data)
    } finally {
      this.ctrl = null
    }
  }
}
</code></pre>
<p>flow 取消：</p>
<pre><code class="language-ts">class S {
  load = flow(function* (this: S, id: string){
    const data = yield api.get(id)
    this.data = data
  })
}
// disposer.cancel() 可取消 generator（mobx-flow 内置）
</code></pre>
<hr />
<h2 id="架构模式domainui-store服务层与依赖注入"><a class="header" href="#架构模式domainui-store服务层与依赖注入">架构模式：Domain/UI Store、服务层与依赖注入</a></h2>
<p>分层建议：</p>
<ul>
<li>Domain Store：围绕业务实体（User/Todo/Order…）组织，方法即业务语义；对外不暴露可变内部结构。</li>
<li>UI Store：页面/组件级状态（筛选条件、对话框显隐、分页等）。</li>
<li>Service/Repository：网络与缓存等 I/O 抽象层；Store 组合服务而非直接发请求，便于测试与复用。</li>
</ul>
<p>RootStore 注入：</p>
<pre><code class="language-ts">class RootStore {
  readonly services = new Services()
  readonly user = new UserStore(this)
  readonly order = new OrderStore(this)
}
class UserStore { constructor(private root: RootStore){} /* 可访问 root.services */ }
</code></pre>
<p>边界规则：</p>
<ul>
<li>Store 之间通过方法通信，少量读取引用可接受；避免循环依赖的强绑定。</li>
<li>领域对象用 id 关联，跨 Store 派生时以 id 查表避免深层引用耦合。</li>
</ul>
<hr />
<h2 id="持久化与水合策略与黑白名单"><a class="header" href="#持久化与水合策略与黑白名单">持久化与水合：策略与黑白名单</a></h2>
<p>常见诉求：登录态、用户偏好、草稿等需要持久化；但网络数据（可来自服务端）可不持久化以降低复杂度。</p>
<p>策略：</p>
<ul>
<li>白名单字段：仅持久化 <code>token/theme/lang</code> 等简单字段，避免大型集合写入本地。</li>
<li>版本化存储：为本地存储加 <code>schemaVersion</code>，迁移时做兼容清理。</li>
</ul>
<p>示例：自定义持久化适配</p>
<pre><code class="language-ts">class PrefStore {
  theme: 'light'|'dark' = 'light'
  lang = 'zh-CN'
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }); this.hydrate() }
  hydrate(){
    const raw = localStorage.getItem('pref:v1')
    if (raw) Object.assign(this, JSON.parse(raw))
  }
  save(){ localStorage.setItem('pref:v1', JSON.stringify({ theme: this.theme, lang: this.lang })) }
  setTheme(t: 'light'|'dark'){ this.theme = t; this.save() }
}
</code></pre>
<hr />
<h2 id="性能专章量化与实践清单"><a class="header" href="#性能专章量化与实践清单">性能专章：量化与实践清单</a></h2>
<p>量化手段：</p>
<ul>
<li>React Profiler：对比重渲染次数与耗时。</li>
<li><code>spy</code>/<code>trace</code>：确认通知链是否符合预期，是否存在“非预期订阅”。</li>
</ul>
<p>实践清单：</p>
<ul>
<li>小组件多 observer，避免把大页面一个 observer 包住。</li>
<li>将昂贵计算改为 computed，并在 UI 中只读结果。</li>
<li>使用 <code>observable.map/set</code> 管理大集合；避免频繁重建数组导致大面积订阅更新。</li>
<li>避免在 render 中创建新函数/对象作为 props 传递；必要时在子组件内读取 store。</li>
</ul>
<p>参数化派生：mobx-utils 的 <code>computedFn</code></p>
<pre><code class="language-ts">import { computedFn } from 'mobx-utils'
const getUserByDept = computedFn((deptId: number) =&gt; store.usersOfDept(deptId))
// 多次相同参数调用复用缓存
</code></pre>
<hr />
<h2 id="typescript-实用技巧汇编"><a class="header" href="#typescript-实用技巧汇编">TypeScript 实用技巧汇编</a></h2>
<ul>
<li>Store API 最小暴露：通过返回只读接口避免外部写入。</li>
</ul>
<pre><code class="language-ts">type ReadonlyCounter = Pick&lt;CounterStore, 'inc'|'double'|'count'&gt;
</code></pre>
<ul>
<li>事件回调 <code>this</code>：<code>action.bound</code> 或构造时 <code>autoBind: true</code>。</li>
<li>枚举状态：</li>
</ul>
<pre><code class="language-ts">export const OrderState = { Draft:'Draft', Paid:'Paid', Shipped:'Shipped' } as const
export type OrderState = typeof OrderState[keyof typeof OrderState]
</code></pre>
<ul>
<li>flow 类型：在项目内统一封装，暴露 Promise 接口以利调用方。</li>
</ul>
<hr />
<h2 id="测试策略与样板"><a class="header" href="#测试策略与样板">测试策略与样板</a></h2>
<p>派生稳定性测试：</p>
<pre><code class="language-ts">import { reaction } from 'mobx'
it('only react when price changes', () =&gt; {
  const fired: number[] = []
  const d = reaction(() =&gt; store.total, v =&gt; fired.push(v))
  store.add('a', 10, 1)
  store.setCurrency('USD') // 不应触发 total
  expect(fired.length).toBe(1)
  d()
})
</code></pre>
<p>组件测试要点：</p>
<ul>
<li>用 Provider 包装，测试用户行为而非内部实现。</li>
<li>使用 <code>act</code> 包裹触发异步后的断言，等待 UI 稳态。</li>
</ul>
<hr />
<h2 id="生产运维与可观测性"><a class="header" href="#生产运维与可观测性">生产运维与可观测性</a></h2>
<ul>
<li>行为日志：在 action 层统一打点，结合 <code>spy</code> 采样关键操作，辅助问题回放。</li>
<li>错误兜底：在 Service 层标准化错误结构，Store 只处理统一格式，避免分支爆炸。</li>
<li>限流退避：对高频 reaction/搜索框输入，使用 <code>debounce</code> 或 <code>scheduler</code>（mobx-utils）降低系统抖动。</li>
</ul>
<hr />
<h2 id="进阶案例电商商品目录筛选排序分页收藏"><a class="header" href="#进阶案例电商商品目录筛选排序分页收藏">进阶案例：电商商品目录（筛选/排序/分页/收藏）</a></h2>
<p>目标：</p>
<ul>
<li>实现多条件筛选（分类、品牌、价位、库存）、多字段排序、分页、收藏与持久化。</li>
<li>要求：列表与汇总统计均由 computed 推导；网络请求具备竞态收敛；UI 分区 observer 控制重渲染。</li>
</ul>
<p>核心数据与派生：</p>
<pre><code class="language-ts">type Product = { id:number; title:string; brand:string; cat:string; price:number; stock:number }
class CatalogStore {
  raw: Product[] = []
  q = ''; cat: string|undefined; brand: string|undefined
  sort: { key: 'price'|'stock'|'title'; dir: 'asc'|'desc' } = { key:'price', dir:'asc' }
  page = 1; pageSize = 20
  fav = new Set&lt;number&gt;()
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  get filtered(){
    const q = this.q.trim().toLowerCase()
    return this.raw.filter(p =&gt;
      (!q || p.title.toLowerCase().includes(q)) &amp;&amp;
      (!this.cat || p.cat === this.cat) &amp;&amp;
      (!this.brand || p.brand === this.brand)
    )
  }
  get sorted(){
    const arr = [...this.filtered]
    const { key, dir } = this.sort
    arr.sort((a,b) =&gt; (a[key] &gt; b[key] ? 1 : -1) * (dir==='asc'?1:-1))
    return arr
  }
  get pageCount(){ return Math.ceil(this.sorted.length / this.pageSize) }
  get pageData(){
    const s = (this.page-1)*this.pageSize
    return this.sorted.slice(s, s+this.pageSize)
  }
  toggleFav(id: number){ this.fav.has(id) ? this.fav.delete(id) : this.fav.add(id) }
  setQuery(q:string){ this.q = q; this.page = 1 }
  setSort(key: CatalogStore['sort']['key'], dir: 'asc'|'desc'){ this.sort = { key, dir } }
  setPage(p:number){ this.page = p }
}
</code></pre>
<p>UI 分区：</p>
<ul>
<li>顶部筛选条（observer）只观察查询与派生统计。</li>
<li>列表区（observer）只观察 <code>pageData</code> 与 <code>fav</code>。</li>
<li>分页器（observer）只观察 <code>page/pageCount</code>。</li>
</ul>
<p>验证标准：</p>
<ul>
<li>输入框快速输入不导致卡顿（Profiler 中渲染时间稳定）。</li>
<li>切换排序仅引发列表组件重渲染，不影响筛选条与分页器。</li>
</ul>
<hr />
<h2 id="迁移与兼容从装饰器到-v6"><a class="header" href="#迁移与兼容从装饰器到-v6">迁移与兼容：从装饰器到 v6</a></h2>
<ul>
<li>v6 推荐放弃装饰器，转向 <code>makeAutoObservable</code>/<code>makeObservable</code>，减少 TS 配置和构建负担。</li>
<li>如果历史项目仍用装饰器：确保启用 <code>experimentalDecorators</code>，并注意 SSR/打包器对装饰器的支持差异。</li>
</ul>
<hr />
<h2 id="学习与实践路线可执行"><a class="header" href="#学习与实践路线可执行">学习与实践路线（可执行）</a></h2>
<p>阶段 1（1 天）：</p>
<ul>
<li>完成 Counter/Todo 练习，掌握 observable/computed/action 与 observer。</li>
<li>用 <code>trace/spy</code> 观察依赖与通知路径。</li>
</ul>
<p>阶段 2（2 天）：</p>
<ul>
<li>引入 Service 层，完成 User/Product 异步加载、错误与并发收敛处理。</li>
<li>编写 6+ 单测覆盖 store 与基本组件。</li>
</ul>
<p>阶段 3（2 天）：</p>
<ul>
<li>拆分 Domain/UI Store，完成看板或电商目录案例；优化 observer 边界与 computed。</li>
<li>增加本地持久化（白名单字段），并在测试中验证水合准确性。</li>
</ul>
<p>阶段 4（1 天）：</p>
<ul>
<li>接入 Next.js，验证 SSR/Hydration；补齐路由切换与取消逻辑。</li>
</ul>
<p>交付物清单：</p>
<ul>
<li>完整项目代码 + README（架构说明/运行方式/测试覆盖）。</li>
<li>测试报告（关键路径与性能截图）。</li>
<li>经验总结（踩坑与优化项）。</li>
</ul>
<hr />
<h2 id="表单状态管理可验证的复杂表单"><a class="header" href="#表单状态管理可验证的复杂表单">表单状态管理：可验证的复杂表单</a></h2>
<p>目标：</p>
<ul>
<li>支持即时校验、跨字段依赖、服务器校验（如用户名是否存在）、草稿持久化与提交后重置。</li>
</ul>
<p>表单 VM 模式：</p>
<pre><code class="language-ts">import { makeAutoObservable, runInAction } from 'mobx'
import * as z from 'zod'

const schema = z.object({
  username: z.string().min(3),
  email: z.string().email(),
  password: z.string().min(8)
})

class SignUpVM {
  values = { username: '', email: '', password: '' }
  errors: Partial&lt;Record&lt;keyof typeof this.values, string&gt;&gt; = {}
  submitting = false
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  set&lt;K extends keyof typeof this.values&gt;(k: K, v: (typeof this.values)[K]){
    this.values[k] = v; this.validate()
  }
  validate(){
    const r = schema.safeParse(this.values)
    this.errors = r.success ? {} : Object.fromEntries(r.error.issues.map(i =&gt; [i.path[0] as string, i.message]))
  }
  get valid(){ return Object.keys(this.errors).length === 0 }
  async submit(){
    this.validate(); if (!this.valid) return
    this.submitting = true
    try {
      await api.signUp(this.values)
      runInAction(() =&gt; { this.values = { username:'', email:'', password:'' } })
    } finally { this.submitting = false }
  }
}
</code></pre>
<p>要点：</p>
<ul>
<li>采用 VM（ViewModel）承载表单状态与校验逻辑，组件只绑定字段与显示错误。</li>
<li>可在 <code>reaction(() =&gt; vm.values.username, ...)</code> 中引入去抖后端校验（重名检测）。</li>
<li>草稿用本地存储白名单字段保存，提交成功后清理。</li>
</ul>
<hr />
<h2 id="与-tanstack-query-协作服务器状态-vs-客户端状态"><a class="header" href="#与-tanstack-query-协作服务器状态-vs-客户端状态">与 TanStack Query 协作：服务器状态 vs 客户端状态</a></h2>
<p>推荐分工：</p>
<ul>
<li>服务器状态（可重新获取、过期失效、缓存策略） → 交给 Query；</li>
<li>客户端状态（UI 控制、选择集、跨组件派生） → 交给 MobX。</li>
</ul>
<p>桥接模式：</p>
<pre><code class="language-ts">function useProducts(){
  const q = useQuery({ queryKey:['products'], queryFn: api.list })
  // 在 MobX 派生中消费 q.data，避免把整个数据 toJS 传下去
  return q
}

const vm = useLocalObservable(() =&gt; new CatalogStore())
const products = useProducts()
// UI 层将 products.data 写入 vm.raw（一次性），其余筛选/分页用 MobX 派生完成
useEffect(() =&gt; { if (products.data) vm.raw = products.data }, [products.data])
</code></pre>
<p>经验：</p>
<ul>
<li>避免重复缓存：同一份服务端数据不要同时持久化到本地与 Query 缓存。</li>
<li>MobX 派生做“视图型聚合”（筛选、排序、统计），Query 负责“时效与刷新”。</li>
</ul>
<hr />
<h2 id="复杂派生图案例预算与报表"><a class="header" href="#复杂派生图案例预算与报表">复杂派生图案例：预算与报表</a></h2>
<p>场景：部门预算（预算项、实际支出、回款），需要随筛选维度（部门/时间区间/科目）即时汇总并导出。</p>
<p>设计：</p>
<ul>
<li>原子数据：<code>entries: { id, dept, subject, amount, type: 'budget'|'expense'|'return', date }[]</code></li>
<li>维度筛选：<code>filter = { depts: string[], range: [Date, Date], subjects: string[] }</code></li>
<li>派生：
<ul>
<li><code>filtered = entries.filter(...)</code></li>
<li><code>summaryByDept = group(filtered, 'dept')</code></li>
<li><code>summaryBySubject = group(filtered, 'subject')</code></li>
<li><code>delta = budget - expense + return</code></li>
</ul>
</li>
</ul>
<p>代码要点：</p>
<ul>
<li><code>group</code> 结果缓存为 computed，避免每次导出重算。</li>
<li>跨维度派生拆分为多个 computed，小粒度复用。</li>
</ul>
<hr />
<h2 id="调度与节流mobx-utils-工具箱"><a class="header" href="#调度与节流mobx-utils-工具箱">调度与节流：mobx-utils 工具箱</a></h2>
<p>常用能力：</p>
<ul>
<li><code>fromPromise(promise)</code>：把 Promise 转为可观察对象（<code>state</code>/<code>value</code>/<code>case</code>）。</li>
<li><code>now(interval)</code>：返回周期自增的时间戳，适合心跳型 UI。</li>
<li><code>throttle(func, delay)</code> / <code>debounce(func, delay)</code>：对高频副作用限流。</li>
<li><code>lazyObservable</code>：按需加载并缓存。</li>
</ul>
<p>示例：可观察 Promise</p>
<pre><code class="language-ts">import { fromPromise } from 'mobx-utils'
class AsyncVM {
  user = fromPromise(api.me())
  get name(){ return this.user.case({
    fulfilled: (v) =&gt; v.name,
    pending:   () =&gt; 'Loading...',
    rejected:  (e) =&gt; 'Error'
  })}
}
</code></pre>
<hr />
<h2 id="撤销重做undoredo基础模式"><a class="header" href="#撤销重做undoredo基础模式">撤销/重做（Undo/Redo）基础模式</a></h2>
<p>轻量策略：</p>
<ul>
<li>对小体量数据使用快照栈：每次 action 前后存入 <code>JSON.stringify(state)</code>，配合 <code>observable.ref</code> 避免深变更追踪。</li>
<li>对大体量数据记录意图（Command Pattern）：为操作定义反向操作（如 <code>add</code> 的逆为 <code>remove</code>）。</li>
</ul>
<p>示例：快照栈（演示用）</p>
<pre><code class="language-ts">class History&lt;T&gt; {
  past: T[] = []
  future: T[] = []
  push(s: T){ this.past.push(s); this.future = [] }
  undo(cur: T){ const p = this.past.pop(); if (!p) return cur; this.future.push(cur); return p }
  redo(cur: T){ const f = this.future.pop(); if (!f) return cur; this.past.push(cur); return f }
}
</code></pre>
<hr />
<h2 id="anti-patterns-对照表避免踩坑"><a class="header" href="#anti-patterns-对照表避免踩坑">Anti-Patterns 对照表（避免踩坑）</a></h2>
<ul>
<li>在 render 中到处 <code>toJS</code> → 破坏依赖颗粒度，导致全量重渲染。</li>
<li>把大型远端数据同时放在 Query 与 MobX → 双份缓存、状态竞争。</li>
<li>在 autorun 中写状态 → 容易形成反馈环，应将写操作放到 action 或 reaction 的 effect 中。</li>
<li>滥用全局单例 Store → 测试困难、耦合紧；优先 RootStore 构造与 Context 注入。</li>
<li>在非观察组件中读取 store → 视图不更新。</li>
</ul>
<hr />
<h2 id="api-速查常用片段"><a class="header" href="#api-速查常用片段">API 速查（常用片段）</a></h2>
<ul>
<li><code>configure({ enforceActions: 'always'|'observed'|'never' })</code>：控制是否必须在 action 中修改状态。</li>
<li><code>runInAction(() =&gt; { ... })</code>：事务化更新状态。</li>
<li><code>autorun(() =&gt; { expr })</code>：首次与依赖变更时执行；返回 disposer。</li>
<li><code>reaction(() =&gt; data, (data, prev) =&gt; { effect })</code>：数据变化时执行 effect；更精确。</li>
<li><code>when(() =&gt; cond, () =&gt; effect())</code>：条件满足一次后执行 effect，并自动清理。</li>
<li><code>onBecomeObserved/Unobserved(obj, prop, handler)</code>：某字段被观察/不再被观察时触发。</li>
</ul>
<hr />
<h2 id="实训任务清单可提交作品"><a class="header" href="#实训任务清单可提交作品">实训任务清单（可提交作品）</a></h2>
<p>任务 A：多条件筛选商品目录（上文进阶案例）</p>
<ul>
<li>要求：Query + MobX 协作、并发收敛、分页、收藏、10+ 单测。</li>
</ul>
<p>任务 B：团队看板</p>
<ul>
<li>要求：拖拽排序、泳道统计、搜索与过滤、持久化偏好、性能分析报告。</li>
</ul>
<p>任务 C：SSR 博客</p>
<ul>
<li>要求：Next.js SSR、分类/标签过滤、阅读进度、草稿模式、Hydration 无警告。</li>
</ul>
<p>评分标准（建议）：</p>
<ul>
<li>架构清晰度（20%）/ 功能完备性（25%）/ 性能与可维护性（25%）/ 测试与文档（20%）/ 代码风格（10%）。</li>
</ul>
<hr />
<h2 id="实时系统websocket订阅推送与一致性"><a class="header" href="#实时系统websocket订阅推送与一致性">实时系统：WebSocket/订阅推送与一致性</a></h2>
<p>要点：</p>
<ul>
<li>将推送事件转换为 action，确保所有状态变更在 action 内批量执行。</li>
<li>服务器为权威数据源，客户端以 id 合并本地：新增/更新/删除三类事件。</li>
<li>对列表分页/筛选视图：只更新受影响项的集合，避免重建整表。</li>
</ul>
<p>示例：</p>
<pre><code class="language-ts">class LiveOrderStore {
  byId = new Map&lt;number, Order&gt;()
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  onEvent(ev: { type:'created'|'updated'|'deleted'; data: Order }){
    runInAction(() =&gt; {
      if (ev.type === 'deleted') this.byId.delete(ev.data.id)
      else this.byId.set(ev.data.id, { ...this.byId.get(ev.data.id), ...ev.data })
    })
  }
}
</code></pre>
<p>避免重复：</p>
<ul>
<li>对来自自己客户端的写操作，服务器回推时可用 <code>lastMutationId</code> 去重。</li>
</ul>
<hr />
<h2 id="模块化与微前端跨应用通信"><a class="header" href="#模块化与微前端跨应用通信">模块化与微前端：跨应用通信</a></h2>
<p>场景：多个子应用各自维护 Store，需要暴露有限 API 给宿主调用。</p>
<p>建议：</p>
<ul>
<li>以接口暴露只读派生与行为方法，不泄漏内部可变数据结构。</li>
<li>以事件总线/自定义事件桥接，或以 <code>postMessage</code> 跨 iframe 通信。</li>
</ul>
<p>示例接口：</p>
<pre><code class="language-ts">export interface UserPanelAPI {
  open(userId: number): void
  on(event: 'close'|'saved', cb: () =&gt; void): () =&gt; void
}
</code></pre>
<hr />
<h2 id="权限与特性开关feature-flags"><a class="header" href="#权限与特性开关feature-flags">权限与特性开关（Feature Flags）</a></h2>
<p>模式：</p>
<ul>
<li><code>AuthStore</code> 提供角色与权限集合；<code>FlagStore</code> 维护实验开关；</li>
<li>业务派生根据权限过滤功能菜单与按钮显隐；</li>
<li>SSR 下在服务端注入首屏所需权限，避免闪烁。</li>
</ul>
<p>示例：</p>
<pre><code class="language-ts">class FlagStore { flags = new Set&lt;string&gt;(); constructor(){ makeAutoObservable(this) } has(k:string){ return this.flags.has(k) } }
class MenuStore {
  constructor(private auth: AuthStore, private flags: FlagStore){ makeAutoObservable(this, {}, { autoBind: true }) }
  get visibleItems(){ return ALL_ITEMS.filter(i =&gt; this.auth.can(i.perm) &amp;&amp; (!i.flag || this.flags.has(i.flag))) }
}
</code></pre>
<hr />
<h2 id="国际化i18n与本地化l10n"><a class="header" href="#国际化i18n与本地化l10n">国际化（i18n）与本地化（l10n）</a></h2>
<p>要点：</p>
<ul>
<li><code>I18nStore</code> 维护当前语言与资源包；</li>
<li>UI 通过 computed 拼装带参数的文案；</li>
<li>切换语言只需更新 <code>lang</code> 与资源，observer 组件自动重渲染。</li>
</ul>
<p>示例：</p>
<pre><code class="language-ts">class I18nStore {
  lang: 'zh'|'en' = 'zh'
  res: Record&lt;string, string&gt; = {}
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  t(k: string, params?: Record&lt;string, string&gt;){
    let s = this.res[k] ?? k
    if (params) for (const [k,v] of Object.entries(params)) s = s.replaceAll(`{${k}}`, v)
    return s
  }
}
</code></pre>
<hr />
<h2 id="事件建模可观察领域事件流"><a class="header" href="#事件建模可观察领域事件流">事件建模：可观察领域事件流</a></h2>
<p>目的：把关键业务变化（订单创建、支付完成）作为事件序列，以 reaction 触发边界动作（日志、埋点、消息、二次派生）。</p>
<p>示例：</p>
<pre><code class="language-ts">type DomainEvent = { name:'order.created'|'order.paid'; payload:any; at:number }
class EventBus {
  list: DomainEvent[] = []
  constructor(){ makeAutoObservable(this) }
  emit(e: DomainEvent){ this.list.push(e) }
}
reaction(
  () =&gt; bus.list.length,
  () =&gt; {
    const e = bus.list.at(-1)!; switch(e.name){
      case 'order.paid': analytics.track('order_paid', e.payload); break
    }
  }
)
</code></pre>
<hr />
<h2 id="从-redux-迁移到-mobx-的实践"><a class="header" href="#从-redux-迁移到-mobx-的实践">从 Redux 迁移到 MobX 的实践</a></h2>
<p>对照：</p>
<ul>
<li>Reducer → Store 类；Action Creator → Store 方法；Selector → computed。</li>
<li>中间件 → Service/Reaction；Thunk → action/flow。</li>
</ul>
<p>迁移步骤：</p>
<ol>
<li>先迁移只读派生（selector → computed），保持 UI 使用相同选择语义。</li>
<li>把 reducer 的 case 合并为语义化方法（<code>addItem/removeItem</code>），在方法中执行可变更新。</li>
<li>边界处理：把复杂副作用迁移为 Service + reaction。</li>
<li>渐进替换：路由/页面为单位，逐屏迁移。</li>
</ol>
<hr />
<h2 id="重构检查清单review-checklist"><a class="header" href="#重构检查清单review-checklist">重构检查清单（Review Checklist）</a></h2>
<ul>
<li>Store 对外是否仅暴露语义方法与只读派生？</li>
<li>是否存在“大而全”单体 Store？能否按领域拆分？</li>
<li>observer 边界是否过大？高频变化点是否拆分？</li>
<li>是否存在 render 中 <code>toJS</code>/<code>JSON.stringify</code> 等昂贵操作？</li>
<li>是否存在 <code>autorun</code> 写状态导致反馈环？</li>
<li>是否存在未 dispose 的 reaction/autorun？</li>
</ul>
<hr />
<h2 id="常见问答faq精选"><a class="header" href="#常见问答faq精选">常见问答（FAQ，精选）</a></h2>
<p>Q1：为什么 observer 包裹后组件还是不更新？
A：确认组件函数内是否真的读取了 observable 字段；若通过 props 传入，请确保传入的是 observable 字段或 computed，避免父组件中 toJS。</p>
<p>Q2：computed 何时会被重算？
A：当其依赖集合之一变更时，并且下一次有观察者访问它时；MobX 会在读取时按需重算并缓存。</p>
<p>Q3：action 一定必要吗？
A：推荐开启 <code>enforceActions: 'observed'</code> 或更严格，以保证所有写操作集中在 action，提高可观测性与可维护性。</p>
<p>Q4：如何避免“后到的旧请求覆盖新结果”？
A：使用请求序号收敛或 AbortController 取消；或使用 Query 的 <code>staleTime</code> 与 <code>refetchOn...</code> 策略。</p>
<p>Q5：如何在大型表格中保持高性能？
A：虚拟滚动（react-virtual）、按列 observer、行级 observer、computed 选择器、避免把整表数据以新引用传给子组件。</p>
<p>Q6：如何跨页面共享临时状态？
A：放入 RootStore 的 UI Store，并在路由变化时按需重置。</p>
<p>Q7：能否时间旅行调试？
A：MobX 本身无内建时间旅行。可在 action 层记录快照或意图命令，成本取舍见“撤销/重做”。</p>
<p>Q8：如何在严格模式中更新？
A：在 <code>configure({ enforceActions:'always' })</code> 下，所有写入必须放在 <code>action/runInAction/flow</code> 内。</p>
<hr />
<h2 id="术语表glossary"><a class="header" href="#术语表glossary">术语表（Glossary）</a></h2>
<ul>
<li>Observable：可观察的状态源。</li>
<li>Derivation：从状态推导出的值或副作用（computed/render/reaction）。</li>
<li>Reaction：响应依赖变化的副作用执行单元（autorun/reaction/when）。</li>
<li>Batch/Transaction：批量更新阶段，降低通知次数。</li>
<li>Hydration：把持久化或 SSR 快照注入运行时状态。</li>
</ul>
<hr />
<h2 id="附录示例项目结构建议"><a class="header" href="#附录示例项目结构建议">附录：示例项目结构（建议）</a></h2>
<pre><code>src/
  app/
    providers.tsx        # RootStoreProvider + 其他全局上下文
    routes/              # 路由与页面
  store/
    root.ts              # RootStore 聚合与注入
    user.ts              # 领域 store：用户
    product.ts           # 领域 store：商品
    cart.ts              # 领域 store：购物车
    ui/
      catalog.ts         # UI store：商品目录筛选与分页
      modal.ts           # UI store：弹窗显隐
  services/
    http.ts              # axios/fetch 封装、拦截器、错误标准化
    user.ts              # 用户 API
    product.ts           # 商品 API
  components/            # 观察组件
  pages/                 # 页面组合
  tests/                 # 单测与组件测试
</code></pre>
<hr />
<h2 id="参考与延伸阅读建议收藏"><a class="header" href="#参考与延伸阅读建议收藏">参考与延伸阅读（建议收藏）</a></h2>
<ul>
<li>官方：mobx.js.org、mobx-react-lite 文档与示例仓库</li>
<li>工具：mobx-utils、mobx-persist-store、mobx-keystone、mst</li>
<li>文章：State of JS 调研对比、响应式系统设计、渲染性能分析实践</li>
<li>视频：MobX 作者分享、React 性能优化实战</li>
</ul>
<hr />
<h2 id="端到端脚手架可复制到项目"><a class="header" href="#端到端脚手架可复制到项目">端到端脚手架（可复制到项目）</a></h2>
<p>目标：提供一套 MobX + React 18 + TypeScript + Next.js/CSR 通用脚手架片段，覆盖鉴权、服务封装、错误边界、全局注入、SSR/Hydration、实时推送、测试样板。</p>
<p>项目结构建议：</p>
<pre><code>src/
  app/
    providers.tsx         # RootStoreProvider + 主题/路由/国际化
  components/
    ErrorBoundary.tsx
    Loading.tsx
    Guard.tsx
  pages/                  # 若使用 Next.js Pages Router
    _app.tsx
    index.tsx
    login.tsx
  services/
    http.ts               # fetch/axios 封装、拦截器
    auth.ts               # 鉴权 API
    product.ts            # 业务 API
    ws.ts                 # WebSocket 封装
  store/
    root.ts
    auth.ts
    product.ts
    ui/
      layout.ts
  tests/
    auth.spec.ts
    product.spec.ts
</code></pre>
<p>服务层封装（以 fetch 为例）：</p>
<pre><code class="language-ts">// src/services/http.ts
export type HttpError = { code: string; message: string; status: number }

export class HttpClient {
  constructor(private base = '', private getToken?: () =&gt; string | null) {}
  async request&lt;T&gt;(path: string, init: RequestInit = {}): Promise&lt;T&gt; {
    const headers: HeadersInit = { 'Content-Type': 'application/json', ...(init.headers || {}) }
    const token = this.getToken?.()
    if (token) (headers as any).Authorization = `Bearer ${token}`
    const res = await fetch(`${this.base}${path}`, { ...init, headers })
    const text = await res.text()
    const json = text ? JSON.parse(text) : undefined
    if (!res.ok) throw { status: res.status, code: json?.code ?? 'HTTP_ERROR', message: json?.message ?? res.statusText } as HttpError
    return json as T
  }
  get&lt;T&gt;(p: string){ return this.request&lt;T&gt;(p) }
  post&lt;T&gt;(p: string, body: any){ return this.request&lt;T&gt;(p, { method: 'POST', body: JSON.stringify(body) }) }
}
</code></pre>
<p>鉴权 Store：</p>
<pre><code class="language-ts">// src/store/auth.ts
import { makeAutoObservable, runInAction } from 'mobx'
import { HttpClient } from '../services/http'

type User = { id:number; name:string; role:string }
export class AuthStore {
  token: string | null = null
  me: User | null = null
  loading = false
  client = new HttpClient('/api', () =&gt; this.token)
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }); this.hydrate() }
  hydrate(){ const raw = localStorage.getItem('auth:v1'); if(raw){ const s = JSON.parse(raw); this.token = s.token; this.me = s.me } }
  persist(){ localStorage.setItem('auth:v1', JSON.stringify({ token:this.token, me:this.me })) }
  async login(username: string, password: string){
    this.loading = true
    try {
      const { token, user } = await this.client.post&lt;{token:string; user:User}&gt;('/login', { username, password })
      runInAction(() =&gt; { this.token = token; this.me = user; this.persist() })
    } finally { this.loading = false }
  }
  logout(){ this.token = null; this.me = null; localStorage.removeItem('auth:v1') }
  get isAuthed(){ return !!this.token }
  can(perm: string){ return this.me?.role === 'admin' || false }
}
</code></pre>
<p>RootStore 与注入：</p>
<pre><code class="language-tsx">// src/store/root.ts
import { createContext, useContext } from 'react'
import { AuthStore } from './auth'
import { ProductStore } from './product'

export class RootStore {
  readonly auth = new AuthStore()
  readonly product = new ProductStore(this)
}
const Ctx = createContext&lt;RootStore | null&gt;(null)
export const RootStoreProvider = ({ children }: { children: React.ReactNode }) =&gt; (
  &lt;Ctx.Provider value={new RootStore()}&gt;{children}&lt;/Ctx.Provider&gt;
)
export const useStore = () =&gt; { const s = useContext(Ctx); if(!s) throw new Error('Missing RootStore'); return s }
</code></pre>
<p>错误边界：</p>
<pre><code class="language-tsx">// src/components/ErrorBoundary.tsx
import React from 'react'
type Props = { children: React.ReactNode }
type State = { err: Error | null }
export class ErrorBoundary extends React.Component&lt;Props, State&gt; {
  state: State = { err: null }
  static getDerivedStateFromError(err: Error){ return { err } }
  render(){ return this.state.err ? &lt;div&gt;出错了：{this.state.err.message}&lt;/div&gt; : this.props.children }
}
</code></pre>
<p>Next.js 集成（Pages Router）：</p>
<pre><code class="language-tsx">// src/pages/_app.tsx
import type { AppProps } from 'next/app'
import { enableStaticRendering } from 'mobx-react-lite'
import { RootStoreProvider } from '../store/root'
import { ErrorBoundary } from '../components/ErrorBoundary'

enableStaticRendering(typeof window === 'undefined')
export default function App({ Component, pageProps }: AppProps){
  return (
    &lt;ErrorBoundary&gt;
      &lt;RootStoreProvider&gt;
        &lt;Component {...pageProps} /&gt;
      &lt;/RootStoreProvider&gt;
    &lt;/ErrorBoundary&gt;
  )
}
</code></pre>
<p>登录页与守卫：</p>
<pre><code class="language-tsx">// src/components/Guard.tsx
import { observer } from 'mobx-react-lite'
import { useStore } from '../store/root'
export const Guard = observer(({ children }: { children: React.ReactNode }) =&gt; {
  const { auth } = useStore()
  if (!auth.isAuthed) return &lt;div&gt;请先登录&lt;/div&gt;
  return &lt;&gt;{children}&lt;/&gt;
})
</code></pre>
<hr />
<h2 id="深入专题1跨字段跨步表单校验矩阵"><a class="header" href="#深入专题1跨字段跨步表单校验矩阵">深入专题（1）：跨字段/跨步表单校验矩阵</a></h2>
<p>要点：</p>
<ul>
<li>使用 zod/yup 定义 schema，并在 VM 层统一调用 <code>safeParse</code>。</li>
<li>通过 reaction 监听关键字段组合的变化，执行异步校验并去抖。</li>
<li>对分步表单，按步骤动态构造 schema，避免一次验证全部字段。</li>
</ul>
<p>片段：</p>
<pre><code class="language-ts">import { reaction } from 'mobx'
const dispose = reaction(
  () =&gt; [vm.values.username, vm.values.email] as const,
  debounce(async ([u, e]) =&gt; {
    const ok = await api.checkUser(u, e)
    runInAction(() =&gt; vm.errors.username = ok ? '' : '用户名或邮箱已被占用')
  }, 300)
)
</code></pre>
<hr />
<h2 id="深入专题2多标签页多窗口状态同步"><a class="header" href="#深入专题2多标签页多窗口状态同步">深入专题（2）：多标签页/多窗口状态同步</a></h2>
<p>方案：</p>
<ul>
<li>BroadcastChannel：现代浏览器原生多上下文通信。</li>
<li>localStorage <code>storage</code> 事件：兼容更好，但只能同步字符串。</li>
</ul>
<p>示例：</p>
<pre><code class="language-ts">class CrossTab {
  ch = new BroadcastChannel('app')
  constructor(private auth: AuthStore){
    this.ch.onmessage = e =&gt; { if (e.data.type === 'LOGOUT') this.auth.logout() }
  }
  broadcastLogout(){ this.ch.postMessage({ type:'LOGOUT' }) }
}
</code></pre>
<hr />
<h2 id="完整样板商品目录端到端含组件"><a class="header" href="#完整样板商品目录端到端含组件">完整样板：商品目录端到端（含组件）</a></h2>
<p>服务定义：</p>
<pre><code class="language-ts">// src/services/product.ts
import { HttpClient } from './http'
export type Product = { id:number; title:string; brand:string; cat:string; price:number; stock:number; createdAt:string }
export class ProductService {
  constructor(private http: HttpClient){}
  list(params?: { q?:string; cat?:string; brand?:string; page?:number; pageSize?:number; sort?:string }){
    const qs = new URLSearchParams(params as any).toString()
    return this.http.get&lt;{ items: Product[]; total: number }&gt;(`/products?${qs}`)
  }
  detail(id:number){ return self.http.get&lt;Product&gt;(`/products/${id}`) }
  update(id:number, patch: Partial&lt;Product&gt;){ return self.http.post&lt;Product&gt;(`/products/${id}`, patch) }
}
</code></pre>
<p>Store：</p>
<pre><code class="language-ts">// src/store/product.ts
import { makeAutoObservable, flow, runInAction, reaction, comparer } from 'mobx'
import type { Product } from '../services/product'
import { HttpClient } from '../services/http'

export class ProductStore {
  private client: HttpClient
  constructor(private root: { auth?: { token: string|null } }){
    this.client = new HttpClient('/api', () =&gt; this.root.auth?.token ?? null)
    makeAutoObservable(this, { load: flow }, { autoBind: true })
    this.setupReactions()
  }
  // 状态
  items: Product[] = []
  total = 0
  page = 1
  pageSize = 20
  q = ''
  cat: string | undefined = undefined
  brand: string | undefined = undefined
  sort: { key: 'price'|'stock'|'title'|'createdAt'; dir: 'asc'|'desc' } = { key:'createdAt', dir:'desc' }
  loading = false
  error: string | null = null
  selected = new Set&lt;number&gt;()

  get params(){
    return { q:this.q, cat:this.cat, brand:this.brand, page:this.page, pageSize:this.pageSize, sort:`${this.sort.key}:${this.sort.dir}` }
  }

  get pageCount(){ return Math.max(1, Math.ceil(this.total / this.pageSize)) }
  get pageData(){ return this.items }
  get hasSelection(){ return this.selected.size &gt; 0 }

  setQuery(q:string){ this.q = q; this.page = 1 }
  setCat(c?:string){ this.cat = c; this.page = 1 }
  setBrand(b?:string){ this.brand = b; this.page = 1 }
  setSort(key: ProductStore['sort']['key'], dir: 'asc'|'desc'){ this.sort = { key, dir } }
  setPage(p:number){ this.page = Math.min(Math.max(1, p), this.pageCount) }
  toggle(id:number){ this.selected.has(id) ? this.selected.delete(id) : this.selected.add(id) }
  clearSel(){ this.selected.clear() }

  // 并发收敛：序号
  private seq = 0
  load = flow(function* (this: ProductStore){
    const my = ++this.seq
    this.loading = true; this.error = null
    try {
      const qs = new URLSearchParams(this.params as any).toString()
      const res: { items: Product[]; total: number } = yield this.client.get(`/products?${qs}`)
      if (my !== this.seq) return // 弃用过期结果
      this.items = res.items
      this.total = res.total
    } catch (e: any) {
      this.error = e?.message ?? '加载失败'
    } finally { this.loading = false }
  })

  setupReactions(){
    // 查询参数变化时自动加载，去抖合并
    reaction(
      () =&gt; [this.q, this.cat, this.brand, this.sort.key, this.sort.dir, this.page, this.pageSize] as const,
      () =&gt; { this.load() },
      { equals: comparer.structural, fireImmediately: true }
    )
  }
}
</code></pre>
<p>UI 组件：</p>
<pre><code class="language-tsx">// src/components/Catalog/Filters.tsx
import { observer } from 'mobx-react-lite'
import { useStore } from '../../store/root'
export const Filters = observer(() =&gt; {
  const { product } = useStore()
  return (
    &lt;div&gt;
      &lt;input value={product.q} onChange={e =&gt; product.setQuery(e.target.value)} placeholder="搜索标题" /&gt;
      &lt;select value={product.cat ?? ''} onChange={e =&gt; product.setCat(e.target.value || undefined)}&gt;
        &lt;option value=""&gt;全部分类&lt;/option&gt;
        &lt;option value="phone"&gt;手机&lt;/option&gt;
        &lt;option value="laptop"&gt;笔电&lt;/option&gt;
      &lt;/select&gt;
      &lt;select value={product.brand ?? ''} onChange={e =&gt; product.setBrand(e.target.value || undefined)}&gt;
        &lt;option value=""&gt;全部品牌&lt;/option&gt;
        &lt;option value="apple"&gt;Apple&lt;/option&gt;
        &lt;option value="huawei"&gt;Huawei&lt;/option&gt;
      &lt;/select&gt;
      &lt;select value={`${product.sort.key}:${product.sort.dir}`} onChange={e =&gt; { const [k,d] = e.target.value.split(':') as any; product.setSort(k, d) }}&gt;
        &lt;option value="createdAt:desc"&gt;最新&lt;/option&gt;
        &lt;option value="price:asc"&gt;价格升序&lt;/option&gt;
        &lt;option value="price:desc"&gt;价格降序&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
  )
})

// src/components/Catalog/Grid.tsx
import { observer } from 'mobx-react-lite'
import { useStore } from '../../store/root'
export const Grid = observer(() =&gt; {
  const { product } = useStore()
  if (product.loading) return &lt;div&gt;加载中...&lt;/div&gt;
  if (product.error) return &lt;div&gt;错误：{product.error}&lt;/div&gt;
  return (
    &lt;div&gt;
      {product.pageData.map(p =&gt; (
        &lt;div key={p.id}&gt;
          &lt;label&gt;
            &lt;input type="checkbox" checked={product.selected.has(p.id)} onChange={() =&gt; product.toggle(p.id)} /&gt;
            {p.title} - ￥{p.price}
          &lt;/label&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  )
})

// src/components/Catalog/Pager.tsx
import { observer } from 'mobx-react-lite'
import { useStore } from '../../store/root'
export const Pager = observer(() =&gt; {
  const { product } = useStore()
  const { page, pageCount } = product
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; product.setPage(1)} disabled={page===1}&gt;首页&lt;/button&gt;
      &lt;button onClick={() =&gt; product.setPage(page-1)} disabled={page===1}&gt;上一页&lt;/button&gt;
      &lt;span&gt;{page} / {pageCount}&lt;/span&gt;
      &lt;button onClick={() =&gt; product.setPage(page+1)} disabled={page===pageCount}&gt;下一页&lt;/button&gt;
      &lt;button onClick={() =&gt; product.setPage(pageCount)} disabled={page===pageCount}&gt;末页&lt;/button&gt;
    &lt;/div&gt;
  )
})
</code></pre>
<p>页面组合：</p>
<pre><code class="language-tsx">// src/pages/index.tsx
import { Filters } from '../components/Catalog/Filters'
import { Grid } from '../components/Catalog/Grid'
import { Pager } from '../components/Catalog/Pager'
import { Guard } from '../components/Guard'
export default function Home(){
  return (
    &lt;Guard&gt;
      &lt;Filters /&gt;
      &lt;Grid /&gt;
      &lt;Pager /&gt;
    &lt;/Guard&gt;
  )
}
</code></pre>
<p>测试样板：</p>
<pre><code class="language-ts">// src/tests/product.spec.ts
import { describe, it, expect, vi } from 'vitest'
import { ProductStore } from '../store/product'

// 伪造 HttpClient 行为：
class MockRoot { auth = { token: 't' as string|null } }
describe('ProductStore', () =&gt; {
  it('loads with params changes', async () =&gt; {
    const s = new ProductStore(new MockRoot())
    // monkey-patch client.request
    // @ts-expect-error private access in test
    s.client.request = vi.fn(async () =&gt; ({ items:[{ id:1, title:'A', brand:'x', cat:'y', price:1, stock:1, createdAt:'2020-01-01' }], total: 1 }))
    s.setQuery('A'); await s.load() as any
    expect(s.items.length).toBe(1)
  })
})
</code></pre>
<hr />
<h2 id="故障排查手册playbook"><a class="header" href="#故障排查手册playbook">故障排查手册（Playbook）</a></h2>
<p>现象与诊断：</p>
<ul>
<li>视图不更新：确认组件是否 observer；确认读取的是 observable（非解构后的普通值）。</li>
<li>更新频繁：在父层创建新对象/数组传 props；将逻辑搬到子组件或 computed。</li>
<li>computed 不触发：内部读取路径不是 observable；使用 trace 检查依赖。</li>
<li>请求竞态：返回顺序混乱覆盖新结果；加序号或 AbortController。</li>
<li>内存泄漏：未 dispose reaction/autorun；在组件卸载 useEffect 返回 disposer。</li>
<li>SSR 警告 hydration mismatch：初始值不一致；避免首次渲染调用非确定值。</li>
</ul>
<p>排查步骤：</p>
<ol>
<li>在可疑 render/autorun 内加 <code>trace(true)</code>，观察依赖。</li>
<li>在 <code>spy(ev =&gt; ...)</code> 中筛 action/reaction，确认更新链路。</li>
<li>React Profiler 量化渲染次数与耗时，定位 observer 边界。</li>
<li>注释掉非关键派生，逐步恢复定位罪魁祸首。</li>
</ol>
<hr />
<h2 id="代码规范建议团队采纳"><a class="header" href="#代码规范建议团队采纳">代码规范（建议团队采纳）</a></h2>
<ul>
<li>Store 只暴露语义方法与只读派生，不直接暴露可变集合。</li>
<li>方法命名以业务语义为先（<code>addToCart</code> 而非 <code>pushItem</code>）。</li>
<li>所有写入集中在 action；开启 <code>enforceActions:'observed'</code>。</li>
<li>跨 Store 通信通过方法/事件，避免读取内部集合直接改写。</li>
<li>组件内避免 <code>toJS</code>；子组件内部读取 store。</li>
<li>大集合优先 Map/Set；不可变快照使用 <code>observable.ref</code>。</li>
</ul>
<hr />
<h2 id="常用片段大全snippets"><a class="header" href="#常用片段大全snippets">常用片段大全（Snippets）</a></h2>
<p>防抖搜索：</p>
<pre><code class="language-ts">import { reaction } from 'mobx'
const dispose = reaction(() =&gt; vm.q, debounce(q =&gt; vm.search(q), 300))
</code></pre>
<p>条件触发一次：</p>
<pre><code class="language-ts">import { when } from 'mobx'
when(() =&gt; store.ready, () =&gt; initCharts())
</code></pre>
<p>按需缓存的参数化派生：</p>
<pre><code class="language-ts">import { computedFn } from 'mobx-utils'
const postsByUser = computedFn((uid:number) =&gt; store.posts.filter(p =&gt; p.uid === uid))
</code></pre>
<p>观测集合变化：</p>
<pre><code class="language-ts">import { observe } from 'mobx'
observe(store.byId, change =&gt; { console.log(change.type, change.name) })
</code></pre>
<p>拦截非法写入：</p>
<pre><code class="language-ts">import { intercept } from 'mobx'
intercept(store.profile, change =&gt; change.name==='age' &amp;&amp; change.newValue&lt;0 ? null : change)
</code></pre>
<hr />
<h2 id="练习与参考答案精选"><a class="header" href="#练习与参考答案精选">练习与参考答案（精选）</a></h2>
<p>练习 1：实现收藏夹</p>
<ul>
<li>要求：在产品列表界面为每个条目添加收藏按钮，新增 <code>fav:Set&lt;number&gt;</code> 与 <code>toggleFav</code> 方法；页面提供“仅看收藏”过滤。</li>
</ul>
<p>参考实现：</p>
<pre><code class="language-ts">class FavFeature {
  fav = new Set&lt;number&gt;()
  constructor(private store: ProductStore){ makeAutoObservable(this, {}, { autoBind: true }) }
  toggle(id:number){ this.fav.has(id) ? this.fav.delete(id) : this.fav.add(id) }
  get onlyFav(){ return [...this.store.items].filter(p =&gt; this.fav.has(p.id)) }
}
</code></pre>
<p>练习 2：表格内联编辑</p>
<ul>
<li>要求：单元格可编辑，失焦自动保存；保存期间显示 loading；失败回滚。</li>
</ul>
<p>参考实现：</p>
<pre><code class="language-ts">class InlineEditVM {
  editing = new Map&lt;number, Partial&lt;Product&gt;&gt;()
  constructor(private svc: ProductService, private store: ProductStore){ makeAutoObservable(this, {}, { autoBind: true }) }
  setField(id:number, patch: Partial&lt;Product&gt;){ const cur = this.editing.get(id) || {}; this.editing.set(id, { ...cur, ...patch }) }
  async save(id:number){
    const patch = this.editing.get(id)
    if (!patch) return
    const old = this.store.items.find(p =&gt; p.id===id)!
    const snapshot = { ...old }
    Object.assign(old, patch)
    try { await this.svc.update(id, patch) }
    catch(e){ Object.assign(old, snapshot) }
    finally { this.editing.delete(id) }
  }
}
</code></pre>
<p>练习 3：实时推送合并</p>
<ul>
<li>要求：在 WebSocket 事件到来时，按 id 合并记录；若视图存在筛选/排序，保证只影响必要部分。</li>
</ul>
<p>参考提示：</p>
<ul>
<li>在 action 中批量写入；仅替换发生变化的记录字段；不要整体替换列表引用。</li>
</ul>
<hr />
<h2 id="大型表格与聚合实践细节"><a class="header" href="#大型表格与聚合实践细节">大型表格与聚合（实践细节）</a></h2>
<ul>
<li>采用行级 observer；列的显示/隐藏作为 UI Store 管理；</li>
<li>聚合统计使用 computed，并把昂贵聚合拆分为多级 computed；</li>
<li>导出前拍平派生，防止在导出时触发大量重算；</li>
<li>虚拟滚动与分段加载结合，加载指示通过 UI Store 控制。</li>
</ul>
<hr />
<h2 id="事件与埋点体系可观测性"><a class="header" href="#事件与埋点体系可观测性">事件与埋点体系（可观测性）</a></h2>
<ul>
<li>统一在 action 中调用 <code>analytics.track</code>；</li>
<li>在 spy 中捕获 action 以防遗漏；</li>
<li>构造领域事件总线，把关键动作映射为结构化事件，方便 A/B 分析与回放。</li>
</ul>
<hr />
<h2 id="版本化持久化与迁移策略"><a class="header" href="#版本化持久化与迁移策略">版本化持久化与迁移策略</a></h2>
<ul>
<li>在本地持久化对象中保存 <code>schemaVersion</code>；</li>
<li>升级时执行迁移函数，将老版本数据映射到新结构；</li>
<li>无法迁移时清理并回退到默认值，记录日志。</li>
</ul>
<p>示例：</p>
<pre><code class="language-ts">type SnapshotV1 = { token: string }
type SnapshotV2 = { token: string; theme: 'light'|'dark' }
function migrate(v: any){
  if (v.schemaVersion===1){ const s = v as SnapshotV1; return { schemaVersion:2, token:s.token, theme:'light' } as const }
  return v
}
</code></pre>
<hr />
<h2 id="nextjs-app-router-集成rscclient-组件搭配"><a class="header" href="#nextjs-app-router-集成rscclient-组件搭配">Next.js App Router 集成（RSC/Client 组件搭配）</a></h2>
<p>要点：</p>
<ul>
<li>Store 仍在 Client 组件侧创建与注入；</li>
<li>服务端组件用于获取数据快照，通过 props 传给 Client 组件在首屏水合；</li>
<li>避免在服务端使用 MobX 的响应式 API（无意义且可能带来隐患）。</li>
</ul>
<p>示例：</p>
<pre><code class="language-tsx">// app/layout.tsx （Server Component）
export default function RootLayout({ children }: { children: React.ReactNode }){
  return &lt;html&gt;&lt;body&gt;{children}&lt;/body&gt;&lt;/html&gt;
}

// app/page.tsx （Server Component）
import { fetchProducts } from '@/server/product'
import PageClient from './page.client'
export default async function Page(){
  const initial = await fetchProducts()
  return &lt;PageClient initial={initial} /&gt;
}

// app/page.client.tsx （Client Component）
'use client'
import { RootStoreProvider, useStore } from '@/store/root'
import { observer } from 'mobx-react-lite'
export default function PageClient({ initial }: { initial: any }){
  return &lt;RootStoreProvider&gt;&lt;Inner initial={initial} /&gt;&lt;/RootStoreProvider&gt;
}
const Inner = observer(({ initial }: { initial: any }) =&gt; {
  const { product } = useStore()
  // 将 SSR 数据注入：
  useEffect(() =&gt; { product.items = initial.items; product.total = initial.total }, [initial])
  return &lt;div&gt;首屏 {product.items.length} 条&lt;/div&gt;
})
</code></pre>
<hr />
<h2 id="api-速查大全扩展版"><a class="header" href="#api-速查大全扩展版">API 速查大全（扩展版）</a></h2>
<p>配置与全局：</p>
<ul>
<li><code>configure({ enforceActions:'always'|'observed'|'never', reactionScheduler? })</code></li>
<li><code>isObservable</code>, <code>isAction</code>, <code>isComputedProp</code> 检查</li>
<li><code>runInAction(name?, fn)</code> 命名便于调试</li>
</ul>
<p>observable 创建：</p>
<ul>
<li><code>observable.box(value)</code>、<code>observable.object(obj)</code>、<code>observable.array(arr)</code>、<code>observable.map(init)</code>、<code>observable.set(init)</code></li>
<li><code>makeAutoObservable(target, overrides?, options?)</code></li>
<li><code>makeObservable(target, annotations)</code> 注解精确控制</li>
</ul>
<p>computed：</p>
<ul>
<li><code>computed(() =&gt; expr, { equals })</code> 自定义等价比较</li>
<li><code>keepAlive(computedValue)</code> 保持缓存</li>
</ul>
<p>actions 与批量：</p>
<ul>
<li><code>action(fn)</code>、<code>action.bound</code>、<code>transaction(fn)</code>（v6 可用 runInAction 达成类似效果）</li>
</ul>
<p>reactions：</p>
<ul>
<li><code>autorun(trackFn, opts?)</code>、<code>reaction(dataFn, effectFn, opts?)</code>、<code>when(predicate, effect?, opts?)</code></li>
<li><code>opts:{ fireImmediately, delay, equals, scheduler }</code></li>
</ul>
<p>集合观察：</p>
<ul>
<li><code>observe(obj|map|set|array, listener)</code>、<code>intercept(target, handler)</code></li>
</ul>
<p>调试：</p>
<ul>
<li><code>spy(listener)</code>、<code>trace(enterDebugger?)</code>、<code>whyRun()</code></li>
</ul>
<p>工具：</p>
<ul>
<li><code>toJS(value, options?)</code>、<code>untracked(fn)</code>、<code>allowStateChanges(fn)</code>（极少使用）</li>
</ul>
<p>mobx-react-lite：</p>
<ul>
<li><code>observer(Component)</code>、<code>&lt;Observer&gt;{render}&lt;/Observer&gt;</code>、<code>useLocalObservable(factory)</code>、<code>enableStaticRendering(bool)</code></li>
</ul>
<p>mobx-utils 精选：</p>
<ul>
<li><code>computedFn</code>、<code>fromPromise</code>、<code>keepAlive</code>、<code>now(interval)</code>、<code>throttle/debounce</code>、<code>lazyObservable</code></li>
</ul>
<hr />
<h2 id="大型-faq精选-60-问"><a class="header" href="#大型-faq精选-60-问">大型 FAQ（精选 60 问）</a></h2>
<ol>
<li>Q：开启严格模式会怎样？A：<code>enforceActions:'always'</code> 下，任何非 action 的写入会抛错，强制把写入集中到动作中。</li>
<li>Q：observer 一定包最外层组件吗？A：不必。按变动颗粒度把 observer 放到变动最频繁的局部。</li>
<li>Q：读取 props 会触发订阅吗？A：不会，只有读取 observable 才会被追踪。</li>
<li>Q：父组件解构 store 再传子组件有问题吗？A：若解构成普通值，会丢失追踪；让子组件直接读取 store。</li>
<li>Q：computed 里可以异步吗？A：不可以。computed 必须纯同步无副作用。</li>
<li>Q：flow 和 async 差异？A：flow 支持取消、内部 <code>yield</code> 更直观；async 配合 runInAction 也能满足多数场景。</li>
<li>Q：如何调试 action 来源？A：使用 <code>spy(ev =&gt; ev.type==='action' &amp;&amp; console.log(ev))</code>。</li>
<li>Q：Map/Set 为什么更推荐？A：频繁增删和按 id 访问更高效，且订阅颗粒度更好。</li>
<li>Q：如何只在某个字段被观察时才计算？A：用 <code>onBecomeObserved/Unobserved(obj, 'field', handler)</code>。</li>
<li>Q：为什么 reaction 不触发？A：检查 dataFn 是否真正读取了 observable；<code>equals</code> 是否过于严格；是否在 <code>untracked</code> 中读取。</li>
<li>Q：如何防止表单输入造成频繁渲染？A：把输入状态放在本地 VM，或对副作用使用 debounce。</li>
<li>Q：如何实现基于角色的菜单？A：<code>MenuStore.visibleItems = ALL.filter(i =&gt; auth.can(i.perm))</code>，computed 自动更新。</li>
<li>Q：SSR 时如何避免副作用？A：<code>enableStaticRendering(true)</code> 并在服务端不要使用 reactions。</li>
<li>Q：可以在 reducer 思维下使用 MobX 吗？A：可以，但不必要。MobX 直接可变即可。</li>
<li>Q：如何做“选择集”功能？A：在 Store 中维护 <code>Set&lt;id&gt;</code>；在行组件读取 <code>selected.has(id)</code>。</li>
<li>Q：如何处理乐观更新失败回滚？A：记录快照或命令，在失败时回滚。</li>
<li>Q：如何记录审计日志？A：在 action 层统一封装并在 spy 中记录。</li>
<li>Q：不同页面复用 Store？A：RootStore 单例 + 路由切换时重置 UI Store。</li>
<li>Q：切换语言为何部分文本不更新？A：确认组件是否读取了 <code>i18n.t(...)</code> 的值而不是提前计算的常量。</li>
<li>Q：computed 的缓存何时失效？A：当依赖之一变化时，下次被访问会重算。</li>
<li>Q：可以在 render 中 new Store 吗？A：不推荐；会导致每次重渲染重置状态。在顶层 useRef 或 Context。</li>
<li>Q：如何确保只在必要时渲染？A：observer 边界 + 行级/局部观察 + 避免传递新引用 props。</li>
<li>Q：大量列表为什么慢？A：虚拟化、行级 observer、避免大对象 toJS、减少排序/过滤在 render 中做。</li>
<li>Q：如何对接 WebSocket？A：事件到来时包进 action 批量更新，合并到 Map/Set。</li>
<li>Q：如何做“未保存更改离开提示”？A：UI Store 维护 dirty 标记，路由切换前弹窗确认。</li>
<li>Q：如何避免循环依赖 Store？A：使用 RootStore 注入，跨 store 用方法通信或 id 引用。</li>
<li>Q：flow 取消如何做？A：持有返回的取消句柄或在 generator 外部调用 <code>cancel</code>（借助库）。</li>
<li>Q：如何节流 reaction？A：使用 <code>scheduler</code> 或外部 <code>throttle</code> 包裹 effect。</li>
<li>Q：为何 useLocalObservable 不生效？A：确保在 observer 组件内使用，并返回对象而非类实例时注意 this。</li>
<li>Q：如何监听 Map 的新增/删除？A：<code>observe(map, listener)</code> 可以收到 add/delete 事件。</li>
<li>Q：如何统一错误处理？A：服务层标准化错误结构，Store 只设置 <code>error</code> 字段，UI 统一显示。</li>
<li>Q：分页切换数据错乱？A：确保查询参数变化联动 page=1 或正确更新。</li>
<li>Q：computedFn 会泄漏内存吗？A：参数空间很大且不被重复使用时可能缓存过多；可包一层 LRU。</li>
<li>Q：如何在 DevTools 中标注 action 名称？A：<code>action('add to cart', fn)</code> 或 <code>runInAction('batch update', fn)</code>。</li>
<li>Q：Store 内可以使用 fetch 吗？A：可以，但推荐经服务层；利于测试和迁移。</li>
<li>Q：如何在 React 18 并发模式下安全？A：避免副作用在 render；使用 effect/reaction；保证 id 稳定。</li>
<li>Q：如何与 Redux 共存？A：以页面为界分治；或把 Redux 逐步迁移为 Store 方法。</li>
<li>Q：如何做全局 Loading？A：UI Store 维护计数器，进入请求 +1，完成 -1。</li>
<li>Q：如何自动刷新过期数据？A：结合 TanStack Query 或在 reaction 中按时间策略触发 <code>load</code>。</li>
<li>Q：如何支持主题切换？A：<code>PrefStore.theme</code> + body class，observer 触发视图更新。</li>
<li>Q：如何防止 computed 里读写状态？A：computed 内部只读；写操作必须在 action。</li>
<li>Q：如何防止 store 被外部任意修改？A：仅通过方法暴露改变；类型上导出只读接口。</li>
<li>Q：如何为复杂表单做草稿？A：白名单持久化 + 提交后清理。</li>
<li>Q：如何避免 Map 的大量键字符串化成本？A：使用数字 id 或复合 key（<code>${a}:${b}</code>）时谨慎，必要时二级 Map。</li>
<li>Q：SSR 初始快照如何注水？A：在 Client 组件接收 props 后一次性写入 Store。</li>
<li>Q：如何对接权限后端？A：AuthStore 拉取权限集合，MenuStore 根据集合过滤可见项。</li>
<li>Q：为什么 autorun 不推荐写状态？A：易出现反馈环；使用 reaction 的 effect 或显式 action。</li>
<li>Q：能否批量更新避免多次渲染？A：action/runInAction 内天然批量；UI 合理 observer 边界。</li>
<li>Q：如何记录性能基线？A：Profiler + 自定义计时器，提交报告纳入验收。</li>
<li>Q：如何组织文件？A：按领域拆分 Store；UI Store 单独目录；服务分层。</li>
<li>Q：如何做依赖注入？A：RootStore 传给子 Store；或用轻量 IOC 容器。</li>
<li>Q：如何迁移旧装饰器语法？A：改为 <code>makeAutoObservable</code>/<code>makeObservable</code>；移除 TS 装饰器配置。</li>
<li>Q：如何处理时间区间筛选？A：在 Store 内统一管理 range；computed 基于 range 聚合。</li>
<li>Q：导出大 CSV 很慢？A：把聚合在 Store computed 中完成；导出时直接读取结果；必要时 Web Worker。</li>
<li>Q：Web Worker 如何协作？A：把纯计算下沉至 Worker，完成后通过 action 写回。</li>
<li>Q：如何拆分巨型 Store？A：领域模块化；抽出 Service 层；UI Store 独立；减少横向依赖。</li>
<li>Q：如何防止“全局状态污染组件测试”？A：每个测试创建独立 RootStore 实例。</li>
<li>Q：如何监控关键派生是否被误订阅？A：在 computed 内 <code>onBecomeObserved</code> 打日志并审阅调用栈。</li>
<li>Q：如何处理浏览器存储配额？A：仅存配置/偏好等小数据；大数据走 IndexedDB；失败时降级。</li>
<li>Q：如何灰度发布新特性？A：FlagStore 控制；reaction 在标志开启时初始化资源，在关闭时清理。</li>
</ol>
<hr />
<h2 id="迁移对照redux-toolkit--zustand--mst"><a class="header" href="#迁移对照redux-toolkit--zustand--mst">迁移对照：Redux Toolkit / Zustand / MST</a></h2>
<p>Redux Toolkit → MobX：</p>
<ul>
<li>Slice → Store 类；CreateAsyncThunk → flow/服务层 + runInAction；Selector → computed。</li>
<li>中间件 → reaction/服务层；不可变更新 → 可变写入（批量）。</li>
</ul>
<p>Zustand → MobX：</p>
<ul>
<li>选择器订阅 → 通过 observer + computed 达到粒度控制；</li>
<li>Immer 更新 → MobX 可变即可；复杂派生更适合 computed。</li>
</ul>
<p>MST（MobX-State-Tree） → MobX：</p>
<ul>
<li>MST 提供快照与类型模型；若团队不需快照回放与 patch，可直接使用轻量 MobX 自由度更高。</li>
</ul>
<hr />
<h2 id="运行与部署指南"><a class="header" href="#运行与部署指南">运行与部署指南</a></h2>
<ul>
<li>环境变量：在服务层读取 <code>process.env.NEXT_PUBLIC_API_BASE</code>；</li>
<li>构建：开启 <code>TSCONFIG</code> 严格模式；</li>
<li>CI：运行 <code>lint</code>、<code>type-check</code>、<code>test</code>，产出覆盖率；</li>
<li>监控：接入前端埋点与错误上报（sourcemap）。</li>
</ul>
<hr />
<h2 id="性能预算与验收"><a class="header" href="#性能预算与验收">性能预算与验收</a></h2>
<ul>
<li>列表 1k 行交互：滚动流畅无明显掉帧（&gt;50 FPS）。</li>
<li>搜索输入响应：端到端 &lt; 150ms。</li>
<li>首屏渲染 TTI：CSR &lt; 3s（低端机 &lt; 5s），SSR &lt; 2s。</li>
<li>渲染次数：关键组件优化后下降 ≥30%。</li>
</ul>
<hr />
<h2 id="多租户-saas-场景租户隔离--权限--配置"><a class="header" href="#多租户-saas-场景租户隔离--权限--配置">多租户 SaaS 场景（租户隔离 + 权限 + 配置）</a></h2>
<p>需求要点：</p>
<ul>
<li>每个租户拥有自己的配置与数据范围；</li>
<li>用户可在多个租户间切换；</li>
<li>菜单/功能根据租户与用户权限动态变化；</li>
<li>SSR 首屏需要注入当前租户的偏好与主题。</li>
</ul>
<p>设计：</p>
<pre><code class="language-ts">type Tenant = { id:string; name:string; theme:'light'|'dark'; region:string; features: string[] }
export class TenantStore {
  current: Tenant | null = null
  list: Tenant[] = []
  constructor(private root: RootStore){ makeAutoObservable(this, {}, { autoBind: true }) }
  setCurrent(id:string){ const t = this.list.find(x =&gt; x.id === id) || null; this.current = t }
  get region(){ return this.current?.region ?? 'cn' }
  hasFeature(f: string){ return !!this.current?.features.includes(f) }
}

export class MenuStore {
  raw = ALL_ITEMS
  constructor(private auth: AuthStore, private tenant: TenantStore){ makeAutoObservable(this, {}, { autoBind: true }) }
  get visible(){ return this.raw.filter(i =&gt; this.auth.can(i.perm) &amp;&amp; (!i.flag || this.tenant.hasFeature(i.flag))) }
}
</code></pre>
<p>SSR 注入：</p>
<ul>
<li>在服务端根据 cookie/session 获取当前租户与用户基本信息，拼成 <code>initialState</code>；</li>
<li>客户端 <code>hydrate()</code> 一次性写入 TenantStore 与 AuthStore。</li>
</ul>
<hr />
<h2 id="indexeddb-离线缓存dexie-示例"><a class="header" href="#indexeddb-离线缓存dexie-示例">IndexedDB 离线缓存（Dexie 示例）</a></h2>
<p>适用：大体量可缓存数据（只读类），离线可用。</p>
<p>示例：</p>
<pre><code class="language-ts">import Dexie, { Table } from 'dexie'
type ProductRow = { id:number; title:string; updatedAt:number }
class DB extends Dexie { products!: Table&lt;ProductRow, number&gt;; constructor(){ super('app'); this.version(1).stores({ products:'id, updatedAt' }) } }
export const db = new DB()

export class CatalogCache {
  constructor(private store: ProductStore){}
  async hydrateFromDB(){ const rows = await db.products.toArray(); runInAction(() =&gt; this.store.items = rows as any) }
  async persist(){ await db.products.bulkPut(this.store.items.map(p =&gt; ({ id:p.id, title:p.title, updatedAt:Date.now() }))) }
}
</code></pre>
<hr />
<h2 id="web-workercomlink-协作把昂贵计算下沉"><a class="header" href="#web-workercomlink-协作把昂贵计算下沉">Web Worker/Comlink 协作（把昂贵计算下沉）</a></h2>
<p>场景：对 10w+ 数据进行聚合排序，主线程阻塞明显。</p>
<p>示例：</p>
<pre><code class="language-ts">// worker.ts
export function aggregate(list: any[]){ /* 重计算 */ return { /* 统计 */ } }

// main.ts
import { wrap } from 'comlink'
const worker = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' })
const api = wrap&lt;{ aggregate(list:any[]): Promise&lt;any&gt; }&gt;(worker)
class AggStore { result:any=null; constructor(){ makeAutoObservable(this, {}, { autoBind:true }) } async run(){ this.result = await api.aggregate(toJS(store.raw)) } }
</code></pre>
<hr />
<h2 id="深度reaction-调度与取消"><a class="header" href="#深度reaction-调度与取消">深度：reaction 调度与取消</a></h2>
<ul>
<li><code>scheduler</code>：把 effect 放到自定义队列（如 <code>requestAnimationFrame</code>），降低抖动；</li>
<li>返回的函数即 disposer，组件卸载时调用；</li>
<li>在 effect 内检查 <code>disposed</code> 标志，避免竞态下的写入。</li>
</ul>
<p>片段：</p>
<pre><code class="language-ts">const disposers: (() =&gt; void)[] = []
function setup(){
  const d = reaction(
    () =&gt; store.q,
    q =&gt; store.search(q),
    { scheduler: (fn) =&gt; requestAnimationFrame(fn) }
  )
  disposers.push(d)
}
function teardown(){ disposers.forEach(d =&gt; d()) }
</code></pre>
<hr />
<h2 id="spy-事件类型速览"><a class="header" href="#spy-事件类型速览">Spy 事件类型速览</a></h2>
<ul>
<li><code>action</code>：动作开始/结束，包含名称与堆栈；</li>
<li><code>reaction</code>：reaction 运行；</li>
<li><code>scheduled-reaction</code>：被调度；</li>
<li><code>compute</code>：computed 计算；</li>
<li><code>update</code>：observable 更新（对象/数组/Map/Set 不同细节字段）。</li>
</ul>
<p>示例：</p>
<pre><code class="language-ts">import { spy } from 'mobx'
spy(ev =&gt; { if (ev.type === 'action') console.log('action', ev.name) })
</code></pre>
<hr />
<h2 id="更大-faq61120"><a class="header" href="#更大-faq61120">更大 FAQ（61—120）</a></h2>
<ol start="61">
<li>Q：怎样在大型项目组织 RootStore？A：分层：services、domain stores、ui stores；RootStore 聚合并注入 Context。</li>
<li>Q：可以把 RootStore 放全局单例吗？A：可以，但测试时注意实例隔离；SSR 需每请求实例化。</li>
<li>Q：如何组件化地注入局部 store？A：<code>useLocalObservable</code> 创建并通过 props 传给子组件。</li>
<li>Q：如何实现“只在被观察时才拉取数据”？A：<code>onBecomeObserved</code> 某个字段时触发 <code>load()</code>；在 <code>onBecomeUnobserved</code> 清理定时器。</li>
<li>Q：为什么我的列表 filter 改变时卡顿？A：把过滤放 computed，并对昂贵计算 <code>equals: comparer.structural</code>。</li>
<li>Q：在多 store 场景如何做一致的错误上报？A：服务层集中处理；Store 仅暴露 <code>error</code> 与 <code>loading</code>。</li>
<li>Q：如何避免“幽灵状态”（未被任何视图使用的字段）？A：建立映射清单并定期用 <code>onBecomeObserved</code> 跟踪。</li>
<li>Q：如何处理路由切换重置 UI？A：在路由 effect 中调用 <code>ui.reset()</code>；或使用新的 UI Store 实例。</li>
<li>Q：如何实现分步加载进度条？A：UI Store 维护 <code>progress</code>，在各阶段 action 中更新。</li>
<li>Q：如何共享可读副作用结果？A：把副作用结果写到可观察字段，由观察组件消费。</li>
<li>Q：如何防止两个 reaction 相互触发？A：明确单向数据流；写入只在 action；避免在 reaction 里读回会触发的依赖链。</li>
<li>Q：可以在 computed 中缓存 HTTP 结果吗？A：不要。网络请求应在 action/服务层。</li>
<li>Q：如何为派生设置保活？A：<code>keepAlive</code>；用于昂贵计算在观察者临时消失时仍保持缓存。</li>
<li>Q：使用 shallow 有何副作用？A：仅第一层可观察；更深层变化不会触发订阅。</li>
<li>Q：如何做基于 key 的表单列表（动态字段）？A：Map 存储表单项，行级 observer。</li>
<li>Q：如何在表格编辑中保存编辑中的值？A：UI VM 维护 <code>editing</code> Map；保存成功后写回 Store。</li>
<li>Q：如何在移动端优化输入法卡顿？A：去抖副作用、避免 render 中重型计算、尽量本地状态管理。</li>
<li>Q：如何在 DevTools 中查看依赖？A：在渲染函数里调用 <code>trace(true)</code>，打开控制台。</li>
<li>Q：从 Zustand 迁移有哪些坑？A：丢失选择器思维；要学会 observer 边界 + computed。</li>
<li>Q：如何保证对外 API 稳定？A：Store 导出只读接口类型。</li>
<li>Q：为什么某些组件频繁刷新？A：父组件传下新的函数/对象引用；使用 useCallback/useMemo 或在子组件内读。</li>
<li>Q：可否全局启用 structural equals？A：不建议；按需在具体 computed 设置。</li>
<li>Q：如何做分组视图（Group by）？A：computed 拆分：先 filter，再 group，再 aggregate。</li>
<li>Q：如何用 reaction 做路由同步？A：监听某些状态变化后调用 router.push()。</li>
<li>Q：如何在 SSR 时避免本地存储？A：分支判断 <code>typeof window</code>，在客户端再持久化。</li>
<li>Q：如何做“最近访问记录”？A：UI Store 用 <code>observable.array</code> 记录，去重并限长。</li>
<li>Q：如何做“离开页签暂停刷新”？A：<code>document.visibilityState</code> 结合 reaction 的 scheduler。</li>
<li>Q：多个窗口编辑同一条数据怎么办？A：以服务器为权威，冲突策略 + 时间戳/版本号。</li>
<li>Q：如何把 MobX 事件接到监控？A：在 spy 中汇总 action/reaction，上传关键事件。</li>
<li>Q：如何收敛多来源写入？A：把写入集中到单一 Store 方法，其他模块只调用方法。</li>
<li>Q：如何防止“状态爆炸”？A：领域拆分、派生优先、UI 与 Domain 隔离、删除不必要字段。</li>
<li>Q：大计算如何避免阻塞？A：Web Worker/Comlink；或后端聚合下发。</li>
<li>Q：如何做打印/导出时的只读快照？A：<code>toJS</code> 一次性拍平；导出后丢弃。</li>
<li>Q：如何清理订阅？A：disposer 收集在数组中，组件卸载统一遍历调用。</li>
<li>Q：如何测量优化是否有效？A：基线 + 实施 + Profiler 对比 + 报告。</li>
<li>Q：如何设计跨租户开关？A：TenantStore.features + FlagStore 组合校验。</li>
<li>Q：是否需要 MST 快照？A：若无时间旅行/快照编辑需求，MobX 足够。</li>
<li>Q：如何保证写入原子性？A：使用 <code>runInAction</code> 或单个 action 包裹相关写入。</li>
<li>Q：如何避免“悬空引用”？A：以 id 关联，删除实体时清理所有引用集合。</li>
<li>Q：如何在表格行展开细节？A：UI Store 维护 <code>expanded:Set&lt;id&gt;</code>，行级 observer 控制显示。</li>
<li>Q：如何管理通知/消息条？A：ToastStore 列表 + 自动过期；观察组件渲染。</li>
<li>Q：如何实现键盘快捷键？A：UI Store 监听 keydown，写状态驱动行为。</li>
<li>Q：如何对接权限变更实时生效？A：WebSocket 推送权限变更，AuthStore 更新，菜单 computed 自动刷新。</li>
<li>Q：如何做“保存草稿/发布”流程？A：两个状态通道；发布成功后清理草稿并打事件。</li>
<li>Q：如何处理日期区间变更带来的大量刷新？A：拆分派生、延迟聚合、scheduler 合并。</li>
<li>Q：何时用 <code>observable.ref</code>？A：外部不可变快照或大对象，按引用变化通知。</li>
<li>Q：如何在数据透视表中实现切片器？A：UI Store 维护切片条件，computed 生成透视结果。</li>
<li>Q：如何避免 Map 键泄漏？A：弱引用不可用；定期清理无用项或 LRU。</li>
<li>Q：如何调试谁在写入？A：<code>spy</code> 过滤 <code>update</code> 事件，打印来源堆栈。</li>
<li>Q：如何把 MobX 与表单库（react-hook-form）结合？A：表单库管理表单值，MobX 管理业务状态与副作用。</li>
<li>Q：大图像/文件列表如何管理？A：只存元数据；上传进度在 UI Store；大文件内容不入 MobX。</li>
<li>Q：如何在图表联动中高效？A：交互状态在 UI Store，数据派生用 computed，避免在 render 计算聚合。</li>
<li>Q：如何维护“标签系统”？A：TagStore：Map&lt;tag, Set<id>&gt;；computed 提供按标签过滤结果。</li>
<li>Q：为什么建议服务层？A：隔离 I/O，测试更容易；Store 聚焦业务语义。</li>
<li>Q：如何节省包体？A：只引入 mobx + mobx-react-lite + 少量工具；避免装饰器依赖。</li>
<li>Q：如何分模块打包？A：代码分割；Store 按需实例化；避免在入口即加载全部。</li>
<li>Q：如何安全处理 HTML？A：统一 sanitize；UI 用 <code>dangerouslySetInnerHTML</code> 时特别注意。</li>
<li>Q：如何集成错误边界？A：ErrorBoundary 包裹应用；Store 错误字段用于用户友好提示。</li>
<li>Q：如何在小程序/非 React 环境用 MobX？A：只要有可观察→订阅桥接即可；生态各自适配。</li>
<li>Q：如何学习路径闭环？A：从简单 Counter→Todo→异步→架构→SSR→性能→测试→实战项目。</li>
</ol>
<hr />
<h2 id="bench-实验与观察法"><a class="header" href="#bench-实验与观察法">Bench 实验与观察法</a></h2>
<ul>
<li>基线：无优化渲染次数/耗时；</li>
<li>调整 observer 边界后记录变化；</li>
<li>把昂贵计算改为 computed 后记录变化；</li>
<li>报告包含页面级/组件级指标与截图。</li>
</ul>
<hr />
<h2 id="事故应对-playbook"><a class="header" href="#事故应对-playbook">事故应对 Playbook</a></h2>
<ul>
<li>级别划分：P0/P1/P2；</li>
<li>快速止血：回滚 flag；</li>
<li>定位：spy + Profiler + 网络面板；</li>
<li>根因：错误输入、竞态、订阅过度、数据一致性；</li>
<li>修复：测试覆盖 + 文档化经验。</li>
</ul>
<hr />
<h2 id="项目实战-1工时管理系统timesheet"><a class="header" href="#项目实战-1工时管理系统timesheet">项目实战 1：工时管理系统（Timesheet）</a></h2>
<p>目标：</p>
<ul>
<li>录入工时、审批流程、月度汇总、导出 CSV；</li>
<li>角色：成员/主管/管理员，权限不同；</li>
<li>并发：多人同时修改同一条目时的冲突处理。</li>
</ul>
<p>数据与 Store：</p>
<pre><code class="language-ts">type Entry = { id:string; userId:number; project:string; date:string; hours:number; status:'draft'|'submitted'|'approved'|'rejected' }
class TimesheetStore {
  byId = new Map&lt;string, Entry&gt;()
  filter = { userId: undefined as number|undefined, range: [null as Date|null, null as Date|null] }
  constructor(private root: RootStore){ makeAutoObservable(this, {}, { autoBind: true }) }
  add(e: Entry){ this.byId.set(e.id, e) }
  submit(id:string){ const e = this.byId.get(id); if(e) e.status='submitted' }
  approve(id:string){ const e = this.byId.get(id); if(e) e.status='approved' }
  get monthSummary(){ /* 按月/项目聚合 */ return [] as { project:string; hours:number }[] }
}
</code></pre>
<p>并发冲突策略：</p>
<ul>
<li>每条记录持有 <code>version</code>；提交更新时携带旧 <code>version</code>；若后端返回 <code>409</code>，提示并拉取最新进行合并。</li>
</ul>
<hr />
<h2 id="项目实战-2聊天室websocket--乐观消息"><a class="header" href="#项目实战-2聊天室websocket--乐观消息">项目实战 2：聊天室（WebSocket + 乐观消息）</a></h2>
<p>要点：</p>
<ul>
<li>临时 id、发送中状态、失败重试；</li>
<li>消息列表 Map + 按会话列表；</li>
<li>连接状态在 UI Store，断线重连指数退避。</li>
</ul>
<p>片段：</p>
<pre><code class="language-ts">type Msg = { id:string; convId:string; from:number; text:string; ts:number; state:'sending'|'sent'|'failed' }
class ChatStore {
  byConv = new Map&lt;string, Msg[]&gt;()
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  send(convId:string, text:string){
    const id = `tmp_${crypto.randomUUID()}`
    const m: Msg = { id, convId, from: 1, text, ts: Date.now(), state:'sending' }
    const arr = this.byConv.get(convId) || []
    arr.push(m); this.byConv.set(convId, arr)
    ws.send(JSON.stringify({ convId, text, clientId:id }))
  }
  onAck(serverId:string, clientId:string){
    const arr = this.byConv.get(/* convId */) || []
    const m = arr.find(x =&gt; x.id===clientId); if(m){ m.id = serverId; m.state='sent' }
  }
}
</code></pre>
<hr />
<h2 id="项目实战-3报表仪表板多图联动--维度切片"><a class="header" href="#项目实战-3报表仪表板多图联动--维度切片">项目实战 3：报表仪表板（多图联动 + 维度切片）</a></h2>
<p>要点：</p>
<ul>
<li>维度切片（时间/地区/产品）由 UI Store 管理；</li>
<li>每个图表组件只读取自己的数据切片；</li>
<li>导出/打印模式下冻结派生。</li>
</ul>
<p>片段：</p>
<pre><code class="language-ts">class SliceStore { range:[Date,Date]; region?:string; product?:string; constructor(){ makeAutoObservable(this) } }
class MetricStore { raw:any[]=[]; constructor(private slice:SliceStore){ makeAutoObservable(this) } get sales(){ return groupAndSum(this.raw, this.slice) } }
</code></pre>
<hr />
<h2 id="进阶代码片段更多"><a class="header" href="#进阶代码片段更多">进阶代码片段（更多）</a></h2>
<p>TTL 缓存：</p>
<pre><code class="language-ts">class TTL&lt;T&gt; { v:T|null=null; exp=0; set(v:T, ms:number){ this.v=v; this.exp=Date.now()+ms } get(){ return Date.now()&lt;this.exp ? this.v : null } }
</code></pre>
<p>LRU for computedFn：</p>
<pre><code class="language-ts">function lruComputedFn&lt;A extends unknown[], R&gt;(fn: (...a:A)=&gt;R, cap=100){
  const map = new Map&lt;string, { k:string, v:R }&gt;()
  return ((...a:A) =&gt; {
    const k = JSON.stringify(a)
    if (map.has(k)){ const e = map.get(k)!; map.delete(k); map.set(k, e); return e.v }
    const v = fn(...a); map.set(k,{k,v}); if(map.size&gt;cap){ const first = map.keys().next().value; map.delete(first) } return v
  })
}
</code></pre>
<p>稳定 key 的列表渲染：</p>
<pre><code class="language-tsx">{store.ids.map(id =&gt; &lt;Row key={id} id={id} /&gt;)}
</code></pre>
<hr />
<h2 id="调试与监控集成sentry自建"><a class="header" href="#调试与监控集成sentry自建">调试与监控集成（Sentry/自建）</a></h2>
<p>统一上报：</p>
<pre><code class="language-ts">spy(ev =&gt; {
  if (ev.type === 'action') monitor.track('action', { name: ev.name })
  if (ev.type === 'update') monitor.track('update', { name: ev.name, newValue: String((ev as any).newValue).slice(0,100) })
})
</code></pre>
<p>错误边界与 Store：</p>
<ul>
<li>ErrorBoundary 展示；</li>
<li>Store.error 字段为用户提示；</li>
<li>monitor 作为后端上报。</li>
</ul>
<hr />
<h2 id="eslinttsconfig-建议"><a class="header" href="#eslinttsconfig-建议">ESLint/TSConfig 建议</a></h2>
<p>TS：</p>
<ul>
<li><code>strict: true</code>、<code>noImplicitAny: true</code>、<code>noUncheckedIndexedAccess: true</code></li>
<li><code>useDefineForClassFields: true</code>（对类字段行为明确）</li>
</ul>
<p>ESLint：</p>
<ul>
<li><code>@typescript-eslint/no-floating-promises</code>：禁止漏 await；</li>
<li><code>no-restricted-imports</code>：限制从实现层相互引用，约束架构；</li>
<li><code>react-hooks/exhaustive-deps</code>：搭配 observer 时审慎处理（对 MobX 订阅不强制）。</li>
</ul>
<hr />
<h2 id="vitest-配置样板"><a class="header" href="#vitest-配置样板">Vitest 配置样板</a></h2>
<pre><code class="language-ts">// vitest.config.ts
import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: { environment: 'happy-dom', globals: true, coverage: { reporter: ['text','json','html'] } }
})
</code></pre>
<hr />
<h2 id="nginx部署要点ssr"><a class="header" href="#nginx部署要点ssr">Nginx/部署要点（SSR）</a></h2>
<ul>
<li>反向代理 <code>/api</code> 到后端；</li>
<li>缓存静态资源，开启 gzip/br；</li>
<li>处理长连接（WebSocket）的升级头。</li>
</ul>
<p>示例：</p>
<pre><code class="language-nginx">location /api/ { proxy_pass http://backend; proxy_set_header Host $host; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; }
</code></pre>
<hr />
<h2 id="深入专题3长列表虚拟化--行级-observer"><a class="header" href="#深入专题3长列表虚拟化--行级-observer">深入专题（3）：长列表虚拟化 + 行级 observer</a></h2>
<p>策略：</p>
<ul>
<li>使用 react-virtual 或 react-window 实现窗口化渲染。</li>
<li>行组件单独 <code>observer</code>，并仅读取该行实体，避免列表刷新导致全量重渲染。</li>
</ul>
<p>片段：</p>
<pre><code class="language-tsx">const Row = observer(({ id }: { id: number }) =&gt; {
  const item = store.byId.get(id)! // 仅订阅该 id
  return &lt;div&gt;{item.title} - {item.price}&lt;/div&gt;
})
</code></pre>
<hr />
<h2 id="深入专题4撤销重做的命令模式实现"><a class="header" href="#深入专题4撤销重做的命令模式实现">深入专题（4）：撤销/重做的命令模式实现</a></h2>
<p>核心：</p>
<ul>
<li>为每个动作定义 <code>do/undo</code>，把副作用封装进命令。</li>
<li>历史栈存放命令而非快照，降低内存占用。</li>
</ul>
<p>片段：</p>
<pre><code class="language-ts">type Cmd = { do(): void; undo(): void }
class History2 { past: Cmd[] = []; future: Cmd[] = []; push(c: Cmd){ this.past.push(c); this.future=[] } undo(){ this.past.pop()?.undo() } redo(){ const c = this.future.pop(); c?.do() } }
</code></pre>
<hr />
<h2 id="深入专题5自定义-scheduler-与节流-reaction"><a class="header" href="#深入专题5自定义-scheduler-与节流-reaction">深入专题（5）：自定义 scheduler 与节流 reaction</a></h2>
<p>需求：搜索输入触发副作用时，控制节奏与优先级。</p>
<p>片段：</p>
<pre><code class="language-ts">import { reaction } from 'mobx'
function throttle&lt;T extends (...args:any)=&gt;any&gt;(fn: T, wait: number): T { let last=0; let saved:any; return ((...args:any) =&gt; { const now=Date.now(); saved=args; if(now-last&gt;wait){ last=now; fn(...saved) } }) as T }
const dispose = reaction(
  () =&gt; vm.q,
  throttle(q =&gt; vm.search(q), 200),
  { fireImmediately: false }
)
</code></pre>
<hr />
<h2 id="深入专题6派生选择器参数化与缓存陷阱"><a class="header" href="#深入专题6派生选择器参数化与缓存陷阱">深入专题（6）：派生选择器参数化与缓存陷阱</a></h2>
<p>建议：</p>
<ul>
<li>使用 <code>computedFn</code> 对参数化查询进行缓存；参数必须可作为稳定 key。</li>
<li>不要在 computed 内产生副作用或创建新 observable。</li>
</ul>
<hr />
<h2 id="深入专题7图数据建模与路径计算"><a class="header" href="#深入专题7图数据建模与路径计算">深入专题（7）：图数据建模与路径计算</a></h2>
<p>案例：节点/边图结构（流程图、关系图），在变动时重新计算最短路径或连通分量。</p>
<p>数据与派生：</p>
<pre><code class="language-ts">type Node = { id:string }
type Edge = { from:string; to:string; w:number }
class GraphStore {
  nodes = new Map&lt;string, Node&gt;()
  edges = new Set&lt;Edge&gt;()
  constructor(){ makeAutoObservable(this) }
  get neighbors(){ const m = new Map&lt;string, Edge[]&gt;(); for (const e of this.edges){ if(!m.has(e.from)) m.set(e.from, []); m.get(e.from)!.push(e) } return m }
  // computed: shortestPath(from,to) 可用 computedFn + Dijkstra 实现
}
</code></pre>
<hr />
<h2 id="附录实战看板完整-store--组件片段"><a class="header" href="#附录实战看板完整-store--组件片段">附录：实战看板完整 Store + 组件片段</a></h2>
<p>Store：</p>
<pre><code class="language-ts">type Card = { id:string; title:string; desc?:string; status:'todo'|'doing'|'done'; assignee?:number; createdAt:number }
class KanbanStore {
  cards = new Map&lt;string, Card&gt;()
  order: Record&lt;Card['status'], string[]&gt; = { todo:[], doing:[], done:[] }
  q = ''
  constructor(){ makeAutoObservable(this, {}, { autoBind: true }) }
  add(title:string){ const id = crypto.randomUUID(); const c:Card = { id, title, status:'todo', createdAt:Date.now() }; this.cards.set(id,c); this.order.todo.unshift(id) }
  move(id:string, to:Card['status'], index?:number){
    const c = this.cards.get(id); if(!c) return; const from = c.status
    if (from === to &amp;&amp; index===undefined) return
    // 从旧泳道移除
    this.order[from] = this.order[from].filter(x =&gt; x!==id)
    // 加入新泳道
    c.status = to
    const arr = this.order[to]
    if(index===undefined) arr.unshift(id); else arr.splice(index,0,id)
  }
  get lane(){
    const q = this.q.toLowerCase()
    return (s:Card['status']) =&gt; this.order[s].map(id =&gt; this.cards.get(id)!).filter(c =&gt; !q || c.title.toLowerCase().includes(q))
  }
}
</code></pre>
<p>组件：</p>
<pre><code class="language-tsx">const Lane = observer(({ s }: { s: Card['status'] }) =&gt; {
  const { kb } = useStore()
  const list = kb.lane(s)
  return (
    &lt;div&gt;
      &lt;h3&gt;{s} ({list.length})&lt;/h3&gt;
      {list.map(c =&gt; &lt;div key={c.id}&gt;{c.title}&lt;/div&gt;)}
    &lt;/div&gt;
  )
})
</code></pre>
<hr />
<h2 id="附录快照导入导出脚本"><a class="header" href="#附录快照导入导出脚本">附录：快照导入导出脚本</a></h2>
<p>导出：</p>
<pre><code class="language-ts">function dump(store: RootStore){
  return JSON.stringify({ auth: { token: store.auth.token }, product: { items: toJS(store.product.items) } })
}
</code></pre>
<p>导入：</p>
<pre><code class="language-ts">function load(store: RootStore, raw: string){
  const s = JSON.parse(raw)
  runInAction(() =&gt; { store.auth.token = s.auth.token; store.product.items = s.product.items })
}
</code></pre>
<hr />
<h2 id="faq121160"><a class="header" href="#faq121160">FAQ（121—160）</a></h2>
<ol start="121">
<li>Q：如何把异常转换为用户友好提示？A：服务层统一 map，为用户可读的 message；Store 用 error 字段；ErrorBoundary 捕获未知异常。</li>
<li>Q：如何避免“渲染抖动”？A：批量更新；避免在动画中频繁 set；scheduler 在 rAF。</li>
<li>Q：如何做“只读模式”？A：Store 方法根据 flag 早返回；UI 禁用交互；权限层过滤。</li>
<li>Q：如何在移动端优化触摸列表？A：减少点击区域重渲染；使用 pointer 事件；虚拟化。</li>
<li>Q：如何用 MobX 做定时刷新？A：<code>now(interval)</code> 或 setInterval + action 写入。</li>
<li>Q：如何测试 reaction 分支？A：手动变更依赖并断言 effect；使用虚拟时钟。</li>
<li>Q：如何让 computed 返回稳定引用？A：对结果数组进行缓存或使用 <code>equals</code>。</li>
<li>Q：如何对齐 REST 与 Store？A：Service 层负责适配字段名与结构，Store 只用领域模型。</li>
<li>Q：如何追踪是谁修改了状态？A：在 action 层包一层并记录调用栈 <code>new Error().stack</code>。</li>
<li>Q：如何减少 bundle 体积？A：按需引入；移除装饰器；动态 import 少用的大组件。</li>
<li>Q：如何兼容旧浏览器？A：编译目标降级；polyfill；MobX v6 对 proxy 依赖，需现代环境。</li>
<li>Q：如何在服务端使用 MobX？A：禁用 reactions；每请求创建独立实例。</li>
<li>Q：如何做拖拽排序？A：拖拽回调中调用 <code>move(id, to, index)</code>，在 Store 里维护顺序数组。</li>
<li>Q：如何实现乐观删除？A：先从列表移除，失败再插回；或使用软删除标记。</li>
<li>Q：如何显示“并发编辑提醒”？A：订阅远端版本变更，UI 层提示并提供合并/覆盖选项。</li>
<li>Q：如何避免“深层传 props”？A：Context + RootStore；或在页面级组装。</li>
<li>Q：如何批量选择并操作？A：<code>selected:Set&lt;id&gt;</code>；提供 <code>selectAllInView()</code> 方法。</li>
<li>Q：如何对脏数据做自动修复？A：在 intercept 中修正或丢弃非法变更。</li>
<li>Q：如何保证导入数据合法？A：导入时先 schema 校验，再写入 Store。</li>
<li>Q：如何控制打印布局？A：UI Store 维护 <code>printMode</code>，组件根据模式调整展示。</li>
<li>Q：如何确保某些 computed 始终预热？A：<code>keepAlive</code> 并在启动阶段访问一次。</li>
<li>Q：如何在 iframe 中共享状态？A：postMessage 桥接，转为 action 更新。</li>
<li>Q：如何记录“指令链路”？A：在 action 层增设 correlationId 贯穿链路。</li>
<li>Q：如何防止用户重复提交？A：在 VM 中维护 <code>submitting</code>，按钮根据状态禁用。</li>
<li>Q：如何对滚动位置做状态化？A：UI Store 记录 scrollTop；路由切换恢复。</li>
<li>Q：如何把 UI 选择与 URL 同步？A：在 reaction 中 <code>router.replace({ query })</code>；解析时写回 Store。</li>
<li>Q：如何实现“草稿自动保存”？A：reaction + debounce 持久化白名单字段。</li>
<li>Q：如何做“最近搜索建议”？A：UI Store 保存历史；在输入时过滤展示。</li>
<li>Q：如何隔离第三方组件副作用？A：用 Adapter 组件把事件转换为 action。</li>
<li>Q：如何将大计算延后到空闲？A：<code>scheduler: (fn) =&gt; requestIdleCallback(fn)</code>（需降级方案）。</li>
<li>Q：如何在打印/导出时冻结数据？A：拍平快照；临时挂起 reaction。</li>
<li>Q：如何在 React.StrictMode 下重复调用副作用？A：使用 <code>once</code> 守卫或在 reaction 中防抖。</li>
<li>Q：如何定义领域错误类型？A：统一 <code>AppError { code, message }</code>，服务层抛出，Store 捕获。</li>
<li>Q：如何保证 UI 与状态一致性？A：状态源唯一且由 UI 读；尽量避免 UI 本地状态与 Store 重复。</li>
<li>Q：如何设计“草稿→发布→归档”的生命周期？A：状态机建模，方法显式变更状态并验证合法性。</li>
<li>Q：如何为 computed 分层？A：原子派生→组合派生→视图派生，避免巨型 computed。</li>
<li>Q：如何记录变更历史？A：在 action 中追加历史记录条目；按需持久化。</li>
<li>Q：如何为子系统提供 SDK？A：只暴露语义方法与只读派生；隐藏内部实现与集合。</li>
<li>Q：如何在 Hooks 中使用非观察数据？A：用 <code>useRef</code>/<code>useState</code> 保存瞬时值，不入 MobX。</li>
<li>Q：如何实现“导出后还原”流程？A：导出前拍平数据→下载→导出后清理快照并恢复观察状态。</li>
</ol>
<hr />
<h2 id="附录常用数学聚合工具可直接使用"><a class="header" href="#附录常用数学聚合工具可直接使用">附录：常用数学/聚合工具（可直接使用）</a></h2>
<pre><code class="language-ts">export function groupBy&lt;T, K extends PropertyKey&gt;(arr: T[], key: (x:T)=&gt;K){
  const m = new Map&lt;K, T[]&gt;(); for(const x of arr){ const k = key(x); if(!m.has(k)) m.set(k, []); m.get(k)!.push(x) } return m
}
export function sum(arr:number[]){ return arr.reduce((a,b)=&gt;a+b,0) }
export function avg(arr:number[]){ return arr.length? sum(arr)/arr.length : 0 }
export function sortBy&lt;T&gt;(arr:T[], key:(x:T)=&gt;any, dir:'asc'|'desc'='asc'){ const s=[...arr].sort((a,b)=&gt;key(a)&gt;key(b)?1:-1); return dir==='asc'?s:s.reverse() }
</code></pre>
<hr />
<h2 id="附录完整表单页面实现注册登录一体"><a class="header" href="#附录完整表单页面实现注册登录一体">附录：完整表单页面实现（注册/登录一体）</a></h2>
<p>ViewModel：</p>
<pre><code class="language-ts">// src/vm/auth.ts
import { makeAutoObservable, reaction, runInAction } from 'mobx'
import * as z from 'zod'

const SignUpSchema = z.object({
  username: z.string().min(3, '至少 3 个字符').max(20),
  email: z.string().email('邮箱格式不正确'),
  password: z.string().min(8, '至少 8 位'),
  agree: z.literal(true, { errorMap: () =&gt; ({ message:'请同意协议' }) })
})

type SignUp = z.infer&lt;typeof SignUpSchema&gt;
type Errors = Partial&lt;Record&lt;keyof SignUp, string&gt;&gt;

export class AuthVM {
  mode: 'login'|'signup' = 'login'
  values: SignUp = { username:'', email:'', password:'', agree:false }
  errors: Errors = {}
  submitting = false
  checking = false
  constructor(private svc: { signUp(d:SignUp):Promise&lt;void&gt;; login(u:string,p:string):Promise&lt;void&gt;; checkUser(u:string):Promise&lt;boolean&gt; }){
    makeAutoObservable(this, {}, { autoBind: true })
    reaction(() =&gt; this.values.username, this.checkUsername, { delay: 400 })
  }
  set&lt;K extends keyof SignUp&gt;(k:K, v: SignUp[K]){ (this.values[k] as any) = v }
  validate(){ const r = SignUpSchema.safeParse(this.values); this.errors = r.success ? {} : Object.fromEntries(r.error.issues.map(i =&gt; [i.path[0] as string, i.message])) }
  get valid(){ return Object.keys(this.errors).length===0 }
  async checkUsername(u:string){ if (this.mode!=='signup' || !u) return; this.checking = true; try { const ok = await this.svc.checkUser(u); runInAction(()=&gt; this.errors.username = ok ? '' : '用户名已存在') } finally { this.checking = false } }
  async submit(){
    if (this.mode==='login') return this.login()
    this.validate(); if (!this.valid) return
    this.submitting = true
    try { await this.svc.signUp(this.values); runInAction(()=&gt; { this.mode='login' }) }
    finally { this.submitting = false }
  }
  async login(){ this.submitting = true; try { await this.svc.login(this.values.username, this.values.password) } finally { this.submitting=false } }
}
</code></pre>
<p>UI：</p>
<pre><code class="language-tsx">// src/components/AuthForm.tsx
import { observer } from 'mobx-react-lite'
export const AuthForm = observer(({ vm }: { vm: AuthVM }) =&gt; {
  return (
    &lt;form onSubmit={e =&gt; { e.preventDefault(); vm.submit() }}&gt;
      &lt;div&gt;
        &lt;label&gt;用户名&lt;/label&gt;
        &lt;input value={vm.values.username} onChange={e =&gt; vm.set('username', e.target.value)} /&gt;
        {vm.errors.username &amp;&amp; &lt;span&gt;{vm.errors.username}&lt;/span&gt;}
      &lt;/div&gt;
      {vm.mode==='signup' &amp;&amp; (
        &lt;div&gt;
          &lt;label&gt;邮箱&lt;/label&gt;
          &lt;input value={vm.values.email} onChange={e =&gt; vm.set('email', e.target.value)} /&gt;
          {vm.errors.email &amp;&amp; &lt;span&gt;{vm.errors.email}&lt;/span&gt;}
        &lt;/div&gt;
      )}
      &lt;div&gt;
        &lt;label&gt;密码&lt;/label&gt;
        &lt;input type="password" value={vm.values.password} onChange={e =&gt; vm.set('password', e.target.value)} /&gt;
        {vm.errors.password &amp;&amp; &lt;span&gt;{vm.errors.password}&lt;/span&gt;}
      &lt;/div&gt;
      {vm.mode==='signup' &amp;&amp; (
        &lt;div&gt;
          &lt;label&gt;
            &lt;input type="checkbox" checked={vm.values.agree} onChange={e =&gt; vm.set('agree', e.target.checked)} /&gt;同意协议
          &lt;/label&gt;
          {vm.errors.agree &amp;&amp; &lt;span&gt;{vm.errors.agree}&lt;/span&gt;}
        &lt;/div&gt;
      )}
      &lt;div&gt;
        &lt;button type="submit" disabled={vm.submitting}&gt;{vm.mode==='signup' ? '注册' : '登录'}&lt;/button&gt;
        &lt;button type="button" onClick={() =&gt; vm.mode = vm.mode==='signup'?'login':'signup'}&gt;{vm.mode==='signup'?'已有账户？登录':'没有账户？注册'}&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  )
})
</code></pre>
<hr />
<h2 id="附录store-测试大全模式示例"><a class="header" href="#附录store-测试大全模式示例">附录：Store 测试大全（模式示例）</a></h2>
<ol>
<li>行为测试（方法语义）：</li>
</ol>
<pre><code class="language-ts">it('add then computed reflects changes', () =&gt; {
  const s = new CartStore(); s.add('a', 10, 2); expect(s.total).toBe(20)
})
</code></pre>
<ol start="2">
<li>副作用测试（reaction）：</li>
</ol>
<pre><code class="language-ts">it('fires on price change only', () =&gt; {
  const fired: number[] = []
  const d = reaction(() =&gt; s.total, v =&gt; fired.push(v))
  s.add('a', 10, 1); s.setCurrency('USD'); expect(fired.length).toBe(1); d()
})
</code></pre>
<ol start="3">
<li>竞态测试：</li>
</ol>
<pre><code class="language-ts">it('drops outdated responses', async () =&gt; {
  s.setQuery('x')
  const r1 = s.load(); s.setQuery('y'); const r2 = s.load(); await r1 as any; await r2 as any; expect(s.q).toBe('y')
})
</code></pre>
<hr />
<h2 id="附录性能策略案例前后对比"><a class="header" href="#附录性能策略案例前后对比">附录：性能策略案例（前后对比）</a></h2>
<ol>
<li>
<p>重构前：父组件计算 filtered 然后传给子组件，导致父变动触发全部子组件更新。</p>
</li>
<li>
<p>重构后：把 filtered 放入 Store 的 computed；子组件直接读取 <code>store.pageData</code>；渲染次数下降显著。</p>
</li>
<li>
<p>量化：Profiler 截图对比；渲染时间从 120ms 降至 35ms。</p>
</li>
</ol>
<hr />
<h2 id="附录命名与分层建议示例"><a class="header" href="#附录命名与分层建议示例">附录：命名与分层建议（示例）</a></h2>
<ul>
<li>Store：名词或领域 + Store（<code>UserStore</code>、<code>OrderStore</code>）；</li>
<li>方法：语义化动词（<code>submitOrder</code>、<code>approve</code>、<code>publish</code>）；</li>
<li>UI Store：页面/模块 + VM（<code>LoginVM</code>、<code>CatalogUI</code>）。</li>
</ul>
<hr />
<h2 id="附录ssr-水合完整流程nextjs-pages"><a class="header" href="#附录ssr-水合完整流程nextjs-pages">附录：SSR 水合完整流程（Next.js Pages）</a></h2>
<ol>
<li>服务端获取首屏数据：</li>
</ol>
<pre><code class="language-ts">// pages/index.tsx
import type { GetServerSideProps } from 'next'
export const getServerSideProps: GetServerSideProps = async (ctx) =&gt; {
  const token = ctx.req.cookies['token'] ?? null
  const initial = await fetch(`${process.env.API}/products?initial=1`, { headers: token?{ Authorization:`Bearer ${token}` }:{} }).then(r=&gt;r.json())
  return { props: { initial, token } }
}
</code></pre>
<ol start="2">
<li>客户端水合：</li>
</ol>
<pre><code class="language-tsx">export default function Page({ initial, token }: any){
  return (
    &lt;RootStoreProvider&gt;
      &lt;Hydrator initial={initial} token={token} /&gt;
    &lt;/RootStoreProvider&gt;
  )
}
const Hydrator = observer(({ initial, token }: any) =&gt; {
  const { auth, product } = useStore()
  useEffect(() =&gt; { auth.token = token; product.items = initial.items; product.total = initial.total }, [initial, token])
  return &lt;Home /&gt;
})
</code></pre>
<hr />
<h2 id="附录i18n-资源示例片段"><a class="header" href="#附录i18n-资源示例片段">附录：i18n 资源示例（片段）</a></h2>
<pre><code class="language-json">{
  "app.title": "产品目录",
  "auth.login": "登录",
  "auth.signup": "注册",
  "form.username": "用户名",
  "form.password": "密码",
  "form.email": "邮箱",
  "button.submit": "提交",
  "button.cancel": "取消",
  "msg.loading": "加载中...",
  "msg.error": "出错了"
}
</code></pre>
<hr />
<h2 id="附录错误码与处理器"><a class="header" href="#附录错误码与处理器">附录：错误码与处理器</a></h2>
<p>标准化：</p>
<pre><code class="language-ts">type AppError = { code: 'UNAUTHORIZED'|'FORBIDDEN'|'NOT_FOUND'|'VALIDATION'|'NETWORK'|'UNKNOWN'; message: string; status?: number }
function mapHttpError(e:any): AppError {
  if (!e || !e.status) return { code:'NETWORK', message:'网络异常' }
  if (e.status === 401) return { code:'UNAUTHORIZED', message:'未登录', status: e.status }
  if (e.status === 403) return { code:'FORBIDDEN', message:'无权限', status: e.status }
  if (e.status === 404) return { code:'NOT_FOUND', message:'未找到', status: e.status }
  if (e.status === 422) return { code:'VALIDATION', message:e.message || '参数错误', status: e.status }
  return { code:'UNKNOWN', message:e.message || '未知错误', status: e.status }
}
</code></pre>
<p>Store 使用：</p>
<pre><code class="language-ts">try { await svc.doSomething() } catch (e:any){ runInAction(() =&gt; store.error = mapHttpError(e).message) }
</code></pre>
<hr />
<h2 id="附录脚手架命令packagejson-片段"><a class="header" href="#附录脚手架命令packagejson-片段">附录：脚手架命令（package.json 片段）</a></h2>
<pre><code class="language-json">{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint .",
    "type-check": "tsc --noEmit",
    "test": "vitest run",
    "test:ui": "vitest"
  }
}
</code></pre>
<hr />
<h2 id="附录cigithub-actions"><a class="header" href="#附录cigithub-actions">附录：CI（GitHub Actions）</a></h2>
<pre><code class="language-yaml">name: ci
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: npm ci
      - run: npm run type-check
      - run: npm run lint
      - run: npm test -- --coverage
      - run: npm run build
</code></pre>
<hr />
<h2 id="领域建模范式可借鉴"><a class="header" href="#领域建模范式可借鉴">领域建模范式（可借鉴）</a></h2>
<ul>
<li>实体（Entity）：可识别（id）、可变（如 User、Order）。</li>
<li>值对象（Value Object）：不可变且无标识（如 Money、DateRange）。</li>
<li>聚合（Aggregate）：边界内的一致性规则与事务（如 Order + OrderItem）。</li>
<li>仓储（Repository）：对外提供实体的持久化访问接口（服务层近似角色）。</li>
</ul>
<p>MobX 落地：</p>
<ul>
<li>Entity 用 Map 存；Value Object 以不可变对象/类型表示；</li>
<li>聚合规则在 Store 方法中保证；</li>
<li>Repository 对应服务层。</li>
</ul>
<hr />
<h2 id="anti-patterns-扩展示例"><a class="header" href="#anti-patterns-扩展示例">Anti-Patterns 扩展示例</a></h2>
<p>反例 1：在 render 中 <code>const data = store.items.filter(...)</code></p>
<ul>
<li>危害：父更新导致所有子组件刷新；</li>
<li>正确：把 <code>filtered</code> 放 Store 的 computed；子组件直接读取。</li>
</ul>
<p>反例 2：在 autorun 内写状态</p>
<ul>
<li>危害：反馈环 + 难以控制；</li>
<li>正确：reaction(effect) 中写，或显式 action。</li>
</ul>
<p>反例 3：到处传 <code>toJS(store.bigMap)</code></p>
<ul>
<li>危害：深拷贝昂贵 + 失去订阅颗粒度；</li>
<li>正确：子组件内按需读取；或派生需要的视图模型。</li>
</ul>
<hr />
<h2 id="附录术语中英对照扩展"><a class="header" href="#附录术语中英对照扩展">附录：术语中英对照（扩展）</a></h2>
<ul>
<li>可观察：Observable</li>
<li>派生：Derivation</li>
<li>动作：Action</li>
<li>反应：Reaction（autorun/reaction/when）</li>
<li>事务/批量：Transaction/Batch</li>
<li>订阅：Subscription</li>
<li>依赖图：Dependency Graph</li>
<li>水合：Hydration</li>
<li>领域事件：Domain Event</li>
<li>聚合：Aggregate</li>
<li>快照：Snapshot</li>
</ul>
<hr />
<h2 id="学习路径甘特图建议时间规划"><a class="header" href="#学习路径甘特图建议时间规划">学习路径甘特图建议（时间规划）</a></h2>
<ul>
<li>第 1 天：核心概念 + React 集成（4h 实操 + 2h 复盘）</li>
<li>第 2—3 天：异步/副作用 + 架构分层 + 实战 Todo/Catalog（12h）</li>
<li>第 4 天：性能与调试 + 测试（6h）</li>
<li>第 5—6 天：端到端项目（SSR/权限/实时）（12h）</li>
<li>第 7 天：优化/验收/文档化（6h）</li>
</ul>
<hr />
<h2 id="进一步阅读与参考实现"><a class="header" href="#进一步阅读与参考实现">进一步阅读与参考实现</a></h2>
<ul>
<li>MobX 官方文档与 examples 仓库</li>
<li>mobx-state-tree、mobx-keystone：建模与快照流派</li>
<li>TanStack Query：服务器状态协作</li>
<li>dnd-kit/react-beautiful-dnd：拖拽</li>
<li>react-virtual：虚拟化</li>
<li>dexie：IndexedDB 封装</li>
<li>framer-motion：动画</li>
<li>vitest/testing-library：测试</li>
</ul>
<hr />
<h2 id="cheatsheet上手小抄"><a class="header" href="#cheatsheet上手小抄">CheatSheet（上手小抄）</a></h2>
<ul>
<li>新建 Store：<code>class X { constructor(){ makeAutoObservable(this, {}, { autoBind:true }) } }</code></li>
<li>读派生：<code>get computed(){ return ... }</code></li>
<li>写状态：<code>runInAction(() =&gt; { ... })</code> 或方法标注 action</li>
<li>React 订阅：<code>export default observer(Component)</code></li>
<li>局部状态：<code>const vm = useLocalObservable(() =&gt; ({ ... }))</code></li>
<li>异步：<code>flow(function*(){ const r = yield fetch(...); this.data = r })</code></li>
<li>条件一次：<code>when(() =&gt; ready, () =&gt; effect())</code></li>
<li>精确副作用：<code>reaction(() =&gt; sel, (v, prev) =&gt; effect(v, prev))</code></li>
<li>调试：render 内 <code>trace(true)</code>；全局 <code>spy(ev =&gt; ...)</code></li>
<li>性能：小组件多 observer；computed 缓存；Map/Set 管理集合</li>
</ul>
<hr />
<h2 id="深入专题8与-immer-协作的取舍"><a class="header" href="#深入专题8与-immer-协作的取舍">深入专题（8）：与 immer 协作的取舍</a></h2>
<ul>
<li>MobX 已支持可变更新，通常不需要 immer；</li>
<li>若团队强依赖不可变思维，可在部分模块使用 immer 生成新引用，再以 <code>observable.ref</code> 管理，权衡性能成本。</li>
</ul>
<hr />
<h2 id="深入专题9crdt离线合并基础"><a class="header" href="#深入专题9crdt离线合并基础">深入专题（9）：CRDT/离线合并基础</a></h2>
<p>方向：离线编辑后合并远端变更，基于 vector clock/版本号合并到 <code>observable.map</code>，冲突以“最后写入为准”或策略化解析。</p>
<hr />
<h2 id="深入专题10复杂国际化复数区间占位"><a class="header" href="#深入专题10复杂国际化复数区间占位">深入专题（10）：复杂国际化（复数、区间、占位）</a></h2>
<p>建议：在 <code>I18nStore</code> 内提供格式化 API，computed 负责复用和缓存；使用 ICU Message 格式。</p>
<hr />
<h2 id="深入专题11动画与状态framer-motion"><a class="header" href="#深入专题11动画与状态framer-motion">深入专题（11）：动画与状态（framer-motion）</a></h2>
<p>实践：</p>
<ul>
<li>状态切换驱动动画；动画结束回调触发下一步 action。</li>
<li>避免在动画过程中频繁写状态导致抖动。</li>
</ul>
<hr />
<h2 id="深入专题12大集合内存与分片加载"><a class="header" href="#深入专题12大集合内存与分片加载">深入专题（12）：大集合内存与分片加载</a></h2>
<p>策略：分页与分片缓存；在 Map 内以 id 存储并记录 <code>loadedRange</code>；只有在视区附近触发加载。</p>
<hr />
<h2 id="深入专题13安全与可信输入"><a class="header" href="#深入专题13安全与可信输入">深入专题（13）：安全与可信输入</a></h2>
<p>对于富文本/外部数据：严格走服务层统一转义/清洗；Store 层只接收规范化后的数据结构。</p>
<hr />
<h2 id="深入专题14跨域与凭证"><a class="header" href="#深入专题14跨域与凭证">深入专题（14）：跨域与凭证</a></h2>
<p>服务层提供统一跨域与凭证策略；错误码标准化，Store 只消费统一的错误对象。</p>
<hr />
<h2 id="深入专题15与-service-worker-协作"><a class="header" href="#深入专题15与-service-worker-协作">深入专题（15）：与 Service Worker 协作</a></h2>
<p>将离线缓存/推送通知委托给 SW；事件回调进入 Store 的 action 统一处理。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/language/32-ReactJS.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/language/34-NextJS.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/language/32-ReactJS.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/language/34-NextJS.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

