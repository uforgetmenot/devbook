<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Open vSwitch 学习笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="open-vswitch-学习笔记"><a class="header" href="#open-vswitch-学习笔记">Open vSwitch 学习笔记</a></h1>
<h2 id="学习目标定位"><a class="header" href="#学习目标定位">学习目标定位</a></h2>
<p><strong>角色定位</strong>: 1-5年经验的网络工程师/云平台开发者，希望掌握软件定义网络(SDN)和网络虚拟化技术</p>
<p><strong>学习成果</strong>: 完成本笔记学习后，你将能够：</p>
<ul>
<li>理解Open vSwitch的架构和工作原理</li>
<li>熟练配置和管理OVS网络</li>
<li>使用OpenFlow流表实现复杂的网络策略</li>
<li>在虚拟化环境中部署OVS</li>
<li>进行性能优化和故障排查</li>
<li>集成OVS到云平台和SDN环境</li>
</ul>
<hr />
<h2 id="第一部分open-vswitch-基础入门"><a class="header" href="#第一部分open-vswitch-基础入门">第一部分：Open vSwitch 基础入门</a></h2>
<h3 id="11-什么是open-vswitch"><a class="header" href="#11-什么是open-vswitch">1.1 什么是Open vSwitch</a></h3>
<h4 id="定义与核心特点"><a class="header" href="#定义与核心特点">定义与核心特点</a></h4>
<p>Open vSwitch（OVS）是一个开源的多层虚拟交换机，主要用于虚拟化环境中的网络交换。它支持标准的管理接口和协议，同时也支持OpenFlow等SDN协议。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li><strong>开源免费</strong>: Apache 2.0许可证</li>
<li><strong>高性能</strong>: 支持DPDK和AF_XDP加速</li>
<li><strong>标准兼容</strong>: 支持802.1Q VLAN、QoS、LACP等</li>
<li><strong>可编程性</strong>: 支持OpenFlow和P4</li>
<li><strong>平台无关</strong>: 支持Linux、Windows、FreeBSD</li>
<li><strong>生产就绪</strong>: 被广泛应用于云平台（OpenStack、Kubernetes）</li>
</ul>
<h4 id="open-vswitch-vs-传统交换机"><a class="header" href="#open-vswitch-vs-传统交换机">Open vSwitch vs 传统交换机</a></h4>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>传统交换机</th><th>Open vSwitch</th></tr></thead><tbody>
<tr><td><strong>控制平面</strong></td><td>本地固化</td><td>可分离到控制器</td></tr>
<tr><td><strong>可编程性</strong></td><td>有限（CLI/SNMP）</td><td>高度可编程（OpenFlow/OVSDB）</td></tr>
<tr><td><strong>虚拟化支持</strong></td><td>不支持</td><td>原生支持VM/容器</td></tr>
<tr><td><strong>部署方式</strong></td><td>硬件设备</td><td>软件实现</td></tr>
<tr><td><strong>扩展性</strong></td><td>端口数受限</td><td>可灵活扩展</td></tr>
<tr><td><strong>成本</strong></td><td>高昂</td><td>免费开源</td></tr>
<tr><td><strong>管理接口</strong></td><td>命令行/Web</td><td>CLI + OVSDB + OpenFlow</td></tr>
</tbody></table>
</div>
<h4 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h4>
<pre><code>1. 云平台网络
   ├── OpenStack Neutron网络
   ├── Kubernetes CNI插件
   └── 私有云虚拟网络

2. SDN网络
   ├── SDN控制器接入点
   ├── 网络功能虚拟化(NFV)
   └── 流量工程

3. 虚拟化环境
   ├── KVM虚拟机网络
   ├── Docker容器网络
   └── 虚拟化桌面(VDI)

4. 网络实验室
   ├── SDN学习和实验
   ├── 网络协议测试
   └── 性能基准测试
</code></pre>
<h3 id="12-架构设计"><a class="header" href="#12-架构设计">1.2 架构设计</a></h3>
<h4 id="整体架构图"><a class="header" href="#整体架构图">整体架构图</a></h4>
<pre><code>┌─────────────────────────────────────────────────────┐
│                SDN Controller                       │
│            (Ryu, ONOS, ODL, etc.)                  │
└────────────────────┬────────────────────────────────┘
                     │ OpenFlow Protocol
                     │
┌────────────────────▼────────────────────────────────┐
│              ovs-vswitchd                           │
│         (用户空间交换守护进程)                        │
│  ┌──────────────────────────────────────────────┐  │
│  │  OpenFlow Module  │  OVSDB Client            │  │
│  └──────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────┘
                     │ Netlink
                     │
┌────────────────────▼────────────────────────────────┐
│           openvswitch.ko (内核模块)                  │
│  ┌──────────────────────────────────────────────┐  │
│  │  Flow Table Cache │ Tunnel Processing        │  │
│  └──────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────┘
                     │
         ┌───────────┼───────────┐
         │           │           │
    ┌────▼────┐ ┌───▼────┐ ┌───▼────┐
    │  eth0   │ │  tap0  │ │ vxlan0 │
    │ 物理网卡 │ │ 虚拟网卡│ │  隧道  │
    └─────────┘ └────────┘ └────────┘

┌─────────────────────────────────────────────────────┐
│              ovsdb-server                           │
│          (配置数据库服务)                            │
│  ┌──────────────────────────────────────────────┐  │
│  │  Bridge DB │ Port DB │ Interface DB          │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
</code></pre>
<h4 id="数据平面与控制平面分离"><a class="header" href="#数据平面与控制平面分离">数据平面与控制平面分离</a></h4>
<p><strong>数据平面 (Data Plane)</strong>：</p>
<ul>
<li>位置：主要在内核空间(openvswitch.ko)</li>
<li>功能：高速数据包转发</li>
<li>机制：基于流表缓存进行快速匹配</li>
<li>性能：可达10Gbps+（硬件加速可达100Gbps+）</li>
</ul>
<p><strong>控制平面 (Control Plane)</strong>：</p>
<ul>
<li>位置：用户空间(ovs-vswitchd)</li>
<li>功能：流表管理、协议处理、配置管理</li>
<li>机制：OpenFlow协议、OVSDB协议</li>
<li>交互：通过Netlink与内核模块通信</li>
</ul>
<p><strong>工作流程</strong>：</p>
<pre><code>1. 新数据包到达 → 内核模块查找流表缓存
2. 缓存未命中 → 上送到用户空间ovs-vswitchd
3. ovs-vswitchd处理 → 查询OpenFlow流表
4. 流表未命中 → 询问SDN控制器
5. 控制器下发新流表 → 更新到内核缓存
6. 后续数据包 → 直接在内核转发（快速路径）
</code></pre>
<h3 id="13-核心概念"><a class="header" href="#13-核心概念">1.3 核心概念</a></h3>
<h4 id="bridge网桥"><a class="header" href="#bridge网桥">Bridge（网桥）</a></h4>
<p>网桥是OVS中的虚拟交换机实例，类似于传统的二层交换机。</p>
<pre><code class="language-bash"># 一个主机可以有多个bridge
br0 (管理网络)
 ├── eth0 (物理网卡)
 └── tap0 (虚拟机网卡)

br1 (业务网络)
 ├── eth1 (物理网卡)
 └── vxlan0 (隧道接口)
</code></pre>
<h4 id="port端口"><a class="header" href="#port端口">Port（端口）</a></h4>
<p>端口是bridge上的接入点，可以连接物理网卡、虚拟网卡或隧道。</p>
<p><strong>端口类型</strong>：</p>
<ul>
<li><strong>System Port</strong>: 对应系统中的网络接口</li>
<li><strong>Internal Port</strong>: OVS内部虚拟端口</li>
<li><strong>Patch Port</strong>: 连接两个bridge的虚拟patch线缆</li>
<li><strong>Tunnel Port</strong>: VXLAN、GRE等隧道端口</li>
</ul>
<h4 id="interface接口"><a class="header" href="#interface接口">Interface（接口）</a></h4>
<p>接口是端口的具体实现，定义了接口的类型和参数。</p>
<pre><code class="language-bash"># 接口类型
- internal: 内部接口
- system: 系统接口
- tap: TAP设备
- vxlan: VXLAN隧道
- gre: GRE隧道
- patch: Patch接口
</code></pre>
<h4 id="flow流表项"><a class="header" href="#flow流表项">Flow（流表项）</a></h4>
<p>流表项定义了数据包的匹配规则和处理动作。</p>
<pre><code>Flow Entry = Match Fields + Priority + Actions + Statistics
</code></pre>
<hr />
<h2 id="第二部分安装与基础配置"><a class="header" href="#第二部分安装与基础配置">第二部分：安装与基础配置</a></h2>
<h3 id="21-环境安装"><a class="header" href="#21-环境安装">2.1 环境安装</a></h3>
<h4 id="实战案例1在ubuntu上安装ovs"><a class="header" href="#实战案例1在ubuntu上安装ovs">实战案例1：在Ubuntu上安装OVS</a></h4>
<pre><code class="language-bash"># 方法1：使用APT安装（推荐新手）
sudo apt update
sudo apt install -y openvswitch-switch openvswitch-common

# 验证安装
ovs-vsctl --version
# 输出: ovs-vsctl (Open vSwitch) 2.13.x

# 启动服务
sudo systemctl start openvswitch-switch
sudo systemctl enable openvswitch-switch

# 检查服务状态
sudo systemctl status openvswitch-switch

# 验证内核模块
lsmod | grep openvswitch
</code></pre>
<h4 id="实战案例2从源码编译安装"><a class="header" href="#实战案例2从源码编译安装">实战案例2：从源码编译安装</a></h4>
<pre><code class="language-bash"># 1. 安装依赖
sudo apt install -y \
    build-essential \
    libssl-dev \
    python3 python3-pip \
    autoconf automake libtool \
    libcap-ng-dev

# 2. 下载源码
cd /tmp
wget https://www.openvswitch.org/releases/openvswitch-2.17.0.tar.gz
tar -xzf openvswitch-2.17.0.tar.gz
cd openvswitch-2.17.0

# 3. 配置编译选项
./configure --prefix=/usr/local --enable-ssl
make -j$(nproc)
sudo make install

# 4. 加载内核模块
sudo modprobe openvswitch

# 5. 创建配置目录
sudo mkdir -p /usr/local/etc/openvswitch
sudo mkdir -p /usr/local/var/run/openvswitch

# 6. 初始化数据库
sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db \
    vswitchd/vswitch.ovsschema

# 7. 启动服务
sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \
    --remote=db:Open_vSwitch,Open_vSwitch,manager_options \
    --private-key=db:Open_vSwitch,SSL,private_key \
    --certificate=db:Open_vSwitch,SSL,certificate \
    --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \
    --pidfile --detach

sudo ovs-vsctl --no-wait init

sudo ovs-vswitchd --pidfile --detach --log-file
</code></pre>
<h4 id="实战案例3centosrhel安装"><a class="header" href="#实战案例3centosrhel安装">实战案例3：CentOS/RHEL安装</a></h4>
<pre><code class="language-bash"># 安装
sudo yum install -y openvswitch

# 启动服务
sudo systemctl start openvswitch
sudo systemctl enable openvswitch

# 检查状态
sudo systemctl status openvswitch
</code></pre>
<h3 id="22-基础配置操作"><a class="header" href="#22-基础配置操作">2.2 基础配置操作</a></h3>
<h4 id="实战案例4创建第一个虚拟交换机"><a class="header" href="#实战案例4创建第一个虚拟交换机">实战案例4：创建第一个虚拟交换机</a></h4>
<pre><code class="language-bash"># 1. 创建bridge
sudo ovs-vsctl add-br br0

# 2. 查看bridge
sudo ovs-vsctl show
# 输出示例:
# Bridge br0
#     Port br0
#         Interface br0
#             type: internal

# 3. 查看所有bridge
sudo ovs-vsctl list-br

# 4. 添加物理网卡到bridge
sudo ovs-vsctl add-port br0 eth1

# 5. 给bridge分配IP
sudo ip addr add 192.168.1.100/24 dev br0
sudo ip link set br0 up

# 6. 验证配置
sudo ovs-vsctl show
ip addr show br0
</code></pre>
<h4 id="实战案例5配置vm网络"><a class="header" href="#实战案例5配置vm网络">实战案例5：配置VM网络</a></h4>
<p><strong>场景</strong>: 为KVM虚拟机配置网络</p>
<pre><code class="language-bash"># 1. 创建桥接网络
sudo ovs-vsctl add-br br-int

# 2. 添加物理网卡
sudo ovs-vsctl add-port br-int eth0

# 3. 为VM创建tap设备
sudo ip tuntap add dev tap0 mode tap
sudo ip link set tap0 up

# 4. 将tap设备添加到bridge
sudo ovs-vsctl add-port br-int tap0

# 5. 设置VLAN tag (可选)
sudo ovs-vsctl set port tap0 tag=100

# 6. 验证配置
sudo ovs-vsctl show
</code></pre>
<p><strong>KVM虚拟机XML配置</strong>：</p>
<pre><code class="language-xml">&lt;interface type='bridge'&gt;
  &lt;mac address='52:54:00:12:34:56'/&gt;
  &lt;source bridge='br-int'/&gt;
  &lt;virtualport type='openvswitch'/&gt;
  &lt;model type='virtio'/&gt;
&lt;/interface&gt;
</code></pre>
<h3 id="23-命令行工具详解"><a class="header" href="#23-命令行工具详解">2.3 命令行工具详解</a></h3>
<h4 id="ovs-vsctl配置管理工具"><a class="header" href="#ovs-vsctl配置管理工具">ovs-vsctl（配置管理工具）</a></h4>
<pre><code class="language-bash"># Bridge操作
ovs-vsctl add-br &lt;bridge&gt;              # 创建bridge
ovs-vsctl del-br &lt;bridge&gt;              # 删除bridge
ovs-vsctl list-br                      # 列出所有bridge
ovs-vsctl br-exists &lt;bridge&gt;           # 检查bridge是否存在

# Port操作
ovs-vsctl add-port &lt;bridge&gt; &lt;port&gt;     # 添加端口
ovs-vsctl del-port &lt;bridge&gt; &lt;port&gt;     # 删除端口
ovs-vsctl list-ports &lt;bridge&gt;          # 列出bridge的所有端口
ovs-vsctl port-to-br &lt;port&gt;            # 查询端口属于哪个bridge

# 查询和显示
ovs-vsctl show                         # 显示数据库内容
ovs-vsctl list bridge                  # 列出bridge详细信息
ovs-vsctl list port                    # 列出port详细信息
ovs-vsctl list interface               # 列出interface详细信息

# 设置和获取
ovs-vsctl set &lt;table&gt; &lt;record&gt; &lt;column&gt;=&lt;value&gt;
ovs-vsctl get &lt;table&gt; &lt;record&gt; &lt;column&gt;
ovs-vsctl remove &lt;table&gt; &lt;record&gt; &lt;column&gt; &lt;value&gt;

# 控制器配置
ovs-vsctl set-controller &lt;bridge&gt; &lt;target&gt;
ovs-vsctl del-controller &lt;bridge&gt;
ovs-vsctl get-controller &lt;bridge&gt;
</code></pre>
<h4 id="ovs-ofctlopenflow管理工具"><a class="header" href="#ovs-ofctlopenflow管理工具">ovs-ofctl（OpenFlow管理工具）</a></h4>
<pre><code class="language-bash"># 查看信息
ovs-ofctl show &lt;bridge&gt;                # 显示bridge端口信息
ovs-ofctl dump-flows &lt;bridge&gt;          # 显示所有流表
ovs-ofctl dump-ports &lt;bridge&gt;          # 显示端口统计
ovs-ofctl dump-groups &lt;bridge&gt;         # 显示组表

# 流表管理
ovs-ofctl add-flow &lt;bridge&gt; &lt;flow&gt;     # 添加流表项
ovs-ofctl mod-flows &lt;bridge&gt; &lt;flow&gt;    # 修改流表项
ovs-ofctl del-flows &lt;bridge&gt; [&lt;flow&gt;]  # 删除流表项

# 监控
ovs-ofctl monitor &lt;bridge&gt; [watch:]    # 监控OpenFlow消息
ovs-ofctl snoop &lt;bridge&gt;               # 监听控制器通信
</code></pre>
<h4 id="ovs-dpctl数据路径管理工具"><a class="header" href="#ovs-dpctl数据路径管理工具">ovs-dpctl（数据路径管理工具）</a></h4>
<pre><code class="language-bash"># 数据路径操作
ovs-dpctl show                         # 显示数据路径
ovs-dpctl dump-flows                   # 显示内核流表缓存
ovs-dpctl del-flows                    # 清除内核流表

# 统计信息
ovs-dpctl show -s                      # 显示详细统计
</code></pre>
<hr />
<h2 id="第三部分openflow流表详解"><a class="header" href="#第三部分openflow流表详解">第三部分：OpenFlow流表详解</a></h2>
<h3 id="31-流表结构"><a class="header" href="#31-流表结构">3.1 流表结构</a></h3>
<h4 id="流表项组成"><a class="header" href="#流表项组成">流表项组成</a></h4>
<pre><code>Flow Entry完整结构:

┌─────────────────────────────────────────┐
│  Match Fields (匹配字段)                 │
│  - 入端口、MAC地址、IP地址、端口号等      │
├─────────────────────────────────────────┤
│  Priority (优先级)                       │
│  - 0-65535，数值越大优先级越高           │
├─────────────────────────────────────────┤
│  Counters (计数器)                       │
│  - 匹配的数据包数量和字节数               │
├─────────────────────────────────────────┤
│  Instructions/Actions (指令/动作)        │
│  - 如何处理匹配的数据包                   │
├─────────────────────────────────────────┤
│  Timeouts (超时时间)                     │
│  - idle_timeout: 空闲超时                │
│  - hard_timeout: 硬超时                  │
├─────────────────────────────────────────┤
│  Cookie (标识符)                         │
│  - 流表项的唯一标识                       │
└─────────────────────────────────────────┘
</code></pre>
<h4 id="常用匹配字段"><a class="header" href="#常用匹配字段">常用匹配字段</a></h4>
<pre><code class="language-bash"># 二层匹配
in_port=&lt;port&gt;              # 入端口
dl_src=&lt;MAC&gt;                # 源MAC地址
dl_dst=&lt;MAC&gt;                # 目标MAC地址
dl_type=&lt;ethertype&gt;         # 以太网类型 (0x0800=IPv4, 0x0806=ARP)
dl_vlan=&lt;vlan&gt;              # VLAN ID

# 三层匹配
nw_src=&lt;IP/mask&gt;            # 源IP地址
nw_dst=&lt;IP/mask&gt;            # 目标IP地址
nw_proto=&lt;protocol&gt;         # IP协议 (6=TCP, 17=UDP, 1=ICMP)
nw_tos=&lt;tos&gt;                # ToS/DSCP

# 四层匹配
tp_src=&lt;port&gt;               # 源端口号
tp_dst=&lt;port&gt;               # 目标端口号

# ICMP
icmp_type=&lt;type&gt;            # ICMP类型
icmp_code=&lt;code&gt;            # ICMP代码
</code></pre>
<h3 id="32-流表动作"><a class="header" href="#32-流表动作">3.2 流表动作</a></h3>
<h4 id="基本动作"><a class="header" href="#基本动作">基本动作</a></h4>
<pre><code class="language-bash"># 输出动作
output:&lt;port&gt;               # 从指定端口输出
output:IN_PORT              # 从入端口输出
output:NORMAL               # 使用传统L2/L3处理
output:FLOOD                # 泛洪（除入端口外的所有端口）
output:ALL                  # 所有端口输出
output:CONTROLLER           # 发送到控制器

# 丢弃
drop                        # 丢弃数据包

# 修改动作
mod_dl_src:&lt;MAC&gt;            # 修改源MAC
mod_dl_dst:&lt;MAC&gt;            # 修改目标MAC
mod_nw_src:&lt;IP&gt;             # 修改源IP
mod_nw_dst:&lt;IP&gt;             # 修改目标IP
mod_tp_src:&lt;port&gt;           # 修改源端口
mod_tp_dst:&lt;port&gt;           # 修改目标端口

# VLAN动作
mod_vlan_vid:&lt;vlan&gt;         # 设置VLAN ID
strip_vlan                  # 移除VLAN标签
push_vlan:&lt;ethertype&gt;       # 添加VLAN标签

# 其他
set_queue:&lt;queue&gt;           # 设置队列
resubmit:&lt;port&gt;             # 重新提交到指定端口
</code></pre>
<h3 id="33-流表实战案例"><a class="header" href="#33-流表实战案例">3.3 流表实战案例</a></h3>
<h4 id="实战案例6基本二层转发"><a class="header" href="#实战案例6基本二层转发">实战案例6：基本二层转发</a></h4>
<pre><code class="language-bash"># 场景：配置简单的二层交换

# 1. 创建bridge
sudo ovs-vsctl add-br br0
sudo ovs-vsctl add-port br0 eth0
sudo ovs-vsctl add-port br0 eth1

# 2. 删除默认流表（如果有）
sudo ovs-ofctl del-flows br0

# 3. 添加ARP广播规则
sudo ovs-ofctl add-flow br0 \
    "priority=100,dl_type=0x0806,actions=flood"

# 4. 添加MAC学习规则（使用NORMAL action）
sudo ovs-ofctl add-flow br0 \
    "priority=0,actions=normal"

# 5. 查看流表
sudo ovs-ofctl dump-flows br0

# 6. 测试
ping -c 3 192.168.1.2
</code></pre>
<h4 id="实战案例7vlan隔离"><a class="header" href="#实战案例7vlan隔离">实战案例7：VLAN隔离</a></h4>
<pre><code class="language-bash"># 场景：实现多租户VLAN隔离

# 1. 创建bridge
sudo ovs-vsctl add-br br0

# 2. 添加端口并设置VLAN
# 租户1 - VLAN 100
sudo ovs-vsctl add-port br0 eth0 tag=100
sudo ovs-vsctl add-port br0 tap0 tag=100

# 租户2 - VLAN 200
sudo ovs-vsctl add-port br0 eth1 tag=200
sudo ovs-vsctl add-port br0 tap1 tag=200

# 3. 配置trunk端口（连接其他交换机）
sudo ovs-vsctl add-port br0 eth2 trunks=100,200,300

# 4. 查看配置
sudo ovs-vsctl show

# 5. 验证VLAN隔离
# VLAN 100的设备只能与VLAN 100的设备通信
</code></pre>
<h4 id="实战案例8访问控制列表acl"><a class="header" href="#实战案例8访问控制列表acl">实战案例8：访问控制列表(ACL)</a></h4>
<pre><code class="language-bash"># 场景：实现基于IP的访问控制

# 1. 创建bridge
sudo ovs-vsctl add-br br0
sudo ovs-vsctl add-port br0 eth0

# 2. 禁止特定IP访问（高优先级）
sudo ovs-ofctl add-flow br0 \
    "priority=200,ip,nw_src=192.168.1.100,actions=drop"

# 3. 只允许特定子网访问SSH（端口22）
sudo ovs-ofctl add-flow br0 \
    "priority=150,tcp,nw_dst=192.168.1.10,tp_dst=22,nw_src=10.0.0.0/8,actions=normal"

sudo ovs-ofctl add-flow br0 \
    "priority=150,tcp,nw_dst=192.168.1.10,tp_dst=22,actions=drop"

# 4. 允许ICMP
sudo ovs-ofctl add-flow br0 \
    "priority=100,icmp,actions=normal"

# 5. 默认允许所有流量
sudo ovs-ofctl add-flow br0 \
    "priority=0,actions=normal"

# 6. 查看流表和统计
sudo ovs-ofctl dump-flows br0
</code></pre>
<h4 id="实战案例9负载均衡"><a class="header" href="#实战案例9负载均衡">实战案例9：负载均衡</a></h4>
<pre><code class="language-bash"># 场景：将HTTP流量分发到3台后端服务器

# 1. 使用group table实现负载均衡
sudo ovs-ofctl -O OpenFlow13 add-group br0 \
    "group_id=1,type=select,\
    bucket=weight:50,actions=mod_nw_dst:192.168.1.10,output:1,\
    bucket=weight:30,actions=mod_nw_dst:192.168.1.11,output:1,\
    bucket=weight:20,actions=mod_nw_dst:192.168.1.12,output:1"

# 2. 将HTTP流量导向group
sudo ovs-ofctl -O OpenFlow13 add-flow br0 \
    "priority=100,tcp,tp_dst=80,actions=group:1"

# 3. 其他流量正常转发
sudo ovs-ofctl add-flow br0 \
    "priority=0,actions=normal"

# 4. 查看group配置
sudo ovs-ofctl -O OpenFlow13 dump-groups br0

# 5. 查看group统计
sudo ovs-ofctl -O OpenFlow13 dump-group-stats br0
</code></pre>
<hr />
<h2 id="第四部分隧道与overlay网络"><a class="header" href="#第四部分隧道与overlay网络">第四部分：隧道与overlay网络</a></h2>
<h3 id="41-隧道技术概述"><a class="header" href="#41-隧道技术概述">4.1 隧道技术概述</a></h3>
<h4 id="支持的隧道类型"><a class="header" href="#支持的隧道类型">支持的隧道类型</a></h4>
<div class="table-wrapper"><table><thead><tr><th>隧道类型</th><th>封装协议</th><th>端口</th><th>应用场景</th><th>特点</th></tr></thead><tbody>
<tr><td>VXLAN</td><td>UDP</td><td>4789</td><td>大规模云网络</td><td>支持1600万租户</td></tr>
<tr><td>GRE</td><td>IP协议47</td><td>-</td><td>点对点连接</td><td>简单高效</td></tr>
<tr><td>Geneve</td><td>UDP</td><td>6081</td><td>通用overlay</td><td>灵活扩展</td></tr>
<tr><td>STT</td><td>TCP</td><td>7471</td><td>性能优化</td><td>TCP友好</td></tr>
<tr><td>GRE over IPsec</td><td>-</td><td>-</td><td>加密隧道</td><td>安全性高</td></tr>
</tbody></table>
</div>
<h3 id="42-vxlan实战"><a class="header" href="#42-vxlan实战">4.2 VXLAN实战</a></h3>
<h4 id="实战案例10搭建vxlan网络"><a class="header" href="#实战案例10搭建vxlan网络">实战案例10：搭建VXLAN网络</a></h4>
<p><strong>拓扑结构</strong>：</p>
<pre><code>Host1 (192.168.1.10)          Host2 (192.168.1.20)
    │                              │
    │  VXLAN Tunnel (VNI 100)     │
    └──────────────────────────────┘

    VM1 (10.0.0.10/24)        VM2 (10.0.0.20/24)
</code></pre>
<p><strong>Host1配置</strong>：</p>
<pre><code class="language-bash"># 1. 创建bridge
sudo ovs-vsctl add-br br0

# 2. 创建VXLAN隧道
sudo ovs-vsctl add-port br0 vxlan0 -- \
    set interface vxlan0 type=vxlan \
    options:remote_ip=192.168.1.20 \
    options:key=100

# 3. 添加VM网卡
sudo ovs-vsctl add-port br0 tap0

# 4. 配置bridge IP
sudo ip addr add 10.0.0.1/24 dev br0
sudo ip link set br0 up

# 5. 验证配置
sudo ovs-vsctl show
</code></pre>
<p><strong>Host2配置</strong>：</p>
<pre><code class="language-bash"># 1. 创建bridge
sudo ovs-vsctl add-br br0

# 2. 创建VXLAN隧道
sudo ovs-vsctl add-port br0 vxlan0 -- \
    set interface vxlan0 type=vxlan \
    options:remote_ip=192.168.1.10 \
    options:key=100

# 3. 添加VM网卡
sudo ovs-vsctl add-port br0 tap0

# 4. 配置bridge IP
sudo ip addr add 10.0.0.2/24 dev br0
sudo ip link set br0 up
</code></pre>
<p><strong>测试连通性</strong>：</p>
<pre><code class="language-bash"># 从Host1的VM1 ping Host2的VM2
ping 10.0.0.20

# 抓包验证VXLAN封装
sudo tcpdump -i eth0 -nn udp port 4789
</code></pre>
<h4 id="实战案例11多播vxlan"><a class="header" href="#实战案例11多播vxlan">实战案例11：多播VXLAN</a></h4>
<pre><code class="language-bash"># 使用多播地址实现VXLAN自动发现

# 1. 创建多播VXLAN
sudo ovs-vsctl add-port br0 vxlan0 -- \
    set interface vxlan0 type=vxlan \
    options:remote_ip=224.0.0.100 \
    options:key=100 \
    options:local_ip=192.168.1.10

# 2. 配置多播路由
sudo ip route add 224.0.0.0/4 dev eth0

# 这样同一VNI的所有主机可以自动发现
</code></pre>
<h3 id="43-gre隧道"><a class="header" href="#43-gre隧道">4.3 GRE隧道</a></h3>
<h4 id="实战案例12gre点对点隧道"><a class="header" href="#实战案例12gre点对点隧道">实战案例12：GRE点对点隧道</a></h4>
<pre><code class="language-bash"># Host1配置
sudo ovs-vsctl add-br br0
sudo ovs-vsctl add-port br0 gre0 -- \
    set interface gre0 type=gre \
    options:remote_ip=192.168.1.20 \
    options:local_ip=192.168.1.10

# Host2配置
sudo ovs-vsctl add-br br0
sudo ovs-vsctl add-port br0 gre0 -- \
    set interface gre0 type=gre \
    options:remote_ip=192.168.1.10 \
    options:local_ip=192.168.1.20

# 测试
ping -I br0 &lt;对端IP&gt;
</code></pre>
<hr />
<h2 id="第五部分高级特性"><a class="header" href="#第五部分高级特性">第五部分：高级特性</a></h2>
<h3 id="51-qos服务质量"><a class="header" href="#51-qos服务质量">5.1 QoS（服务质量）</a></h3>
<h4 id="实战案例13配置带宽限制"><a class="header" href="#实战案例13配置带宽限制">实战案例13：配置带宽限制</a></h4>
<pre><code class="language-bash"># 场景：限制端口带宽为1Mbps

# 1. 创建QoS规则
sudo ovs-vsctl set port eth0 qos=@newqos -- \
    --id=@newqos create qos type=linux-htb \
    other-config:max-rate=1000000 \
    queues=0=@q0 -- \
    --id=@q0 create queue \
    other-config:min-rate=500000 \
    other-config:max-rate=1000000

# 2. 查看QoS配置
sudo ovs-vsctl list qos
sudo ovs-vsctl list queue

# 3. 测试带宽
iperf3 -c &lt;server_ip&gt;

# 4. 删除QoS
sudo ovs-vsctl clear port eth0 qos
sudo ovs-vsctl destroy qos &lt;qos_uuid&gt;
sudo ovs-vsctl destroy queue &lt;queue_uuid&gt;
</code></pre>
<h4 id="实战案例14qos流量分类"><a class="header" href="#实战案例14qos流量分类">实战案例14：QoS流量分类</a></h4>
<pre><code class="language-bash"># 场景：为不同流量配置不同QoS

# 1. 创建多个队列
sudo ovs-vsctl set port eth0 qos=@newqos -- \
    --id=@newqos create qos type=linux-htb \
    other-config:max-rate=10000000 \
    queues:0=@q0 queues:1=@q1 queues:2=@q2 -- \
    --id=@q0 create queue other-config:min-rate=8000000 -- \
    --id=@q1 create queue other-config:min-rate=1500000 -- \
    --id=@q2 create queue other-config:min-rate=500000

# 2. 配置流表将流量分配到不同队列
# 高优先级流量（如VoIP）到队列0
sudo ovs-ofctl add-flow br0 \
    "priority=100,udp,tp_dst=5060,actions=set_queue:0,normal"

# 普通流量到队列1
sudo ovs-ofctl add-flow br0 \
    "priority=50,actions=set_queue:1,normal"

# 低优先级流量到队列2
sudo ovs-ofctl add-flow br0 \
    "priority=10,tcp,tp_dst=22,actions=set_queue:2,normal"
</code></pre>
<h3 id="52-端口镜像"><a class="header" href="#52-端口镜像">5.2 端口镜像</a></h3>
<h4 id="实战案例15流量镜像监控"><a class="header" href="#实战案例15流量镜像监控">实战案例15：流量镜像监控</a></h4>
<pre><code class="language-bash"># 场景：将eth0的流量镜像到eth2用于监控

# 1. 创建镜像
sudo ovs-vsctl -- set Bridge br0 mirrors=@m -- \
    --id=@m create Mirror name=mirror0 \
    select-dst-port=eth0 \
    select-src-port=eth0 \
    output-port=eth2

# 2. 查看镜像配置
sudo ovs-vsctl list mirror

# 3. 在监控端口抓包
sudo tcpdump -i eth2 -w capture.pcap

# 4. 删除镜像
sudo ovs-vsctl clear bridge br0 mirrors
</code></pre>
<h3 id="53-链路聚合lacp"><a class="header" href="#53-链路聚合lacp">5.3 链路聚合(LACP)</a></h3>
<h4 id="实战案例16配置lacp-bond"><a class="header" href="#实战案例16配置lacp-bond">实战案例16：配置LACP bond</a></h4>
<pre><code class="language-bash"># 场景：将eth0和eth1聚合为bond0

# 1. 创建bond
sudo ovs-vsctl add-bond br0 bond0 eth0 eth1 \
    lacp=active \
    bond_mode=balance-tcp \
    other_config:lacp-time=fast

# 2. 查看bond状态
sudo ovs-appctl bond/show bond0

# 3. 查看LACP状态
sudo ovs-appctl lacp/show bond0

# 4. 测试故障转移
# 断开一条链路，观察流量是否正常
sudo ip link set eth0 down
# 等待几秒后
sudo ip link set eth0 up
</code></pre>
<hr />
<h2 id="第六部分与虚拟化集成"><a class="header" href="#第六部分与虚拟化集成">第六部分：与虚拟化集成</a></h2>
<h3 id="61-kvmqemu集成"><a class="header" href="#61-kvmqemu集成">6.1 KVM/QEMU集成</a></h3>
<h4 id="实战案例17kvm虚拟机网络配置"><a class="header" href="#实战案例17kvm虚拟机网络配置">实战案例17：KVM虚拟机网络配置</a></h4>
<pre><code class="language-bash"># 1. 创建OVS网桥
sudo ovs-vsctl add-br br0
sudo ovs-vsctl add-port br0 eth0

# 2. 为VM创建tap设备
sudo ip tuntap add dev tap0 mode tap user `whoami`
sudo ip link set tap0 up
sudo ovs-vsctl add-port br0 tap0

# 3. 启动KVM虚拟机
sudo qemu-system-x86_64 \
    -enable-kvm \
    -m 2048 \
    -drive file=vm.qcow2,format=qcow2 \
    -netdev tap,id=net0,ifname=tap0,script=no,downscript=no \
    -device virtio-net-pci,netdev=net0,mac=52:54:00:12:34:56

# 4. 配置VLAN（可选）
sudo ovs-vsctl set port tap0 tag=100
</code></pre>
<h3 id="62-docker集成"><a class="header" href="#62-docker集成">6.2 Docker集成</a></h3>
<h4 id="实战案例18docker容器使用ovs网络"><a class="header" href="#实战案例18docker容器使用ovs网络">实战案例18：Docker容器使用OVS网络</a></h4>
<pre><code class="language-bash"># 1. 安装ovs-docker工具
wget https://raw.githubusercontent.com/openvswitch/ovs/master/utilities/ovs-docker
chmod +x ovs-docker
sudo mv ovs-docker /usr/local/bin/

# 2. 创建bridge
sudo ovs-vsctl add-br br0

# 3. 启动Docker容器
docker run -d --name=container1 --net=none ubuntu:20.04 sleep 3600
docker run -d --name=container2 --net=none ubuntu:20.04 sleep 3600

# 4. 连接容器到OVS
sudo ovs-docker add-port br0 eth0 container1 --ipaddress=10.0.0.10/24
sudo ovs-docker add-port br0 eth0 container2 --ipaddress=10.0.0.20/24

# 5. 测试连通性
docker exec container1 ping -c 3 10.0.0.20

# 6. 删除端口
sudo ovs-docker del-port br0 eth0 container1
</code></pre>
<h3 id="63-kubernetes集成"><a class="header" href="#63-kubernetes集成">6.3 Kubernetes集成</a></h3>
<h4 id="实战案例19ovs-cni配置"><a class="header" href="#实战案例19ovs-cni配置">实战案例19：OVS CNI配置</a></h4>
<p><strong>创建OVS CNI配置文件</strong>：</p>
<pre><code class="language-bash"># /etc/cni/net.d/10-ovs.conf
{
    "cniVersion": "0.3.1",
    "name": "ovs-net",
    "type": "ovs",
    "bridge": "br0",
    "vlan": 100,
    "ipam": {
        "type": "host-local",
        "subnet": "10.244.0.0/16",
        "rangeStart": "10.244.1.10",
        "rangeEnd": "10.244.1.250",
        "routes": [
            { "dst": "0.0.0.0/0" }
        ],
        "gateway": "10.244.1.1"
    }
}
</code></pre>
<hr />
<h2 id="第七部分性能优化"><a class="header" href="#第七部分性能优化">第七部分：性能优化</a></h2>
<h3 id="71-dpdk加速"><a class="header" href="#71-dpdk加速">7.1 DPDK加速</a></h3>
<h4 id="实战案例20启用dpdk"><a class="header" href="#实战案例20启用dpdk">实战案例20：启用DPDK</a></h4>
<pre><code class="language-bash"># 1. 安装DPDK
sudo apt install -y dpdk dpdk-dev

# 2. 配置大页内存
echo 1024 | sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
sudo mkdir -p /mnt/huge
sudo mount -t hugetlbfs nodev /mnt/huge

# 3. 绑定网卡到DPDK驱动
sudo dpdk-devbind.py --status
sudo dpdk-devbind.py --bind=vfio-pci 0000:01:00.0

# 4. 配置OVS使用DPDK
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-socket-mem="1024,1024"
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:pmd-cpu-mask=0x6

# 5. 重启OVS
sudo systemctl restart openvswitch-switch

# 6. 创建DPDK bridge
sudo ovs-vsctl add-br br0 -- set bridge br0 datapath_type=netdev

# 7. 添加DPDK端口
sudo ovs-vsctl add-port br0 dpdk0 -- \
    set Interface dpdk0 type=dpdk \
    options:dpdk-devargs=0000:01:00.0

# 8. 验证DPDK状态
sudo ovs-vsctl get Open_vSwitch . dpdk_initialized
sudo ovs-appctl dpdk/show
</code></pre>
<h3 id="72-性能调优"><a class="header" href="#72-性能调优">7.2 性能调优</a></h3>
<h4 id="实战案例21流表优化"><a class="header" href="#实战案例21流表优化">实战案例21：流表优化</a></h4>
<pre><code class="language-bash"># 1. 增加流表大小
sudo ovs-vsctl set bridge br0 flow_tables:0=@ft -- \
    --id=@ft create Flow_Table flow_limit=1000000

# 2. 启用megaflow
sudo ovs-vsctl set Open_vSwitch . other_config:max-idle=30000

# 3. 调整内核参数
sudo sysctl -w net.core.rmem_max=134217728
sudo sysctl -w net.core.wmem_max=134217728
sudo sysctl -w net.core.rmem_default=67108864
sudo sysctl -w net.core.wmem_default=67108864
sudo sysctl -w net.core.netdev_max_backlog=300000

# 4. 永久化配置
cat &lt;&lt;EOF | sudo tee -a /etc/sysctl.conf
net.core.rmem_max = 134217728
net.core.wmem_max = 134217728
net.core.rmem_default = 67108864
net.core.wmem_default = 67108864
net.core.netdev_max_backlog = 300000
EOF

sudo sysctl -p
</code></pre>
<hr />
<h2 id="第八部分监控与故障排查"><a class="header" href="#第八部分监控与故障排查">第八部分：监控与故障排查</a></h2>
<h3 id="81-监控工具"><a class="header" href="#81-监控工具">8.1 监控工具</a></h3>
<h4 id="实战案例22流表监控"><a class="header" href="#实战案例22流表监控">实战案例22：流表监控</a></h4>
<pre><code class="language-bash"># 1. 实时监控流表变化
sudo ovs-ofctl monitor br0 watch: --detach

# 2. 查看端口统计
sudo ovs-ofctl dump-ports br0

# 3. 查看流表统计
sudo ovs-ofctl dump-flows br0 | \
    awk '{print $1,$3,$7}' | column -t

# 4. 监控数据路径
sudo ovs-dpctl dump-flows | head -20

# 5. 查看接口统计
sudo ovs-vsctl --columns=statistics list interface
</code></pre>
<h3 id="82-故障排查"><a class="header" href="#82-故障排查">8.2 故障排查</a></h3>
<h4 id="实战案例23流表追踪"><a class="header" href="#实战案例23流表追踪">实战案例23：流表追踪</a></h4>
<pre><code class="language-bash"># 场景：追踪数据包如何被处理

# 1. 追踪特定数据包
sudo ovs-appctl ofproto/trace br0 \
    in_port=1,dl_src=00:11:22:33:44:55,dl_dst=00:aa:bb:cc:dd:ee,dl_type=0x0800,nw_src=192.168.1.10,nw_dst=192.168.1.20,nw_proto=6,tp_src=12345,tp_dst=80

# 2. 追踪并显示详细信息
sudo ovs-appctl ofproto/trace br0 \
    'in_port=1,tcp,nw_src=10.0.0.1,nw_dst=10.0.0.2,tp_dst=80' --verbose

# 输出会显示：
# - 流表匹配过程
# - 执行的动作
# - 最终结果
</code></pre>
<h4 id="常见问题排查"><a class="header" href="#常见问题排查">常见问题排查</a></h4>
<p><strong>问题1：网络不通</strong></p>
<pre><code class="language-bash"># 排查步骤

# 1. 检查bridge和端口状态
sudo ovs-vsctl show
sudo ovs-ofctl show br0

# 2. 检查流表
sudo ovs-ofctl dump-flows br0

# 3. 检查端口统计（是否有流量）
sudo ovs-ofctl dump-ports br0

# 4. 检查内核流表
sudo ovs-dpctl dump-flows

# 5. 抓包分析
sudo ovs-tcpdump -i br0

# 6. 启用详细日志
sudo ovs-appctl vlog/set any:any:dbg
sudo journalctl -u openvswitch-switch -f
</code></pre>
<p><strong>问题2：性能下降</strong></p>
<pre><code class="language-bash"># 排查步骤

# 1. 检查CPU使用率
top -p $(pgrep ovs-vswitchd)

# 2. 检查流表大小
sudo ovs-ofctl dump-flows br0 | wc -l

# 3. 检查缓存命中率
sudo ovs-dpctl show -s

# 4. 检查端口丢包
sudo ovs-ofctl dump-ports br0 | grep -i drop

# 5. 性能测试
iperf3 -c &lt;server_ip&gt;
</code></pre>
<h3 id="83-日志管理"><a class="header" href="#83-日志管理">8.3 日志管理</a></h3>
<pre><code class="language-bash"># 查看OVS日志
sudo journalctl -u openvswitch-switch -f

# 设置日志级别
sudo ovs-appctl vlog/list
sudo ovs-appctl vlog/set module:facility:level

# 示例
sudo ovs-appctl vlog/set ofproto_dpif:syslog:dbg
sudo ovs-appctl vlog/set netdev:file:info

# 查看特定组件日志
sudo ovs-appctl vlog/list | grep ofproto
</code></pre>
<hr />
<h2 id="学习验证标准"><a class="header" href="#学习验证标准">学习验证标准</a></h2>
<p>完成本笔记学习后，你应该能够独立完成以下任务：</p>
<h3 id="验证标准1基础配置能力"><a class="header" href="#验证标准1基础配置能力">验证标准1：基础配置能力</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
成功安装和启动OVS服务</li>
<li><input disabled="" type="checkbox"/>
创建bridge并添加端口</li>
<li><input disabled="" type="checkbox"/>
配置VM/容器网络连接</li>
<li><input disabled="" type="checkbox"/>
使用ovs-vsctl、ovs-ofctl命令</li>
</ul>
<h3 id="验证标准2流表配置能力"><a class="header" href="#验证标准2流表配置能力">验证标准2：流表配置能力</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
配置基本的二层转发流表</li>
<li><input disabled="" type="checkbox"/>
实现VLAN隔离</li>
<li><input disabled="" type="checkbox"/>
配置基于IP的ACL规则</li>
<li><input disabled="" type="checkbox"/>
使用流表追踪调试问题</li>
</ul>
<h3 id="验证标准3隧道网络"><a class="header" href="#验证标准3隧道网络">验证标准3：隧道网络</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
搭建VXLAN overlay网络</li>
<li><input disabled="" type="checkbox"/>
配置GRE隧道</li>
<li><input disabled="" type="checkbox"/>
理解不同隧道协议的应用场景</li>
<li><input disabled="" type="checkbox"/>
实现跨主机VM通信</li>
</ul>
<h3 id="验证标准4高级特性"><a class="header" href="#验证标准4高级特性">验证标准4：高级特性</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
配置QoS带宽限制</li>
<li><input disabled="" type="checkbox"/>
实现端口镜像</li>
<li><input disabled="" type="checkbox"/>
配置LACP链路聚合</li>
<li><input disabled="" type="checkbox"/>
集成到虚拟化平台</li>
</ul>
<h3 id="验证标准5生产环境运维"><a class="header" href="#验证标准5生产环境运维">验证标准5：生产环境运维</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
进行性能调优和优化</li>
<li><input disabled="" type="checkbox"/>
监控OVS运行状态</li>
<li><input disabled="" type="checkbox"/>
排查网络故障</li>
<li><input disabled="" type="checkbox"/>
编写运维文档</li>
</ul>
<hr />
<h2 id="扩展资源与进阶建议"><a class="header" href="#扩展资源与进阶建议">扩展资源与进阶建议</a></h2>
<h3 id="官方资源"><a class="header" href="#官方资源">官方资源</a></h3>
<ul>
<li><a href="https://www.openvswitch.org/">Open vSwitch官网</a></li>
<li><a href="https://docs.openvswitch.org/">OVS文档</a></li>
<li><a href="https://github.com/openvswitch/ovs">OVS GitHub</a></li>
<li><a href="https://www.opennetworking.org/software-defined-standards/specifications/">OpenFlow规范</a></li>
</ul>
<h3 id="推荐书籍"><a class="header" href="#推荐书籍">推荐书籍</a></h3>
<ul>
<li>《SDN核心技术剖析和实战指南》</li>
<li>《Open vSwitch完全使用指南》</li>
<li>《Software Defined Networks: A Comprehensive Approach》</li>
</ul>
<h3 id="相关技术"><a class="header" href="#相关技术">相关技术</a></h3>
<ul>
<li><strong>SDN控制器</strong>: Ryu、ONOS、OpenDaylight、Floodlight</li>
<li><strong>容器网络</strong>: Calico、Flannel、Weave</li>
<li><strong>云平台</strong>: OpenStack Neutron、Kubernetes</li>
<li><strong>网络监控</strong>: Prometheus、Grafana、ELK</li>
</ul>
<h3 id="学习路线图"><a class="header" href="#学习路线图">学习路线图</a></h3>
<pre><code>阶段1（1-2周）：基础入门
├── OVS安装配置
├── 基本命令使用
└── 简单网络搭建

阶段2（2-3周）：流表掌握
├── OpenFlow流表语法
├── 常见流表配置
└── 流表调试技巧

阶段3（2-3周）：高级特性
├── VXLAN/GRE隧道
├── QoS和镜像
└── LACP聚合

阶段4（2-4周）：虚拟化集成
├── KVM/Docker集成
├── Kubernetes CNI
└── OpenStack集成

阶段5（持续）：生产实战
├── DPDK性能优化
├── 监控运维
└── 故障排查
</code></pre>
<h3 id="实战项目建议"><a class="header" href="#实战项目建议">实战项目建议</a></h3>
<ol>
<li>搭建基于OVS的实验网络环境</li>
<li>实现多租户VLAN隔离网络</li>
<li>构建VXLAN overlay网络</li>
<li>开发简单的SDN控制器应用</li>
<li>集成OVS到容器编排平台</li>
</ol>
<hr />
<h2 id="附录快速参考"><a class="header" href="#附录快速参考">附录：快速参考</a></h2>
<h3 id="a1-常用命令速查"><a class="header" href="#a1-常用命令速查">A1. 常用命令速查</a></h3>
<pre><code class="language-bash"># Bridge管理
ovs-vsctl add-br &lt;bridge&gt;
ovs-vsctl del-br &lt;bridge&gt;
ovs-vsctl list-br
ovs-vsctl show

# Port管理
ovs-vsctl add-port &lt;bridge&gt; &lt;port&gt;
ovs-vsctl del-port &lt;bridge&gt; &lt;port&gt;
ovs-vsctl list-ports &lt;bridge&gt;

# 流表管理
ovs-ofctl add-flow &lt;bridge&gt; &lt;flow&gt;
ovs-ofctl del-flows &lt;bridge&gt;
ovs-ofctl dump-flows &lt;bridge&gt;

# 信息查看
ovs-ofctl show &lt;bridge&gt;
ovs-ofctl dump-ports &lt;bridge&gt;
ovs-dpctl show
</code></pre>
<h3 id="a2-流表语法模板"><a class="header" href="#a2-流表语法模板">A2. 流表语法模板</a></h3>
<pre><code class="language-bash"># 基本转发
ovs-ofctl add-flow br0 "priority=100,in_port=1,actions=output:2"

# VLAN处理
ovs-ofctl add-flow br0 "priority=100,dl_vlan=100,actions=strip_vlan,output:1"

# IP ACL
ovs-ofctl add-flow br0 "priority=200,ip,nw_src=10.0.0.0/24,actions=drop"

# NAT
ovs-ofctl add-flow br0 "priority=100,ip,nw_dst=1.2.3.4,actions=mod_nw_dst:10.0.0.10,output:1"
</code></pre>
<h3 id="a3-故障排查checklist"><a class="header" href="#a3-故障排查checklist">A3. 故障排查checklist</a></h3>
<pre><code>□ 检查OVS服务状态
□ 验证bridge和port配置
□ 查看流表规则
□ 检查端口统计
□ 使用流表追踪
□ 抓包分析
□ 查看日志
□ 测试连通性
</code></pre>
<hr />
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>Open vSwitch是云计算和SDN领域的基石技术，掌握它需要：</p>
<ol>
<li><strong>扎实的网络基础</strong>：理解TCP/IP、VLAN、路由等</li>
<li><strong>实践经验</strong>：多动手搭建实验环境</li>
<li><strong>深入原理</strong>：理解数据平面和控制平面</li>
<li><strong>持续学习</strong>：跟进OpenFlow和SDN发展</li>
<li><strong>融会贯通</strong>：结合虚拟化和云平台应用</li>
</ol>
<p>记住：<strong>网络虚拟化是云计算的核心，OVS是实现网络虚拟化的利器</strong>。祝你早日成为OVS专家！</p>
<hr />
<p><strong>文档版本</strong>: v1.0
<strong>最后更新</strong>: 2025-11-02
<strong>适用版本</strong>: Open vSwitch 2.13+</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/network/openrestry.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/network/三层交换机.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/network/openrestry.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/network/三层交换机.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

