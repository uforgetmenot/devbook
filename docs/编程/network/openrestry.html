<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OpenResty 学习笔记 - 开发</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/pagetoc.css">
        <link rel="stylesheet" href="../../theme/help-overlay.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">开发</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="搜索本书内容..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="openresty-学习笔记"><a class="header" href="#openresty-学习笔记">OpenResty 学习笔记</a></h1>
<h2 id="学习目标定位"><a class="header" href="#学习目标定位">学习目标定位</a></h2>
<p><strong>角色定位</strong>: 1-5年经验的后端开发/运维工程师，已具备基础的Nginx知识，希望掌握OpenResty动态Web开发能力</p>
<p><strong>学习成果</strong>: 完成本笔记学习后，你将能够：</p>
<ul>
<li>理解OpenResty架构和核心原理</li>
<li>使用Lua编写高性能Web应用</li>
<li>构建API网关和微服务架构</li>
<li>实现复杂的业务逻辑和性能优化</li>
<li>在生产环境中部署和运维OpenResty服务</li>
</ul>
<hr />
<h2 id="第一部分openresty-基础入门"><a class="header" href="#第一部分openresty-基础入门">第一部分：OpenResty 基础入门</a></h2>
<h3 id="11-openresty-简介"><a class="header" href="#11-openresty-简介">1.1 OpenResty 简介</a></h3>
<h4 id="什么是openresty"><a class="header" href="#什么是openresty">什么是OpenResty？</a></h4>
<p>OpenResty（也称为ngx_openresty）是一个基于Nginx与LuaJIT的高性能Web平台，其内部集成了大量精良的Lua库、第三方模块以及大多数的依赖项。</p>
<p><strong>核心组成</strong>：</p>
<pre><code>OpenResty = Nginx + LuaJIT + 丰富的Lua库 + 第三方模块
</code></pre>
<h4 id="openresty-vs-nginx"><a class="header" href="#openresty-vs-nginx">OpenResty vs Nginx</a></h4>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>Nginx</th><th>OpenResty</th></tr></thead><tbody>
<tr><td>配置灵活性</td><td>静态配置文件</td><td>动态Lua脚本</td></tr>
<tr><td>扩展方式</td><td>C模块开发</td><td>Lua脚本编写</td></tr>
<tr><td>开发效率</td><td>低（需编译）</td><td>高（脚本语言）</td></tr>
<tr><td>性能</td><td>极高</td><td>接近Nginx</td></tr>
<tr><td>适用场景</td><td>静态代理、负载均衡</td><td>动态业务、API网关</td></tr>
<tr><td>学习曲线</td><td>平缓</td><td>较陡（需学Lua）</td></tr>
</tbody></table>
</div>
<h4 id="核心优势"><a class="header" href="#核心优势">核心优势</a></h4>
<ol>
<li><strong>高性能</strong>: 基于Nginx事件驱动模型，性能接近C模块</li>
<li><strong>开发高效</strong>: 使用Lua脚本，无需编译，支持热更新</li>
<li><strong>功能丰富</strong>: 内置大量常用库（HTTP、Redis、MySQL等）</li>
<li><strong>非阻塞</strong>: 所有I/O操作都是非阻塞的</li>
<li><strong>生态完善</strong>: 大量第三方模块和成熟案例</li>
</ol>
<h3 id="12-架构设计"><a class="header" href="#12-架构设计">1.2 架构设计</a></h3>
<h4 id="openresty请求处理流程"><a class="header" href="#openresty请求处理流程">OpenResty请求处理流程</a></h4>
<pre><code>                    ┌──────────────────────────┐
                    │    Client Request        │
                    └───────────┬──────────────┘
                                │
                    ┌───────────▼──────────────┐
                    │   Nginx Event Model      │
                    └───────────┬──────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
┌───────▼────────┐   ┌─────────▼────────┐   ┌─────────▼────────┐
│ Nginx Modules  │   │  Lua Coroutines  │   │   C Modules      │
│ (Static Logic) │   │ (Dynamic Logic)  │   │  (Performance)   │
└───────┬────────┘   └─────────┬────────┘   └─────────┬────────┘
        │                       │                       │
        └───────────────────────┼───────────────────────┘
                                │
                    ┌───────────▼──────────────┐
                    │   Backend Services       │
                    │ (MySQL/Redis/HTTP API)   │
                    └───────────┬──────────────┘
                                │
                    ┌───────────▼──────────────┐
                    │    Client Response       │
                    └──────────────────────────┘
</code></pre>
<h4 id="nginx请求处理阶段"><a class="header" href="#nginx请求处理阶段">Nginx请求处理阶段</a></h4>
<p>OpenResty可以在Nginx的多个阶段插入Lua代码：</p>
<div class="table-wrapper"><table><thead><tr><th>阶段</th><th>指令</th><th>说明</th><th>适用场景</th></tr></thead><tbody>
<tr><td>init</td><td>init_by_lua</td><td>Nginx启动时执行</td><td>加载全局配置、初始化共享内存</td></tr>
<tr><td>init_worker</td><td>init_worker_by_lua</td><td>Worker进程启动时执行</td><td>初始化连接池、定时任务</td></tr>
<tr><td>ssl_certificate</td><td>ssl_certificate_by_lua</td><td>SSL握手时执行</td><td>动态证书加载</td></tr>
<tr><td>set</td><td>set_by_lua</td><td>变量赋值</td><td>复杂变量计算</td></tr>
<tr><td>rewrite</td><td>rewrite_by_lua</td><td>重写阶段</td><td>URL改写、请求参数处理</td></tr>
<tr><td>access</td><td>access_by_lua</td><td>访问控制阶段</td><td>认证、鉴权、限流</td></tr>
<tr><td>content</td><td>content_by_lua</td><td>内容生成阶段</td><td>业务逻辑处理、响应生成</td></tr>
<tr><td>header_filter</td><td>header_filter_by_lua</td><td>响应头过滤</td><td>修改响应头</td></tr>
<tr><td>body_filter</td><td>body_filter_by_lua</td><td>响应体过滤</td><td>修改响应体</td></tr>
<tr><td>log</td><td>log_by_lua</td><td>日志阶段</td><td>自定义日志、统计</td></tr>
</tbody></table>
</div>
<h3 id="13-环境安装与搭建"><a class="header" href="#13-环境安装与搭建">1.3 环境安装与搭建</a></h3>
<h4 id="实战案例1在ubuntu上安装openresty"><a class="header" href="#实战案例1在ubuntu上安装openresty">实战案例1：在Ubuntu上安装OpenResty</a></h4>
<p><strong>方法一：使用官方仓库（推荐）</strong></p>
<pre><code class="language-bash"># 1. 导入GPG密钥
wget -qO - https://openresty.org/package/pubkey.gpg | sudo apt-key add -

# 2. 添加官方仓库
sudo apt-get -y install software-properties-common
sudo add-apt-repository -y "deb http://openresty.org/package/ubuntu $(lsb_release -sc) main"

# 3. 更新并安装
sudo apt-get update
sudo apt-get install -y openresty

# 4. 验证安装
openresty -v
/usr/bin/openresty -V

# 5. 启动服务
sudo systemctl start openresty
sudo systemctl enable openresty
sudo systemctl status openresty
</code></pre>
<p><strong>方法二：源码编译安装</strong></p>
<pre><code class="language-bash"># 1. 安装依赖
sudo apt-get install -y \
    libpcre3-dev libssl-dev perl make build-essential curl \
    libreadline-dev libncurses5-dev libgd-dev

# 2. 下载源码
cd /tmp
wget https://openresty.org/download/openresty-1.21.4.1.tar.gz
tar -xzf openresty-1.21.4.1.tar.gz
cd openresty-1.21.4.1

# 3. 配置编译选项
./configure \
    --prefix=/usr/local/openresty \
    --with-http_ssl_module \
    --with-http_v2_module \
    --with-http_realip_module \
    --with-http_stub_status_module \
    --with-stream \
    --with-stream_ssl_module \
    --with-luajit

# 4. 编译安装
make -j$(nproc)
sudo make install

# 5. 配置环境变量
echo 'export PATH=/usr/local/openresty/bin:$PATH' &gt;&gt; ~/.bashrc
source ~/.bashrc

# 6. 验证
openresty -v
resty -v  # OpenResty的Lua命令行工具
</code></pre>
<h4 id="实战案例2docker部署openresty"><a class="header" href="#实战案例2docker部署openresty">实战案例2：Docker部署OpenResty</a></h4>
<pre><code class="language-bash"># 快速启动
docker run -d --name my-openresty \
    -p 80:80 \
    openresty/openresty:alpine

# 挂载自定义配置
docker run -d --name my-openresty \
    -p 80:80 \
    -v /path/to/nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf:ro \
    -v /path/to/lua:/usr/local/openresty/nginx/lua:ro \
    openresty/openresty:alpine
</code></pre>
<p><strong>Dockerfile示例</strong>：</p>
<pre><code class="language-dockerfile">FROM openresty/openresty:alpine-fat

# 安装额外的Lua模块
RUN /usr/local/openresty/luajit/bin/luarocks install lua-resty-jwt
RUN /usr/local/openresty/luajit/bin/luarocks install lua-resty-http

# 复制配置文件
COPY nginx.conf /usr/local/openresty/nginx/conf/nginx.conf
COPY lua/ /usr/local/openresty/nginx/lua/

# 复制静态文件
COPY html/ /usr/local/openresty/nginx/html/

EXPOSE 80 443

CMD ["/usr/local/openresty/bin/openresty", "-g", "daemon off;"]
</code></pre>
<h3 id="14-目录结构"><a class="header" href="#14-目录结构">1.4 目录结构</a></h3>
<h4 id="openresty标准目录"><a class="header" href="#openresty标准目录">OpenResty标准目录</a></h4>
<pre><code>/usr/local/openresty/
├── bin/
│   ├── openresty           # OpenResty可执行文件
│   ├── resty              # Lua命令行工具
│   └── restydoc           # 文档查看工具
├── luajit/
│   ├── bin/
│   │   ├── luajit         # LuaJIT解释器
│   │   └── luarocks       # Lua包管理器
│   ├── include/           # 头文件
│   └── lib/               # 库文件
├── lualib/                # Lua库目录
│   ├── resty/             # OpenResty官方库
│   │   ├── core.lua
│   │   ├── redis.lua
│   │   ├── mysql.lua
│   │   ├── http.lua
│   │   └── ...
│   └── ngx/               # Nginx Lua API
├── nginx/
│   ├── conf/              # 配置文件
│   │   └── nginx.conf
│   ├── html/              # 默认网站
│   ├── logs/              # 日志文件
│   └── sbin/
│       └── nginx          # Nginx可执行文件
└── site/                  # 第三方模块安装目录
</code></pre>
<hr />
<h2 id="第二部分lua-编程基础"><a class="header" href="#第二部分lua-编程基础">第二部分：Lua 编程基础</a></h2>
<h3 id="21-lua-语言快速入门"><a class="header" href="#21-lua-语言快速入门">2.1 Lua 语言快速入门</a></h3>
<h4 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h4>
<pre><code class="language-lua">-- 变量定义（默认全局变量）
local name = "OpenResty"  -- local声明局部变量
local age = 10
local is_active = true

-- 数据类型
local str = "Hello"                    -- 字符串
local num = 123                        -- 数字
local bool = true                      -- 布尔
local tbl = {1, 2, 3}                 -- 表（数组）
local dict = {name="John", age=30}    -- 表（字典）
local func = function() end           -- 函数
local nothing = nil                    -- 空值

-- 字符串操作
local s = "Hello World"
local len = #s                        -- 长度
local upper = string.upper(s)         -- 转大写
local sub = string.sub(s, 1, 5)       -- 截取 "Hello"
local concat = s .. " OpenResty"      -- 连接

-- 表操作
local arr = {10, 20, 30}
table.insert(arr, 40)                 -- 插入
table.remove(arr, 1)                  -- 删除
local len = #arr                      -- 长度

local dict = {name="John", age=30}
dict.email = "john@example.com"       -- 添加
dict.age = nil                        -- 删除

-- 控制结构
if age &gt; 18 then
    print("Adult")
elseif age &gt; 12 then
    print("Teenager")
else
    print("Child")
end

-- 循环
for i = 1, 10 do
    print(i)
end

for i, v in ipairs(arr) do            -- 遍历数组
    print(i, v)
end

for k, v in pairs(dict) do            -- 遍历字典
    print(k, v)
end

-- 函数定义
local function add(a, b)
    return a + b
end

local result = add(10, 20)
</code></pre>
<h3 id="22-openresty-lua-api核心"><a class="header" href="#22-openresty-lua-api核心">2.2 OpenResty Lua API核心</a></h3>
<h4 id="实战案例3hello-world"><a class="header" href="#实战案例3hello-world">实战案例3：Hello World</a></h4>
<pre><code class="language-nginx"># nginx.conf
worker_processes 1;
error_log logs/error.log;

events {
    worker_connections 1024;
}

http {
    server {
        listen 80;

        location /hello {
            content_by_lua_block {
                ngx.say("Hello, OpenResty!")
            }
        }
    }
}
</code></pre>
<pre><code class="language-bash"># 测试
curl http://localhost/hello
# 输出: Hello, OpenResty!
</code></pre>
<h4 id="实战案例4请求和响应处理"><a class="header" href="#实战案例4请求和响应处理">实战案例4：请求和响应处理</a></h4>
<pre><code class="language-nginx">location /api/info {
    content_by_lua_block {
        -- 获取请求方法
        local method = ngx.req.get_method()

        -- 获取请求URI
        local uri = ngx.var.request_uri

        -- 获取查询参数
        local args = ngx.req.get_uri_args()
        local name = args.name or "Guest"

        -- 获取请求头
        local headers = ngx.req.get_headers()
        local user_agent = headers["User-Agent"]

        -- 获取请求体（POST）
        ngx.req.read_body()
        local body = ngx.req.get_body_data()

        -- 设置响应头
        ngx.header["Content-Type"] = "application/json"
        ngx.header["X-Custom-Header"] = "OpenResty"

        -- 构建JSON响应
        local cjson = require "cjson"
        local response = {
            method = method,
            uri = uri,
            name = name,
            user_agent = user_agent,
            timestamp = ngx.time()
        }

        -- 返回JSON
        ngx.say(cjson.encode(response))
    }
}
</code></pre>
<h4 id="ngx-api常用函数速查"><a class="header" href="#ngx-api常用函数速查">ngx API常用函数速查</a></h4>
<p><strong>请求相关</strong>：</p>
<pre><code class="language-lua">ngx.req.get_method()              -- 获取请求方法
ngx.req.get_uri_args()            -- 获取URL参数
ngx.req.get_post_args()           -- 获取POST参数
ngx.req.get_headers()             -- 获取请求头
ngx.req.read_body()               -- 读取请求体
ngx.req.get_body_data()           -- 获取请求体数据
ngx.var.request_uri               -- 获取请求URI
ngx.var.remote_addr               -- 获取客户端IP
</code></pre>
<p><strong>响应相关</strong>：</p>
<pre><code class="language-lua">ngx.say(...)                      -- 输出并换行
ngx.print(...)                    -- 输出不换行
ngx.header["Name"] = "value"      -- 设置响应头
ngx.status = 404                  -- 设置状态码
ngx.exit(200)                     -- 退出并返回状态码
ngx.redirect(url, status)         -- 重定向
</code></pre>
<p><strong>其他常用</strong>：</p>
<pre><code class="language-lua">ngx.time()                        -- 当前时间戳（秒）
ngx.now()                         -- 当前时间（秒，带小数）
ngx.log(ngx.ERR, "message")      -- 记录日志
ngx.encode_base64(str)            -- Base64编码
ngx.decode_base64(str)            -- Base64解码
ngx.md5(str)                      -- MD5哈希
ngx.sha1_bin(str)                 -- SHA1哈希
</code></pre>
<hr />
<h2 id="第三部分核心功能模块"><a class="header" href="#第三部分核心功能模块">第三部分：核心功能模块</a></h2>
<h3 id="31-数据库集成"><a class="header" href="#31-数据库集成">3.1 数据库集成</a></h3>
<h4 id="实战案例5redis操作"><a class="header" href="#实战案例5redis操作">实战案例5：Redis操作</a></h4>
<pre><code class="language-lua">-- /usr/local/openresty/nginx/lua/redis_handler.lua
local redis = require "resty.redis"

local red = redis:new()
red:set_timeout(1000) -- 1秒超时

-- 连接Redis
local ok, err = red:connect("127.0.0.1", 6379)
if not ok then
    ngx.log(ngx.ERR, "failed to connect redis: ", err)
    return ngx.exit(500)
end

-- 设置值
local ok, err = red:set("user:1:name", "John")
if not ok then
    ngx.log(ngx.ERR, "failed to set: ", err)
end

-- 获取值
local value, err = red:get("user:1:name")
if not value then
    ngx.log(ngx.ERR, "failed to get: ", err)
end

-- 放回连接池
local ok, err = red:set_keepalive(10000, 100)
if not ok then
    ngx.log(ngx.ERR, "failed to set keepalive: ", err)
end

return value
</code></pre>
<p><strong>Nginx配置</strong>：</p>
<pre><code class="language-nginx">location /redis/get {
    content_by_lua_block {
        local redis = require "resty.redis"
        local red = redis:new()
        red:set_timeout(1000)

        local ok, err = red:connect("127.0.0.1", 6379)
        if not ok then
            ngx.status = 500
            ngx.say('{"error":"Redis connection failed"}')
            return
        end

        local key = ngx.var.arg_key
        local value, err = red:get(key)

        red:set_keepalive(10000, 100)

        if value == ngx.null then
            ngx.status = 404
            ngx.say('{"error":"Key not found"}')
        else
            local cjson = require "cjson"
            ngx.say(cjson.encode({key=key, value=value}))
        end
    }
}
</code></pre>
<h4 id="实战案例6mysql操作"><a class="header" href="#实战案例6mysql操作">实战案例6：MySQL操作</a></h4>
<pre><code class="language-lua">local mysql = require "resty.mysql"

local db, err = mysql:new()
if not db then
    ngx.log(ngx.ERR, "failed to create mysql: ", err)
    return ngx.exit(500)
end

db:set_timeout(1000)

-- 连接数据库
local ok, err = db:connect({
    host = "127.0.0.1",
    port = 3306,
    database = "mydb",
    user = "root",
    password = "password",
    charset = "utf8mb4",
    max_packet_size = 1024 * 1024
})

if not ok then
    ngx.log(ngx.ERR, "failed to connect mysql: ", err)
    return ngx.exit(500)
end

-- 执行查询
local res, err = db:query("SELECT id, name FROM users WHERE id = 1")
if not res then
    ngx.log(ngx.ERR, "query failed: ", err)
    return ngx.exit(500)
end

-- 处理结果
local cjson = require "cjson"
ngx.say(cjson.encode(res))

-- 放回连接池
db:set_keepalive(10000, 100)
</code></pre>
<h4 id="实战案例7连接池最佳实践"><a class="header" href="#实战案例7连接池最佳实践">实战案例7：连接池最佳实践</a></h4>
<pre><code class="language-lua">-- /usr/local/openresty/nginx/lua/db_pool.lua
local _M = {}

local mysql = require "resty.mysql"

-- MySQL连接池配置
local mysql_config = {
    host = "127.0.0.1",
    port = 3306,
    database = "mydb",
    user = "root",
    password = "password",
    charset = "utf8mb4",
    max_packet_size = 1024 * 1024
}

function _M.get_mysql_connection()
    local db, err = mysql:new()
    if not db then
        return nil, err
    end

    db:set_timeout(1000)

    local ok, err = db:connect(mysql_config)
    if not ok then
        return nil, err
    end

    return db, nil
end

function _M.close_mysql(db)
    if not db then
        return
    end

    -- 放回连接池：10秒空闲超时，最多100个连接
    local ok, err = db:set_keepalive(10000, 100)
    if not ok then
        ngx.log(ngx.ERR, "failed to set keepalive: ", err)
    end
end

return _M
</code></pre>
<p><strong>使用连接池</strong>：</p>
<pre><code class="language-nginx">location /users {
    content_by_lua_block {
        local db_pool = require "db_pool"
        local cjson = require "cjson"

        local db, err = db_pool.get_mysql_connection()
        if not db then
            ngx.status = 500
            ngx.say('{"error":"Database connection failed"}')
            return
        end

        local res, err = db:query("SELECT id, name, email FROM users LIMIT 10")

        db_pool.close_mysql(db)

        if not res then
            ngx.status = 500
            ngx.say('{"error":"Query failed"}')
            return
        end

        ngx.header["Content-Type"] = "application/json"
        ngx.say(cjson.encode(res))
    }
}
</code></pre>
<h3 id="32-共享内存字典ngxshareddict"><a class="header" href="#32-共享内存字典ngxshareddict">3.2 共享内存字典（ngx.shared.DICT）</a></h3>
<h4 id="实战案例8使用共享内存实现缓存"><a class="header" href="#实战案例8使用共享内存实现缓存">实战案例8：使用共享内存实现缓存</a></h4>
<pre><code class="language-nginx"># nginx.conf
http {
    # 定义共享内存字典，大小10MB
    lua_shared_dict my_cache 10m;
    lua_shared_dict my_limit 10m;

    server {
        listen 80;

        location /cache/set {
            content_by_lua_block {
                local cache = ngx.shared.my_cache
                local key = ngx.var.arg_key
                local value = ngx.var.arg_value
                local expire = tonumber(ngx.var.arg_expire) or 60

                -- 设置缓存，60秒过期
                local success, err = cache:set(key, value, expire)

                if success then
                    ngx.say('{"status":"ok"}')
                else
                    ngx.say('{"status":"error","message":"', err, '"}')
                end
            }
        }

        location /cache/get {
            content_by_lua_block {
                local cache = ngx.shared.my_cache
                local key = ngx.var.arg_key

                local value, flags = cache:get(key)

                if value then
                    ngx.say('{"key":"', key, '","value":"', value, '"}')
                else
                    ngx.status = 404
                    ngx.say('{"error":"Key not found"}')
                end
            }
        }
    }
}
</code></pre>
<h4 id="实战案例9分布式限流"><a class="header" href="#实战案例9分布式限流">实战案例9：分布式限流</a></h4>
<pre><code class="language-lua">location /api/limited {
    access_by_lua_block {
        local limit = ngx.shared.my_limit
        local key = "rate_limit:" .. ngx.var.remote_addr
        local limit_count = 10  -- 每分钟10次
        local limit_time = 60   -- 60秒窗口

        -- 获取当前计数
        local count, err = limit:get(key)

        if not count then
            -- 首次请求，设置计数为1
            limit:set(key, 1, limit_time)
            count = 1
        else
            -- 增加计数
            count = limit:incr(key, 1)
        end

        -- 检查是否超限
        if count &gt; limit_count then
            ngx.status = 429
            ngx.header["X-RateLimit-Limit"] = limit_count
            ngx.header["X-RateLimit-Remaining"] = 0
            ngx.say('{"error":"Rate limit exceeded"}')
            return ngx.exit(429)
        end

        -- 设置响应头
        ngx.header["X-RateLimit-Limit"] = limit_count
        ngx.header["X-RateLimit-Remaining"] = limit_count - count
    }

    content_by_lua_block {
        ngx.say('{"message":"Success"}')
    }
}
</code></pre>
<h3 id="33-http客户端"><a class="header" href="#33-http客户端">3.3 HTTP客户端</a></h3>
<h4 id="实战案例10调用后端api"><a class="header" href="#实战案例10调用后端api">实战案例10：调用后端API</a></h4>
<pre><code class="language-lua">location /proxy/api {
    content_by_lua_block {
        local http = require "resty.http"
        local httpc = http.new()

        -- 设置超时：连接、发送、读取
        httpc:set_timeout(5000)

        -- 发送GET请求
        local res, err = httpc:request_uri("http://api.example.com/users", {
            method = "GET",
            headers = {
                ["User-Agent"] = "OpenResty",
                ["Accept"] = "application/json"
            },
            query = {
                page = 1,
                limit = 10
            }
        })

        if not res then
            ngx.log(ngx.ERR, "request failed: ", err)
            ngx.status = 500
            ngx.say('{"error":"Backend service unavailable"}')
            return
        end

        -- 转发响应
        ngx.status = res.status
        for k, v in pairs(res.headers) do
            ngx.header[k] = v
        end
        ngx.say(res.body)
    }
}
</code></pre>
<h4 id="实战案例11post请求和连接复用"><a class="header" href="#实战案例11post请求和连接复用">实战案例11：POST请求和连接复用</a></h4>
<pre><code class="language-lua">location /proxy/post {
    content_by_lua_block {
        local http = require "resty.http"
        local cjson = require "cjson"

        -- 读取请求体
        ngx.req.read_body()
        local body = ngx.req.get_body_data()

        local httpc = http.new()
        httpc:set_timeout(5000)

        -- 连接到后端
        local ok, err = httpc:connect("api.example.com", 80)
        if not ok then
            ngx.log(ngx.ERR, "connect failed: ", err)
            return ngx.exit(500)
        end

        -- 发送POST请求
        local res, err = httpc:request({
            method = "POST",
            path = "/api/users",
            headers = {
                ["Content-Type"] = "application/json",
                ["Content-Length"] = #body
            },
            body = body
        })

        if not res then
            ngx.log(ngx.ERR, "request failed: ", err)
            return ngx.exit(500)
        end

        -- 读取响应体
        local response_body = res:read_body()

        -- 连接复用（放回连接池）
        httpc:set_keepalive(10000, 50)

        -- 返回响应
        ngx.status = res.status
        ngx.say(response_body)
    }
}
</code></pre>
<hr />
<h2 id="第四部分高级特性与实战"><a class="header" href="#第四部分高级特性与实战">第四部分：高级特性与实战</a></h2>
<h3 id="41-jwt认证"><a class="header" href="#41-jwt认证">4.1 JWT认证</a></h3>
<h4 id="实战案例12实现jwt验证"><a class="header" href="#实战案例12实现jwt验证">实战案例12：实现JWT验证</a></h4>
<pre><code class="language-bash"># 安装lua-resty-jwt
/usr/local/openresty/luajit/bin/luarocks install lua-resty-jwt
</code></pre>
<pre><code class="language-lua">-- /usr/local/openresty/nginx/lua/jwt_auth.lua
local jwt = require "resty.jwt"
local cjson = require "cjson"

local _M = {}

-- JWT密钥
local jwt_secret = "your-secret-key-change-me"

-- 生成JWT Token
function _M.generate_token(payload)
    local jwt_token = jwt:sign(
        jwt_secret,
        {
            header = {typ = "JWT", alg = "HS256"},
            payload = payload
        }
    )
    return jwt_token
end

-- 验证JWT Token
function _M.verify_token()
    -- 从请求头获取token
    local auth_header = ngx.var.http_Authorization

    if not auth_header then
        ngx.status = 401
        ngx.say('{"error":"No authorization header"}')
        return ngx.exit(401)
    end

    -- 提取token (格式: Bearer &lt;token&gt;)
    local token = string.match(auth_header, "Bearer%s+(.+)")

    if not token then
        ngx.status = 401
        ngx.say('{"error":"Invalid authorization header"}')
        return ngx.exit(401)
    end

    -- 验证token
    local jwt_obj = jwt:verify(jwt_secret, token)

    if not jwt_obj.verified then
        ngx.status = 401
        ngx.say('{"error":"Invalid token","reason":"', jwt_obj.reason, '"}')
        return ngx.exit(401)
    end

    -- 返回payload
    return jwt_obj.payload
end

return _M
</code></pre>
<p><strong>登录接口（生成Token）</strong>：</p>
<pre><code class="language-nginx">location /api/login {
    content_by_lua_block {
        local cjson = require "cjson"
        local jwt_auth = require "jwt_auth"

        ngx.req.read_body()
        local body = ngx.req.get_body_data()
        local data = cjson.decode(body)

        -- 验证用户名密码（示例）
        if data.username == "admin" and data.password == "password" then
            local payload = {
                user_id = 1,
                username = "admin",
                exp = ngx.time() + 3600  -- 1小时后过期
            }

            local token = jwt_auth.generate_token(payload)

            ngx.header["Content-Type"] = "application/json"
            ngx.say(cjson.encode({
                success = true,
                token = token,
                expires_in = 3600
            }))
        else
            ngx.status = 401
            ngx.say('{"error":"Invalid credentials"}')
        end
    }
}
</code></pre>
<p><strong>受保护的接口</strong>：</p>
<pre><code class="language-nginx">location /api/protected {
    access_by_lua_block {
        local jwt_auth = require "jwt_auth"

        -- 验证token
        local payload = jwt_auth.verify_token()

        -- 将用户信息存储到nginx变量中
        ngx.var.user_id = payload.user_id
        ngx.var.username = payload.username
    }

    content_by_lua_block {
        local cjson = require "cjson"
        ngx.say(cjson.encode({
            message = "Protected resource",
            user_id = ngx.var.user_id,
            username = ngx.var.username
        }))
    }
}
</code></pre>
<h3 id="42-api网关实现"><a class="header" href="#42-api网关实现">4.2 API网关实现</a></h3>
<h4 id="实战案例13完整的api网关"><a class="header" href="#实战案例13完整的api网关">实战案例13：完整的API网关</a></h4>
<pre><code class="language-nginx"># nginx.conf
http {
    lua_shared_dict api_cache 100m;
    lua_shared_dict api_limit 10m;

    # 加载Lua模块路径
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;;";

    # 初始化
    init_by_lua_block {
        require "resty.core"

        -- 加载配置
        config = {
            jwt_secret = "your-secret-key",
            rate_limit = 100,  -- 每秒100次
            cache_ttl = 300    -- 缓存5分钟
        }
    }

    # Worker初始化
    init_worker_by_lua_block {
        -- 初始化定时任务等
    }

    server {
        listen 80;
        server_name api.example.com;

        # 全局错误处理
        error_page 500 502 503 504 /50x.json;
        location = /50x.json {
            internal;
            content_by_lua_block {
                local cjson = require "cjson"
                ngx.say(cjson.encode({
                    error = "Internal Server Error",
                    status = ngx.status
                }))
            }
        }

        # 健康检查
        location /health {
            access_log off;
            content_by_lua_block {
                ngx.say('{"status":"ok"}')
            }
        }

        # API路由
        location ~ ^/api/(.*) {
            # 限流
            access_by_lua_block {
                local limit = require "resty.limit.req"
                local lim, err = limit.new("api_limit", 100, 50)

                if not lim then
                    ngx.log(ngx.ERR, "failed to create limiter: ", err)
                    return ngx.exit(500)
                end

                local key = ngx.var.remote_addr
                local delay, err = lim:incoming(key, true)

                if not delay then
                    if err == "rejected" then
                        ngx.header["X-RateLimit-Limit"] = "100"
                        ngx.header["X-RateLimit-Remaining"] = "0"
                        return ngx.exit(429)
                    end
                    ngx.log(ngx.ERR, "failed to limit: ", err)
                    return ngx.exit(500)
                end
            }

            # JWT认证
            access_by_lua_block {
                local jwt_auth = require "jwt_auth"

                -- 公开接口跳过认证
                local uri = ngx.var.uri
                if uri == "/api/login" or uri == "/api/register" then
                    return
                end

                -- 验证JWT
                local payload = jwt_auth.verify_token()
                ngx.ctx.user = payload
            }

            # 代理到后端
            content_by_lua_block {
                local http = require "resty.http"
                local cjson = require "cjson"

                local httpc = http.new()
                httpc:set_timeout(5000)

                -- 构建后端URL
                local backend_url = "http://backend-service:8080" .. ngx.var.uri

                -- 读取请求体
                ngx.req.read_body()
                local body = ngx.req.get_body_data()

                -- 转发请求
                local res, err = httpc:request_uri(backend_url, {
                    method = ngx.req.get_method(),
                    body = body,
                    headers = {
                        ["Content-Type"] = ngx.var.http_content_type,
                        ["X-User-ID"] = ngx.ctx.user and ngx.ctx.user.user_id or "",
                    }
                })

                if not res then
                    ngx.log(ngx.ERR, "backend request failed: ", err)
                    return ngx.exit(502)
                end

                -- 返回响应
                ngx.status = res.status
                ngx.say(res.body)
            }
        }
    }
}
</code></pre>
<h3 id="43-动态路由"><a class="header" href="#43-动态路由">4.3 动态路由</a></h3>
<h4 id="实战案例14基于redis的动态路由"><a class="header" href="#实战案例14基于redis的动态路由">实战案例14：基于Redis的动态路由</a></h4>
<pre><code class="language-lua">-- /usr/local/openresty/nginx/lua/dynamic_router.lua
local redis = require "resty.redis"
local cjson = require "cjson"

local _M = {}

function _M.get_backend(service_name)
    local red = redis:new()
    red:set_timeout(1000)

    local ok, err = red:connect("127.0.0.1", 6379)
    if not ok then
        ngx.log(ngx.ERR, "redis connect failed: ", err)
        return nil
    end

    -- 从Redis获取服务配置
    local key = "route:" .. service_name
    local config, err = red:get(key)

    red:set_keepalive(10000, 100)

    if not config or config == ngx.null then
        return nil
    end

    return cjson.decode(config)
end

return _M
</code></pre>
<p><strong>配置路由到Redis</strong>：</p>
<pre><code class="language-bash"># 设置路由规则
redis-cli SET "route:user-service" '{"backend":"http://user-service:8080","timeout":5000}'
redis-cli SET "route:order-service" '{"backend":"http://order-service:8080","timeout":3000}'
</code></pre>
<p><strong>使用动态路由</strong>：</p>
<pre><code class="language-nginx">location ~ ^/api/([^/]+)/(.*) {
    content_by_lua_block {
        local router = require "dynamic_router"
        local http = require "resty.http"

        local service = ngx.var[1]  -- 提取服务名
        local path = ngx.var[2]     -- 提取路径

        -- 获取路由配置
        local config = router.get_backend(service)
        if not config then
            ngx.status = 404
            ngx.say('{"error":"Service not found"}')
            return
        end

        -- 代理到后端
        local httpc = http.new()
        httpc:set_timeout(config.timeout or 5000)

        local url = config.backend .. "/" .. path
        local res, err = httpc:request_uri(url, {
            method = ngx.req.get_method()
        })

        if not res then
            return ngx.exit(502)
        end

        ngx.status = res.status
        ngx.say(res.body)
    }
}
</code></pre>
<hr />
<h2 id="第五部分性能优化"><a class="header" href="#第五部分性能优化">第五部分：性能优化</a></h2>
<h3 id="51-缓存策略"><a class="header" href="#51-缓存策略">5.1 缓存策略</a></h3>
<h4 id="实战案例15多级缓存"><a class="header" href="#实战案例15多级缓存">实战案例15：多级缓存</a></h4>
<pre><code class="language-lua">location /api/user {
    content_by_lua_block {
        local cjson = require "cjson"
        local cache = ngx.shared.my_cache
        local redis = require "resty.redis"

        local user_id = ngx.var.arg_id
        local cache_key = "user:" .. user_id

        -- Level 1: 共享内存缓存
        local cached_data = cache:get(cache_key)
        if cached_data then
            ngx.header["X-Cache"] = "HIT-L1"
            ngx.say(cached_data)
            return
        end

        -- Level 2: Redis缓存
        local red = redis:new()
        red:set_timeout(1000)
        local ok = red:connect("127.0.0.1", 6379)

        if ok then
            local redis_data = red:get(cache_key)
            red:set_keepalive(10000, 100)

            if redis_data and redis_data ~= ngx.null then
                -- 写入L1缓存
                cache:set(cache_key, redis_data, 60)
                ngx.header["X-Cache"] = "HIT-L2"
                ngx.say(redis_data)
                return
            end
        end

        -- Level 3: 数据库查询
        local db_pool = require "db_pool"
        local db = db_pool.get_mysql_connection()

        if not db then
            return ngx.exit(500)
        end

        local sql = string.format("SELECT * FROM users WHERE id = %s", user_id)
        local res, err = db:query(sql)
        db_pool.close_mysql(db)

        if not res or #res == 0 then
            ngx.status = 404
            ngx.say('{"error":"User not found"}')
            return
        end

        local user_data = cjson.encode(res[1])

        -- 写入缓存
        cache:set(cache_key, user_data, 60)
        if ok then
            red:connect("127.0.0.1", 6379)
            red:setex(cache_key, 300, user_data)
            red:set_keepalive(10000, 100)
        end

        ngx.header["X-Cache"] = "MISS"
        ngx.say(user_data)
    }
}
</code></pre>
<h3 id="52-协程和异步编程"><a class="header" href="#52-协程和异步编程">5.2 协程和异步编程</a></h3>
<h4 id="实战案例16并发请求处理"><a class="header" href="#实战案例16并发请求处理">实战案例16：并发请求处理</a></h4>
<pre><code class="language-lua">location /api/dashboard {
    content_by_lua_block {
        local http = require "resty.http"
        local cjson = require "cjson"

        -- 创建多个HTTP客户端
        local httpc1 = http.new()
        local httpc2 = http.new()
        local httpc3 = http.new()

        local function fetch_users()
            local res = httpc1:request_uri("http://api/users")
            return res and res.body or nil
        end

        local function fetch_orders()
            local res = httpc2:request_uri("http://api/orders")
            return res and res.body or nil
        end

        local function fetch_stats()
            local res = httpc3:request_uri("http://api/stats")
            return res and res.body or nil
        end

        -- 并发执行
        local users, orders, stats

        local co1 = ngx.thread.spawn(function()
            users = fetch_users()
        end)

        local co2 = ngx.thread.spawn(function()
            orders = fetch_orders()
        end)

        local co3 = ngx.thread.spawn(function()
            stats = fetch_stats()
        end)

        -- 等待所有协程完成
        ngx.thread.wait(co1)
        ngx.thread.wait(co2)
        ngx.thread.wait(co3)

        -- 组合结果
        local result = {
            users = users and cjson.decode(users) or {},
            orders = orders and cjson.decode(orders) or {},
            stats = stats and cjson.decode(stats) or {}
        }

        ngx.say(cjson.encode(result))
    }
}
</code></pre>
<hr />
<h2 id="第六部分监控与运维"><a class="header" href="#第六部分监控与运维">第六部分：监控与运维</a></h2>
<h3 id="61-日志和监控"><a class="header" href="#61-日志和监控">6.1 日志和监控</a></h3>
<h4 id="实战案例17结构化日志"><a class="header" href="#实战案例17结构化日志">实战案例17：结构化日志</a></h4>
<pre><code class="language-nginx">http {
    # 定义JSON格式日志
    log_format json_log escape=json '{'
        '"time":"$time_iso8601",'
        '"remote_addr":"$remote_addr",'
        '"request_method":"$request_method",'
        '"request_uri":"$request_uri",'
        '"status":$status,'
        '"body_bytes_sent":$body_bytes_sent,'
        '"request_time":$request_time,'
        '"upstream_response_time":"$upstream_response_time",'
        '"user_id":"$http_x_user_id"'
    '}';

    access_log logs/access.log json_log;

    server {
        location /api/ {
            # 业务日志
            log_by_lua_block {
                local cjson = require "cjson"

                local log_data = {
                    timestamp = ngx.time(),
                    uri = ngx.var.uri,
                    method = ngx.req.get_method(),
                    status = ngx.status,
                    request_time = ngx.var.request_time,
                    user_id = ngx.ctx.user and ngx.ctx.user.user_id or nil
                }

                ngx.log(ngx.INFO, "BUSINESS_LOG: ", cjson.encode(log_data))
            }
        }
    }
}
</code></pre>
<h3 id="62-性能监控"><a class="header" href="#62-性能监控">6.2 性能监控</a></h3>
<h4 id="实战案例18prometheus指标导出"><a class="header" href="#实战案例18prometheus指标导出">实战案例18：Prometheus指标导出</a></h4>
<pre><code class="language-lua">-- /usr/local/openresty/nginx/lua/metrics.lua
local _M = {}

local prometheus = require "resty.prometheus"

-- 初始化Prometheus
function _M.init()
    _M.metrics = prometheus.init("prometheus_metrics")

    -- 定义指标
    _M.http_requests = _M.metrics:counter(
        "http_requests_total",
        "Total HTTP requests",
        {"method", "endpoint", "status"}
    )

    _M.http_latency = _M.metrics:histogram(
        "http_request_duration_seconds",
        "HTTP request latency",
        {"method", "endpoint"}
    )
end

-- 记录请求
function _M.log_request()
    local method = ngx.req.get_method()
    local uri = ngx.var.uri
    local status = ngx.status
    local latency = tonumber(ngx.var.request_time)

    _M.http_requests:inc(1, {method, uri, status})
    _M.http_latency:observe(latency, {method, uri})
end

return _M
</code></pre>
<p><strong>配置</strong>：</p>
<pre><code class="language-nginx">http {
    lua_shared_dict prometheus_metrics 10m;

    init_worker_by_lua_block {
        local metrics = require "metrics"
        metrics.init()
    }

    server {
        # 指标导出接口
        location /metrics {
            content_by_lua_block {
                local metrics = require "metrics"
                metrics.metrics:collect()
            }
        }

        location /api/ {
            log_by_lua_block {
                local metrics = require "metrics"
                metrics.log_request()
            }

            proxy_pass http://backend;
        }
    }
}
</code></pre>
<hr />
<h2 id="学习验证标准"><a class="header" href="#学习验证标准">学习验证标准</a></h2>
<p>完成本笔记学习后，你应该能够独立完成以下任务：</p>
<h3 id="验证标准1环境搭建与基础能力"><a class="header" href="#验证标准1环境搭建与基础能力">验证标准1：环境搭建与基础能力</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
成功安装OpenResty并验证运行</li>
<li><input disabled="" type="checkbox"/>
编写Hello World程序</li>
<li><input disabled="" type="checkbox"/>
理解并使用至少10个ngx API函数</li>
<li><input disabled="" type="checkbox"/>
能够调试Lua脚本并查看日志</li>
</ul>
<h3 id="验证标准2数据库与缓存"><a class="header" href="#验证标准2数据库与缓存">验证标准2：数据库与缓存</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
实现Redis连接池和基本操作</li>
<li><input disabled="" type="checkbox"/>
实现MySQL连接池和CRUD操作</li>
<li><input disabled="" type="checkbox"/>
使用共享内存字典实现缓存</li>
<li><input disabled="" type="checkbox"/>
实现多级缓存策略</li>
</ul>
<h3 id="验证标准3api网关开发"><a class="header" href="#验证标准3api网关开发">验证标准3：API网关开发</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
实现JWT认证和授权</li>
<li><input disabled="" type="checkbox"/>
实现请求限流和熔断</li>
<li><input disabled="" type="checkbox"/>
实现API路由和转发</li>
<li><input disabled="" type="checkbox"/>
实现请求/响应转换</li>
</ul>
<h3 id="验证标准4性能优化"><a class="header" href="#验证标准4性能优化">验证标准4：性能优化</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
使用协程实现并发请求</li>
<li><input disabled="" type="checkbox"/>
实现多级缓存提升性能</li>
<li><input disabled="" type="checkbox"/>
优化连接池配置</li>
<li><input disabled="" type="checkbox"/>
进行性能测试并调优</li>
</ul>
<h3 id="验证标准5生产环境部署"><a class="header" href="#验证标准5生产环境部署">验证标准5：生产环境部署</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
部署一个完整的API网关项目</li>
<li><input disabled="" type="checkbox"/>
实现结构化日志和监控</li>
<li><input disabled="" type="checkbox"/>
实现热更新和灰度发布</li>
<li><input disabled="" type="checkbox"/>
编写运维文档和故障处理流程</li>
</ul>
<hr />
<h2 id="扩展资源与进阶建议"><a class="header" href="#扩展资源与进阶建议">扩展资源与进阶建议</a></h2>
<h3 id="官方资源"><a class="header" href="#官方资源">官方资源</a></h3>
<ul>
<li><a href="https://openresty.org/cn/">OpenResty官方文档</a></li>
<li><a href="https://github.com/openresty/openresty">OpenResty GitHub</a></li>
<li><a href="https://www.lua.org/manual/5.1/">Lua参考手册</a></li>
<li><a href="http://luajit.org/">LuaJIT官网</a></li>
</ul>
<h3 id="推荐库和工具"><a class="header" href="#推荐库和工具">推荐库和工具</a></h3>
<ul>
<li><strong>lua-resty-http</strong>: HTTP客户端库</li>
<li><strong>lua-resty-redis</strong>: Redis客户端库</li>
<li><strong>lua-resty-mysql</strong>: MySQL客户端库</li>
<li><strong>lua-resty-jwt</strong>: JWT处理库</li>
<li><strong>lua-resty-limit-traffic</strong>: 限流库</li>
<li><strong>lua-resty-lock</strong>: 分布式锁</li>
</ul>
<h3 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h3>
<ul>
<li>《OpenResty完全开发指南》</li>
<li>《OpenResty最佳实践》（GitBook）</li>
<li>OpenResty官方博客</li>
<li>云风的博客（Lua相关）</li>
</ul>
<h3 id="实战项目建议"><a class="header" href="#实战项目建议">实战项目建议</a></h3>
<ol>
<li>实现一个完整的API网关（包含认证、限流、路由）</li>
<li>构建高性能缓存代理服务</li>
<li>开发动态配置管理系统</li>
<li>实现简单的WAF（Web应用防火墙）</li>
<li>构建微服务治理平台</li>
</ol>
<h3 id="学习路线图"><a class="header" href="#学习路线图">学习路线图</a></h3>
<pre><code>阶段1（1-2周）：基础入门
├── OpenResty安装配置
├── Lua语法基础
└── ngx API使用

阶段2（2-3周）：核心模块
├── Redis/MySQL集成
├── HTTP客户端使用
└── 共享内存字典

阶段3（2-3周）：高级特性
├── JWT认证授权
├── 限流熔断
└── 动态路由

阶段4（2-4周）：性能优化
├── 缓存策略
├── 协程并发
└── 连接池优化

阶段5（持续）：生产实战
├── API网关开发
├── 监控运维
└── 性能调优
</code></pre>
<hr />
<h2 id="常见问题与解决方案"><a class="header" href="#常见问题与解决方案">常见问题与解决方案</a></h2>
<h3 id="q1-如何调试lua代码"><a class="header" href="#q1-如何调试lua代码">Q1: 如何调试Lua代码？</a></h3>
<pre><code class="language-lua">-- 方法1：使用ngx.log
ngx.log(ngx.ERR, "Debug: ", variable)

-- 方法2：使用print（仅在resty命令行）
print("Debug:", variable)

-- 方法3：返回调试信息
ngx.say("Debug: ", cjson.encode(data))

-- 方法4：使用ZeroBrane Studio远程调试
</code></pre>
<h3 id="q2-内存泄漏如何排查"><a class="header" href="#q2-内存泄漏如何排查">Q2: 内存泄漏如何排查？</a></h3>
<pre><code class="language-bash"># 1. 监控worker进程内存
ps aux | grep nginx

# 2. 使用nginx-systemtap-toolkit
./ngx-sample-lua-bt -p &lt;pid&gt; --luajit20

# 3. 检查共享内存使用
lua_shared_dict status
</code></pre>
<h3 id="q3-如何实现热更新"><a class="header" href="#q3-如何实现热更新">Q3: 如何实现热更新？</a></h3>
<pre><code class="language-bash"># 方法1：重载配置
openresty -s reload

# 方法2：使用lua_code_cache off（仅开发环境）
lua_code_cache off;

# 方法3：动态加载模块
package.loaded["module_name"] = nil
require "module_name"
</code></pre>
<h3 id="q4-性能不达预期怎么办"><a class="header" href="#q4-性能不达预期怎么办">Q4: 性能不达预期怎么办？</a></h3>
<pre><code>1. 检查lua_code_cache是否开启
2. 优化数据库连接池配置
3. 使用共享内存减少外部调用
4. 启用HTTP长连接
5. 使用火焰图分析性能瓶颈
</code></pre>
<hr />
<h2 id="附录实用代码片段"><a class="header" href="#附录实用代码片段">附录：实用代码片段</a></h2>
<h3 id="a1-通用响应封装"><a class="header" href="#a1-通用响应封装">A1. 通用响应封装</a></h3>
<pre><code class="language-lua">-- /usr/local/openresty/nginx/lua/response.lua
local cjson = require "cjson"
local _M = {}

function _M.success(data, message)
    ngx.header["Content-Type"] = "application/json"
    ngx.say(cjson.encode({
        code = 0,
        message = message or "success",
        data = data
    }))
end

function _M.error(code, message)
    ngx.status = code
    ngx.header["Content-Type"] = "application/json"
    ngx.say(cjson.encode({
        code = code,
        message = message,
        data = nil
    }))
    ngx.exit(code)
end

return _M
</code></pre>
<h3 id="a2-ip白名单检查"><a class="header" href="#a2-ip白名单检查">A2. IP白名单检查</a></h3>
<pre><code class="language-lua">local function is_ip_allowed(ip)
    local whitelist = {
        ["127.0.0.1"] = true,
        ["192.168.1.100"] = true
    }

    return whitelist[ip] == true
end

-- 使用
if not is_ip_allowed(ngx.var.remote_addr) then
    return ngx.exit(403)
end
</code></pre>
<h3 id="a3-请求签名验证"><a class="header" href="#a3-请求签名验证">A3. 请求签名验证</a></h3>
<pre><code class="language-lua">local function verify_signature()
    local timestamp = ngx.var.http_x_timestamp
    local sign = ngx.var.http_x_signature
    local secret = "your-secret-key"

    -- 检查时间戳（5分钟有效期）
    if not timestamp or math.abs(ngx.time() - tonumber(timestamp)) &gt; 300 then
        return false
    end

    -- 验证签名
    local content = timestamp .. secret
    local expected_sign = ngx.md5(content)

    return sign == expected_sign
end
</code></pre>
<hr />
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>OpenResty是一个强大的Web开发平台，它结合了Nginx的高性能和Lua的灵活性。掌握OpenResty需要：</p>
<ol>
<li><strong>扎实的基础</strong>：深入理解Nginx和Lua</li>
<li><strong>实战经验</strong>：多动手编写实际项目</li>
<li><strong>性能意识</strong>：时刻关注性能优化</li>
<li><strong>持续学习</strong>：跟进社区最新动态</li>
<li><strong>最佳实践</strong>：学习优秀开源项目</li>
</ol>
<p>记住：<strong>性能来自设计，稳定来自实践</strong>。祝你早日成为OpenResty专家！</p>
<hr />
<p><strong>文档版本</strong>: v1.0
<strong>最后更新</strong>: 2025-11-02
<strong>适用版本</strong>: OpenResty 1.19.9+</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../编程/network/nginx.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../编程/network/openvswitch.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../编程/network/nginx.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../编程/network/openvswitch.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../theme/segmentit.umd.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../theme/searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>



    </div>
    </body>
</html>

