# C++游戏引擎开发 - 实战项目指南

> 本文档提供完整的实战项目案例，从零开始构建可玩的游戏Demo。

---

## 目录
- [一、第三人称射击游戏](#一第三人称射击游戏)
- [二、物理解谜游戏](#二物理解谜游戏)
- [三、平台跳跃游戏](#三平台跳跃游戏)
- [四、性能优化实战](#四性能优化实战)
- [五、引擎调试技巧](#五引擎调试技巧)

---

## 一、第三人称射击游戏

### 1.1 项目需求分析

#### 核心功能列表
```
TPS游戏核心系统
├── 角色控制系统
│   ├── WASD移动
│   ├── 鼠标视角控制
│   ├── 跳跃与下蹲
│   └── 冲刺功能
├── 相机系统
│   ├── 第三人称跟随
│   ├── 肩膀切换
│   ├── 碰撞检测避障
│   └── 瞄准模式（缩放）
├── 武器系统
│   ├── 射击检测（Raycast）
│   ├── 后坐力模拟
│   ├── 弹药管理
│   └── 换弹动画
├── 敌人AI
│   ├── 巡逻路径
│   ├── 追击玩家
│   ├── 攻击判定
│   └── 血量系统
└── UI系统
    ├── 准星显示
    ├── 血量条
    ├── 弹药显示
    └── 击杀提示
```

### 1.2 角色控制器实现

#### C++角色控制器

```cpp
// tps_character_controller.h
class TPSCharacterController : public Component {
private:
    Rigidbody* rigidbody;
    Camera* followCamera;

    // 移动参数
    float moveSpeed = 5.0f;
    float sprintSpeed = 8.0f;
    float jumpForce = 10.0f;
    float rotationSpeed = 720.0f;

    // 状态
    bool isGrounded = false;
    bool isSprinting = false;
    bool isCrouching = false;

    // 输入
    float horizontalInput = 0.0f;
    float verticalInput = 0.0f;
    float mouseX = 0.0f;
    float mouseY = 0.0f;

public:
    TPSCharacterController(GameObject* go) : Component(go) {}

    void start() override {
        rigidbody = gameObject->getComponent<Rigidbody>();
        followCamera = GameObject::find("MainCamera")->getComponent<Camera>();
    }

    void update(float deltaTime) override {
        handleInput();
        updateMovement(deltaTime);
        updateRotation(deltaTime);
        checkGrounded();
    }

    void handleInput() {
        // 移动输入
        horizontalInput = 0.0f;
        verticalInput = 0.0f;

        if (Input::getKey(GLFW_KEY_W)) verticalInput += 1.0f;
        if (Input::getKey(GLFW_KEY_S)) verticalInput -= 1.0f;
        if (Input::getKey(GLFW_KEY_A)) horizontalInput -= 1.0f;
        if (Input::getKey(GLFW_KEY_D)) horizontalInput += 1.0f;

        // 冲刺
        isSprinting = Input::getKey(GLFW_KEY_LEFT_SHIFT);

        // 跳跃
        if (Input::getKeyDown(GLFW_KEY_SPACE) && isGrounded) {
            rigidbody->addImpulse(glm::vec3(0.0f, jumpForce, 0.0f));
        }

        // 下蹲
        if (Input::getKeyDown(GLFW_KEY_C)) {
            isCrouching = !isCrouching;
            // 调整碰撞体高度
        }

        // 鼠标输入
        glm::vec2 mouseDelta = Input::getMouseDelta();
        mouseX = mouseDelta.x;
        mouseY = mouseDelta.y;
    }

    void updateMovement(float deltaTime) {
        if (horizontalInput == 0.0f && verticalInput == 0.0f) return;

        // 获取相机前方向（Y轴归零）
        glm::vec3 cameraForward = followCamera->getGameObject()->getTransform()->forward();
        cameraForward.y = 0.0f;
        cameraForward = glm::normalize(cameraForward);

        glm::vec3 cameraRight = followCamera->getGameObject()->getTransform()->right();
        cameraRight.y = 0.0f;
        cameraRight = glm::normalize(cameraRight);

        // 计算移动方向
        glm::vec3 moveDirection = cameraForward * verticalInput + cameraRight * horizontalInput;
        moveDirection = glm::normalize(moveDirection);

        // 应用速度
        float currentSpeed = isSprinting ? sprintSpeed : moveSpeed;
        glm::vec3 velocity = rigidbody->getVelocity();
        velocity.x = moveDirection.x * currentSpeed;
        velocity.z = moveDirection.z * currentSpeed;
        rigidbody->setVelocity(velocity);
    }

    void updateRotation(float deltaTime) {
        if (horizontalInput == 0.0f && verticalInput == 0.0f) return;

        // 角色朝向移动方向
        glm::vec3 cameraForward = followCamera->getGameObject()->getTransform()->forward();
        cameraForward.y = 0.0f;
        cameraForward = glm::normalize(cameraForward);

        glm::vec3 cameraRight = followCamera->getGameObject()->getTransform()->right();
        cameraRight.y = 0.0f;
        cameraRight = glm::normalize(cameraRight);

        glm::vec3 targetDirection = cameraForward * verticalInput + cameraRight * horizontalInput;
        targetDirection = glm::normalize(targetDirection);

        // 平滑旋转
        float targetAngle = std::atan2(targetDirection.x, targetDirection.z);
        float currentAngle = std::atan2(
            gameObject->getTransform()->forward().x,
            gameObject->getTransform()->forward().z
        );

        float angleDiff = targetAngle - currentAngle;
        // 规范化角度差到[-π, π]
        while (angleDiff > glm::pi<float>()) angleDiff -= 2.0f * glm::pi<float>();
        while (angleDiff < -glm::pi<float>()) angleDiff += 2.0f * glm::pi<float>();

        float rotationAmount = glm::radians(rotationSpeed) * deltaTime;
        if (std::abs(angleDiff) < rotationAmount) {
            currentAngle = targetAngle;
        } else {
            currentAngle += glm::sign(angleDiff) * rotationAmount;
        }

        glm::quat rotation = glm::angleAxis(currentAngle, glm::vec3(0.0f, 1.0f, 0.0f));
        gameObject->getTransform()->setRotation(rotation);
    }

    void checkGrounded() {
        // 射线检测
        glm::vec3 origin = gameObject->getTransform()->getPosition();
        glm::vec3 direction = glm::vec3(0.0f, -1.0f, 0.0f);
        glm::vec3 hitPoint;

        isGrounded = PhysicsWorld::getInstance().raycast(origin, origin + direction * 0.6f, hitPoint);
    }
};
```

### 1.3 第三人称相机

```cpp
// tps_camera.h
class TPSCamera : public Component {
private:
    Camera* camera;
    GameObject* target;

    float distance = 5.0f;
    float minDistance = 2.0f;
    float maxDistance = 10.0f;

    float yaw = 0.0f;
    float pitch = 15.0f;
    float minPitch = -30.0f;
    float maxPitch = 60.0f;

    float mouseSensitivity = 0.1f;
    float scrollSensitivity = 1.0f;

    glm::vec3 shoulderOffset = glm::vec3(0.5f, 0.5f, 0.0f);
    bool isRightShoulder = true;

public:
    TPSCamera(GameObject* go) : Component(go) {}

    void start() override {
        camera = gameObject->getComponent<Camera>();
        target = GameObject::find("Player");
    }

    void lateUpdate(float deltaTime) override {
        handleInput();
        updatePosition();
        handleCollision();
    }

    void handleInput() {
        // 鼠标旋转
        glm::vec2 mouseDelta = Input::getMouseDelta();
        yaw += mouseDelta.x * mouseSensitivity;
        pitch -= mouseDelta.y * mouseSensitivity;
        pitch = glm::clamp(pitch, minPitch, maxPitch);

        // 滚轮缩放
        float scroll = Input::getMouseScroll();
        distance -= scroll * scrollSensitivity;
        distance = glm::clamp(distance, minDistance, maxDistance);

        // 切换肩膀
        if (Input::getKeyDown(GLFW_KEY_V)) {
            isRightShoulder = !isRightShoulder;
        }
    }

    void updatePosition() {
        if (!target) return;

        // 计算相机位置
        glm::vec3 targetPos = target->getTransform()->getPosition();

        float yawRad = glm::radians(yaw);
        float pitchRad = glm::radians(pitch);

        glm::vec3 offset;
        offset.x = distance * std::cos(pitchRad) * std::sin(yawRad);
        offset.y = distance * std::sin(pitchRad);
        offset.z = distance * std::cos(pitchRad) * std::cos(yawRad);

        // 肩膀偏移
        glm::vec3 shoulder = shoulderOffset;
        if (!isRightShoulder) shoulder.x = -shoulder.x;

        glm::mat4 rotation = glm::rotate(glm::mat4(1.0f), yawRad, glm::vec3(0, 1, 0));
        glm::vec3 rotatedShoulder = glm::vec3(rotation * glm::vec4(shoulder, 0.0f));

        glm::vec3 desiredPosition = targetPos + rotatedShoulder + offset;
        gameObject->getTransform()->setPosition(desiredPosition);

        // 相机朝向目标
        glm::vec3 lookTarget = targetPos + glm::vec3(0.0f, 1.5f, 0.0f);  // 角色胸部位置
        glm::vec3 direction = glm::normalize(lookTarget - desiredPosition);

        float lookYaw = std::atan2(direction.x, direction.z);
        float lookPitch = std::asin(-direction.y);

        glm::quat rotation_quat = glm::quat(glm::vec3(lookPitch, lookYaw, 0.0f));
        gameObject->getTransform()->setRotation(rotation_quat);
    }

    void handleCollision() {
        // 相机与墙壁碰撞检测
        glm::vec3 targetPos = target->getTransform()->getPosition();
        glm::vec3 cameraPos = gameObject->getTransform()->getPosition();

        glm::vec3 direction = cameraPos - targetPos;
        float currentDistance = glm::length(direction);

        glm::vec3 hitPoint;
        bool hit = PhysicsWorld::getInstance().raycast(targetPos, cameraPos, hitPoint);

        if (hit) {
            float hitDistance = glm::length(hitPoint - targetPos);
            if (hitDistance < currentDistance) {
                // 相机拉近避免穿墙
                glm::vec3 newPosition = targetPos + glm::normalize(direction) * (hitDistance - 0.2f);
                gameObject->getTransform()->setPosition(newPosition);
            }
        }
    }

    void setTarget(GameObject* newTarget) { target = newTarget; }
    void setDistance(float dist) { distance = dist; }
};
```

### 1.4 武器系统

```cpp
// weapon_system.h
class Weapon : public Component {
public:
    struct WeaponStats {
        std::string name;
        int maxAmmo;
        int currentAmmo;
        int magazineSize;
        float fireRate;        // 每秒射击次数
        float damage;
        float range;
        float recoilAmount;
        float reloadTime;
    };

private:
    WeaponStats stats;
    float fireTimer = 0.0f;
    bool isReloading = false;
    float reloadTimer = 0.0f;

    Camera* fpCamera;
    LineRenderer* bulletTracer;

public:
    Weapon(GameObject* go) : Component(go) {}

    void initialize(const WeaponStats& weaponStats) {
        stats = weaponStats;
        stats.currentAmmo = stats.magazineSize;
    }

    void update(float deltaTime) override {
        fireTimer += deltaTime;

        // 换弹逻辑
        if (isReloading) {
            reloadTimer += deltaTime;
            if (reloadTimer >= stats.reloadTime) {
                finishReload();
            }
            return;
        }

        // 射击输入
        if (Input::getMouseButton(0)) {  // 左键
            if (canFire()) {
                fire();
            }
        }

        // 换弹输入
        if (Input::getKeyDown(GLFW_KEY_R)) {
            if (stats.currentAmmo < stats.magazineSize && stats.maxAmmo > 0) {
                startReload();
            }
        }
    }

    bool canFire() {
        return !isReloading &&
               stats.currentAmmo > 0 &&
               fireTimer >= (1.0f / stats.fireRate);
    }

    void fire() {
        stats.currentAmmo--;
        fireTimer = 0.0f;

        // 射线检测
        glm::vec3 rayOrigin = fpCamera->getGameObject()->getTransform()->getPosition();
        glm::vec3 rayDirection = fpCamera->getGameObject()->getTransform()->forward();

        // 添加随机扩散（后坐力）
        rayDirection.x += randomFloat(-stats.recoilAmount, stats.recoilAmount);
        rayDirection.y += randomFloat(-stats.recoilAmount, stats.recoilAmount);
        rayDirection = glm::normalize(rayDirection);

        glm::vec3 hitPoint;
        glm::vec3 rayEnd = rayOrigin + rayDirection * stats.range;

        bool hit = PhysicsWorld::getInstance().raycast(rayOrigin, rayEnd, hitPoint);

        if (hit) {
            // 命中处理
            GameObject* hitObject = getHitObject(hitPoint);
            if (hitObject) {
                Health* health = hitObject->getComponent<Health>();
                if (health) {
                    health->takeDamage(stats.damage);
                }
            }

            // 显示子弹轨迹
            showBulletTracer(rayOrigin, hitPoint);

            // 生成击中特效
            spawnImpactEffect(hitPoint);
        } else {
            showBulletTracer(rayOrigin, rayEnd);
        }

        // 播放射击音效
        AudioEngine::getInstance().playSound("gunshot", rayOrigin);

        // 相机后坐力
        applyRecoil();

        // 如果弹匣空了，自动换弹
        if (stats.currentAmmo == 0 && stats.maxAmmo > 0) {
            startReload();
        }
    }

    void startReload() {
        isReloading = true;
        reloadTimer = 0.0f;

        // 播放换弹动画
        Animator* animator = gameObject->getComponent<Animator>();
        if (animator) {
            animator->play("Reload");
        }

        // 播放换弹音效
        AudioEngine::getInstance().playSound("reload", gameObject->getTransform()->getPosition());
    }

    void finishReload() {
        int ammoNeeded = stats.magazineSize - stats.currentAmmo;
        int ammoToReload = std::min(ammoNeeded, stats.maxAmmo);

        stats.currentAmmo += ammoToReload;
        stats.maxAmmo -= ammoToReload;

        isReloading = false;
        reloadTimer = 0.0f;
    }

    void applyRecoil() {
        // 相机抖动
        TPSCamera* tpsCamera = fpCamera->getGameObject()->getComponent<TPSCamera>();
        if (tpsCamera) {
            // 添加随机相机偏移
            float recoilX = randomFloat(-2.0f, 2.0f);
            float recoilY = randomFloat(1.0f, 3.0f);  // 向上为主
            // tpsCamera->addRecoil(recoilX, recoilY);
        }
    }

    void showBulletTracer(const glm::vec3& start, const glm::vec3& end) {
        // 创建临时线条渲染器
        GameObject* tracerObj = new GameObject("BulletTracer");
        LineRenderer* tracer = tracerObj->addComponent<LineRenderer>();
        tracer->setPoints(start, end);
        tracer->setColor(glm::vec4(1.0f, 1.0f, 0.0f, 1.0f));
        tracer->setWidth(0.02f);

        // 0.1秒后销毁
        tracerObj->destroyAfter(0.1f);
    }

    void spawnImpactEffect(const glm::vec3& position) {
        // 生成粒子效果
        GameObject* effectObj = new GameObject("ImpactEffect");
        effectObj->getTransform()->setPosition(position);

        ParticleSystem* particles = effectObj->addComponent<ParticleSystem>();
        particles->setEmitRate(50.0f);
        particles->setLifetime(0.5f);
        particles->setSize(0.1f);

        effectObj->destroyAfter(1.0f);
    }

    GameObject* getHitObject(const glm::vec3& hitPoint) {
        // 通过物理射线获取击中的GameObject
        // 具体实现依赖物理引擎
        return nullptr;
    }

    float randomFloat(float min, float max) {
        return min + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX / (max - min)));
    }

    // Getters
    const WeaponStats& getStats() const { return stats; }
    bool getIsReloading() const { return isReloading; }
};
```

### 1.5 敌人AI系统

```cpp
// enemy_ai.h
class EnemyAI : public Component {
public:
    enum State {
        PATROL,
        CHASE,
        ATTACK,
        DEAD
    };

private:
    State currentState = PATROL;

    GameObject* player;
    Rigidbody* rigidbody;
    Animator* animator;
    Health* health;

    // 巡逻
    std::vector<glm::vec3> patrolPoints;
    int currentPatrolIndex = 0;
    float patrolWaitTime = 2.0f;
    float patrolWaitTimer = 0.0f;

    // 追击
    float chaseSpeed = 4.0f;
    float detectionRange = 15.0f;
    float loseTargetRange = 20.0f;

    // 攻击
    float attackRange = 2.0f;
    float attackDamage = 10.0f;
    float attackCooldown = 1.5f;
    float attackTimer = 0.0f;

public:
    EnemyAI(GameObject* go) : Component(go) {}

    void start() override {
        player = GameObject::find("Player");
        rigidbody = gameObject->getComponent<Rigidbody>();
        animator = gameObject->getComponent<Animator>();
        health = gameObject->getComponent<Health>();

        // 设置巡逻点
        patrolPoints = {
            glm::vec3(0.0f, 0.0f, 0.0f),
            glm::vec3(10.0f, 0.0f, 0.0f),
            glm::vec3(10.0f, 0.0f, 10.0f),
            glm::vec3(0.0f, 0.0f, 10.0f)
        };

        // 监听死亡事件
        if (health) {
            health->onDeath = [this]() {
                onDeath();
            };
        }
    }

    void update(float deltaTime) override {
        if (currentState == DEAD) return;

        // 检测玩家距离
        float distanceToPlayer = glm::length(
            player->getTransform()->getPosition() -
            gameObject->getTransform()->getPosition()
        );

        // 状态转换
        switch (currentState) {
            case PATROL:
                if (distanceToPlayer < detectionRange) {
                    changeState(CHASE);
                } else {
                    updatePatrol(deltaTime);
                }
                break;

            case CHASE:
                if (distanceToPlayer < attackRange) {
                    changeState(ATTACK);
                } else if (distanceToPlayer > loseTargetRange) {
                    changeState(PATROL);
                } else {
                    updateChase(deltaTime);
                }
                break;

            case ATTACK:
                if (distanceToPlayer > attackRange) {
                    changeState(CHASE);
                } else {
                    updateAttack(deltaTime);
                }
                break;
        }
    }

    void changeState(State newState) {
        if (currentState == newState) return;

        // 退出旧状态
        switch (currentState) {
            case PATROL:
                patrolWaitTimer = 0.0f;
                break;
            case CHASE:
                break;
            case ATTACK:
                attackTimer = 0.0f;
                break;
        }

        currentState = newState;

        // 进入新状态
        switch (newState) {
            case PATROL:
                if (animator) animator->play("Walk");
                break;
            case CHASE:
                if (animator) animator->play("Run");
                break;
            case ATTACK:
                if (animator) animator->play("Attack");
                break;
        }
    }

    void updatePatrol(float deltaTime) {
        glm::vec3 currentPos = gameObject->getTransform()->getPosition();
        glm::vec3 targetPos = patrolPoints[currentPatrolIndex];

        float distance = glm::length(targetPos - currentPos);

        if (distance < 0.5f) {
            // 到达巡逻点，等待
            patrolWaitTimer += deltaTime;
            if (patrolWaitTimer >= patrolWaitTime) {
                currentPatrolIndex = (currentPatrolIndex + 1) % patrolPoints.size();
                patrolWaitTimer = 0.0f;
            }
        } else {
            // 移动到巡逻点
            glm::vec3 direction = glm::normalize(targetPos - currentPos);
            rigidbody->setVelocity(direction * 2.0f);  // 慢速巡逻

            // 朝向移动方向
            lookAt(targetPos);
        }
    }

    void updateChase(float deltaTime) {
        glm::vec3 playerPos = player->getTransform()->getPosition();
        glm::vec3 currentPos = gameObject->getTransform()->getPosition();

        glm::vec3 direction = glm::normalize(playerPos - currentPos);
        rigidbody->setVelocity(direction * chaseSpeed);

        lookAt(playerPos);
    }

    void updateAttack(float deltaTime) {
        // 停止移动
        rigidbody->setVelocity(glm::vec3(0.0f));

        // 朝向玩家
        lookAt(player->getTransform()->getPosition());

        // 攻击计时
        attackTimer += deltaTime;
        if (attackTimer >= attackCooldown) {
            performAttack();
            attackTimer = 0.0f;
        }
    }

    void performAttack() {
        // 播放攻击动画
        if (animator) {
            animator->play("Attack");
        }

        // 对玩家造成伤害
        Health* playerHealth = player->getComponent<Health>();
        if (playerHealth) {
            playerHealth->takeDamage(attackDamage);
        }

        // 播放攻击音效
        AudioEngine::getInstance().playSound("enemy_attack",
            gameObject->getTransform()->getPosition());
    }

    void lookAt(const glm::vec3& target) {
        glm::vec3 currentPos = gameObject->getTransform()->getPosition();
        glm::vec3 direction = target - currentPos;
        direction.y = 0.0f;  // 只在水平面旋转

        if (glm::length(direction) > 0.01f) {
            direction = glm::normalize(direction);
            float angle = std::atan2(direction.x, direction.z);
            glm::quat rotation = glm::angleAxis(angle, glm::vec3(0.0f, 1.0f, 0.0f));
            gameObject->getTransform()->setRotation(rotation);
        }
    }

    void onDeath() {
        changeState(DEAD);

        // 播放死亡动画
        if (animator) {
            animator->play("Death");
        }

        // 禁用碰撞和AI
        rigidbody->setEnabled(false);
        this->setEnabled(false);

        // 3秒后销毁
        gameObject->destroyAfter(3.0f);

        // 播放死亡音效
        AudioEngine::getInstance().playSound("enemy_death",
            gameObject->getTransform()->getPosition());
    }

    void setPatrolPoints(const std::vector<glm::vec3>& points) {
        patrolPoints = points;
    }
};
```

### 1.6 血量系统

```cpp
// health.h
class Health : public Component {
private:
    float maxHealth = 100.0f;
    float currentHealth = 100.0f;
    bool isDead = false;

public:
    std::function<void()> onDeath;
    std::function<void(float)> onDamage;
    std::function<void(float)> onHeal;

    Health(GameObject* go) : Component(go) {}

    void takeDamage(float amount) {
        if (isDead) return;

        currentHealth -= amount;
        currentHealth = glm::max(0.0f, currentHealth);

        if (onDamage) {
            onDamage(amount);
        }

        // 显示伤害数字
        showDamageNumber(amount);

        if (currentHealth <= 0.0f) {
            die();
        }
    }

    void heal(float amount) {
        if (isDead) return;

        currentHealth += amount;
        currentHealth = glm::min(maxHealth, currentHealth);

        if (onHeal) {
            onHeal(amount);
        }
    }

    void die() {
        if (isDead) return;

        isDead = true;

        if (onDeath) {
            onDeath();
        }
    }

    void showDamageNumber(float damage) {
        // 在3D空间生成浮动伤害数字
        GameObject* damageText = new GameObject("DamageNumber");
        damageText->getTransform()->setPosition(
            gameObject->getTransform()->getPosition() + glm::vec3(0.0f, 2.0f, 0.0f)
        );

        // 添加UI文字组件并设置动画
        // ... 实现浮动效果

        damageText->destroyAfter(1.0f);
    }

    float getHealth() const { return currentHealth; }
    float getMaxHealth() const { return maxHealth; }
    float getHealthPercentage() const { return currentHealth / maxHealth; }
    bool getIsDead() const { return isDead; }

    void setMaxHealth(float max) {
        maxHealth = max;
        currentHealth = glm::min(currentHealth, maxHealth);
    }
};
```

### 1.7 游戏主循环集成

```cpp
// tps_game_main.cpp
int main() {
    // 初始化引擎
    Engine engine(1920, 1080, "TPS Game Demo");
    engine.initialize();

    // 加载场景
    Scene* scene = new Scene("MainScene");

    // 创建地面
    GameObject* ground = new GameObject("Ground");
    ground->getTransform()->setPosition(glm::vec3(0.0f, -0.5f, 0.0f));
    ground->getTransform()->setScale(glm::vec3(50.0f, 1.0f, 50.0f));

    MeshRenderer* groundRenderer = ground->addComponent<MeshRenderer>();
    groundRenderer->setMesh(ResourceManager::getMesh("cube"));
    groundRenderer->setMaterial(ResourceManager::getMaterial("ground"));

    Rigidbody* groundRb = ground->addComponent<Rigidbody>();
    groundRb->setMass(0.0f);  // 静态物体
    groundRb->initialize(new btBoxShape(btVector3(50.0f, 1.0f, 50.0f)));

    scene->addGameObject(ground);

    // 创建玩家
    GameObject* player = new GameObject("Player");
    player->getTransform()->setPosition(glm::vec3(0.0f, 2.0f, 0.0f));

    MeshRenderer* playerRenderer = player->addComponent<MeshRenderer>();
    playerRenderer->setMesh(ResourceManager::getMesh("character"));
    playerRenderer->setMaterial(ResourceManager::getMaterial("character"));

    Animator* playerAnimator = player->addComponent<Animator>();
    playerAnimator->loadAnimation("idle", "animations/idle.fbx");
    playerAnimator->loadAnimation("walk", "animations/walk.fbx");
    playerAnimator->loadAnimation("run", "animations/run.fbx");

    Rigidbody* playerRb = player->addComponent<Rigidbody>();
    playerRb->setMass(80.0f);
    playerRb->initialize(new btCapsuleShape(0.5f, 1.8f));

    TPSCharacterController* controller = player->addComponent<TPSCharacterController>();

    Health* playerHealth = player->addComponent<Health>();
    playerHealth->setMaxHealth(100.0f);
    playerHealth->onDeath = []() {
        std::cout << "Player died!" << std::endl;
        // 显示游戏结束UI
    };

    scene->addGameObject(player);

    // 创建武器
    GameObject* rifle = new GameObject("Rifle");
    rifle->setParent(player);
    rifle->getTransform()->setPosition(glm::vec3(0.3f, 1.2f, 0.5f));

    MeshRenderer* rifleRenderer = rifle->addComponent<MeshRenderer>();
    rifleRenderer->setMesh(ResourceManager::getMesh("rifle"));
    rifleRenderer->setMaterial(ResourceManager::getMaterial("metal"));

    Weapon* weapon = rifle->addComponent<Weapon>();
    Weapon::WeaponStats rifleStats;
    rifleStats.name = "Assault Rifle";
    rifleStats.maxAmmo = 120;
    rifleStats.currentAmmo = 30;
    rifleStats.magazineSize = 30;
    rifleStats.fireRate = 10.0f;
    rifleStats.damage = 25.0f;
    rifleStats.range = 100.0f;
    rifleStats.recoilAmount = 0.02f;
    rifleStats.reloadTime = 2.0f;
    weapon->initialize(rifleStats);

    // 创建相机
    GameObject* cameraObj = new GameObject("MainCamera");
    cameraObj->getTransform()->setPosition(glm::vec3(0.0f, 5.0f, 10.0f));

    Camera* camera = cameraObj->addComponent<Camera>();
    camera->setAspectRatio(16.0f / 9.0f);
    camera->setFOV(60.0f);

    TPSCamera* tpsCamera = cameraObj->addComponent<TPSCamera>();
    tpsCamera->setTarget(player);

    scene->addGameObject(cameraObj);
    scene->setMainCamera(camera);

    // 创建敌人
    for (int i = 0; i < 5; i++) {
        GameObject* enemy = new GameObject("Enemy_" + std::to_string(i));
        enemy->getTransform()->setPosition(glm::vec3(
            randomFloat(-20.0f, 20.0f),
            2.0f,
            randomFloat(-20.0f, 20.0f)
        ));

        MeshRenderer* enemyRenderer = enemy->addComponent<MeshRenderer>();
        enemyRenderer->setMesh(ResourceManager::getMesh("enemy"));
        enemyRenderer->setMaterial(ResourceManager::getMaterial("enemy"));

        Animator* enemyAnimator = enemy->addComponent<Animator>();
        enemyAnimator->loadAnimation("walk", "animations/enemy_walk.fbx");
        enemyAnimator->loadAnimation("run", "animations/enemy_run.fbx");
        enemyAnimator->loadAnimation("attack", "animations/enemy_attack.fbx");
        enemyAnimator->loadAnimation("death", "animations/enemy_death.fbx");

        Rigidbody* enemyRb = enemy->addComponent<Rigidbody>();
        enemyRb->setMass(70.0f);
        enemyRb->initialize(new btCapsuleShape(0.5f, 1.8f));

        EnemyAI* ai = enemy->addComponent<EnemyAI>();

        Health* enemyHealth = enemy->addComponent<Health>();
        enemyHealth->setMaxHealth(100.0f);

        scene->addGameObject(enemy);
    }

    // 创建光照
    LightingSystem* lighting = scene->getLightingSystem();

    LightingSystem::DirectionalLight dirLight;
    dirLight.direction = glm::vec3(-0.3f, -1.0f, -0.5f);
    dirLight.ambient = glm::vec3(0.2f);
    dirLight.diffuse = glm::vec3(0.8f);
    dirLight.specular = glm::vec3(1.0f);
    lighting->setDirectionalLight(dirLight);

    // 游戏主循环
    float lastFrame = 0.0f;
    while (!engine.shouldClose()) {
        float currentFrame = engine.getTime();
        float deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // 更新
        scene->update(deltaTime);

        // 渲染
        engine.beginFrame();
        scene->render(camera);

        // UI渲染
        renderGameUI(player, weapon);

        engine.endFrame();
    }

    // 清理
    delete scene;
    engine.shutdown();

    return 0;
}

void renderGameUI(GameObject* player, Weapon* weapon) {
    // 准星
    renderCrosshair();

    // 血量条
    Health* health = player->getComponent<Health>();
    if (health) {
        renderHealthBar(health->getHealthPercentage());
    }

    // 弹药显示
    if (weapon) {
        const auto& stats = weapon->getStats();
        renderAmmoDisplay(stats.currentAmmo, stats.maxAmmo);

        if (weapon->getIsReloading()) {
            renderReloadingText();
        }
    }
}

void renderCrosshair() {
    Font* font = ResourceManager::getFont("default");
    font->renderText("+", 960 - 10, 540 - 10, 2.0f, glm::vec3(1.0f), 1920, 1080);
}

void renderHealthBar(float percentage) {
    // 使用UIImage绘制血量条背景和前景
    UIImage* healthBarBg = /* ... */;
    UIImage* healthBarFill = /* ... */;

    healthBarFill->setSize(glm::vec2(200.0f * percentage, 20.0f));
}

void renderAmmoDisplay(int current, int reserve) {
    Font* font = ResourceManager::getFont("default");
    std::string ammoText = std::to_string(current) + " / " + std::to_string(reserve);
    font->renderText(ammoText, 1700, 50, 1.0f, glm::vec3(1.0f), 1920, 1080);
}

void renderReloadingText() {
    Font* font = ResourceManager::getFont("default");
    font->renderText("RELOADING...", 860, 540, 1.5f, glm::vec3(1.0f, 1.0f, 0.0f), 1920, 1080);
}
```

---

## 二、物理解谜游戏

### 2.1 项目概述

创建类似《Portal》或《The Witness》的物理解谜游戏。

#### 核心机制
```
物理解谜游戏
├── 物理交互
│   ├── 抓取/投掷物体
│   ├── 压力板触发
│   ├── 重力操控
│   └── 物体堆叠
├── 解谜元素
│   ├── 激光反射
│   ├── 按钮与门
│   ├── 传送门
│   └── 时间倒流
└── 关卡系统
    ├── 关卡加载
    ├── 检查点
    ├── 计时与评分
    └── 关卡编辑器
```

### 2.2 物体抓取系统

```cpp
// object_grabber.h
class ObjectGrabber : public Component {
private:
    Camera* camera;
    GameObject* grabbedObject;
    Rigidbody* grabbedRigidbody;

    float grabRange = 3.0f;
    float holdDistance = 2.0f;
    float throwForce = 15.0f;

    bool isHolding = false;

public:
    ObjectGrabber(GameObject* go) : Component(go) {}

    void start() override {
        camera = gameObject->getComponent<Camera>();
    }

    void update(float deltaTime) override {
        if (Input::getKeyDown(GLFW_KEY_E)) {
            if (isHolding) {
                releaseObject();
            } else {
                tryGrabObject();
            }
        }

        if (isHolding) {
            updateHeldObject();

            // 投掷
            if (Input::getMouseButtonDown(0)) {
                throwObject();
            }
        }
    }

    void tryGrabObject() {
        glm::vec3 rayOrigin = gameObject->getTransform()->getPosition();
        glm::vec3 rayDirection = camera->getGameObject()->getTransform()->forward();

        glm::vec3 hitPoint;
        bool hit = PhysicsWorld::getInstance().raycast(
            rayOrigin,
            rayOrigin + rayDirection * grabRange,
            hitPoint
        );

        if (hit) {
            // 获取击中的物体
            GameObject* hitObject = /* 从物理世界获取 */;

            if (hitObject && hitObject->hasTag("Grabbable")) {
                grabObject(hitObject);
            }
        }
    }

    void grabObject(GameObject* obj) {
        grabbedObject = obj;
        grabbedRigidbody = obj->getComponent<Rigidbody>();

        if (grabbedRigidbody) {
            // 设置为运动学模式
            grabbedRigidbody->setKinematic(true);
            isHolding = true;
        }
    }

    void updateHeldObject() {
        if (!grabbedObject) return;

        glm::vec3 targetPos = gameObject->getTransform()->getPosition() +
                              camera->getGameObject()->getTransform()->forward() * holdDistance;

        // 平滑移动到目标位置
        glm::vec3 currentPos = grabbedObject->getTransform()->getPosition();
        glm::vec3 newPos = glm::mix(currentPos, targetPos, 0.2f);

        grabbedRigidbody->setKinematicTarget(newPos, grabbedObject->getTransform()->getRotation());
    }

    void releaseObject() {
        if (!grabbedObject) return;

        grabbedRigidbody->setKinematic(false);

        grabbedObject = nullptr;
        grabbedRigidbody = nullptr;
        isHolding = false;
    }

    void throwObject() {
        if (!grabbedObject) return;

        grabbedRigidbody->setKinematic(false);

        glm::vec3 throwDirection = camera->getGameObject()->getTransform()->forward();
        grabbedRigidbody->addImpulse(throwDirection * throwForce);

        grabbedObject = nullptr;
        grabbedRigidbody = nullptr;
        isHolding = false;
    }
};
```

### 2.3 压力板机关

```cpp
// pressure_plate.h
class PressurePlate : public Component {
private:
    std::vector<GameObject*> triggerObjects;  // 在压力板上的物体
    bool isActivated = false;
    float requiredWeight = 50.0f;  // 需要的总重量

public:
    std::function<void()> onActivated;
    std::function<void()> onDeactivated;

    PressurePlate(GameObject* go) : Component(go) {}

    void start() override {
        // 添加触发器碰撞体
        BoxCollider* collider = gameObject->addComponent<BoxCollider>();
        collider->setIsTrigger(true);
        collider->setSize(glm::vec3(2.0f, 0.2f, 2.0f));

        // 注册碰撞回调
        collider->onTriggerEnter = [this](GameObject* other) {
            onTriggerEnter(other);
        };

        collider->onTriggerExit = [this](GameObject* other) {
            onTriggerExit(other);
        };
    }

    void onTriggerEnter(GameObject* other) {
        triggerObjects.push_back(other);
        checkActivation();
    }

    void onTriggerExit(GameObject* other) {
        auto it = std::find(triggerObjects.begin(), triggerObjects.end(), other);
        if (it != triggerObjects.end()) {
            triggerObjects.erase(it);
        }
        checkActivation();
    }

    void checkActivation() {
        float totalWeight = 0.0f;

        for (auto obj : triggerObjects) {
            Rigidbody* rb = obj->getComponent<Rigidbody>();
            if (rb) {
                totalWeight += rb->getMass();
            }
        }

        bool shouldBeActivated = totalWeight >= requiredWeight;

        if (shouldBeActivated && !isActivated) {
            activate();
        } else if (!shouldBeActivated && isActivated) {
            deactivate();
        }
    }

    void activate() {
        isActivated = true;

        // 视觉反馈：改变材质颜色
        MeshRenderer* renderer = gameObject->getComponent<MeshRenderer>();
        if (renderer) {
            renderer->getMaterial()->setColor(glm::vec4(0.0f, 1.0f, 0.0f, 1.0f));
        }

        // 播放音效
        AudioEngine::getInstance().playSound("plate_activate",
            gameObject->getTransform()->getPosition());

        if (onActivated) {
            onActivated();
        }
    }

    void deactivate() {
        isActivated = false;

        MeshRenderer* renderer = gameObject->getComponent<MeshRenderer>();
        if (renderer) {
            renderer->getMaterial()->setColor(glm::vec4(0.5f, 0.5f, 0.5f, 1.0f));
        }

        AudioEngine::getInstance().playSound("plate_deactivate",
            gameObject->getTransform()->getPosition());

        if (onDeactivated) {
            onDeactivated();
        }
    }

    bool getIsActivated() const { return isActivated; }
    void setRequiredWeight(float weight) { requiredWeight = weight; }
};
```

### 2.4 门控系统

```cpp
// door.h
class Door : public Component {
public:
    enum DoorState {
        CLOSED,
        OPENING,
        OPEN,
        CLOSING
    };

private:
    DoorState state = CLOSED;

    glm::vec3 closedPosition;
    glm::vec3 openPosition;
    float openSpeed = 2.0f;
    float currentTime = 0.0f;

    bool requiresKey = false;
    std::string requiredKeyID;

public:
    Door(GameObject* go) : Component(go) {}

    void start() override {
        closedPosition = gameObject->getTransform()->getPosition();
        openPosition = closedPosition + glm::vec3(0.0f, 3.0f, 0.0f);  // 向上移动
    }

    void update(float deltaTime) override {
        switch (state) {
            case OPENING:
                currentTime += deltaTime * openSpeed;
                if (currentTime >= 1.0f) {
                    currentTime = 1.0f;
                    state = OPEN;
                }
                updatePosition();
                break;

            case CLOSING:
                currentTime -= deltaTime * openSpeed;
                if (currentTime <= 0.0f) {
                    currentTime = 0.0f;
                    state = CLOSED;
                }
                updatePosition();
                break;
        }
    }

    void open() {
        if (state == CLOSED || state == CLOSING) {
            state = OPENING;
            AudioEngine::getInstance().playSound("door_open",
                gameObject->getTransform()->getPosition());
        }
    }

    void close() {
        if (state == OPEN || state == OPENING) {
            state = CLOSING;
            AudioEngine::getInstance().playSound("door_close",
                gameObject->getTransform()->getPosition());
        }
    }

    void toggle() {
        if (state == CLOSED || state == CLOSING) {
            open();
        } else {
            close();
        }
    }

    void updatePosition() {
        glm::vec3 newPos = glm::mix(closedPosition, openPosition, currentTime);
        gameObject->getTransform()->setPosition(newPos);
    }

    bool canOpen(GameObject* actor) {
        if (!requiresKey) return true;

        Inventory* inventory = actor->getComponent<Inventory>();
        if (inventory) {
            return inventory->hasItem(requiredKeyID);
        }

        return false;
    }

    DoorState getState() const { return state; }
    void setRequiresKey(bool requires, const std::string& keyID = "") {
        requiresKey = requires;
        requiredKeyID = keyID;
    }
};
```

---

## 三、平台跳跃游戏

### 3.1 2.5D角色控制器

```cpp
// platformer_controller.h
class PlatformerController : public Component {
private:
    Rigidbody* rigidbody;
    Animator* animator;

    float moveSpeed = 8.0f;
    float jumpForce = 12.0f;
    float gravity = -25.0f;
    float maxFallSpeed = -20.0f;

    bool isGrounded = false;
    bool isFacingRight = true;

    float coyoteTime = 0.15f;  // 土狼时间
    float coyoteTimeCounter = 0.0f;

    float jumpBufferTime = 0.2f;  // 跳跃缓冲
    float jumpBufferCounter = 0.0f;

    int maxAirJumps = 1;
    int currentAirJumps = 0;

public:
    PlatformerController(GameObject* go) : Component(go) {}

    void start() override {
        rigidbody = gameObject->getComponent<Rigidbody>();
        animator = gameObject->getComponent<Animator>();
    }

    void update(float deltaTime) override {
        float horizontalInput = 0.0f;
        if (Input::getKey(GLFW_KEY_A)) horizontalInput = -1.0f;
        if (Input::getKey(GLFW_KEY_D)) horizontalInput = 1.0f;

        // 检查接地
        checkGrounded();

        // 土狼时间
        if (isGrounded) {
            coyoteTimeCounter = coyoteTime;
            currentAirJumps = maxAirJumps;  // 重置空中跳跃次数
        } else {
            coyoteTimeCounter -= deltaTime;
        }

        // 跳跃缓冲
        if (Input::getKeyDown(GLFW_KEY_SPACE)) {
            jumpBufferCounter = jumpBufferTime;
        } else {
            jumpBufferCounter -= deltaTime;
        }

        // 跳跃逻辑
        if (jumpBufferCounter > 0.0f) {
            if (coyoteTimeCounter > 0.0f) {
                // 正常跳跃
                jump();
                jumpBufferCounter = 0.0f;
            } else if (currentAirJumps > 0) {
                // 二段跳
                jump();
                currentAirJumps--;
                jumpBufferCounter = 0.0f;
            }
        }

        // 可变跳跃高度（松开跳跃键提前结束上升）
        if (Input::getKeyUp(GLFW_KEY_SPACE) && rigidbody->getVelocity().y > 0.0f) {
            glm::vec3 vel = rigidbody->getVelocity();
            vel.y *= 0.5f;
            rigidbody->setVelocity(vel);
        }

        // 水平移动
        glm::vec3 velocity = rigidbody->getVelocity();
        velocity.x = horizontalInput * moveSpeed;

        // 限制下落速度
        if (velocity.y < maxFallSpeed) {
            velocity.y = maxFallSpeed;
        }

        rigidbody->setVelocity(velocity);

        // 翻转角色朝向
        if (horizontalInput > 0 && !isFacingRight) {
            flip();
        } else if (horizontalInput < 0 && isFacingRight) {
            flip();
        }

        // 更新动画
        updateAnimations(horizontalInput);
    }

    void jump() {
        glm::vec3 vel = rigidbody->getVelocity();
        vel.y = jumpForce;
        rigidbody->setVelocity(vel);

        AudioEngine::getInstance().playSound("jump",
            gameObject->getTransform()->getPosition());
    }

    void checkGrounded() {
        glm::vec3 origin = gameObject->getTransform()->getPosition();
        glm::vec3 direction = glm::vec3(0.0f, -1.0f, 0.0f);
        glm::vec3 hitPoint;

        isGrounded = PhysicsWorld::getInstance().raycast(
            origin,
            origin + direction * 0.6f,
            hitPoint
        );
    }

    void flip() {
        isFacingRight = !isFacingRight;

        glm::vec3 scale = gameObject->getTransform()->getScale();
        scale.x *= -1.0f;
        gameObject->getTransform()->setScale(scale);
    }

    void updateAnimations(float horizontalInput) {
        if (!animator) return;

        if (!isGrounded) {
            if (rigidbody->getVelocity().y > 0) {
                animator->play("Jump");
            } else {
                animator->play("Fall");
            }
        } else if (std::abs(horizontalInput) > 0.01f) {
            animator->play("Run");
        } else {
            animator->play("Idle");
        }
    }
};
```

### 3.2 关卡设计工具

```cpp
// level_editor.h
class LevelEditor {
public:
    enum EditorMode {
        SELECT,
        PLACE,
        MOVE,
        ROTATE,
        DELETE
    };

private:
    EditorMode currentMode = SELECT;
    GameObject* selectedObject = nullptr;

    // 预制体库
    std::map<std::string, GameObject*> prefabs;

    // 关卡数据
    std::vector<GameObject*> levelObjects;

    Camera* editorCamera;
    bool isPlaying = false;

public:
    LevelEditor() {
        // 加载预制体
        loadPrefabs();
    }

    void loadPrefabs() {
        // 平台
        GameObject* platformPrefab = new GameObject("Platform");
        platformPrefab->addComponent<MeshRenderer>()->setMesh(ResourceManager::getMesh("cube"));
        prefabs["platform"] = platformPrefab;

        // 敌人
        GameObject* enemyPrefab = new GameObject("Enemy");
        enemyPrefab->addComponent<MeshRenderer>()->setMesh(ResourceManager::getMesh("sphere"));
        prefabs["enemy"] = enemyPrefab;

        // 可收集物
        GameObject* coinPrefab = new GameObject("Coin");
        coinPrefab->addComponent<MeshRenderer>()->setMesh(ResourceManager::getMesh("coin"));
        prefabs["coin"] = coinPrefab;
    }

    void update(float deltaTime) {
        if (isPlaying) {
            // 游戏模式：更新所有对象
            for (auto obj : levelObjects) {
                obj->update(deltaTime);
            }
        } else {
            // 编辑模式：处理编辑器输入
            handleEditorInput();
        }
    }

    void handleEditorInput() {
        // 模式切换
        if (Input::getKeyDown(GLFW_KEY_1)) currentMode = SELECT;
        if (Input::getKeyDown(GLFW_KEY_2)) currentMode = PLACE;
        if (Input::getKeyDown(GLFW_KEY_3)) currentMode = MOVE;
        if (Input::getKeyDown(GLFW_KEY_4)) currentMode = ROTATE;
        if (Input::getKeyDown(GLFW_KEY_5)) currentMode = DELETE;

        switch (currentMode) {
            case SELECT:
                handleSelectMode();
                break;
            case PLACE:
                handlePlaceMode();
                break;
            case MOVE:
                handleMoveMode();
                break;
            case ROTATE:
                handleRotateMode();
                break;
            case DELETE:
                handleDeleteMode();
                break;
        }

        // 播放/停止
        if (Input::getKeyDown(GLFW_KEY_SPACE)) {
            togglePlayMode();
        }

        // 保存关卡
        if (Input::getKey(GLFW_KEY_LEFT_CONTROL) && Input::getKeyDown(GLFW_KEY_S)) {
            saveLevel("level.json");
        }

        // 加载关卡
        if (Input::getKey(GLFW_KEY_LEFT_CONTROL) && Input::getKeyDown(GLFW_KEY_O)) {
            loadLevel("level.json");
        }
    }

    void handleSelectMode() {
        if (Input::getMouseButtonDown(0)) {
            // 射线检测选择物体
            glm::vec3 rayOrigin = editorCamera->getGameObject()->getTransform()->getPosition();
            glm::vec3 rayDirection = editorCamera->screenPointToRay(Input::getMousePosition());

            glm::vec3 hitPoint;
            GameObject* hitObject = raycastObjects(rayOrigin, rayDirection, hitPoint);

            if (hitObject) {
                selectedObject = hitObject;
                std::cout << "Selected: " << hitObject->getName() << std::endl;
            } else {
                selectedObject = nullptr;
            }
        }
    }

    void handlePlaceMode() {
        // 显示预览
        if (Input::getMouseButtonDown(0)) {
            // 获取鼠标在世界空间的位置
            glm::vec3 worldPos = getMouseWorldPosition();

            // 实例化预制体
            GameObject* newObj = instantiatePrefab("platform", worldPos);
            levelObjects.push_back(newObj);
        }
    }

    void handleMoveMode() {
        if (selectedObject && Input::getMouseButton(0)) {
            glm::vec3 worldPos = getMouseWorldPosition();
            selectedObject->getTransform()->setPosition(worldPos);
        }
    }

    void handleRotateMode() {
        if (selectedObject) {
            if (Input::getKey(GLFW_KEY_Q)) {
                glm::quat rotation = selectedObject->getTransform()->getRotation();
                rotation = glm::rotate(rotation, glm::radians(90.0f) * Time::deltaTime, glm::vec3(0, 1, 0));
                selectedObject->getTransform()->setRotation(rotation);
            }
        }
    }

    void handleDeleteMode() {
        if (selectedObject && Input::getMouseButtonDown(0)) {
            deleteObject(selectedObject);
            selectedObject = nullptr;
        }
    }

    void togglePlayMode() {
        isPlaying = !isPlaying;

        if (isPlaying) {
            // 保存当前状态
            saveTemporaryState();
            std::cout << "Play Mode" << std::endl;
        } else {
            // 恢复状态
            loadTemporaryState();
            std::cout << "Edit Mode" << std::endl;
        }
    }

    void saveLevel(const std::string& filename) {
        json levelJson;
        levelJson["levelName"] = "My Level";

        json objectsJson = json::array();
        for (auto obj : levelObjects) {
            objectsJson.push_back(serializeGameObject(obj));
        }
        levelJson["objects"] = objectsJson;

        std::ofstream file(filename);
        file << levelJson.dump(4);
        file.close();

        std::cout << "Level saved to " << filename << std::endl;
    }

    void loadLevel(const std::string& filename) {
        std::ifstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Failed to open level file: " << filename << std::endl;
            return;
        }

        json levelJson;
        file >> levelJson;
        file.close();

        // 清除现有对象
        clearLevel();

        // 加载对象
        for (auto& objJson : levelJson["objects"]) {
            GameObject* obj = deserializeGameObject(objJson);
            levelObjects.push_back(obj);
        }

        std::cout << "Level loaded from " << filename << std::endl;
    }

    void clearLevel() {
        for (auto obj : levelObjects) {
            delete obj;
        }
        levelObjects.clear();
        selectedObject = nullptr;
    }

    GameObject* raycastObjects(const glm::vec3& origin, const glm::vec3& direction, glm::vec3& hitPoint) {
        // 简化版本：检测AABB碰撞
        float closestDistance = FLT_MAX;
        GameObject* hitObject = nullptr;

        for (auto obj : levelObjects) {
            MeshRenderer* renderer = obj->getComponent<MeshRenderer>();
            if (renderer) {
                AABB bounds = renderer->getMesh()->getBounds();
                // 变换到世界空间
                // ... 射线-AABB相交测试
            }
        }

        return hitObject;
    }

    glm::vec3 getMouseWorldPosition() {
        glm::vec2 mousePos = Input::getMousePosition();
        // 转换到世界空间（假设Y=0平面）
        glm::vec3 rayOrigin = editorCamera->getGameObject()->getTransform()->getPosition();
        glm::vec3 rayDir = editorCamera->screenPointToRay(mousePos);

        // 与Y=0平面相交
        float t = -rayOrigin.y / rayDir.y;
        return rayOrigin + rayDir * t;
    }

    GameObject* instantiatePrefab(const std::string& prefabName, const glm::vec3& position) {
        auto it = prefabs.find(prefabName);
        if (it == prefabs.end()) return nullptr;

        // 克隆预制体
        GameObject* newObj = cloneGameObject(it->second);
        newObj->getTransform()->setPosition(position);
        return newObj;
    }

    void deleteObject(GameObject* obj) {
        auto it = std::find(levelObjects.begin(), levelObjects.end(), obj);
        if (it != levelObjects.end()) {
            levelObjects.erase(it);
            delete obj;
        }
    }

    void render() {
        // 渲染所有关卡对象
        for (auto obj : levelObjects) {
            MeshRenderer* renderer = obj->getComponent<MeshRenderer>();
            if (renderer) {
                renderer->render(editorCamera);
            }
        }

        // 渲染选中物体的轮廓
        if (selectedObject) {
            renderSelectionOutline(selectedObject);
        }

        // 渲染编辑器UI
        renderEditorUI();
    }

    void renderSelectionOutline(GameObject* obj) {
        MeshRenderer* renderer = obj->getComponent<MeshRenderer>();
        if (renderer) {
            AABB bounds = renderer->getMesh()->getBounds();
            Debug::drawBox(bounds, glm::vec4(1.0f, 1.0f, 0.0f, 1.0f));
        }
    }

    void renderEditorUI() {
        Font* font = ResourceManager::getFont("editor");

        // 模式指示器
        std::string modeText = "Mode: ";
        switch (currentMode) {
            case SELECT: modeText += "Select (1)"; break;
            case PLACE: modeText += "Place (2)"; break;
            case MOVE: modeText += "Move (3)"; break;
            case ROTATE: modeText += "Rotate (4)"; break;
            case DELETE: modeText += "Delete (5)"; break;
        }
        font->renderText(modeText, 10, 10, 1.0f, glm::vec3(1.0f), 1920, 1080);

        // 播放模式指示器
        std::string playText = isPlaying ? "PLAYING (Space to Stop)" : "EDITING (Space to Play)";
        font->renderText(playText, 10, 50, 1.0f,
                        isPlaying ? glm::vec3(0.0f, 1.0f, 0.0f) : glm::vec3(1.0f), 1920, 1080);

        // 选中物体信息
        if (selectedObject) {
            std::string objInfo = "Selected: " + selectedObject->getName();
            font->renderText(objInfo, 10, 90, 1.0f, glm::vec3(1.0f, 1.0f, 0.0f), 1920, 1080);
        }

        // 提示信息
        font->renderText("Ctrl+S: Save | Ctrl+O: Load", 10, 1050, 0.8f, glm::vec3(0.7f), 1920, 1080);
    }

    void saveTemporaryState() {
        // 保存临时状态用于Play模式
    }

    void loadTemporaryState() {
        // 恢复临时状态
    }

    json serializeGameObject(GameObject* obj) {
        json objJson;
        objJson["name"] = obj->getName();

        Transform* transform = obj->getTransform();
        objJson["position"] = {transform->getPosition().x, transform->getPosition().y, transform->getPosition().z};
        objJson["rotation"] = {transform->getRotation().x, transform->getRotation().y,
                               transform->getRotation().z, transform->getRotation().w};
        objJson["scale"] = {transform->getScale().x, transform->getScale().y, transform->getScale().z};

        return objJson;
    }

    GameObject* deserializeGameObject(const json& objJson) {
        GameObject* obj = new GameObject(objJson["name"]);

        Transform* transform = obj->getTransform();
        transform->setPosition(glm::vec3(objJson["position"][0], objJson["position"][1], objJson["position"][2]));
        transform->setRotation(glm::quat(objJson["rotation"][3], objJson["rotation"][0],
                                         objJson["rotation"][1], objJson["rotation"][2]));
        transform->setScale(glm::vec3(objJson["scale"][0], objJson["scale"][1], objJson["scale"][2]));

        return obj;
    }

    GameObject* cloneGameObject(GameObject* original) {
        // 简化版本：创建新对象并复制属性
        GameObject* clone = new GameObject(original->getName());
        // ... 复制组件
        return clone;
    }
};
```

### 3.3 收集物与检查点系统

```cpp
// collectible.h
class Collectible : public Component {
private:
    enum Type {
        COIN,
        GEM,
        POWER_UP,
        HEALTH
    };

    Type type;
    int value;
    bool isCollected = false;

    float rotationSpeed = 90.0f;
    float bobHeight = 0.2f;
    float bobSpeed = 2.0f;
    float bobTimer = 0.0f;

    glm::vec3 originalPosition;

public:
    Collectible(GameObject* go, Type t = COIN, int v = 1)
        : Component(go), type(t), value(v) {}

    void start() override {
        originalPosition = gameObject->getTransform()->getPosition();

        // 添加触发器
        BoxCollider* collider = gameObject->addComponent<BoxCollider>();
        collider->setIsTrigger(true);
        collider->setSize(glm::vec3(0.5f));

        collider->onTriggerEnter = [this](GameObject* other) {
            if (other->hasTag("Player")) {
                collect(other);
            }
        };
    }

    void update(float deltaTime) override {
        if (isCollected) return;

        // 旋转动画
        Transform* transform = gameObject->getTransform();
        glm::quat rotation = transform->getRotation();
        rotation = glm::rotate(rotation, glm::radians(rotationSpeed * deltaTime), glm::vec3(0, 1, 0));
        transform->setRotation(rotation);

        // 上下浮动动画
        bobTimer += deltaTime * bobSpeed;
        float bobOffset = std::sin(bobTimer) * bobHeight;
        transform->setPosition(originalPosition + glm::vec3(0, bobOffset, 0));
    }

    void collect(GameObject* collector) {
        if (isCollected) return;
        isCollected = true;

        // 给玩家添加分数/物品
        PlayerInventory* inventory = collector->getComponent<PlayerInventory>();
        if (inventory) {
            switch (type) {
                case COIN:
                    inventory->addCoins(value);
                    break;
                case GEM:
                    inventory->addGems(value);
                    break;
                case POWER_UP:
                    inventory->activatePowerUp(value);
                    break;
                case HEALTH:
                    Health* health = collector->getComponent<Health>();
                    if (health) health->heal(value);
                    break;
            }
        }

        // 播放收集音效
        AudioEngine::getInstance().playSound("collect", gameObject->getTransform()->getPosition());

        // 生成收集特效
        spawnCollectEffect();

        // 销毁物体
        gameObject->destroy();
    }

    void spawnCollectEffect() {
        GameObject* effectObj = new GameObject("CollectEffect");
        effectObj->getTransform()->setPosition(gameObject->getTransform()->getPosition());

        ParticleSystem* particles = effectObj->addComponent<ParticleSystem>();
        particles->setEmitRate(50.0f);
        particles->setLifetime(0.5f);
        particles->setStartColor(glm::vec4(1.0f, 1.0f, 0.0f, 1.0f));
        particles->setEndColor(glm::vec4(1.0f, 1.0f, 0.0f, 0.0f));

        effectObj->destroyAfter(1.0f);
    }
};

// checkpoint.h
class Checkpoint : public Component {
private:
    bool isActivated = false;
    glm::vec3 respawnPosition;
    glm::quat respawnRotation;

    GameObject* visualIndicator;

public:
    Checkpoint(GameObject* go) : Component(go) {}

    void start() override {
        respawnPosition = gameObject->getTransform()->getPosition();
        respawnRotation = gameObject->getTransform()->getRotation();

        // 创建视觉指示器
        visualIndicator = new GameObject("CheckpointIndicator");
        visualIndicator->setParent(gameObject);
        visualIndicator->getTransform()->setPosition(glm::vec3(0, 1, 0));

        MeshRenderer* renderer = visualIndicator->addComponent<MeshRenderer>();
        renderer->setMesh(ResourceManager::getMesh("flag"));
        renderer->setMaterial(ResourceManager::getMaterial(isActivated ? "checkpoint_active" : "checkpoint_inactive"));

        // 添加触发器
        BoxCollider* collider = gameObject->addComponent<BoxCollider>();
        collider->setIsTrigger(true);
        collider->setSize(glm::vec3(2.0f, 3.0f, 2.0f));

        collider->onTriggerEnter = [this](GameObject* other) {
            if (other->hasTag("Player") && !isActivated) {
                activate(other);
            }
        };
    }

    void activate(GameObject* player) {
        isActivated = true;

        // 更新材质
        MeshRenderer* renderer = visualIndicator->getComponent<MeshRenderer>();
        if (renderer) {
            renderer->setMaterial(ResourceManager::getMaterial("checkpoint_active"));
        }

        // 保存玩家状态
        PlayerController* controller = player->getComponent<PlayerController>();
        if (controller) {
            controller->setLastCheckpoint(this);
        }

        // 播放激活音效
        AudioEngine::getInstance().playSound("checkpoint", gameObject->getTransform()->getPosition());

        // 显示UI提示
        showActivationUI();

        std::cout << "Checkpoint activated!" << std::endl;
    }

    void respawnPlayer(GameObject* player) {
        player->getTransform()->setPosition(respawnPosition);
        player->getTransform()->setRotation(respawnRotation);

        // 重置玩家状态
        Health* health = player->getComponent<Health>();
        if (health) {
            health->heal(health->getMaxHealth());
        }

        Rigidbody* rb = player->getComponent<Rigidbody>();
        if (rb) {
            rb->setVelocity(glm::vec3(0.0f));
        }
    }

    void showActivationUI() {
        // 显示 "Checkpoint Activated!" 文字
        Font* font = ResourceManager::getFont("game");
        // ... UI显示逻辑
    }

    glm::vec3 getRespawnPosition() const { return respawnPosition; }
    bool getIsActivated() const { return isActivated; }
};
```

### 3.4 相机效果增强

```cpp
// camera_effects.h
class CameraEffects : public Component {
private:
    Camera* camera;

    // 相机抖动
    struct ScreenShake {
        float intensity = 0.0f;
        float duration = 0.0f;
        float timer = 0.0f;
        glm::vec3 originalPosition;
    } shake;

    // 相机跟随平滑
    float smoothSpeed = 10.0f;
    GameObject* followTarget = nullptr;
    glm::vec3 offset = glm::vec3(0, 0, 10);

public:
    CameraEffects(GameObject* go) : Component(go) {}

    void start() override {
        camera = gameObject->getComponent<Camera>();
    }

    void update(float deltaTime) override {
        // 更新相机抖动
        if (shake.timer > 0.0f) {
            shake.timer -= deltaTime;

            if (shake.timer <= 0.0f) {
                // 抖动结束，恢复原位
                gameObject->getTransform()->setPosition(shake.originalPosition);
                shake.intensity = 0.0f;
            } else {
                // 应用抖动
                float shakeAmount = shake.intensity * (shake.timer / shake.duration);
                glm::vec3 randomOffset = glm::vec3(
                    randomFloat(-1.0f, 1.0f),
                    randomFloat(-1.0f, 1.0f),
                    randomFloat(-1.0f, 1.0f)
                ) * shakeAmount;

                gameObject->getTransform()->setPosition(shake.originalPosition + randomOffset);
            }
        }

        // 平滑跟随目标
        if (followTarget) {
            glm::vec3 targetPosition = followTarget->getTransform()->getPosition() + offset;
            glm::vec3 currentPosition = gameObject->getTransform()->getPosition();

            glm::vec3 newPosition = glm::mix(currentPosition, targetPosition, smoothSpeed * deltaTime);
            gameObject->getTransform()->setPosition(newPosition);
        }
    }

    void startShake(float intensity, float duration) {
        shake.intensity = intensity;
        shake.duration = duration;
        shake.timer = duration;
        shake.originalPosition = gameObject->getTransform()->getPosition();
    }

    void setFollowTarget(GameObject* target) {
        followTarget = target;
    }

    void setOffset(const glm::vec3& newOffset) {
        offset = newOffset;
    }

private:
    float randomFloat(float min, float max) {
        return min + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX / (max - min)));
    }
};
```

---

## 四、性能优化实战

### 4.1 帧率分析与优化

#### 实时性能监控

```cpp
// performance_monitor.h
class PerformanceMonitor {
private:
    struct FrameData {
        float cpuTime;      // CPU时间（毫秒）
        float gpuTime;      // GPU时间（毫秒）
        int drawCalls;      // Draw Call数量
        int triangles;      // 三角形数量
        int textureBinds;   // 纹理绑定次数
        int stateChanges;   // 状态切换次数
    };

    std::deque<FrameData> frameHistory;
    size_t maxHistorySize = 120;  // 保存2秒数据（60fps）

    FrameData currentFrame;
    FPSCounter fpsCounter;
    GPUProfiler gpuProfiler;

public:
    void beginFrame() {
        currentFrame = FrameData{};
        fpsCounter.update(Time::deltaTime);
    }

    void endFrame() {
        frameHistory.push_back(currentFrame);
        if (frameHistory.size() > maxHistorySize) {
            frameHistory.pop_front();
        }
    }

    void recordDrawCall(int triangleCount) {
        currentFrame.drawCalls++;
        currentFrame.triangles += triangleCount;
    }

    void recordTextureBinding() {
        currentFrame.textureBinds++;
    }

    void recordStateChange() {
        currentFrame.stateChanges++;
    }

    void renderOverlay() {
        Font* font = ResourceManager::getFont("debug");

        // FPS信息
        char buffer[256];
        sprintf(buffer, "FPS: %.1f (%.2f ms)", fpsCounter.getFPS(), fpsCounter.getFrameTime());
        font->renderText(buffer, 10, 10, 1.0f, glm::vec3(0.0f, 1.0f, 0.0f), 1920, 1080);

        // CPU/GPU时间
        sprintf(buffer, "CPU: %.2f ms | GPU: %.2f ms",
                currentFrame.cpuTime, currentFrame.gpuTime);
        font->renderText(buffer, 10, 40, 1.0f, glm::vec3(1.0f, 1.0f, 0.0f), 1920, 1080);

        // Draw Call信息
        sprintf(buffer, "Draw Calls: %d | Triangles: %d",
                currentFrame.drawCalls, currentFrame.triangles);
        font->renderText(buffer, 10, 70, 1.0f, glm::vec3(1.0f, 0.5f, 0.0f), 1920, 1080);

        // 纹理与状态
        sprintf(buffer, "Texture Binds: %d | State Changes: %d",
                currentFrame.textureBinds, currentFrame.stateChanges);
        font->renderText(buffer, 10, 100, 1.0f, glm::vec3(0.5f, 1.0f, 1.0f), 1920, 1080);

        // 性能图表
        renderPerformanceGraph();
    }

    void renderPerformanceGraph() {
        // 绘制帧时间曲线图
        if (frameHistory.size() < 2) return;

        std::vector<glm::vec2> points;
        float maxTime = 33.33f;  // 30fps = 33.33ms

        for (size_t i = 0; i < frameHistory.size(); i++) {
            float x = 10.0f + (i / (float)maxHistorySize) * 400.0f;
            float y = 150.0f + (1.0f - frameHistory[i].cpuTime / maxTime) * 100.0f;
            points.push_back(glm::vec2(x, y));
        }

        // 使用LineRenderer绘制曲线
        for (size_t i = 1; i < points.size(); i++) {
            Debug::drawLine(glm::vec3(points[i-1], 0), glm::vec3(points[i], 0),
                           glm::vec4(0.0f, 1.0f, 0.0f, 1.0f));
        }
    }

    void printReport() {
        std::cout << "=== Performance Report ===" << std::endl;
        std::cout << "Average FPS: " << fpsCounter.getAverageFPS() << std::endl;
        std::cout << "Min FPS: " << fpsCounter.getMinFPS() << std::endl;
        std::cout << "Max FPS: " << fpsCounter.getMaxFPS() << std::endl;

        // 计算平均值
        if (!frameHistory.empty()) {
            float avgDrawCalls = 0.0f;
            float avgTriangles = 0.0f;

            for (const auto& frame : frameHistory) {
                avgDrawCalls += frame.drawCalls;
                avgTriangles += frame.triangles;
            }

            avgDrawCalls /= frameHistory.size();
            avgTriangles /= frameHistory.size();

            std::cout << "Average Draw Calls: " << avgDrawCalls << std::endl;
            std::cout << "Average Triangles: " << avgTriangles << std::endl;
        }
    }

    float getAverageCPUTime() const {
        if (frameHistory.empty()) return 0.0f;
        float sum = 0.0f;
        for (const auto& frame : frameHistory) sum += frame.cpuTime;
        return sum / frameHistory.size();
    }

    float getAverageGPUTime() const {
        if (frameHistory.empty()) return 0.0f;
        float sum = 0.0f;
        for (const auto& frame : frameHistory) sum += frame.gpuTime;
        return sum / frameHistory.size();
    }
};
```

### 4.2 渲染优化实战

#### DrawCall合批实战

```cpp
// 优化前：每个物体单独绘制
void Scene::render_Unoptimized(Camera* camera) {
    for (auto obj : gameObjects) {
        MeshRenderer* renderer = obj->getComponent<MeshRenderer>();
        if (renderer) {
            Shader* shader = renderer->getMaterial()->getShader();
            shader->use();
            shader->setMat4("model", obj->getTransform()->getWorldMatrix());
            shader->setMat4("view", camera->getViewMatrix());
            shader->setMat4("projection", camera->getProjectionMatrix());

            renderer->getMaterial()->apply();
            renderer->getMesh()->draw();  // DrawCall!
        }
    }
}
// 结果：1000个物体 = 1000个DrawCall

// 优化后：使用批渲染
void Scene::render_Optimized(Camera* camera) {
    batchRenderer.clear();

    // 收集所有渲染器
    for (auto obj : gameObjects) {
        MeshRenderer* renderer = obj->getComponent<MeshRenderer>();
        if (renderer) {
            batchRenderer.addRenderer(renderer);
        }
    }

    // 批量渲染
    batchRenderer.render(camera);
}
// 结果：1000个物体 = 10-20个DrawCall（根据材质和网格分组）
```

#### 视锥剔除实战

```cpp
// frustum_culling.h
class FrustumCuller {
private:
    struct Plane {
        glm::vec3 normal;
        float distance;

        float distanceToPoint(const glm::vec3& point) const {
            return glm::dot(normal, point) + distance;
        }
    };

    Plane frustumPlanes[6];  // Left, Right, Bottom, Top, Near, Far

public:
    void updateFrustum(const glm::mat4& viewProjection) {
        // 从视图投影矩阵提取平面
        glm::mat4 vp = glm::transpose(viewProjection);

        // Left
        frustumPlanes[0].normal = glm::vec3(vp[3] + vp[0]);
        frustumPlanes[0].distance = vp[3][3] + vp[0][3];

        // Right
        frustumPlanes[1].normal = glm::vec3(vp[3] - vp[0]);
        frustumPlanes[1].distance = vp[3][3] - vp[0][3];

        // Bottom
        frustumPlanes[2].normal = glm::vec3(vp[3] + vp[1]);
        frustumPlanes[2].distance = vp[3][3] + vp[1][3];

        // Top
        frustumPlanes[3].normal = glm::vec3(vp[3] - vp[1]);
        frustumPlanes[3].distance = vp[3][3] - vp[1][3];

        // Near
        frustumPlanes[4].normal = glm::vec3(vp[3] + vp[2]);
        frustumPlanes[4].distance = vp[3][3] + vp[2][3];

        // Far
        frustumPlanes[5].normal = glm::vec3(vp[3] - vp[2]);
        frustumPlanes[5].distance = vp[3][3] - vp[2][3];

        // 归一化所有平面
        for (int i = 0; i < 6; i++) {
            float length = glm::length(frustumPlanes[i].normal);
            frustumPlanes[i].normal /= length;
            frustumPlanes[i].distance /= length;
        }
    }

    bool isAABBVisible(const AABB& aabb) const {
        for (int i = 0; i < 6; i++) {
            // 获取正向顶点
            glm::vec3 positiveVertex = aabb.min;
            if (frustumPlanes[i].normal.x >= 0) positiveVertex.x = aabb.max.x;
            if (frustumPlanes[i].normal.y >= 0) positiveVertex.y = aabb.max.y;
            if (frustumPlanes[i].normal.z >= 0) positiveVertex.z = aabb.max.z;

            // 如果正向顶点在平面外侧，则整个AABB在外侧
            if (frustumPlanes[i].distanceToPoint(positiveVertex) < 0) {
                return false;
            }
        }
        return true;
    }

    bool isSphereVisible(const glm::vec3& center, float radius) const {
        for (int i = 0; i < 6; i++) {
            float distance = frustumPlanes[i].distanceToPoint(center);
            if (distance < -radius) {
                return false;
            }
        }
        return true;
    }
};

// 在Scene中应用
void Scene::renderWithCulling(Camera* camera) {
    FrustumCuller culler;
    glm::mat4 vp = camera->getProjectionMatrix() * camera->getViewMatrix();
    culler.updateFrustum(vp);

    int visibleCount = 0;
    int totalCount = 0;

    for (auto obj : gameObjects) {
        totalCount++;

        MeshRenderer* renderer = obj->getComponent<MeshRenderer>();
        if (!renderer) continue;

        // 获取世界空间AABB
        AABB worldAABB = renderer->getMesh()->getBounds();
        worldAABB.transform(obj->getTransform()->getWorldMatrix());

        // 视锥剔除
        if (culler.isAABBVisible(worldAABB)) {
            visibleCount++;
            renderer->render(camera);
        }
    }

    std::cout << "Visible: " << visibleCount << " / " << totalCount << std::endl;
}
```

### 4.3 内存优化实战

#### 对象池使用示例

```cpp
// 游戏中的子弹管理
class GameManager {
private:
    ObjectPool<Bullet> bulletPool;
    std::vector<Bullet*> activeBullets;

public:
    GameManager() : bulletPool(100) {}  // 预分配100个子弹

    void spawnBullet(const glm::vec3& position, const glm::vec3& direction) {
        Bullet* bullet = bulletPool.acquire();
        if (bullet) {
            bullet->initialize(position, direction);
            activeBullets.push_back(bullet);
        }
    }

    void update(float deltaTime) {
        for (auto it = activeBullets.begin(); it != activeBullets.end();) {
            Bullet* bullet = *it;
            bullet->update(deltaTime);

            if (bullet->shouldDestroy()) {
                bulletPool.release(bullet);
                it = activeBullets.erase(it);
            } else {
                ++it;
            }
        }

        // 打印池信息
        std::cout << "Active bullets: " << activeBullets.size()
                  << " / Pool capacity: " << bulletPool.getCapacity() << std::endl;
    }
};

// 对比：不使用对象池
class GameManager_Unoptimized {
private:
    std::vector<Bullet*> bullets;

public:
    void spawnBullet(const glm::vec3& position, const glm::vec3& direction) {
        Bullet* bullet = new Bullet();  // 动态分配！性能杀手！
        bullet->initialize(position, direction);
        bullets.push_back(bullet);
    }

    void update(float deltaTime) {
        for (auto it = bullets.begin(); it != bullets.end();) {
            Bullet* bullet = *it;
            bullet->update(deltaTime);

            if (bullet->shouldDestroy()) {
                delete bullet;  // 动态释放！内存碎片！
                it = bullets.erase(it);
            } else {
                ++it;
            }
        }
    }
};

// 性能对比（每秒生成100个子弹，每个子弹存活3秒）：
// 不使用对象池：大量new/delete操作，内存碎片化，性能下降20-30%
// 使用对象池：几乎无动态分配，性能提升显著，内存稳定
```

---

## 五、引擎调试技巧

### 5.1 可视化调试系统

```cpp
// 使用Debug绘制类进行可视化调试

void PlayerController::update(float deltaTime) {
    // 1. 调试玩家前方向
    glm::vec3 position = transform->getPosition();
    glm::vec3 forward = transform->forward();
    Debug::drawRay(position, forward, 5.0f);  // 绘制5单位长的射线

    // 2. 调试碰撞体
    BoxCollider* collider = getComponent<BoxCollider>();
    if (collider) {
        AABB bounds = collider->getBounds();
        Debug::drawBox(bounds, glm::vec4(0.0f, 1.0f, 0.0f, 1.0f));  // 绿色包围盒
    }

    // 3. 调试射线检测
    glm::vec3 rayStart = position + glm::vec3(0, 1, 0);
    glm::vec3 rayEnd = rayStart + forward * 10.0f;
    glm::vec3 hitPoint;

    bool hit = PhysicsWorld::getInstance().raycast(rayStart, rayEnd, hitPoint);
    if (hit) {
        // 绘制射线到击中点（红色）
        Debug::drawLine(rayStart, hitPoint, glm::vec4(1.0f, 0.0f, 0.0f, 1.0f));
        // 绘制击中点标记
        Debug::drawSphere(hitPoint, 0.2f, glm::vec4(1.0f, 0.0f, 0.0f, 1.0f));
    } else {
        // 绘制完整射线（黄色）
        Debug::drawLine(rayStart, rayEnd, glm::vec4(1.0f, 1.0f, 0.0f, 1.0f));
    }
}

void AIController::update(float deltaTime) {
    // 调试AI视野
    glm::vec3 eyePos = transform->getPosition() + glm::vec3(0, 1.5f, 0);
    glm::vec3 forward = transform->forward();

    // 绘制视野锥体
    float viewDistance = 15.0f;
    float viewAngle = 60.0f;  // 度

    glm::vec3 leftEdge = glm::rotate(forward, glm::radians(-viewAngle/2), glm::vec3(0, 1, 0));
    glm::vec3 rightEdge = glm::rotate(forward, glm::radians(viewAngle/2), glm::vec3(0, 1, 0));

    Debug::drawRay(eyePos, leftEdge, viewDistance);
    Debug::drawRay(eyePos, rightEdge, viewDistance);
    Debug::drawLine(eyePos + leftEdge * viewDistance,
                   eyePos + rightEdge * viewDistance,
                   glm::vec4(1.0f, 0.5f, 0.0f, 1.0f));

    // 如果检测到玩家，绘制到玩家的连线
    if (canSeePlayer) {
        Debug::drawLine(eyePos, playerPosition, glm::vec4(1.0f, 0.0f, 0.0f, 1.0f), 0.1f);
    }
}
```

### 5.2 日志系统应用

```cpp
// 分级日志使用示例

class ResourceManager {
public:
    static Texture* loadTexture(const std::string& path) {
        LOG_INFO("Loading texture: ", path);

        if (!std::filesystem::exists(path)) {
            LOG_ERROR("Texture file not found: ", path);
            return nullptr;
        }

        Texture* texture = new Texture();
        bool success = texture->loadFromFile(path);

        if (!success) {
            LOG_ERROR("Failed to decode texture: ", path);
            delete texture;
            return nullptr;
        }

        LOG_INFO("Texture loaded successfully: ", path,
                 " (", texture->getWidth(), "x", texture->getHeight(), ")");

        return texture;
    }

    static Mesh* loadMesh(const std::string& path) {
        LOG_DEBUG("Attempting to load mesh: ", path);

        Assimp::Importer importer;
        const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);

        if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
            LOG_ERROR("Assimp error: ", importer.GetErrorString());
            return nullptr;
        }

        LOG_DEBUG("Scene loaded, processing ", scene->mNumMeshes, " meshes");

        Mesh* mesh = processMesh(scene->mMeshes[0], scene);

        LOG_INFO("Mesh loaded: ", path,
                 " (", mesh->getVertexCount(), " vertices, ",
                 mesh->getIndexCount() / 3, " triangles)");

        return mesh;
    }
};

// 物理系统调试
class PhysicsWorld {
public:
    void stepSimulation(float deltaTime) {
        LOG_TRACE("PhysicsWorld::stepSimulation(", deltaTime, ")");

        int numCollisions = checkCollisions();

        if (numCollisions > 0) {
            LOG_DEBUG("Detected ", numCollisions, " collisions this frame");
        }

        dynamicsWorld->stepSimulation(deltaTime, 10);
    }

    void addRigidBody(btRigidBody* body) {
        if (!body) {
            LOG_WARNING("Attempted to add null rigidbody to physics world");
            return;
        }

        dynamicsWorld->addRigidBody(body);
        LOG_DEBUG("Added rigidbody to physics world (mass: ", body->getMass(), ")");
    }
};

// 游戏逻辑调试
class Player : public Component {
public:
    void takeDamage(float amount) {
        LOG_INFO("Player taking damage: ", amount);

        health -= amount;

        if (health <= 0) {
            LOG_WARNING("Player health reached zero!");
            die();
        } else {
            LOG_DEBUG("Player health: ", health, " / ", maxHealth);
        }
    }

    void collectItem(Item* item) {
        LOG_INFO("Player collected item: ", item->getName());

        inventory.addItem(item);

        LOG_DEBUG("Inventory size: ", inventory.getItemCount(), " / ", inventory.getMaxSize());
    }
};
```

### 5.3 性能瓶颈定位

```cpp
// 使用Profiler定位性能瓶颈

void Scene::update(float deltaTime) {
    PROFILE_FUNCTION();

    {
        PROFILE_SCOPE("Physics Update");
        physicsWorld->stepSimulation(deltaTime);
        // 如果这个区域耗时过长，说明物理计算是瓶颈
    }

    {
        PROFILE_SCOPE("GameObject Updates");
        for (auto obj : gameObjects) {
            PROFILE_SCOPE("Single GameObject");
            obj->update(deltaTime);
        }
        // 如果单个GameObject耗时过长，进一步细化
    }

    {
        PROFILE_SCOPE("Animation System");
        animationSystem->update(deltaTime);
    }

    {
        PROFILE_SCOPE("Particle Systems");
        for (auto ps : particleSystems) {
            ps->update(deltaTime);
        }
    }

    {
        PROFILE_SCOPE("AI Updates");
        for (auto ai : aiControllers) {
            ai->update(deltaTime);
        }
    }
}

void Renderer::render(Scene* scene, Camera* camera) {
    PROFILE_FUNCTION();

    gpuProfiler.beginQuery("Shadow Pass");
    {
        PROFILE_SCOPE("CPU: Shadow Pass");
        renderShadows(scene);
    }
    gpuProfiler.endQuery("Shadow Pass");

    gpuProfiler.beginQuery("Geometry Pass");
    {
        PROFILE_SCOPE("CPU: Geometry Pass");
        renderGeometry(scene, camera);
    }
    gpuProfiler.endQuery("Geometry Pass");

    gpuProfiler.beginQuery("Lighting Pass");
    {
        PROFILE_SCOPE("CPU: Lighting Pass");
        renderLighting(scene, camera);
    }
    gpuProfiler.endQuery("Lighting Pass");

    // 每60帧输出一次报告
    static int frameCount = 0;
    if (++frameCount % 60 == 0) {
        Profiler::getInstance().printReport();
        gpuProfiler.collectResults();
        gpuProfiler.printResults();
    }
}

// 输出示例：
// === CPU Profiling Results ===
// Scene::update: 8.5 ms
//   ├─ Physics Update: 3.2 ms (38%)
//   ├─ GameObject Updates: 2.1 ms (25%)
//   ├─ Animation System: 1.8 ms (21%)
//   ├─ Particle Systems: 0.9 ms (11%)
//   └─ AI Updates: 0.5 ms (6%)
//
// Renderer::render: 12.3 ms
//   ├─ Shadow Pass: 4.1 ms (33%)
//   ├─ Geometry Pass: 5.2 ms (42%)
//   └─ Lighting Pass: 3.0 ms (24%)
//
// === GPU Profiling Results ===
// Shadow Pass: 2.3 ms
// Geometry Pass: 6.8 ms
// Lighting Pass: 4.1 ms
```

### 5.4 常见问题诊断

```cpp
// 问题1：内存泄漏检测
class MemoryLeakDetector {
private:
    struct Allocation {
        void* address;
        size_t size;
        std::string file;
        int line;
    };

    std::map<void*, Allocation> allocations;
    size_t totalAllocated = 0;

public:
    void* trackAllocation(size_t size, const char* file, int line) {
        void* ptr = malloc(size);

        Allocation alloc;
        alloc.address = ptr;
        alloc.size = size;
        alloc.file = file;
        alloc.line = line;

        allocations[ptr] = alloc;
        totalAllocated += size;

        return ptr;
    }

    void trackDeallocation(void* ptr) {
        auto it = allocations.find(ptr);
        if (it != allocations.end()) {
            totalAllocated -= it->second.size;
            allocations.erase(it);
        }
        free(ptr);
    }

    void printLeaks() {
        if (allocations.empty()) {
            std::cout << "No memory leaks detected!" << std::endl;
            return;
        }

        std::cout << "=== MEMORY LEAKS DETECTED ===" << std::endl;
        std::cout << "Total leaked: " << totalAllocated << " bytes" << std::endl;

        for (const auto& pair : allocations) {
            const Allocation& alloc = pair.second;
            std::cout << "Leak: " << alloc.size << " bytes at "
                      << alloc.file << ":" << alloc.line << std::endl;
        }
    }
};

// 问题2：无限循环检测
class InfiniteLoopDetector {
private:
    std::chrono::time_point<std::chrono::high_resolution_clock> loopStartTime;
    float maxLoopTime = 5.0f;  // 5秒超时

public:
    void beginLoop() {
        loopStartTime = std::chrono::high_resolution_clock::now();
    }

    void checkLoop(const std::string& location) {
        auto now = std::chrono::high_resolution_clock::now();
        float elapsed = std::chrono::duration<float>(now - loopStartTime).count();

        if (elapsed > maxLoopTime) {
            LOG_FATAL("Infinite loop detected at: ", location,
                     " (running for ", elapsed, " seconds)");
            // 触发断点或终止程序
            __debugbreak();
        }
    }
};

// 问题3：悬空指针检测
template<typename T>
class SafePointer {
private:
    T* ptr;
    bool valid;

public:
    SafePointer(T* p = nullptr) : ptr(p), valid(p != nullptr) {}

    T* operator->() {
        if (!valid) {
            LOG_ERROR("Attempted to dereference invalid pointer!");
            return nullptr;
        }
        return ptr;
    }

    T& operator*() {
        if (!valid) {
            LOG_ERROR("Attempted to dereference invalid pointer!");
            throw std::runtime_error("Invalid pointer access");
        }
        return *ptr;
    }

    void invalidate() {
        valid = false;
        ptr = nullptr;
    }

    bool isValid() const { return valid; }
};
```

---

**总结**：本实战项目篇提供了完整的游戏实现案例，包括：

1. **第三人称射击游戏（TPS）**：角色控制、相机、武器、敌人AI、血量系统
2. **物理解谜游戏**：物体抓取、压力板、门控系统
3. **平台跳跃游戏**：精确手感、关卡编辑器、收集物、检查点
4. **性能优化实战**：实时监控、DrawCall合批、视锥剔除、对象池应用
5. **引擎调试技巧**：可视化调试、日志系统、性能瓶颈定位、常见问题诊断

配合其他文档使用，可以构建完整的商业级游戏！
