# C++游戏引擎开发 - 性能优化与最佳实践

> 本文档涵盖引擎性能优化技术、调试方法、最佳实践和常见陷阱。

---

## 目录
- [一、性能分析与优化](#一性能分析与优化)
- [二、内存管理](#二内存管理)
- [三、渲染优化](#三渲染优化)
- [四、多线程优化](#四多线程优化)
- [五、调试技巧](#五调试技巧)
- [六、最佳实践](#六最佳实践)

---

## 一、性能分析与优化

### 1.1 性能分析工具集成

#### CPU性能分析 - Chrome Tracing

```cpp
// profiler.h
#include <fstream>
#include <chrono>
#include <thread>
#include <mutex>

class Profiler {
public:
    struct ProfileResult {
        std::string name;
        long long start;
        long long end;
        uint32_t threadID;
    };

private:
    std::string sessionName;
    std::ofstream outputStream;
    std::mutex mutex;
    std::vector<ProfileResult> results;
    bool isActive = false;

public:
    static Profiler& getInstance() {
        static Profiler instance;
        return instance;
    }

    void beginSession(const std::string& name, const std::string& filepath = "profile.json") {
        std::lock_guard<std::mutex> lock(mutex);

        if (isActive) {
            endSession();
        }

        outputStream.open(filepath);
        sessionName = name;
        isActive = true;

        writeHeader();
    }

    void endSession() {
        std::lock_guard<std::mutex> lock(mutex);

        if (!isActive) return;

        writeFooter();
        outputStream.close();
        isActive = false;
        results.clear();
    }

    void writeProfile(const ProfileResult& result) {
        std::lock_guard<std::mutex> lock(mutex);

        if (!isActive) return;

        if (!results.empty()) {
            outputStream << ",";
        }

        outputStream << "{";
        outputStream << "\"cat\":\"function\",";
        outputStream << "\"dur\":" << (result.end - result.start) << ',';
        outputStream << "\"name\":\"" << result.name << "\",";
        outputStream << "\"ph\":\"X\",";
        outputStream << "\"pid\":0,";
        outputStream << "\"tid\":" << result.threadID << ",";
        outputStream << "\"ts\":" << result.start;
        outputStream << "}";

        outputStream.flush();
    }

private:
    void writeHeader() {
        outputStream << "{\"otherData\": {},\"traceEvents\":[";
        outputStream.flush();
    }

    void writeFooter() {
        outputStream << "]}";
        outputStream.flush();
    }
};

// RAII计时器
class ProfileTimer {
private:
    std::string name;
    std::chrono::time_point<std::chrono::high_resolution_clock> startTimepoint;
    bool stopped;

public:
    ProfileTimer(const std::string& name) : name(name), stopped(false) {
        startTimepoint = std::chrono::high_resolution_clock::now();
    }

    ~ProfileTimer() {
        if (!stopped) {
            stop();
        }
    }

    void stop() {
        auto endTimepoint = std::chrono::high_resolution_clock::now();

        long long start = std::chrono::time_point_cast<std::chrono::microseconds>(startTimepoint)
            .time_since_epoch().count();
        long long end = std::chrono::time_point_cast<std::chrono::microseconds>(endTimepoint)
            .time_since_epoch().count();

        uint32_t threadID = std::hash<std::thread::id>{}(std::this_thread::get_id());

        Profiler::getInstance().writeProfile({ name, start, end, threadID });

        stopped = true;
    }
};

// 宏定义方便使用
#ifdef ENABLE_PROFILING
    #define PROFILE_SCOPE(name) ProfileTimer timer##__LINE__(name)
    #define PROFILE_FUNCTION() PROFILE_SCOPE(__FUNCTION__)
#else
    #define PROFILE_SCOPE(name)
    #define PROFILE_FUNCTION()
#endif
```

#### 使用示例

```cpp
void Scene::update(float deltaTime) {
    PROFILE_FUNCTION();

    {
        PROFILE_SCOPE("Update Physics");
        physicsWorld->stepSimulation(deltaTime);
    }

    {
        PROFILE_SCOPE("Update GameObjects");
        for (auto& obj : gameObjects) {
            obj->update(deltaTime);
        }
    }

    {
        PROFILE_SCOPE("Update Animations");
        animationSystem->update(deltaTime);
    }
}

// 主函数中
int main() {
    Profiler::getInstance().beginSession("GameSession", "profile.json");

    // 游戏循环
    while (running) {
        PROFILE_SCOPE("Frame");
        update(deltaTime);
        render();
    }

    Profiler::getInstance().endSession();
}
```

### 1.2 GPU性能分析

#### OpenGL查询对象

```cpp
// gpu_profiler.h
class GPUProfiler {
private:
    struct Query {
        std::string name;
        GLuint queryID;
        bool isActive;
    };

    std::unordered_map<std::string, Query> queries;
    std::unordered_map<std::string, double> results;  // 毫秒

public:
    void initialize(const std::vector<std::string>& queryNames) {
        for (const auto& name : queryNames) {
            Query query;
            query.name = name;
            glGenQueries(1, &query.queryID);
            query.isActive = false;
            queries[name] = query;
        }
    }

    void beginQuery(const std::string& name) {
        auto& query = queries[name];
        glBeginQuery(GL_TIME_ELAPSED, query.queryID);
        query.isActive = true;
    }

    void endQuery(const std::string& name) {
        auto& query = queries[name];
        if (query.isActive) {
            glEndQuery(GL_TIME_ELAPSED);
            query.isActive = false;
        }
    }

    void collectResults() {
        for (auto& pair : queries) {
            GLuint64 elapsed;
            glGetQueryObjectui64v(pair.second.queryID, GL_QUERY_RESULT, &elapsed);
            results[pair.first] = elapsed / 1000000.0;  // 转换为毫秒
        }
    }

    void printResults() {
        std::cout << "=== GPU Profiling Results ===" << std::endl;
        for (const auto& pair : results) {
            std::cout << pair.first << ": " << pair.second << " ms" << std::endl;
        }
    }

    double getResult(const std::string& name) const {
        auto it = results.find(name);
        return (it != results.end()) ? it->second : 0.0;
    }

    ~GPUProfiler() {
        for (auto& pair : queries) {
            glDeleteQueries(1, &pair.second.queryID);
        }
    }
};

// 使用示例
void Renderer::render(Scene* scene, Camera* camera) {
    gpuProfiler.beginQuery("Shadow Pass");
    renderShadows(scene);
    gpuProfiler.endQuery("Shadow Pass");

    gpuProfiler.beginQuery("Geometry Pass");
    renderGeometry(scene, camera);
    gpuProfiler.endQuery("Geometry Pass");

    gpuProfiler.beginQuery("Lighting Pass");
    renderLighting(scene, camera);
    gpuProfiler.endQuery("Lighting Pass");

    gpuProfiler.beginQuery("Post Processing");
    renderPostProcessing();
    gpuProfiler.endQuery("Post Processing");

    // 每隔一段时间收集结果
    static int frameCount = 0;
    if (++frameCount % 60 == 0) {
        gpuProfiler.collectResults();
        gpuProfiler.printResults();
    }
}
```

### 1.3 帧率统计

```cpp
// fps_counter.h
class FPSCounter {
private:
    float fps = 0.0f;
    float frameTime = 0.0f;
    int frameCount = 0;
    float accumTime = 0.0f;
    float updateInterval = 0.5f;  // 每0.5秒更新一次

    // 历史记录
    std::deque<float> fpsHistory;
    std::deque<float> frameTimeHistory;
    size_t maxHistorySize = 120;  // 保存2秒的数据（假设60fps）

public:
    void update(float deltaTime) {
        frameCount++;
        accumTime += deltaTime;

        if (accumTime >= updateInterval) {
            fps = frameCount / accumTime;
            frameTime = (accumTime / frameCount) * 1000.0f;  // 毫秒

            // 更新历史
            fpsHistory.push_back(fps);
            frameTimeHistory.push_back(frameTime);

            if (fpsHistory.size() > maxHistorySize) {
                fpsHistory.pop_front();
                frameTimeHistory.pop_front();
            }

            frameCount = 0;
            accumTime = 0.0f;
        }
    }

    float getFPS() const { return fps; }
    float getFrameTime() const { return frameTime; }

    float getAverageFPS() const {
        if (fpsHistory.empty()) return 0.0f;
        float sum = 0.0f;
        for (float f : fpsHistory) sum += f;
        return sum / fpsHistory.size();
    }

    float getMinFPS() const {
        if (fpsHistory.empty()) return 0.0f;
        return *std::min_element(fpsHistory.begin(), fpsHistory.end());
    }

    float getMaxFPS() const {
        if (fpsHistory.empty()) return 0.0f;
        return *std::max_element(fpsHistory.begin(), fpsHistory.end());
    }

    void renderDebugOverlay() {
        Font* font = ResourceManager::getFont("debug");

        char buffer[256];
        sprintf(buffer, "FPS: %.1f (%.2f ms)", fps, frameTime);
        font->renderText(buffer, 10, 10, 1.0f, glm::vec3(0.0f, 1.0f, 0.0f), 1920, 1080);

        sprintf(buffer, "Avg: %.1f | Min: %.1f | Max: %.1f",
                getAverageFPS(), getMinFPS(), getMaxFPS());
        font->renderText(buffer, 10, 40, 1.0f, glm::vec3(1.0f, 1.0f, 0.0f), 1920, 1080);
    }
};
```

---

## 二、内存管理

### 2.1 对象池 (Object Pool)

```cpp
// object_pool.h
template<typename T>
class ObjectPool {
private:
    struct PoolChunk {
        T object;
        bool inUse;
    };

    std::vector<PoolChunk> pool;
    size_t capacity;
    size_t nextFreeIndex;

public:
    ObjectPool(size_t initialCapacity = 100) : capacity(initialCapacity), nextFreeIndex(0) {
        pool.resize(capacity);
        for (size_t i = 0; i < capacity; i++) {
            pool[i].inUse = false;
        }
    }

    T* acquire() {
        // 查找空闲对象
        for (size_t i = 0; i < capacity; i++) {
            size_t index = (nextFreeIndex + i) % capacity;
            if (!pool[index].inUse) {
                pool[index].inUse = true;
                nextFreeIndex = (index + 1) % capacity;
                return &pool[index].object;
            }
        }

        // 池已满，扩容
        expand();
        return acquire();
    }

    void release(T* obj) {
        for (size_t i = 0; i < pool.size(); i++) {
            if (&pool[i].object == obj) {
                pool[i].inUse = false;
                return;
            }
        }
    }

    void clear() {
        for (auto& chunk : pool) {
            chunk.inUse = false;
        }
        nextFreeIndex = 0;
    }

    size_t getActiveCount() const {
        size_t count = 0;
        for (const auto& chunk : pool) {
            if (chunk.inUse) count++;
        }
        return count;
    }

    size_t getCapacity() const { return capacity; }

private:
    void expand() {
        size_t oldCapacity = capacity;
        capacity *= 2;
        pool.resize(capacity);

        for (size_t i = oldCapacity; i < capacity; i++) {
            pool[i].inUse = false;
        }

        std::cout << "ObjectPool expanded to " << capacity << std::endl;
    }
};

// 使用示例
class BulletManager {
private:
    ObjectPool<Bullet> bulletPool;

public:
    BulletManager() : bulletPool(100) {}

    void spawnBullet(const glm::vec3& position, const glm::vec3& direction) {
        Bullet* bullet = bulletPool.acquire();
        bullet->initialize(position, direction);
    }

    void despawnBullet(Bullet* bullet) {
        bulletPool.release(bullet);
    }

    void update(float deltaTime) {
        // 更新所有活跃子弹
        // ...
    }
};
```

### 2.2 内存分配器

```cpp
// stack_allocator.h
class StackAllocator {
private:
    void* memory;
    size_t size;
    size_t offset;

public:
    StackAllocator(size_t sizeInBytes) : size(sizeInBytes), offset(0) {
        memory = malloc(size);
    }

    ~StackAllocator() {
        free(memory);
    }

    void* allocate(size_t allocationSize, size_t alignment = 4) {
        // 对齐偏移
        size_t padding = 0;
        size_t moduloResult = offset % alignment;
        if (moduloResult != 0) {
            padding = alignment - moduloResult;
        }

        if (offset + padding + allocationSize > size) {
            // 内存不足
            return nullptr;
        }

        offset += padding;
        void* ptr = (char*)memory + offset;
        offset += allocationSize;

        return ptr;
    }

    void clear() {
        offset = 0;
    }

    size_t getUsedMemory() const { return offset; }
    size_t getTotalMemory() const { return size; }
    float getUsagePercentage() const { return (float)offset / size * 100.0f; }
};

// 双缓冲帧分配器
class DoubleBufferedAllocator {
private:
    StackAllocator allocators[2];
    int currentBuffer;

public:
    DoubleBufferedAllocator(size_t sizePerBuffer)
        : allocators{ StackAllocator(sizePerBuffer), StackAllocator(sizePerBuffer) },
          currentBuffer(0) {}

    void* allocate(size_t size, size_t alignment = 4) {
        return allocators[currentBuffer].allocate(size, alignment);
    }

    void swapBuffers() {
        currentBuffer = 1 - currentBuffer;
        allocators[currentBuffer].clear();
    }

    void clearCurrentBuffer() {
        allocators[currentBuffer].clear();
    }
};

// 使用示例
class Engine {
private:
    DoubleBufferedAllocator frameAllocator;

public:
    Engine() : frameAllocator(10 * 1024 * 1024) {}  // 10MB per buffer

    void update(float deltaTime) {
        // 使用帧分配器分配临时数据
        int* tempArray = (int*)frameAllocator.allocate(sizeof(int) * 1000);
        // 使用 tempArray...

        // 帧结束时自动清除
    }

    void endFrame() {
        frameAllocator.swapBuffers();
    }
};
```

### 2.3 智能指针使用规范

```cpp
// 资源管理最佳实践
class ResourceManager {
private:
    // 使用 shared_ptr 管理共享资源
    std::unordered_map<std::string, std::shared_ptr<Texture>> textures;
    std::unordered_map<std::string, std::shared_ptr<Mesh>> meshes;

    // 使用 weak_ptr 避免循环引用
    std::vector<std::weak_ptr<GameObject>> gameObjects;

public:
    std::shared_ptr<Texture> loadTexture(const std::string& name, const std::string& path) {
        auto it = textures.find(name);
        if (it != textures.end()) {
            return it->second;  // 已加载，返回共享指针
        }

        auto texture = std::make_shared<Texture>(path);
        textures[name] = texture;
        return texture;
    }

    void cleanupUnusedResources() {
        // 移除未被引用的纹理
        for (auto it = textures.begin(); it != textures.end();) {
            if (it->second.use_count() == 1) {  // 只有这里持有引用
                std::cout << "Removing unused texture: " << it->first << std::endl;
                it = textures.erase(it);
            } else {
                ++it;
            }
        }

        // 清理已销毁的游戏对象
        gameObjects.erase(
            std::remove_if(gameObjects.begin(), gameObjects.end(),
                [](const std::weak_ptr<GameObject>& wp) { return wp.expired(); }),
            gameObjects.end()
        );
    }
};

// GameObject 使用智能指针
class GameObject : public std::enable_shared_from_this<GameObject> {
private:
    std::vector<std::unique_ptr<Component>> components;  // 独占组件
    std::weak_ptr<GameObject> parent;  // 避免循环引用
    std::vector<std::shared_ptr<GameObject>> children;

public:
    template<typename T>
    T* addComponent() {
        auto component = std::make_unique<T>(this);
        T* ptr = component.get();
        components.push_back(std::move(component));
        return ptr;
    }

    void setParent(std::shared_ptr<GameObject> newParent) {
        parent = newParent;
        if (newParent) {
            newParent->children.push_back(shared_from_this());
        }
    }
};
```

---

## 三、渲染优化

### 3.1 DrawCall合批

```cpp
// batch_renderer.h
class BatchRenderer {
private:
    struct BatchKey {
        Shader* shader;
        unsigned int VAO;
        Material* material;

        bool operator<(const BatchKey& other) const {
            if (shader != other.shader) return shader < other.shader;
            if (VAO != other.VAO) return VAO < other.VAO;
            return material < other.material;
        }
    };

    struct Batch {
        std::vector<glm::mat4> transforms;
        std::vector<MeshRenderer*> renderers;
    };

    std::map<BatchKey, Batch> batches;
    unsigned int instanceVBO;

public:
    BatchRenderer() {
        glGenBuffers(1, &instanceVBO);
    }

    void addRenderer(MeshRenderer* renderer) {
        BatchKey key;
        key.shader = renderer->getMaterial()->getShader();
        key.VAO = renderer->getMesh()->getVAO();
        key.material = renderer->getMaterial();

        batches[key].renderers.push_back(renderer);
        batches[key].transforms.push_back(renderer->getGameObject()->getTransform()->getWorldMatrix());
    }

    void render(Camera* camera) {
        for (auto& pair : batches) {
            const BatchKey& key = pair.first;
            Batch& batch = pair.second;

            if (batch.transforms.empty()) continue;

            // 设置shader
            key.shader->use();
            key.shader->setMat4("view", camera->getViewMatrix());
            key.shader->setMat4("projection", camera->getProjectionMatrix());

            // 应用材质
            key.material->apply();

            // 实例化渲染
            if (batch.transforms.size() > 1) {
                renderInstanced(key.VAO, batch.transforms, batch.renderers[0]->getMesh());
            } else {
                // 单个物体，普通渲染
                key.shader->setMat4("model", batch.transforms[0]);
                glBindVertexArray(key.VAO);
                glDrawElements(GL_TRIANGLES, batch.renderers[0]->getMesh()->getIndexCount(),
                              GL_UNSIGNED_INT, 0);
            }
        }
    }

    void renderInstanced(unsigned int VAO, const std::vector<glm::mat4>& transforms, Mesh* mesh) {
        // 上传实例矩阵
        glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);
        glBufferData(GL_ARRAY_BUFFER, transforms.size() * sizeof(glm::mat4),
                     &transforms[0], GL_DYNAMIC_DRAW);

        glBindVertexArray(VAO);

        // 设置实例属性（mat4需要4个属性槽位）
        for (int i = 0; i < 4; i++) {
            glEnableVertexAttribArray(3 + i);
            glVertexAttribPointer(3 + i, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4),
                                  (void*)(sizeof(glm::vec4) * i));
            glVertexAttribDivisor(3 + i, 1);  // 每个实例更新一次
        }

        glDrawElementsInstanced(GL_TRIANGLES, mesh->getIndexCount(),
                               GL_UNSIGNED_INT, 0, transforms.size());

        // 清理
        for (int i = 0; i < 4; i++) {
            glVertexAttribDivisor(3 + i, 0);
        }
    }

    void clear() {
        batches.clear();
    }

    int getBatchCount() const { return batches.size(); }
    int getTotalRenderers() const {
        int count = 0;
        for (const auto& pair : batches) {
            count += pair.second.renderers.size();
        }
        return count;
    }
};
```

### 3.2 LOD系统 (Level of Detail)

```cpp
// lod_system.h
class LODGroup : public Component {
public:
    struct LODLevel {
        float distance;
        Mesh* mesh;
        float screenRelativeTransitionHeight;
    };

private:
    std::vector<LODLevel> lodLevels;
    int currentLOD;
    Camera* mainCamera;

public:
    LODGroup(GameObject* go) : Component(go), currentLOD(0) {}

    void addLOD(float distance, Mesh* mesh) {
        LODLevel level;
        level.distance = distance;
        level.mesh = mesh;
        lodLevels.push_back(level);

        // 按距离排序
        std::sort(lodLevels.begin(), lodLevels.end(),
                  [](const LODLevel& a, const LODLevel& b) {
                      return a.distance < b.distance;
                  });
    }

    void update(float deltaTime) override {
        if (!mainCamera) {
            mainCamera = Scene::getInstance().getMainCamera();
            return;
        }

        // 计算到相机的距离
        glm::vec3 cameraPos = mainCamera->getGameObject()->getTransform()->getPosition();
        glm::vec3 objectPos = gameObject->getTransform()->getPosition();
        float distance = glm::length(cameraPos - objectPos);

        // 选择合适的LOD级别
        int newLOD = 0;
        for (size_t i = 0; i < lodLevels.size(); i++) {
            if (distance < lodLevels[i].distance) {
                newLOD = i;
                break;
            }
            newLOD = i;
        }

        // LOD切换
        if (newLOD != currentLOD) {
            currentLOD = newLOD;
            switchLOD(currentLOD);
        }
    }

    void switchLOD(int level) {
        if (level < 0 || level >= lodLevels.size()) return;

        MeshRenderer* renderer = gameObject->getComponent<MeshRenderer>();
        if (renderer) {
            renderer->setMesh(lodLevels[level].mesh);
        }
    }

    int getCurrentLOD() const { return currentLOD; }
};

// 使用示例
void setupLODs(GameObject* tree) {
    LODGroup* lodGroup = tree->addComponent<LODGroup>();

    lodGroup->addLOD(10.0f, ResourceManager::getMesh("tree_high"));   // 高细节
    lodGroup->addLOD(30.0f, ResourceManager::getMesh("tree_medium")); // 中细节
    lodGroup->addLOD(60.0f, ResourceManager::getMesh("tree_low"));    // 低细节
    lodGroup->addLOD(100.0f, ResourceManager::getMesh("tree_billboard")); // 公告板
}
```

### 3.3 遮挡剔除 (Occlusion Culling)

```cpp
// occlusion_culling.h
class OcclusionCullingSystem {
private:
    unsigned int queryFBO;
    unsigned int depthTexture;
    Shader* occlusionShader;

    struct OcclusionQuery {
        GameObject* object;
        GLuint queryID;
        bool wasVisible;
    };

    std::vector<OcclusionQuery> queries;

public:
    void initialize(int width, int height) {
        // 创建深度预渲染FBO
        glGenFramebuffers(1, &queryFBO);
        glBindFramebuffer(GL_FRAMEBUFFER, queryFBO);

        glGenTextures(1, &depthTexture);
        glBindTexture(GL_TEXTURE_2D, depthTexture);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT,
                     width, height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, nullptr);

        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                              GL_TEXTURE_2D, depthTexture, 0);

        glDrawBuffer(GL_NONE);
        glReadBuffer(GL_NONE);

        glBindFramebuffer(GL_FRAMEBUFFER, 0);

        occlusionShader = new Shader("occlusion.vert", "occlusion.frag");
    }

    void registerObject(GameObject* object) {
        OcclusionQuery query;
        query.object = object;
        glGenQueries(1, &query.queryID);
        query.wasVisible = true;
        queries.push_back(query);
    }

    void performQueries(Camera* camera) {
        // 第一步：渲染深度
        glBindFramebuffer(GL_FRAMEBUFFER, queryFBO);
        glClear(GL_DEPTH_BUFFER_BIT);
        renderDepthPass(camera);

        // 第二步：执行遮挡查询
        glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
        glDepthMask(GL_FALSE);

        for (auto& query : queries) {
            glBeginQuery(GL_ANY_SAMPLES_PASSED, query.queryID);
            renderBoundingBox(query.object, camera);
            glEndQuery(GL_ANY_SAMPLES_PASSED);
        }

        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        glDepthMask(GL_TRUE);
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
    }

    void collectResults() {
        for (auto& query : queries) {
            GLuint result;
            glGetQueryObjectuiv(query.queryID, GL_QUERY_RESULT, &result);
            query.wasVisible = (result > 0);

            // 根据结果启用/禁用渲染
            MeshRenderer* renderer = query.object->getComponent<MeshRenderer>();
            if (renderer) {
                renderer->setEnabled(query.wasVisible);
            }
        }
    }

    int getVisibleCount() const {
        int count = 0;
        for (const auto& query : queries) {
            if (query.wasVisible) count++;
        }
        return count;
    }

private:
    void renderDepthPass(Camera* camera) {
        occlusionShader->use();
        // 渲染所有大型遮挡物（墙壁、建筑等）
    }

    void renderBoundingBox(GameObject* object, Camera* camera) {
        AABB bounds = object->getComponent<MeshRenderer>()->getMesh()->getBounds();
        // 渲染包围盒
    }
};
```

---

## 四、多线程优化

### 4.1 任务调度系统

```cpp
// task_scheduler.h
#include <functional>
#include <queue>
#include <thread>
#include <condition_variable>

class TaskScheduler {
public:
    using Task = std::function<void()>;

private:
    std::vector<std::thread> workers;
    std::queue<Task> tasks;
    std::mutex queueMutex;
    std::condition_variable condition;
    bool stop;

public:
    TaskScheduler(size_t numThreads = std::thread::hardware_concurrency()) : stop(false) {
        for (size_t i = 0; i < numThreads; i++) {
            workers.emplace_back([this]() {
                workerThread();
            });
        }
    }

    ~TaskScheduler() {
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            stop = true;
        }
        condition.notify_all();

        for (auto& worker : workers) {
            if (worker.joinable()) {
                worker.join();
            }
        }
    }

    void enqueue(Task task) {
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            tasks.push(std::move(task));
        }
        condition.notify_one();
    }

    void enqueueAndWait(const std::vector<Task>& taskList) {
        std::atomic<int> counter(taskList.size());
        std::mutex waitMutex;
        std::condition_variable waitCondition;

        for (const auto& task : taskList) {
            enqueue([&, task]() {
                task();
                if (--counter == 0) {
                    waitCondition.notify_one();
                }
            });
        }

        // 等待所有任务完成
        std::unique_lock<std::mutex> lock(waitMutex);
        waitCondition.wait(lock, [&]() { return counter == 0; });
    }

private:
    void workerThread() {
        while (true) {
            Task task;

            {
                std::unique_lock<std::mutex> lock(queueMutex);
                condition.wait(lock, [this]() {
                    return stop || !tasks.empty();
                });

                if (stop && tasks.empty()) {
                    return;
                }

                task = std::move(tasks.front());
                tasks.pop();
            }

            task();
        }
    }
};

// 使用示例
class ParallelPhysicsSystem {
private:
    TaskScheduler scheduler;

public:
    void update(std::vector<Rigidbody*>& rigidbodies, float deltaTime) {
        // 将刚体分组
        const size_t batchSize = 100;
        std::vector<TaskScheduler::Task> tasks;

        for (size_t i = 0; i < rigidbodies.size(); i += batchSize) {
            size_t end = std::min(i + batchSize, rigidbodies.size());

            tasks.push_back([&rigidbodies, i, end, deltaTime]() {
                for (size_t j = i; j < end; j++) {
                    rigidbodies[j]->updatePhysics(deltaTime);
                }
            });
        }

        // 并行执行并等待完成
        scheduler.enqueueAndWait(tasks);
    }
};
```

### 4.2 数据并行处理

```cpp
// parallel_for.h
template<typename Func>
void parallelFor(size_t begin, size_t end, Func func, size_t minBatchSize = 100) {
    size_t numThreads = std::thread::hardware_concurrency();
    size_t totalSize = end - begin;

    if (totalSize < minBatchSize) {
        // 数据量太小，直接串行执行
        for (size_t i = begin; i < end; i++) {
            func(i);
        }
        return;
    }

    size_t batchSize = (totalSize + numThreads - 1) / numThreads;
    std::vector<std::thread> threads;

    for (size_t t = 0; t < numThreads; t++) {
        size_t start = begin + t * batchSize;
        size_t finish = std::min(start + batchSize, end);

        if (start >= end) break;

        threads.emplace_back([start, finish, &func]() {
            for (size_t i = start; i < finish; i++) {
                func(i);
            }
        });
    }

    for (auto& thread : threads) {
        thread.join();
    }
}

// 使用示例
void ParticleSystem::updateParallel(float deltaTime) {
    parallelFor(0, particles.size(), [&](size_t i) {
        if (particles[i].life > 0.0f) {
            particles[i].life -= deltaTime;
            particles[i].position += particles[i].velocity * deltaTime;
            particles[i].velocity.y -= 9.8f * deltaTime;
        }
    });
}
```

---

## 五、调试技巧

### 5.1 可视化调试

```cpp
// debug_drawer.h
class DebugDrawer {
private:
    struct Line {
        glm::vec3 start;
        glm::vec3 end;
        glm::vec4 color;
        float duration;
    };

    struct Sphere {
        glm::vec3 center;
        float radius;
        glm::vec4 color;
        float duration;
    };

    std::vector<Line> lines;
    std::vector<Sphere> spheres;

    unsigned int lineVAO, lineVBO;
    Shader* debugShader;

public:
    void initialize() {
        glGenVertexArrays(1, &lineVAO);
        glGenBuffers(1, &lineVBO);

        debugShader = new Shader("debug.vert", "debug.frag");
    }

    void drawLine(const glm::vec3& start, const glm::vec3& end,
                  const glm::vec4& color = glm::vec4(1.0f),
                  float duration = 0.0f) {
        lines.push_back({ start, end, color, duration });
    }

    void drawRay(const glm::vec3& origin, const glm::vec3& direction,
                 float length = 10.0f, const glm::vec4& color = glm::vec4(1.0f, 1.0f, 0.0f, 1.0f)) {
        drawLine(origin, origin + direction * length, color);
    }

    void drawBox(const AABB& box, const glm::vec4& color = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f)) {
        glm::vec3 min = box.min;
        glm::vec3 max = box.max;

        // 底面
        drawLine(glm::vec3(min.x, min.y, min.z), glm::vec3(max.x, min.y, min.z), color);
        drawLine(glm::vec3(max.x, min.y, min.z), glm::vec3(max.x, min.y, max.z), color);
        drawLine(glm::vec3(max.x, min.y, max.z), glm::vec3(min.x, min.y, max.z), color);
        drawLine(glm::vec3(min.x, min.y, max.z), glm::vec3(min.x, min.y, min.z), color);

        // 顶面
        drawLine(glm::vec3(min.x, max.y, min.z), glm::vec3(max.x, max.y, min.z), color);
        drawLine(glm::vec3(max.x, max.y, min.z), glm::vec3(max.x, max.y, max.z), color);
        drawLine(glm::vec3(max.x, max.y, max.z), glm::vec3(min.x, max.y, max.z), color);
        drawLine(glm::vec3(min.x, max.y, max.z), glm::vec3(min.x, max.y, min.z), color);

        // 竖线
        drawLine(glm::vec3(min.x, min.y, min.z), glm::vec3(min.x, max.y, min.z), color);
        drawLine(glm::vec3(max.x, min.y, min.z), glm::vec3(max.x, max.y, min.z), color);
        drawLine(glm::vec3(max.x, min.y, max.z), glm::vec3(max.x, max.y, max.z), color);
        drawLine(glm::vec3(min.x, min.y, max.z), glm::vec3(min.x, max.y, max.z), color);
    }

    void drawSphere(const glm::vec3& center, float radius,
                    const glm::vec4& color = glm::vec4(1.0f, 0.0f, 0.0f, 1.0f),
                    float duration = 0.0f) {
        spheres.push_back({ center, radius, color, duration });
    }

    void render(Camera* camera) {
        if (lines.empty()) return;

        debugShader->use();
        debugShader->setMat4("view", camera->getViewMatrix());
        debugShader->setMat4("projection", camera->getProjectionMatrix());

        // 准备线条数据
        std::vector<float> vertices;
        for (const auto& line : lines) {
            // 起点
            vertices.push_back(line.start.x);
            vertices.push_back(line.start.y);
            vertices.push_back(line.start.z);
            vertices.push_back(line.color.r);
            vertices.push_back(line.color.g);
            vertices.push_back(line.color.b);
            vertices.push_back(line.color.a);

            // 终点
            vertices.push_back(line.end.x);
            vertices.push_back(line.end.y);
            vertices.push_back(line.end.z);
            vertices.push_back(line.color.r);
            vertices.push_back(line.color.g);
            vertices.push_back(line.color.b);
            vertices.push_back(line.color.a);
        }

        glBindVertexArray(lineVAO);
        glBindBuffer(GL_ARRAY_BUFFER, lineVBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(float),
                     vertices.data(), GL_DYNAMIC_DRAW);

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)0);

        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * sizeof(float),
                             (void*)(3 * sizeof(float)));

        glDrawArrays(GL_LINES, 0, vertices.size() / 7);
        glBindVertexArray(0);
    }

    void update(float deltaTime) {
        // 移除过期的调试绘制
        lines.erase(
            std::remove_if(lines.begin(), lines.end(),
                [deltaTime](Line& line) {
                    if (line.duration > 0.0f) {
                        line.duration -= deltaTime;
                        return line.duration <= 0.0f;
                    }
                    return true;  // duration == 0 表示只绘制一帧
                }),
            lines.end()
        );
    }

    void clear() {
        lines.clear();
        spheres.clear();
    }
};

// 全局访问
class Debug {
public:
    static DebugDrawer& getDrawer() {
        static DebugDrawer drawer;
        return drawer;
    }

    static void drawLine(const glm::vec3& start, const glm::vec3& end,
                        const glm::vec4& color = glm::vec4(1.0f), float duration = 0.0f) {
        getDrawer().drawLine(start, end, color, duration);
    }

    static void drawRay(const glm::vec3& origin, const glm::vec3& direction,
                       float length = 10.0f) {
        getDrawer().drawRay(origin, direction, length);
    }

    static void drawBox(const AABB& box, const glm::vec4& color = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f)) {
        getDrawer().drawBox(box, color);
    }
};

// 使用示例
void PlayerController::update(float deltaTime) {
    // 调试射线
    glm::vec3 rayOrigin = transform->getPosition();
    glm::vec3 rayDirection = transform->forward();
    Debug::drawRay(rayOrigin, rayDirection, 10.0f);

    // 调试包围盒
    AABB bounds = GetComponent<MeshRenderer>()->getMesh()->getBounds();
    Debug::drawBox(bounds);
}
```

### 5.2 日志系统

```cpp
// logger.h
#include <sstream>
#include <fstream>
#include <ctime>

class Logger {
public:
    enum Level {
        TRACE,
        DEBUG,
        INFO,
        WARNING,
        ERROR,
        FATAL
    };

private:
    Level currentLevel;
    std::ofstream logFile;
    std::mutex mutex;

    static const char* levelToString(Level level) {
        switch (level) {
            case TRACE: return "TRACE";
            case DEBUG: return "DEBUG";
            case INFO: return "INFO";
            case WARNING: return "WARNING";
            case ERROR: return "ERROR";
            case FATAL: return "FATAL";
            default: return "UNKNOWN";
        }
    }

    std::string getCurrentTime() {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }

public:
    static Logger& getInstance() {
        static Logger instance;
        return instance;
    }

    void initialize(const std::string& filename, Level level = INFO) {
        currentLevel = level;
        logFile.open(filename, std::ios::app);
    }

    void setLevel(Level level) {
        currentLevel = level;
    }

    template<typename... Args>
    void log(Level level, const Args&... args) {
        if (level < currentLevel) return;

        std::lock_guard<std::mutex> lock(mutex);

        std::stringstream ss;
        ss << "[" << getCurrentTime() << "] ";
        ss << "[" << levelToString(level) << "] ";

        ((ss << args), ...);

        std::string message = ss.str();

        // 输出到控制台
        if (level >= WARNING) {
            std::cerr << message << std::endl;
        } else {
            std::cout << message << std::endl;
        }

        // 输出到文件
        if (logFile.is_open()) {
            logFile << message << std::endl;
            logFile.flush();
        }
    }

    ~Logger() {
        if (logFile.is_open()) {
            logFile.close();
        }
    }
};

// 便捷宏
#define LOG_TRACE(...) Logger::getInstance().log(Logger::TRACE, __VA_ARGS__)
#define LOG_DEBUG(...) Logger::getInstance().log(Logger::DEBUG, __VA_ARGS__)
#define LOG_INFO(...) Logger::getInstance().log(Logger::INFO, __VA_ARGS__)
#define LOG_WARNING(...) Logger::getInstance().log(Logger::WARNING, __VA_ARGS__)
#define LOG_ERROR(...) Logger::getInstance().log(Logger::ERROR, __VA_ARGS__)
#define LOG_FATAL(...) Logger::getInstance().log(Logger::FATAL, __VA_ARGS__)

// 使用示例
void Texture::load(const std::string& path) {
    LOG_INFO("Loading texture: ", path);

    if (!fileExists(path)) {
        LOG_ERROR("Texture file not found: ", path);
        return;
    }

    // 加载纹理...

    LOG_INFO("Texture loaded successfully: ", path, " (", width, "x", height, ")");
}
```

---

## 六、最佳实践

### 6.1 代码组织

```cpp
// 项目结构最佳实践
GameEngine/
├── Engine/
│   ├── Core/           // 核心系统
│   │   ├── Application.h/cpp
│   │   ├── Window.h/cpp
│   │   └── Time.h/cpp
│   ├── Rendering/      // 渲染系统
│   │   ├── Renderer.h/cpp
│   │   ├── Shader.h/cpp
│   │   ├── Texture.h/cpp
│   │   └── Material.h/cpp
│   ├── Scene/          // 场景管理
│   │   ├── Scene.h/cpp
│   │   ├── GameObject.h/cpp
│   │   └── Component.h/cpp
│   ├── Physics/        // 物理系统
│   │   ├── PhysicsWorld.h/cpp
│   │   └── Rigidbody.h/cpp
│   └── Utils/          // 工具类
│       ├── Math.h
│       ├── Logger.h/cpp
│       └── Profiler.h/cpp
├── Game/               // 游戏逻辑
│   ├── Components/     // 游戏组件
│   ├── Scripts/        // Lua脚本
│   └── Data/           // 配置数据
└── Assets/             // 资源文件
    ├── Models/
    ├── Textures/
    ├── Shaders/
    └── Audio/
```

### 6.2 命名规范

```cpp
// Google C++ 风格指南

// 类名：大驼峰
class GameEngine {};
class MeshRenderer {};

// 函数名：小驼峰
void updateTransform();
float calculateDistance();

// 变量名：小驼峰
float deltaTime;
int vertexCount;

// 成员变量：小驼峰 + 后缀下划线（可选）
class Player {
private:
    float health_;
    int ammo_;

public:
    // Getter/Setter
    float getHealth() const { return health_; }
    void setHealth(float h) { health_ = h; }
};

// 常量：k开头 + 大驼峰
const int kMaxPlayers = 4;
const float kGravity = 9.8f;

// 宏：全大写 + 下划线
#define MAX_TEXTURE_UNITS 32
#define ENABLE_PROFILING

// 命名空间：小写
namespace engine {
namespace rendering {
    class Shader {};
}
}
```

### 6.3 错误处理

```cpp
// 使用异常处理关键错误
class ResourceLoadException : public std::runtime_exception {
public:
    ResourceLoadException(const std::string& message)
        : std::runtime_exception(message.c_str()) {}
};

Texture* Texture::load(const std::string& path) {
    if (!std::filesystem::exists(path)) {
        throw ResourceLoadException("Texture file not found: " + path);
    }

    // 加载纹理...
    if (loadFailed) {
        throw ResourceLoadException("Failed to decode texture: " + path);
    }

    return texture;
}

// 使用std::optional处理可能失败的操作
std::optional<GameObject*> Scene::findGameObject(const std::string& name) {
    for (auto& obj : gameObjects) {
        if (obj->getName() == name) {
            return obj;
        }
    }
    return std::nullopt;
}

// 使用
if (auto player = scene->findGameObject("Player")) {
    player.value()->takeDamage(10);
} else {
    LOG_WARNING("Player not found in scene");
}

// 使用Result类型
template<typename T, typename E>
class Result {
private:
    bool success;
    T value;
    E error;

public:
    static Result Ok(T val) {
        Result r;
        r.success = true;
        r.value = val;
        return r;
    }

    static Result Err(E err) {
        Result r;
        r.success = false;
        r.error = err;
        return r;
    }

    bool isOk() const { return success; }
    bool isErr() const { return !success; }

    T& getValue() { return value; }
    E& getError() { return error; }
};

// 使用
Result<Texture*, std::string> loadTexture(const std::string& path) {
    if (!fileExists(path)) {
        return Result::Err("File not found");
    }

    Texture* tex = /* load */;
    if (!tex) {
        return Result::Err("Decode failed");
    }

    return Result::Ok(tex);
}
```

---

**总结**：本文档涵盖了游戏引擎开发的性能优化、内存管理、渲染优化、多线程、调试技巧和最佳实践。结合前面的文档，可以构建一个高性能、可维护的商业级游戏引擎！
