# C++设计模式完整学习指南

> 系统学习C++设计模式，从基础到进阶，从理论到实战

## 📚 文档导航

本学习指南包含四个部分，建议按顺序学习：

| 文档 | 内容 | 适合阶段 |
|------|------|----------|
| **[📖 主文档](./设计模式.md)**（本文档） | 基础理论、经典GoF模式、学习路径 | 入门-进阶 |
| **[🚀 高级篇](./设计模式-高级篇.md)** | 序列模式、行为模式、解耦模式、优化模式基础 | 进阶 |
| **[💡 实战案例](./设计模式-实战案例.md)** | 完整项目案例：2D游戏、粒子系统、关卡编辑器 | 进阶-实践 |
| **[⚡ 性能优化](./设计模式-性能优化.md)** | 内存优化、缓存优化、多线程模式、性能测量 | 高级 |

**学习建议**：
1. 初学者：先完成主文档的第一、二部分
2. 有基础者：重点学习高级篇和实战案例
3. 性能敏感项目：务必阅读性能优化篇

---

## 学习目标定位

**目标受众**: 0-5年C++开发经验的程序员、游戏开发者、希望系统掌握设计模式的工程师

**核心目标**:
- 理解设计模式的本质：解决重复出现的设计问题
- 掌握经典GoF模式在C++中的实现
- 学习设计模式在游戏编程中的特殊应用
- 培养架构设计思维和权衡能力

---

## 第一部分：设计模式基础理论

### 1.1 什么是设计模式

设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求定制的预制蓝图，可用于解决代码中反复出现的设计问题。

**设计模式不是：**
- 不是可以直接复制粘贴的代码
- 不是特定的算法或数据结构
- 不是万能的解决方案

**设计模式是：**
- 解决特定问题的概念性方法
- 团队沟通的共同语言
- 经过验证的最佳实践
- 可复用的设计思想

### 1.2 为什么游戏开发需要设计模式

游戏开发面临的独特挑战：

1. **性能要求极高** - 需要每秒渲染60帧
2. **代码复杂度高** - AI、物理、渲染、音频等多系统交互
3. **快速迭代需求** - 玩法需要不断调整和实验
4. **团队协作密集** - 多人同时修改代码库

设计模式能够帮助我们：
- **解耦系统** - 减少模块间的依赖，提高可维护性
- **提高灵活性** - 方便添加新功能和修改现有行为
- **优化性能** - 某些模式专门为性能优化而设计
- **促进协作** - 提供统一的设计语言

### 1.3 软件架构的核心原则

#### 架构的本质

软件架构的核心目标是：**最小化在编写代码前需要了解的信息**。

一个好的架构应该：
- 让改动变得容易且可预测
- 将相关代码组织在一起
- 隔离不相关的代码
- 使代码易于理解和调试

#### 编程工作流程

```
获得问题 → 研究代码 → 编写解决方案 → 清理代码 → 回到开始
```

大部分时间都花在"研究代码"阶段 - 理解现有代码如何工作。设计模式的主要作用就是减少这个阶段需要理解的代码量。

#### 解耦的价值

两块代码如果是**耦合的**，意味着你无法只理解其中一个。如果它们是**解耦的**，就可以单独理解某一块。

解耦的定义：
- 当一块代码有改动时，不需要修改另一块代码
- 理解某块代码时，不需要了解另一块代码的细节

### 1.4 架构设计的权衡

#### 没有银弹

好的架构需要在多个目标间权衡：

1. **开发速度** - 实现功能的速度
2. **可维护性** - 长期保持代码整洁的能力
3. **运行性能** - 代码执行的效率

这些目标往往相互冲突：
- 过度抽象会降低性能和开发速度
- 追求极致性能会牺牲灵活性
- 快速实现功能可能留下技术债

#### 性能 vs 灵活性

**性能依赖于假设**：
- 敌人永远不超过256个？可以用一个字节存储ID
- 只调用特定类型的方法？可以做静态调度
- 所有实体同一类型？可以用连续数组存储

**灵活性需要更少假设**：
- 使用接口可以与任何实现交互
- 使用观察者模式方便扩展通信对象
- 抽象层提供扩展点

**实践建议**：
- 保持代码灵活直到确定设计
- 设计确定后再去除抽象层提升性能
- 让有趣的游戏变快比让快的游戏变有趣容易

#### 何时使用原型代码

**原型代码特征**：
- 快速验证想法
- 不考虑架构
- 可以有bug
- 注定会被扔掉

**使用规则**：
- 只用于快速实验
- **必须**在实验后重写或删除
- 明确告知团队这是原型代码
- 不要让原型代码进入生产环境

### 1.5 追求简单

最佳实践：**写最简单、最直接的解决方案**

简单代码的特征：
- 容易理解其工作原理
- 想不到其他实现方式
- 代码量少，需要理解的内容少
- 通常运行也快（更少的开销）

获得简单解决方案的方法：
- 正确设计数据结构和算法
- 识别用例下隐藏的模式
- "蒸馏"代码而非"注水"

---

## 第二部分：GoF经典模式在C++中的应用

### 2.1 命令模式 (Command Pattern)

#### 核心思想

**命令是具现化的方法调用** - 将方法调用封装成对象，使其可以存储、传递、撤销。

#### 使用场景

1. **配置输入** - 将按键映射到游戏行为
2. **撤销/重做** - 实现可逆操作
3. **AI行为** - 将AI决策表示为命令序列
4. **网络同步** - 传输玩家操作
5. **回放系统** - 记录和重放游戏过程

#### 实战案例1：可配置输入系统

**问题**：硬编码的输入处理难以配置

```cpp
// 糟糕的做法：硬编码
void handleInput() {
    if (isPressed(BUTTON_X)) jump();
    else if (isPressed(BUTTON_Y)) fireGun();
    else if (isPressed(BUTTON_A)) swapWeapon();
}
```

**解决方案**：使用命令模式

```cpp
// 1. 定义命令基类
class Command {
public:
    virtual ~Command() {}
    virtual void execute(GameActor& actor) = 0;
};

// 2. 实现具体命令
class JumpCommand : public Command {
public:
    virtual void execute(GameActor& actor) override {
        actor.jump();
    }
};

class FireCommand : public Command {
public:
    virtual void execute(GameActor& actor) override {
        actor.fireGun();
    }
};

// 3. 输入处理器
class InputHandler {
public:
    Command* handleInput() {
        if (isPressed(BUTTON_X)) return buttonX_;
        if (isPressed(BUTTON_Y)) return buttonY_;
        if (isPressed(BUTTON_A)) return buttonA_;
        return nullptr;
    }

    void bindButton(int button, Command* command) {
        // 配置按键绑定
    }

private:
    Command* buttonX_;
    Command* buttonY_;
    Command* buttonA_;
};

// 4. 使用
Command* command = inputHandler.handleInput();
if (command) {
    command->execute(player);  // 可以是玩家或AI控制的任何角色
}
```

**优势**：
- 输入和行为解耦
- 可以动态改变按键绑定
- 同一命令可用于AI和玩家

#### 实战案例2：撤销/重做系统

```cpp
class MoveUnitCommand : public Command {
public:
    MoveUnitCommand(Unit* unit, int x, int y)
        : unit_(unit), x_(x), y_(y),
          xBefore_(0), yBefore_(0) {}

    virtual void execute() override {
        // 保存移动前的位置
        xBefore_ = unit_->x();
        yBefore_ = unit_->y();

        unit_->moveTo(x_, y_);
    }

    virtual void undo() override {
        unit_->moveTo(xBefore_, yBefore_);
    }

private:
    Unit* unit_;
    int x_, y_;
    int xBefore_, yBefore_;
};

// 命令历史管理
class CommandHistory {
public:
    void execute(Command* command) {
        command->execute();
        history_.push_back(command);
        current_ = history_.size() - 1;
    }

    void undo() {
        if (current_ >= 0) {
            history_[current_]->undo();
            current_--;
        }
    }

    void redo() {
        if (current_ < history_.size() - 1) {
            current_++;
            history_[current_]->execute();
        }
    }

private:
    std::vector<Command*> history_;
    int current_;
};
```

#### 实现变体

**使用函数而非类** (C++11)：

```cpp
// 使用std::function
using Command = std::function<void()>;

Command makeMoveCommand(Unit* unit, int x, int y) {
    return [unit, x, y]() {
        unit->moveTo(x, y);
    };
}

// 支持撤销的版本
struct UndoableCommand {
    std::function<void()> execute;
    std::function<void()> undo;
};

UndoableCommand makeMoveCommand(Unit* unit, int x, int y) {
    int xBefore, yBefore;
    return {
        [unit, x, y, &xBefore, &yBefore]() {
            xBefore = unit->x();
            yBefore = unit->y();
            unit->moveTo(x, y);
        },
        [unit, &xBefore, &yBefore]() {
            unit->moveTo(xBefore, yBefore);
        }
    };
}
```

---

### 2.2 享元模式 (Flyweight Pattern)

#### 核心思想

通过共享来支持大量细粒度对象，将对象状态分为：
- **固有状态**（intrinsic）：可以共享的、不随环境改变的状态
- **可变状态**（extrinsic）：随环境改变、不可共享的状态

#### 使用场景

1. **游戏世界** - 森林中的树、地形区块
2. **粒子系统** - 共享纹理和网格
3. **UI元素** - 共享样式和资源
4. **字符渲染** - 字体glyph共享

#### 实战案例：森林渲染系统

**问题**：森林中有上万棵树，每棵树都存储完整数据会耗尽内存

```cpp
// 不好的做法
class Tree {
private:
    Mesh mesh_;           // 巨大的网格数据
    Texture bark_;        // 树皮纹理
    Texture leaves_;      // 树叶纹理
    Vector position_;     // 位置
    double height_;       // 高度
    double thickness_;    // 粗细
    Color barkTint_;     // 树皮色调
    Color leafTint_;     // 树叶色调
};
```

**解决方案**：分离共享和独特数据

```cpp
// 共享数据：树的模型
class TreeModel {
public:
    TreeModel(const Mesh& mesh,
              const Texture& bark,
              const Texture& leaves)
        : mesh_(mesh), bark_(bark), leaves_(leaves) {}

    const Mesh& getMesh() const { return mesh_; }
    const Texture& getBark() const { return bark_; }
    const Texture& getLeaves() const { return leaves_; }

private:
    Mesh mesh_;
    Texture bark_;
    Texture leaves_;
};

// 独特数据：树的实例
class Tree {
public:
    Tree(TreeModel* model, const Vector& position)
        : model_(model), position_(position) {}

    void render() {
        // 使用共享的模型数据和独特的实例数据渲染
        renderMesh(model_->getMesh(),
                  position_,
                  height_,
                  thickness_,
                  barkTint_,
                  leafTint_);
    }

private:
    TreeModel* model_;    // 指向共享数据
    Vector position_;     // 实例特定数据
    double height_;
    double thickness_;
    Color barkTint_;
    Color leafTint_;
};

// 世界管理
class Forest {
public:
    Forest() {
        // 创建少量共享模型
        oakModel_ = new TreeModel(oakMesh, oakBark, oakLeaves);
        pineModel_ = new TreeModel(pineMesh, pineBark, pineLeaves);
    }

    void plantTree(TreeModel* model, const Vector& position) {
        trees_.push_back(Tree(model, position));
    }

    void render() {
        for (auto& tree : trees_) {
            tree.render();
        }
    }

private:
    TreeModel* oakModel_;   // 所有橡树共享
    TreeModel* pineModel_;  // 所有松树共享
    std::vector<Tree> trees_;  // 成千上万的实例
};
```

---

### 2.3 观察者模式 (Observer Pattern)

#### 核心思想

定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都得到通知并自动更新。

#### 使用场景

1. **成就系统** - 游戏事件触发成就解锁
2. **UI更新** - 数据变化时更新显示
3. **事件系统** - 解耦的消息传递
4. **MVC架构** - Model变化通知View

#### 实战案例：成就系统

**问题**：成就系统需要监听各种游戏事件，但不想让游戏代码依赖成就系统

```cpp
// 糟糕的做法：直接耦合
void Physics::updateEntity(Entity& entity) {
    bool wasOnSurface = entity.isOnSurface();
    entity.accelerate(GRAVITY);
    entity.update();

    if (wasOnSurface && !entity.isOnSurface()) {
        // 直接调用成就系统 - 耦合！
        achievements.unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
    }
}
```

**解决方案**：观察者模式

```cpp
// 1. 定义观察者接口
class Observer {
public:
    virtual ~Observer() {}
    virtual void onNotify(const Entity& entity, Event event) = 0;
};

// 2. 定义被观察者基类
class Subject {
public:
    void addObserver(Observer* observer) {
        observers_.push_back(observer);
    }

    void removeObserver(Observer* observer) {
        auto it = std::find(observers_.begin(), observers_.end(), observer);
        if (it != observers_.end()) {
            observers_.erase(it);
        }
    }

protected:
    void notify(const Entity& entity, Event event) {
        for (auto observer : observers_) {
            observer->onNotify(entity, event);
        }
    }

private:
    std::vector<Observer*> observers_;
};

// 3. 物理系统继承Subject
class Physics : public Subject {
public:
    void updateEntity(Entity& entity) {
        bool wasOnSurface = entity.isOnSurface();
        entity.accelerate(GRAVITY);
        entity.update();

        if (wasOnSurface && !entity.isOnSurface()) {
            notify(entity, EVENT_START_FALL);  // 通知观察者
        }
    }
};

// 4. 成就系统实现Observer
class Achievements : public Observer {
public:
    virtual void onNotify(const Entity& entity, Event event) override {
        switch (event) {
            case EVENT_START_FALL:
                if (entity.isHero() && heroIsOnBridge_) {
                    unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);
                }
                break;
        }
    }

private:
    void unlock(Achievement achievement) {
        // 解锁成就逻辑
    }

    bool heroIsOnBridge_;
};
```

---

### 2.4 单例模式 (Singleton Pattern)

#### 核心思想

确保一个类只有一个实例，并提供全局访问点。

#### 为什么要避免滥用

单例模式是最被滥用的设计模式之一。它看起来很方便，但带来很多问题。

**单例的问题**：

1. **它是全局变量** - 所有全局变量的问题它都有
2. **难以测试** - 全局状态导致测试间相互影响
3. **隐藏依赖** - 代码中看不出使用了什么外部资源
4. **对并发不友好** - 全局状态导致竞态条件
5. **解决了你可能没有的问题** - "只有一个实例"和"全局访问"通常不需要同时满足

#### 经典实现

```cpp
class FileSystem {
public:
    static FileSystem& instance() {
        static FileSystem instance;  // C++11保证线程安全
        return instance;
    }

    // 禁止拷贝
    FileSystem(const FileSystem&) = delete;
    FileSystem& operator=(const FileSystem&) = delete;

private:
    FileSystem() {}  // 私有构造函数
};

// 使用
FileSystem::instance().readFile("config.txt");
```

#### 替代方案

**方案1：依赖注入**

```cpp
class Game {
public:
    Game(FileSystem* fs, AudioEngine* audio)
        : fileSystem_(fs), audio_(audio) {}

    void loadLevel() {
        fileSystem_->readFile("level.dat");
        audio_->playMusic("theme.mp3");
    }

private:
    FileSystem* fileSystem_;
    AudioEngine* audio_;
};

// 在main中组装
int main() {
    FileSystem fs;
    AudioEngine audio;
    Game game(&fs, &audio);
}
```

---

### 2.5 状态模式 (State Pattern)

#### 核心思想

允许对象在内部状态改变时改变其行为，对象看起来好像修改了它的类。

#### 实战案例：角色状态系统

**最终方案：状态模式**

```cpp
// 1. 状态接口
class HeroineState {
public:
    virtual ~HeroineState() {}
    virtual void handleInput(Heroine& heroine, Input input) {}
    virtual void update(Heroine& heroine) {}
    virtual void enter(Heroine& heroine) {}
    virtual void exit(Heroine& heroine) {}
};

// 2. 具体状态
class StandingState : public HeroineState {
public:
    virtual void enter(Heroine& heroine) override {
        heroine.setGraphics(IMAGE_STAND);
    }

    virtual void handleInput(Heroine& heroine, Input input) override {
        if (input == PRESS_B) {
            heroine.setState(&HeroineState::jumping);
        } else if (input == PRESS_DOWN) {
            heroine.setState(&HeroineState::ducking);
        }
    }
};

class DuckingState : public HeroineState {
public:
    DuckingState() : chargeTime_(0) {}

    virtual void enter(Heroine& heroine) override {
        heroine.setGraphics(IMAGE_DUCK);
        chargeTime_ = 0;
    }

    virtual void handleInput(Heroine& heroine, Input input) override {
        if (input == RELEASE_DOWN) {
            heroine.setState(&HeroineState::standing);
        }
    }

    virtual void update(Heroine& heroine) override {
        chargeTime_++;
        if (chargeTime_ > MAX_CHARGE) {
            heroine.superBomb();
        }
    }

private:
    int chargeTime_;  // 状态特定数据
};

// 3. 英雄类
class Heroine {
public:
    Heroine() : state_(&HeroineState::standing) {}

    void handleInput(Input input) {
        state_->handleInput(*this, input);
    }

    void update() {
        state_->update(*this);
    }

    void setState(HeroineState* state) {
        if (state_ != nullptr) {
            state_->exit(*this);
        }
        state_ = state;
        state_->enter(*this);
    }

private:
    HeroineState* state_;
};
```

---

### 2.6 原型模式 (Prototype Pattern)

#### 核心思想

通过复制现有对象来创建新对象，而不是通过类实例化。

#### 基本实现

```cpp
// 抽象原型
class Monster {
public:
    virtual ~Monster() {}
    virtual Monster* clone() const = 0;
    virtual void attack() = 0;
};

// 具体原型
class Ghost : public Monster {
public:
    Ghost(int health, int speed)
        : health_(health), speed_(speed) {}

    virtual Monster* clone() const override {
        return new Ghost(*this);  // 使用拷贝构造
    }

    virtual void attack() override {
        // 幽灵攻击
    }

private:
    int health_;
    int speed_;
};
```

---

## 第三部分：游戏编程特定模式

### 3.1 对象池模式 (Object Pool Pattern)

#### 核心思想

预先创建一组可重用对象，避免频繁的分配和释放。

#### 实现

```cpp
template<typename T, size_t Size>
class ObjectPool {
public:
    ObjectPool() {
        for (size_t i = 0; i < Size; i++) {
            pool_[i].setNext(&pool_[i + 1]);
        }
        pool_[Size - 1].setNext(nullptr);
        firstAvailable_ = &pool_[0];
    }

    T* create() {
        if (firstAvailable_ == nullptr) {
            return nullptr;  // 池已满
        }

        T* object = firstAvailable_;
        firstAvailable_ = object->getNext();

        object->init();  // 初始化对象
        return object;
    }

    void destroy(T* object) {
        object->reset();  // 重置对象
        object->setNext(firstAvailable_);
        firstAvailable_ = object;
    }

private:
    T pool_[Size];
    T* firstAvailable_;
};
```

---

## 第四部分：学习路径和实践

### 4.1 从基础到进阶的学习路径

#### 第一阶段：理解模式本质（1-2周）

**学习目标**：
- 理解什么是设计模式
- 知道何时使用/不使用模式
- 理解软件架构的基本原则

**实践任务**：
1. 重构一段现有代码，识别其中的代码异味
2. 用简单的例子实现3个基础模式
3. 分析一个开源项目的架构

#### 第二阶段：掌握经典模式（3-4周）

**学习目标**：
- 熟练实现GoF核心模式
- 理解每个模式的适用场景
- 能够组合多个模式

**实践任务**：
1. 实现一个简单的游戏Demo，至少使用5个模式
2. 阅读游戏引擎源码，识别使用的模式
3. 参与代码评审，讨论设计选择

#### 第三阶段：性能优化和高级应用（3-4周）

**学习目标**：
- 理解模式的性能影响
- 掌握优化技巧
- 能够根据需求调整模式

**实践任务**：
1. 性能分析：测量不同实现的性能差异
2. 内存优化：使用对象池优化粒子系统
3. 并发编程：在多线程环境中使用模式

### 4.2 常见陷阱和避免方法

#### 陷阱1：过度设计

**症状**：
- 为了使用模式而使用模式
- 抽象层次过多
- 代码比需要的复杂

**避免方法**：
```cpp
// 不好：过度抽象
class AnimalFactory {
public:
    virtual Animal* createAnimal() = 0;
};

class DogFactory : public AnimalFactory {
    virtual Animal* createAnimal() override {
        return new Dog();
    }
};

// 好：直接创建
Dog* dog = new Dog();
```

**原则**：
- 只在需要时添加抽象
- 从简单开始，根据需要重构
- YAGNI（You Aren't Gonna Need It）

#### 陷阱2：忽视性能

**症状**：
- 过多的虚函数调用
- 频繁的内存分配
- 缓存不友好的数据结构

**避免方法**：
```cpp
// 不好：每次都分配
Command* cmd = new JumpCommand();
cmd->execute();
delete cmd;

// 好：使用对象池或静态实例
static JumpCommand jumpCmd;
jumpCmd.execute();
```

**原则**：
- 先测量再优化
- 了解目标平台的性能特性
- 在关键路径上谨慎使用抽象

#### 陷阱3：滥用全局状态

**症状**：
- 到处都是单例
- 隐藏的依赖关系
- 难以测试

**避免方法**：
```cpp
// 不好
AudioEngine::instance().play("sound.wav");
FileSystem::instance().load("data.txt");

// 好
class Game {
public:
    Game(AudioEngine& audio, FileSystem& fs)
        : audio_(audio), fs_(fs) {}

    void playSound() {
        audio_.play("sound.wav");
    }

private:
    AudioEngine& audio_;
    FileSystem& fs_;
};
```

**原则**：
- 优先使用依赖注入
- 让依赖关系显式化
- 限制全局状态的范围

---

## 第五部分：扩展资源和进阶方向

### 5.1 推荐阅读

**必读书籍**：
1. 《设计模式：可复用面向对象软件的基础》（GoF）
2. 《游戏编程模式》（本笔记的主要参考）
3. 《代码整洁之道》
4. 《重构：改善既有代码的设计》

**进阶书籍**：
1. 《企业应用架构模式》
2. 《面向模式的软件架构》系列
3. 《领域驱动设计》

**在线资源**：
- refactoring.guru - 设计模式可视化教程
- gameprogrammingpatterns.com - 游戏编程模式在线版
- GitHub - 搜索开源游戏引擎源码

### 5.2 实践项目建议

**入门项目**：
1. **命令模式**：文本编辑器（支持撤销/重做）
2. **观察者模式**：简单的事件系统
3. **状态模式**：有限状态机编辑器

**进阶项目**：
1. **组合模式**：游戏对象层次结构
2. **策略模式**：AI行为系统
3. **工厂模式**：关卡加载系统

**综合项目**：
1. 2D游戏引擎（SDL/SFML）
2. 粒子编辑器
3. 关卡编辑器

### 5.3 后续学习方向

#### 方向1：游戏引擎开发

**学习内容**：
- 渲染系统架构
- 物理引擎集成
- 资源管理系统
- 场景图和空间分割

**推荐引擎源码**：
- Godot（C++）
- Cocos2d-x（C++）
- OGRE（C++）

#### 方向2：性能优化

**学习内容**：
- 数据导向设计（DOD）
- 缓存优化
- 多线程和并发
- SIMD和底层优化

**关键模式**：
- 数据局部性模式
- 脏标记模式
- 空间分区模式

#### 方向3：工具开发

**学习内容**：
- 编辑器架构
- 序列化和反序列化
- 插件系统
- 脚本集成

**关键模式**：
- 类型对象模式
- 组件模式
- 服务定位器模式

---

## 总结：设计模式的核心价值

### 关键要点

1. **模式不是目的，而是手段** - 目标是写出可维护的代码
2. **简单优先** - 从最简单的解决方案开始
3. **权衡取舍** - 在性能、灵活性、开发速度间平衡
4. **持续学习** - 设计是一个不断进化的过程

### 使用设计模式的黄金法则

1. **理解问题** - 确保问题真的需要模式来解决
2. **选择合适的模式** - 不是所有问题都适合用模式
3. **保持简单** - 最简单的解决方案通常是最好的
4. **测量性能** - 在性能关键的代码中谨慎使用抽象
5. **重构而非预设计** - 等到需要时再引入模式

### 最后的建议

设计模式是工具，不是教条。优秀的程序员知道：
- 何时使用模式
- 何时不使用模式
- 如何调整模式以适应需求
- 如何在代码质量和交付速度间平衡

**记住**：做出能玩的游戏永远比做出完美的架构重要。先让游戏运行起来，再根据需要重构和优化。

---

## 附录：快速参考

### 模式速查表

| 模式 | 用途 | 何时使用 | 何时避免 |
|------|------|----------|----------|
| 命令 | 将请求封装为对象 | 需要撤销、队列、日志 | 简单的回调就够了 |
| 观察者 | 对象间一对多通知 | 需要解耦的事件系统 | 观察者很少或固定 |
| 状态 | 根据状态改变行为 | 复杂的状态转换 | 只有2-3个状态 |
| 单例 | 确保唯一实例 | 真正需要唯一性时 | 只是想要全局访问 |
| 享元 | 共享细粒度对象 | 大量相似对象 | 对象数量不多 |
| 原型 | 通过复制创建对象 | 对象创建成本高 | 对象创建简单 |

### 常见问题FAQ

**Q: 我应该学习所有的GoF模式吗？**
A: 不需要。专注于游戏开发中常用的模式。本笔记覆盖的模式已经足够应对大部分场景。

**Q: 设计模式会降低性能吗？**
A: 某些情况下会，但通常影响很小。关键是在性能关键路径上谨慎使用，并进行测量。

**Q: 什么时候应该重构代码使用模式？**
A: 当代码出现明显的重复、难以维护或难以扩展时。不要为了使用模式而重构。

**Q: 如何在团队中推广设计模式？**
A: 通过代码评审、技术分享、结对编程逐步推广。不要强制使用，而是展示其价值。

**Q: 设计模式过时了吗？**
A: 核心思想永不过时，但具体实现会随语言特性演化。现代C++提供了更多工具（如lambda、智能指针），可以更简洁地实现某些模式。

---

**学习永无止境，祝你在C++设计模式的学习之路上越走越远！**

**记住**：最好的学习方式是实践。立即开始一个项目，应用你学到的模式，在实践中不断改进和提高！
