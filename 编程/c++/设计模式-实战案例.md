# C++设计模式完整学习指南 - 实战案例

> 本文档提供完整的实战项目案例，展示设计模式在真实项目中的应用。
>
> **导航**: [← 返回主文档](./设计模式.md) | [← 高级篇](./设计模式-高级篇.md) | [性能优化 →](./设计模式-性能优化.md)

---

## 目录

1. [案例1：2D平台游戏框架](#案例1：2D平台游戏框架)
2. [案例2：粒子系统](#案例2：粒子系统)
3. [案例3：关卡编辑器](#案例3：关卡编辑器)
4. [案例4：技能系统](#案例4：技能系统)
5. [案例5：存档系统](#案例5：存档系统)

---

## 案例1：2D平台游戏框架

### 项目概述

构建一个2D平台跳跃游戏的核心框架，支持：
- 玩家控制和移动
- 敌人AI
- 可收集道具
- 平台和障碍物
- 碰撞检测

### 使用的模式

1. **游戏循环** - 主循环控制
2. **更新方法** - 游戏对象更新
3. **组件模式** - 游戏对象组成
4. **状态模式** - 角色状态管理
5. **命令模式** - 输入处理
6. **对象池** - 粒子和子弹
7. **观察者模式** - 事件系统

### 完整实现

#### 1. 核心游戏循环

```cpp
class Game {
public:
    void run() {
        initialize();

        const double FIXED_DT = 1.0 / 60.0;
        double currentTime = getTime();
        double accumulator = 0.0;

        while (running_) {
            double newTime = getTime();
            double frameTime = newTime - currentTime;

            if (frameTime > 0.25) {
                frameTime = 0.25;  // 防止死亡螺旋
            }

            currentTime = newTime;
            accumulator += frameTime;

            // 输入
            processInput();

            // 固定时间步长更新
            while (accumulator >= FIXED_DT) {
                world_.update(FIXED_DT);
                accumulator -= FIXED_DT;
            }

            // 渲染
            renderer_.render(accumulator / FIXED_DT);

            // 限制帧率
            limitFrameRate();
        }

        shutdown();
    }

private:
    void initialize() {
        // 初始化子系统
        renderer_.initialize();
        audio_.initialize();
        input_.initialize();

        // 加载关卡
        world_.loadLevel("level1.json");
    }

    void processInput() {
        input_.update();

        // 处理退出
        if (input_.isKeyPressed(KEY_ESCAPE)) {
            running_ = false;
        }

        // 转发输入到玩家
        if (player_) {
            player_->handleInput(input_);
        }
    }

    bool running_;
    World world_;
    Renderer renderer_;
    AudioEngine audio_;
    InputManager input_;
    Player* player_;
};
```

#### 2. 组件化游戏对象

```cpp
// 组件基类
class Component {
public:
    virtual ~Component() {}
    virtual void update(float dt) {}
    virtual void render() {}

    void setOwner(GameObject* owner) { owner_ = owner; }
    GameObject* getOwner() { return owner_; }

protected:
    GameObject* owner_;
};

// 游戏对象
class GameObject {
public:
    GameObject() : active_(true), position_(0, 0) {}

    virtual ~GameObject() {
        for (auto comp : components_) {
            delete comp;
        }
    }

    template<typename T>
    T* addComponent() {
        T* comp = new T();
        comp->setOwner(this);
        components_.push_back(comp);
        return comp;
    }

    template<typename T>
    T* getComponent() {
        for (auto comp : components_) {
            T* result = dynamic_cast<T*>(comp);
            if (result) return result;
        }
        return nullptr;
    }

    void update(float dt) {
        if (!active_) return;

        for (auto comp : components_) {
            comp->update(dt);
        }
    }

    void render() {
        if (!active_) return;

        for (auto comp : components_) {
            comp->render();
        }
    }

    Vector2 getPosition() const { return position_; }
    void setPosition(const Vector2& pos) { position_ = pos; }

    bool isActive() const { return active_; }
    void setActive(bool active) { active_ = active; }

private:
    std::vector<Component*> components_;
    Vector2 position_;
    bool active_;
};

// 物理组件
class PhysicsComponent : public Component {
public:
    PhysicsComponent()
        : velocity_(0, 0), acceleration_(0, 0),
          onGround_(false), mass_(1.0f) {}

    virtual void update(float dt) override {
        // 应用重力
        if (!onGround_) {
            acceleration_.y += GRAVITY;
        }

        // 更新速度和位置
        velocity_ += acceleration_ * dt;

        // 限制最大速度
        if (velocity_.x > MAX_VELOCITY) velocity_.x = MAX_VELOCITY;
        if (velocity_.x < -MAX_VELOCITY) velocity_.x = -MAX_VELOCITY;
        if (velocity_.y > MAX_FALL_SPEED) velocity_.y = MAX_FALL_SPEED;

        Vector2 newPos = owner_->getPosition() + velocity_ * dt;
        owner_->setPosition(newPos);

        // 重置加速度
        acceleration_ = Vector2(0, 0);
    }

    void applyForce(const Vector2& force) {
        acceleration_ += force / mass_;
    }

    void setVelocity(const Vector2& vel) { velocity_ = vel; }
    Vector2 getVelocity() const { return velocity_; }

    void setOnGround(bool onGround) { onGround_ = onGround; }
    bool isOnGround() const { return onGround_; }

private:
    static constexpr float GRAVITY = 980.0f;
    static constexpr float MAX_VELOCITY = 500.0f;
    static constexpr float MAX_FALL_SPEED = 1000.0f;

    Vector2 velocity_;
    Vector2 acceleration_;
    bool onGround_;
    float mass_;
};

// 渲染组件
class SpriteComponent : public Component {
public:
    SpriteComponent(const std::string& texturePath)
        : texture_(loadTexture(texturePath)),
          flip_(false) {}

    virtual void render() override {
        Vector2 pos = owner_->getPosition();
        drawSprite(texture_, pos.x, pos.y, flip_);
    }

    void setFlip(bool flip) { flip_ = flip; }

private:
    Texture texture_;
    bool flip_;
};

// 碰撞组件
class ColliderComponent : public Component {
public:
    ColliderComponent(float width, float height)
        : width_(width), height_(height) {}

    bool checkCollision(ColliderComponent* other) {
        Vector2 pos1 = owner_->getPosition();
        Vector2 pos2 = other->owner_->getPosition();

        return (pos1.x < pos2.x + other->width_ &&
                pos1.x + width_ > pos2.x &&
                pos1.y < pos2.y + other->height_ &&
                pos1.y + height_ > pos2.y);
    }

    float getWidth() const { return width_; }
    float getHeight() const { return height_; }

private:
    float width_;
    float height_;
};
```

#### 3. 玩家角色（使用状态模式）

```cpp
// 玩家状态基类
class PlayerState {
public:
    virtual ~PlayerState() {}
    virtual void enter(Player* player) {}
    virtual void exit(Player* player) {}
    virtual void update(Player* player, float dt) = 0;
    virtual void handleInput(Player* player, const InputManager& input) = 0;
};

// 站立状态
class StandingState : public PlayerState {
public:
    virtual void enter(Player* player) override {
        player->getComponent<SpriteComponent>()->setAnimation("idle");
    }

    virtual void update(Player* player, float dt) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 摩擦力
        Vector2 vel = physics->getVelocity();
        vel.x *= 0.8f;
        physics->setVelocity(vel);

        // 检查是否掉落
        if (!physics->isOnGround()) {
            player->setState(new FallingState());
        }
    }

    virtual void handleInput(Player* player, const InputManager& input) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 移动
        if (input.isKeyPressed(KEY_LEFT)) {
            player->setState(new RunningState(true));
        } else if (input.isKeyPressed(KEY_RIGHT)) {
            player->setState(new RunningState(false));
        }

        // 跳跃
        if (input.isKeyJustPressed(KEY_SPACE) && physics->isOnGround()) {
            player->setState(new JumpingState());
        }

        // 俯卧
        if (input.isKeyPressed(KEY_DOWN)) {
            player->setState(new DuckingState());
        }
    }
};

// 奔跑状态
class RunningState : public PlayerState {
public:
    RunningState(bool left) : movingLeft_(left) {}

    virtual void enter(Player* player) override {
        player->getComponent<SpriteComponent>()->setAnimation("run");
        player->getComponent<SpriteComponent>()->setFlip(movingLeft_);
    }

    virtual void update(Player* player, float dt) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 应用移动力
        float direction = movingLeft_ ? -1.0f : 1.0f;
        physics->applyForce(Vector2(direction * RUN_FORCE, 0));

        // 检查是否停止
        if (std::abs(physics->getVelocity().x) < 10.0f) {
            player->setState(new StandingState());
        }

        // 检查是否掉落
        if (!physics->isOnGround()) {
            player->setState(new FallingState());
        }
    }

    virtual void handleInput(Player* player, const InputManager& input) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 转向
        bool pressingLeft = input.isKeyPressed(KEY_LEFT);
        bool pressingRight = input.isKeyPressed(KEY_RIGHT);

        if (pressingLeft && !movingLeft_) {
            movingLeft_ = true;
            player->getComponent<SpriteComponent>()->setFlip(true);
        } else if (pressingRight && movingLeft_) {
            movingLeft_ = false;
            player->getComponent<SpriteComponent>()->setFlip(false);
        }

        // 停止移动
        if (!pressingLeft && !pressingRight) {
            player->setState(new StandingState());
        }

        // 跳跃
        if (input.isKeyJustPressed(KEY_SPACE) && physics->isOnGround()) {
            player->setState(new JumpingState());
        }
    }

private:
    static constexpr float RUN_FORCE = 3000.0f;
    bool movingLeft_;
};

// 跳跃状态
class JumpingState : public PlayerState {
public:
    virtual void enter(Player* player) override {
        auto physics = player->getComponent<PhysicsComponent>();
        physics->setVelocity(Vector2(physics->getVelocity().x, -JUMP_VELOCITY));

        player->getComponent<SpriteComponent>()->setAnimation("jump");

        // 播放跳跃音效
        AudioEngine::instance().playSound("jump.wav");
    }

    virtual void update(Player* player, float dt) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 达到最高点或开始下落
        if (physics->getVelocity().y > 0) {
            player->setState(new FallingState());
        }
    }

    virtual void handleInput(Player* player, const InputManager& input) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 空中控制
        if (input.isKeyPressed(KEY_LEFT)) {
            physics->applyForce(Vector2(-AIR_CONTROL_FORCE, 0));
        } else if (input.isKeyPressed(KEY_RIGHT)) {
            physics->applyForce(Vector2(AIR_CONTROL_FORCE, 0));
        }

        // 可变高度跳跃：松开跳跃键减小上升速度
        if (input.isKeyReleased(KEY_SPACE)) {
            Vector2 vel = physics->getVelocity();
            if (vel.y < 0) {
                vel.y *= 0.5f;
                physics->setVelocity(vel);
            }
        }
    }

private:
    static constexpr float JUMP_VELOCITY = 600.0f;
    static constexpr float AIR_CONTROL_FORCE = 1500.0f;
};

// 下落状态
class FallingState : public PlayerState {
public:
    virtual void enter(Player* player) override {
        player->getComponent<SpriteComponent>()->setAnimation("fall");
    }

    virtual void update(Player* player, float dt) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 着陆
        if (physics->isOnGround()) {
            player->setState(new StandingState());

            // 播放着陆音效
            AudioEngine::instance().playSound("land.wav");
        }
    }

    virtual void handleInput(Player* player, const InputManager& input) override {
        auto physics = player->getComponent<PhysicsComponent>();

        // 空中控制
        if (input.isKeyPressed(KEY_LEFT)) {
            physics->applyForce(Vector2(-AIR_CONTROL_FORCE, 0));
        } else if (input.isKeyPressed(KEY_RIGHT)) {
            physics->applyForce(Vector2(AIR_CONTROL_FORCE, 0));
        }
    }

private:
    static constexpr float AIR_CONTROL_FORCE = 1500.0f;
};

// 玩家类
class Player : public GameObject {
public:
    Player() : currentState_(nullptr) {
        // 添加组件
        addComponent<PhysicsComponent>();
        addComponent<SpriteComponent>("player.png");
        addComponent<ColliderComponent>(32, 48);

        // 设置初始状态
        setState(new StandingState());
    }

    ~Player() {
        delete currentState_;
    }

    void setState(PlayerState* newState) {
        if (currentState_) {
            currentState_->exit(this);
            delete currentState_;
        }

        currentState_ = newState;
        currentState_->enter(this);
    }

    void update(float dt) override {
        GameObject::update(dt);
        if (currentState_) {
            currentState_->update(this, dt);
        }
    }

    void handleInput(const InputManager& input) {
        if (currentState_) {
            currentState_->handleInput(this, input);
        }
    }

private:
    PlayerState* currentState_;
};
```

#### 4. 敌人AI（使用状态模式）

```cpp
// 敌人AI状态
class EnemyState {
public:
    virtual ~EnemyState() {}
    virtual void enter(Enemy* enemy) {}
    virtual void update(Enemy* enemy, float dt) = 0;
};

// 巡逻状态
class PatrolState : public EnemyState {
public:
    PatrolState() : patrolRight_(true) {}

    virtual void update(Enemy* enemy, float dt) override {
        auto physics = enemy->getComponent<PhysicsComponent>();

        // 检测到玩家
        if (enemy->canSeePlayer()) {
            enemy->setState(new ChaseState());
            return;
        }

        // 巡逻移动
        float direction = patrolRight_ ? 1.0f : -1.0f;
        physics->applyForce(Vector2(direction * PATROL_FORCE, 0));

        // 检测边缘或墙壁
        if (enemy->isAtEdge() || enemy->isAgainstWall()) {
            patrolRight_ = !patrolRight_;
        }
    }

private:
    static constexpr float PATROL_FORCE = 1000.0f;
    bool patrolRight_;
};

// 追击状态
class ChaseState : public EnemyState {
public:
    virtual void enter(Enemy* enemy) override {
        enemy->getComponent<SpriteComponent>()->setAnimation("angry");
    }

    virtual void update(Enemy* enemy, float dt) override {
        auto physics = enemy->getComponent<PhysicsComponent>();
        Player* player = enemy->getTargetPlayer();

        if (!player) {
            enemy->setState(new PatrolState());
            return;
        }

        // 失去视线
        if (!enemy->canSeePlayer()) {
            enemy->setState(new SearchState());
            return;
        }

        // 追击玩家
        Vector2 toPlayer = player->getPosition() - enemy->getPosition();
        float direction = (toPlayer.x > 0) ? 1.0f : -1.0f;
        physics->applyForce(Vector2(direction * CHASE_FORCE, 0));

        // 进入攻击范围
        if (toPlayer.length() < ATTACK_RANGE) {
            enemy->setState(new AttackState());
        }
    }

private:
    static constexpr float CHASE_FORCE = 2000.0f;
    static constexpr float ATTACK_RANGE = 50.0f;
};

// 攻击状态
class AttackState : public EnemyState {
public:
    AttackState() : attackTimer_(0) {}

    virtual void enter(Enemy* enemy) override {
        enemy->getComponent<SpriteComponent>()->setAnimation("attack");
        enemy->getComponent<PhysicsComponent>()->setVelocity(Vector2(0, 0));
    }

    virtual void update(Enemy* enemy, float dt) override {
        attackTimer_ += dt;

        if (attackTimer_ >= ATTACK_DURATION) {
            // 执行攻击
            enemy->performAttack();

            Player* player = enemy->getTargetPlayer();
            if (player) {
                Vector2 toPlayer = player->getPosition() - enemy->getPosition();
                if (toPlayer.length() < ATTACK_RANGE) {
                    // 继续攻击
                    attackTimer_ = 0;
                } else {
                    // 返回追击
                    enemy->setState(new ChaseState());
                }
            } else {
                enemy->setState(new PatrolState());
            }
        }
    }

private:
    static constexpr float ATTACK_DURATION = 0.5f;
    static constexpr float ATTACK_RANGE = 50.0f;
    float attackTimer_;
};

// 敌人类
class Enemy : public GameObject {
public:
    Enemy() : currentState_(nullptr), targetPlayer_(nullptr) {
        addComponent<PhysicsComponent>();
        addComponent<SpriteComponent>("enemy.png");
        addComponent<ColliderComponent>(32, 32);

        setState(new PatrolState());
    }

    ~Enemy() {
        delete currentState_;
    }

    void setState(EnemyState* newState) {
        if (currentState_) {
            delete currentState_;
        }
        currentState_ = newState;
        currentState_->enter(this);
    }

    void update(float dt) override {
        GameObject::update(dt);
        if (currentState_) {
            currentState_->update(this, dt);
        }
    }

    bool canSeePlayer() {
        if (!targetPlayer_) return false;

        Vector2 toPlayer = targetPlayer_->getPosition() - getPosition();
        return toPlayer.length() < VISION_RANGE;
    }

    bool isAtEdge() {
        // 检测前方是否有平台
        // 简化实现...
        return false;
    }

    bool isAgainstWall() {
        // 检测是否撞墙
        // 简化实现...
        return false;
    }

    void performAttack() {
        // 执行攻击逻辑
        if (targetPlayer_) {
            Vector2 toPlayer = targetPlayer_->getPosition() - getPosition();
            if (toPlayer.length() < 50.0f) {
                // 对玩家造成伤害
                EventSystem::instance().notify(Event::PLAYER_HIT, this);
            }
        }
    }

    Player* getTargetPlayer() { return targetPlayer_; }
    void setTargetPlayer(Player* player) { targetPlayer_ = player; }

private:
    static constexpr float VISION_RANGE = 300.0f;

    EnemyState* currentState_;
    Player* targetPlayer_;
};
```

#### 5. 世界和关卡管理

```cpp
class World {
public:
    void loadLevel(const std::string& filename) {
        // 清空现有对象
        clear();

        // 从JSON加载关卡
        auto json = loadJSON(filename);

        // 创建平台
        for (auto& platformData : json["platforms"]) {
            auto platform = new Platform(
                platformData["x"],
                platformData["y"],
                platformData["width"],
                platformData["height"]
            );
            addGameObject(platform);
        }

        // 创建敌人
        for (auto& enemyData : json["enemies"]) {
            auto enemy = new Enemy();
            enemy->setPosition(Vector2(enemyData["x"], enemyData["y"]));
            enemy->setTargetPlayer(player_);
            addGameObject(enemy);
        }

        // 创建道具
        for (auto& itemData : json["items"]) {
            auto item = new Collectible(itemData["type"]);
            item->setPosition(Vector2(itemData["x"], itemData["y"]));
            addGameObject(item);
        }

        // 创建玩家
        player_ = new Player();
        player_->setPosition(Vector2(json["playerStart"]["x"], json["playerStart"]["y"]));
        addGameObject(player_);
    }

    void update(float dt) {
        // 更新所有对象
        for (auto obj : gameObjects_) {
            obj->update(dt);
        }

        // 碰撞检测
        checkCollisions();

        // 移除失活对象
        removeInactiveObjects();
    }

    void render() {
        for (auto obj : gameObjects_) {
            obj->render();
        }
    }

private:
    void checkCollisions() {
        for (size_t i = 0; i < gameObjects_.size(); i++) {
            auto col1 = gameObjects_[i]->getComponent<ColliderComponent>();
            if (!col1) continue;

            for (size_t j = i + 1; j < gameObjects_.size(); j++) {
                auto col2 = gameObjects_[j]->getComponent<ColliderComponent>();
                if (!col2) continue;

                if (col1->checkCollision(col2)) {
                    handleCollision(gameObjects_[i], gameObjects_[j]);
                }
            }
        }
    }

    void handleCollision(GameObject* a, GameObject* b) {
        // 玩家与敌人
        if (dynamic_cast<Player*>(a) && dynamic_cast<Enemy*>(b)) {
            handlePlayerEnemyCollision(static_cast<Player*>(a), static_cast<Enemy*>(b));
        }

        // 玩家与道具
        if (dynamic_cast<Player*>(a) && dynamic_cast<Collectible*>(b)) {
            handlePlayerItemCollision(static_cast<Player*>(a), static_cast<Collectible*>(b));
        }

        // 更多碰撞处理...
    }

    void addGameObject(GameObject* obj) {
        gameObjects_.push_back(obj);
    }

    void removeInactiveObjects() {
        gameObjects_.erase(
            std::remove_if(gameObjects_.begin(), gameObjects_.end(),
                [](GameObject* obj) {
                    if (!obj->isActive()) {
                        delete obj;
                        return true;
                    }
                    return false;
                }),
            gameObjects_.end()
        );
    }

    void clear() {
        for (auto obj : gameObjects_) {
            delete obj;
        }
        gameObjects_.clear();
        player_ = nullptr;
    }

    std::vector<GameObject*> gameObjects_;
    Player* player_;
};
```

### 项目总结

这个2D平台游戏框架展示了多个设计模式的协同使用：

**关键设计决策**：

1. **组件模式** - 灵活的游戏对象组成
   - 优点：易于添加新功能，代码复用
   - 缺点：需要更多的内存管理

2. **状态模式** - 角色和AI状态管理
   - 优点：状态逻辑清晰分离
   - 缺点：状态较多时类数量增加

3. **固定时间步长** - 稳定的物理模拟
   - 优点：确定性，可重现
   - 缺点：需要插值才能完全平滑

**扩展建议**：

1. 添加动画系统（使用状态模式）
2. 实现更复杂的AI（行为树）
3. 添加粒子效果（对象池）
4. 实现存档系统（备忘录模式）
5. 添加UI系统（观察者模式）

---

## 案例2：粒子系统

### 项目概述

高性能粒子系统，支持：
- 数千个并发粒子
- 多种发射器类型
- 粒子属性动画
- 零垃圾回收压力

### 使用的模式

1. **对象池** - 粒子复用
2. **享元模式** - 共享粒子属性
3. **原型模式** - 复制发射器配置
4. **建造者模式** - 构建复杂粒子效果

### 完整实现

```cpp
// 粒子结构（轻量级）
struct Particle {
    Vector2 position;
    Vector2 velocity;
    Color color;
    float size;
    float lifetime;
    float age;
    bool active;

    void init(const Vector2& pos, const Vector2& vel, const Color& col,
              float sz, float life) {
        position = pos;
        velocity = vel;
        color = col;
        size = sz;
        lifetime = life;
        age = 0;
        active = true;
    }

    void update(float dt) {
        if (!active) return;

        age += dt;
        if (age >= lifetime) {
            active = false;
            return;
        }

        position += velocity * dt;
        velocity.y += 500.0f * dt;  // 重力

        // 淡出
        float alpha = 1.0f - (age / lifetime);
        color.a = static_cast<uint8_t>(255 * alpha);
    }
};

// 粒子系统（使用对象池）
class ParticleSystem {
public:
    ParticleSystem(size_t maxParticles)
        : maxParticles_(maxParticles), pool_(new Particle[maxParticles]) {
        // 初始化空闲列表
        for (size_t i = 0; i < maxParticles_ - 1; i++) {
            pool_[i].active = false;
        }
    }

    ~ParticleSystem() {
        delete[] pool_;
    }

    void spawn(const Vector2& position, const Vector2& velocity,
               const Color& color, float size, float lifetime) {
        // 从池中获取粒子
        for (size_t i = 0; i < maxParticles_; i++) {
            if (!pool_[i].active) {
                pool_[i].init(position, velocity, color, size, lifetime);
                return;
            }
        }
        // 池已满，丢弃
    }

    void update(float dt) {
        for (size_t i = 0; i < maxParticles_; i++) {
            pool_[i].update(dt);
        }
    }

    void render(Renderer& renderer) {
        for (size_t i = 0; i < maxParticles_; i++) {
            if (pool_[i].active) {
                renderer.drawParticle(pool_[i].position,
                                     pool_[i].size,
                                     pool_[i].color);
            }
        }
    }

private:
    size_t maxParticles_;
    Particle* pool_;
};

// 发射器配置（享元模式）
class EmitterConfig {
public:
    float spawnRate;          // 每秒生成数量
    float particleLifetime;   // 粒子生命周期
    float particleSize;       // 粒子大小
    Color particleColor;      // 粒子颜色
    Vector2 velocityMin;      // 最小速度
    Vector2 velocityMax;      // 最大速度
    float spread;             // 发散角度

    // 复制配置（原型模式）
    EmitterConfig* clone() const {
        return new EmitterConfig(*this);
    }
};

// 粒子发射器
class ParticleEmitter {
public:
    ParticleEmitter(ParticleSystem* system, const EmitterConfig* config)
        : system_(system), config_(config), spawnAccumulator_(0) {}

    void setPosition(const Vector2& pos) { position_ = pos; }

    void update(float dt) {
        if (!active_) return;

        spawnAccumulator_ += dt;
        float spawnInterval = 1.0f / config_->spawnRate;

        while (spawnAccumulator_ >= spawnInterval) {
            spawnParticle();
            spawnAccumulator_ -= spawnInterval;
        }
    }

    void setActive(bool active) { active_ = active; }

private:
    void spawnParticle() {
        // 随机速度
        Vector2 velocity(
            randomFloat(config_->velocityMin.x, config_->velocityMax.x),
            randomFloat(config_->velocityMin.y, config_->velocityMax.y)
        );

        // 应用发散角度
        float angle = randomFloat(-config_->spread, config_->spread);
        velocity = rotateVector(velocity, angle);

        system_->spawn(
            position_,
            velocity,
            config_->particleColor,
            config_->particleSize,
            config_->particleLifetime
        );
    }

    ParticleSystem* system_;
    const EmitterConfig* config_;
    Vector2 position_;
    float spawnAccumulator_;
    bool active_;
};

// 粒子效果建造者
class ParticleEffectBuilder {
public:
    ParticleEffectBuilder() : config_(new EmitterConfig()) {
        // 默认值
        config_->spawnRate = 30.0f;
        config_->particleLifetime = 1.0f;
        config_->particleSize = 5.0f;
        config_->particleColor = Color{255, 255, 255, 255};
        config_->velocityMin = Vector2(-100, -200);
        config_->velocityMax = Vector2(100, -100);
        config_->spread = 0.5f;
    }

    ParticleEffectBuilder& withSpawnRate(float rate) {
        config_->spawnRate = rate;
        return *this;
    }

    ParticleEffectBuilder& withLifetime(float lifetime) {
        config_->particleLifetime = lifetime;
        return *this;
    }

    ParticleEffectBuilder& withSize(float size) {
        config_->particleSize = size;
        return *this;
    }

    ParticleEffectBuilder& withColor(const Color& color) {
        config_->particleColor = color;
        return *this;
    }

    ParticleEffectBuilder& withVelocity(const Vector2& min, const Vector2& max) {
        config_->velocityMin = min;
        config_->velocityMax = max;
        return *this;
    }

    ParticleEffectBuilder& withSpread(float spread) {
        config_->spread = spread;
        return *this;
    }

    EmitterConfig* build() {
        return config_;
    }

private:
    EmitterConfig* config_;
};

// 使用示例
void createFireEffect() {
    ParticleSystem particleSystem(10000);

    // 使用建造者模式创建火焰效果
    auto fireConfig = ParticleEffectBuilder()
        .withSpawnRate(100.0f)
        .withLifetime(0.8f)
        .withSize(10.0f)
        .withColor(Color{255, 100, 0, 255})
        .withVelocity(Vector2(-50, -150), Vector2(50, -100))
        .withSpread(0.3f)
        .build();

    ParticleEmitter fireEmitter(&particleSystem, fireConfig);
    fireEmitter.setPosition(Vector2(400, 300));
    fireEmitter.setActive(true);

    // 游戏循环
    while (running) {
        fireEmitter.update(deltaTime);
        particleSystem.update(deltaTime);
        particleSystem.render(renderer);
    }
}
```

---

## 后续案例预览

由于篇幅限制，以下案例将在后续部分提供：

- **案例3：关卡编辑器** - 命令模式实现撤销/重做
- **案例4：技能系统** - 组合多个模式实现灵活的技能定义
- **案例5：存档系统** - 备忘录模式和序列化

---

## 总结

通过这些实战案例，你可以看到：

1. **模式组合** - 实际项目中通常组合使用多个模式
2. **权衡取舍** - 每个设计决策都有利弊
3. **实践出真知** - 理论知识需要通过实践巩固

**学习建议**：

1. 从简单案例开始实现
2. 逐步添加复杂性
3. 重构代码应用新模式
4. 测量性能影响
5. 记录设计决策和理由

继续阅读：
- [← 返回主文档](./设计模式.md)
- [← 高级篇](./设计模式-高级篇.md)
- [性能优化 →](./设计模式-性能优化.md)
