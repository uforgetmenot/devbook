# C++设计模式完整学习指南 - 高级篇

> 本文档是《C++设计模式完整学习指南》的高级篇，深入讲解更多设计模式和高级应用技巧。
>
> **导航**: [← 返回主文档](./设计模式.md) | [实战案例 →](./设计模式-实战案例.md) | [性能优化 →](./设计模式-性能优化.md)

---

## 目录

1. [序列模式](#序列模式)
   - 双缓冲模式
   - 游戏循环模式
   - 更新方法模式
2. [行为模式](#行为模式)
   - 字节码模式
   - 子类沙箱模式
   - 类型对象模式
3. [解耦模式](#解耦模式)
   - 组件模式
   - 事件队列模式
   - 服务定位器模式
4. [优化模式基础](#优化模式基础)
   - 数据局部性
   - 脏标记模式
   - 空间分区

---

## 第一章：序列模式 (Sequencing Patterns)

### 1.1 双缓冲模式 (Double Buffer)

#### 核心思想

使用两个缓冲区，一个用于读取，一个用于写入，在操作完成后交换它们。这样可以避免状态更新过程中的不一致问题。

#### 使用场景

1. **图形渲染** - 避免画面撕裂
2. **物理模拟** - 确保所有对象使用同一时刻的状态
3. **AI系统** - 避免更新顺序影响决策
4. **音频缓冲** - 平滑音频播放

#### 问题示例

```cpp
// 问题：对象在更新时互相影响
class Actor {
public:
    void update() {
        // 使用其他Actor的当前状态
        // 但其他Actor可能还没更新或已经更新了
        Vector force = calculateForces();
        position_ += force * deltaTime;
    }

private:
    Vector position_;
};

// 更新循环
for (auto& actor : actors) {
    actor.update();  // 顺序会影响结果！
}
```

#### 解决方案：双缓冲

```cpp
class FrameBuffer {
public:
    FrameBuffer(int width, int height)
        : width_(width), height_(height) {
        current_ = new Color[width * height];
        next_ = new Color[width * height];
    }

    ~FrameBuffer() {
        delete[] current_;
        delete[] next_;
    }

    // 读取当前帧
    Color getPixel(int x, int y) const {
        return current_[y * width_ + x];
    }

    // 写入下一帧
    void setPixel(int x, int y, Color color) {
        next_[y * width_ + x] = color;
    }

    // 交换缓冲区
    void swap() {
        Color* temp = current_;
        current_ = next_;
        next_ = temp;
    }

    // 清空下一帧缓冲区
    void clear() {
        memset(next_, 0, width_ * height_ * sizeof(Color));
    }

private:
    Color* current_;  // 当前显示的缓冲区
    Color* next_;     // 正在绘制的缓冲区
    int width_;
    int height_;
};

// 使用
void renderFrame() {
    frameBuffer.clear();

    // 绘制到next缓冲区
    for (auto& sprite : sprites) {
        sprite.draw(frameBuffer);
    }

    // 交换缓冲区，显示新帧
    frameBuffer.swap();
}
```

#### 物理引擎中的应用

```cpp
class GameObject {
public:
    void update(float deltaTime) {
        // 从当前状态读取
        velocity_ = calculateVelocity(currentState_);

        // 写入到下一个状态
        nextState_.position = currentState_.position + velocity_ * deltaTime;
        nextState_.velocity = velocity_;
    }

    void swapBuffers() {
        currentState_ = nextState_;
    }

    const State& getState() const {
        return currentState_;  // 其他对象读取的是稳定的状态
    }

private:
    struct State {
        Vector position;
        Vector velocity;
        float rotation;
    };

    State currentState_;  // 读缓冲区
    State nextState_;     // 写缓冲区
};

// 游戏循环
void gameLoop() {
    while (running) {
        // 第一阶段：所有对象更新到next缓冲区
        for (auto& obj : gameObjects) {
            obj.update(deltaTime);
        }

        // 第二阶段：交换缓冲区
        for (auto& obj : gameObjects) {
            obj.swapBuffers();
        }

        // 现在所有对象都在同一时刻
        render();
    }
}
```

#### 性能优化技巧

**技巧1：只在需要时复制**

```cpp
class SmartBuffer {
public:
    void update() {
        if (!isDirty_) {
            return;  // 没有改变，不需要交换
        }

        swap();
        isDirty_ = false;
    }

    void markDirty() {
        isDirty_ = true;
    }

private:
    bool isDirty_;
};
```

**技巧2：使用指针交换而非数据复制**

```cpp
// 好：只交换指针（O(1)）
void swap() {
    std::swap(current_, next_);
}

// 坏：复制整个缓冲区（O(n)）
void swap() {
    memcpy(current_, next_, size_);
}
```

---

### 1.2 游戏循环模式 (Game Loop)

#### 核心思想

将游戏时间的推进与用户输入和处理器速度解耦。

#### 经典游戏循环

```cpp
class GameLoop {
public:
    void run() {
        const double MS_PER_UPDATE = 16.0;  // 60 FPS
        double previous = getCurrentTime();
        double lag = 0.0;

        while (running_) {
            double current = getCurrentTime();
            double elapsed = current - previous;
            previous = current;
            lag += elapsed;

            // 处理输入
            processInput();

            // 固定时间步长更新
            while (lag >= MS_PER_UPDATE) {
                update(MS_PER_UPDATE);
                lag -= MS_PER_UPDATE;
            }

            // 渲染（使用插值）
            render(lag / MS_PER_UPDATE);
        }
    }

private:
    void processInput() {
        // 处理输入事件
    }

    void update(double deltaTime) {
        // 更新游戏状态
        physics_.update(deltaTime);
        gameObjects_.update(deltaTime);
        ai_.update(deltaTime);
    }

    void render(double interpolation) {
        // 渲染当前帧
        // interpolation用于平滑显示
    }

    bool running_;
    Physics physics_;
    GameObjects gameObjects_;
    AI ai_;
};
```

#### 不同的时间步长策略

**策略1：固定时间步长**

```cpp
void fixedTimeStep() {
    const float FIXED_DT = 1.0f / 60.0f;

    while (running) {
        update(FIXED_DT);
        render();
        waitUntilNextFrame();  // 限制帧率
    }
}
```

优点：
- 确定性，便于调试
- 物理模拟稳定

缺点：
- 快速机器会空等
- 慢速机器会卡顿

**策略2：可变时间步长**

```cpp
void variableTimeStep() {
    double lastTime = getCurrentTime();

    while (running) {
        double currentTime = getCurrentTime();
        double deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        update(deltaTime);
        render();
    }
}
```

优点：
- 适应不同速度的硬件
- 流畅

缺点：
- 不确定性
- 物理模拟可能不稳定
- 时间步长过大时会出问题

**策略3：固定更新，可变渲染（推荐）**

```cpp
void hybridTimeStep() {
    const double FIXED_DT = 1.0 / 60.0;
    double currentTime = getCurrentTime();
    double accumulator = 0.0;

    while (running) {
        double newTime = getCurrentTime();
        double frameTime = newTime - currentTime;

        // 限制最大帧时间，防止"死亡螺旋"
        if (frameTime > 0.25) {
            frameTime = 0.25;
        }

        currentTime = newTime;
        accumulator += frameTime;

        // 固定时间步长更新
        while (accumulator >= FIXED_DT) {
            update(FIXED_DT);
            accumulator -= FIXED_DT;
        }

        // 渲染（可以使用插值）
        const double alpha = accumulator / FIXED_DT;
        render(alpha);
    }
}
```

#### 插值渲染

```cpp
class Sprite {
public:
    void update(float dt) {
        previousPosition_ = currentPosition_;
        currentPosition_ += velocity_ * dt;
    }

    Vector getRenderPosition(float alpha) const {
        // 在当前位置和上一帧位置之间插值
        return previousPosition_ * (1.0f - alpha) + currentPosition_ * alpha;
    }

private:
    Vector previousPosition_;
    Vector currentPosition_;
    Vector velocity_;
};

void render(float alpha) {
    for (auto& sprite : sprites) {
        Vector pos = sprite.getRenderPosition(alpha);
        drawSprite(sprite, pos);
    }
}
```

---

### 1.3 更新方法模式 (Update Method)

#### 核心思想

通过每帧调用一次更新方法来模拟独立对象的行为。

#### 基本实现

```cpp
class GameObject {
public:
    virtual ~GameObject() {}
    virtual void update(float deltaTime) = 0;
};

class Enemy : public GameObject {
public:
    virtual void update(float deltaTime) override {
        // 更新AI
        ai_.update(deltaTime);

        // 更新动画
        animation_.update(deltaTime);

        // 更新物理
        position_ += velocity_ * deltaTime;
    }

private:
    AI ai_;
    Animation animation_;
    Vector position_;
    Vector velocity_;
};

// 游戏世界
class World {
public:
    void update(float deltaTime) {
        for (auto obj : gameObjects_) {
            obj->update(deltaTime);
        }
    }

private:
    std::vector<GameObject*> gameObjects_;
};
```

#### 更新顺序的重要性

```cpp
// 问题：更新顺序会影响结果
void updateBad() {
    player.update();      // 玩家攻击敌人
    enemy.update();       // 敌人还没意识到被攻击
    physics.update();     // 应用伤害
}

// 解决方案：分阶段更新
void updateGood() {
    // 阶段1：处理输入和AI决策
    for (auto obj : gameObjects) {
        obj->processInput();
    }

    // 阶段2：更新物理
    physics.update();

    // 阶段3：响应碰撞和交互
    for (auto obj : gameObjects) {
        obj->handleCollisions();
    }

    // 阶段4：更新动画
    for (auto obj : gameObjects) {
        obj->updateAnimation();
    }
}
```

#### 跳过失活对象

```cpp
class World {
public:
    void update(float deltaTime) {
        for (auto obj : gameObjects_) {
            if (obj->isActive()) {
                obj->update(deltaTime);
            }
        }
    }
};

class GameObject {
public:
    bool isActive() const { return active_; }
    void setActive(bool active) { active_ = active; }

    virtual void update(float deltaTime) {
        if (!active_) return;
        // 更新逻辑
    }

private:
    bool active_;
};
```

#### 休眠对象优化

```cpp
class GameObject {
public:
    void update(float deltaTime) {
        if (shouldSleep()) {
            sleep();
            return;
        }

        if (sleeping_) {
            wakeUp();
        }

        // 正常更新
        doUpdate(deltaTime);
    }

private:
    bool shouldSleep() const {
        // 根据条件判断是否应该休眠
        return velocity_.lengthSquared() < SLEEP_THRESHOLD &&
               timeSinceLastInteraction_ > SLEEP_DELAY;
    }

    void sleep() {
        sleeping_ = true;
        // 从活动列表移到休眠列表
    }

    void wakeUp() {
        sleeping_ = false;
        // 从休眠列表移回活动列表
    }

    bool sleeping_;
    Vector velocity_;
    float timeSinceLastInteraction_;
};
```

---

## 第二章：行为模式 (Behavioral Patterns)

### 2.1 字节码模式 (Bytecode)

#### 核心思想

将行为编码为虚拟机指令，实现数据驱动的行为定义。

#### 使用场景

1. **脚本系统** - 让非程序员定义游戏行为
2. **技能系统** - 灵活定义技能效果
3. **关卡脚本** - 定义关卡事件序列
4. **AI行为树** - 用数据定义AI逻辑

#### 简单虚拟机实现

```cpp
enum Instruction {
    INST_SET_HEALTH,
    INST_SET_WISDOM,
    INST_SET_AGILITY,
    INST_PLAY_SOUND,
    INST_SPAWN_PARTICLES,
    INST_LITERAL,
    INST_ADD,
    INST_DIVIDE
};

class VM {
public:
    void interpret(const uint8_t* bytecode) {
        int stackSize = 0;
        int stack[MAX_STACK];

        for (;;) {
            uint8_t instruction = *bytecode++;

            switch (instruction) {
                case INST_LITERAL: {
                    int value = *bytecode++;
                    stack[stackSize++] = value;
                    break;
                }

                case INST_ADD: {
                    int b = stack[--stackSize];
                    int a = stack[--stackSize];
                    stack[stackSize++] = a + b;
                    break;
                }

                case INST_SET_HEALTH: {
                    int value = stack[--stackSize];
                    setHealth(value);
                    break;
                }

                case INST_PLAY_SOUND: {
                    int soundId = stack[--stackSize];
                    playSound(soundId);
                    break;
                }

                // 更多指令...
            }
        }
    }

private:
    void setHealth(int value) { /* ... */ }
    void playSound(int id) { /* ... */ }
};
```

#### 技能系统示例

```cpp
class SkillVM {
public:
    struct Skill {
        std::vector<uint8_t> bytecode;
        std::string name;
        int manaCost;
    };

    void executeSkill(const Skill& skill, GameObject* caster, GameObject* target) {
        context_.caster = caster;
        context_.target = target;
        interpret(skill.bytecode.data());
    }

private:
    struct Context {
        GameObject* caster;
        GameObject* target;
        int damage;
        Vector targetPosition;
    };

    Context context_;

    void interpret(const uint8_t* code) {
        const uint8_t* pc = code;  // Program Counter

        while (*pc != INST_END) {
            switch (*pc++) {
                case INST_CALCULATE_DAMAGE: {
                    int baseDamage = readInt(pc);
                    int multiplier = readInt(pc);
                    context_.damage = baseDamage * multiplier;
                    break;
                }

                case INST_APPLY_DAMAGE: {
                    context_.target->takeDamage(context_.damage);
                    break;
                }

                case INST_SPAWN_EFFECT: {
                    int effectId = readInt(pc);
                    spawnEffect(effectId, context_.targetPosition);
                    break;
                }

                case INST_HEAL: {
                    int amount = readInt(pc);
                    context_.caster->heal(amount);
                    break;
                }

                case INST_IF_HEALTH_BELOW: {
                    int threshold = readInt(pc);
                    int jumpOffset = readInt(pc);
                    if (context_.target->getHealth() < threshold) {
                        pc += jumpOffset;
                    }
                    break;
                }
            }
        }
    }

    int readInt(const uint8_t*& pc) {
        int value = *reinterpret_cast<const int*>(pc);
        pc += sizeof(int);
        return value;
    }
};

// 定义技能
// 火球术：造成100点伤害，消耗50法力，播放火焰特效
Skill fireball = {
    {
        INST_CALCULATE_DAMAGE, 100, 1,
        INST_APPLY_DAMAGE,
        INST_SPAWN_EFFECT, EFFECT_FIRE,
        INST_END
    },
    "Fireball",
    50
};

// 吸血术：造成50伤害，治疗施法者25点生命
Skill lifeDrain = {
    {
        INST_CALCULATE_DAMAGE, 50, 1,
        INST_APPLY_DAMAGE,
        INST_HEAL, 25,
        INST_SPAWN_EFFECT, EFFECT_DARK,
        INST_END
    },
    "Life Drain",
    30
};
```

#### 从脚本编译到字节码

```cpp
class SkillCompiler {
public:
    std::vector<uint8_t> compile(const std::string& script) {
        std::vector<uint8_t> bytecode;
        auto tokens = tokenize(script);

        for (const auto& token : tokens) {
            if (token == "damage") {
                bytecode.push_back(INST_CALCULATE_DAMAGE);
                bytecode.push_back(getNextInt());
                bytecode.push_back(1);
            } else if (token == "heal") {
                bytecode.push_back(INST_HEAL);
                bytecode.push_back(getNextInt());
            } else if (token == "effect") {
                bytecode.push_back(INST_SPAWN_EFFECT);
                bytecode.push_back(getEffectId(getNextToken()));
            }
        }

        bytecode.push_back(INST_END);
        return bytecode;
    }

private:
    std::vector<std::string> tokenize(const std::string& script);
    int getNextInt();
    std::string getNextToken();
    int getEffectId(const std::string& name);
};

// 使用
SkillCompiler compiler;
auto bytecode = compiler.compile("damage 100 effect fire");
Skill skill = { bytecode, "Custom Spell", 50 };
```

---

### 2.2 子类沙箱模式 (Subclass Sandbox)

#### 核心思想

定义一个基类，提供一组受保护的操作方法，派生类通过组合这些操作来实现自己的行为。

#### 使用场景

1. **技能系统** - 每个技能组合基础效果
2. **怪物AI** - 不同怪物组合基础行为
3. **武器系统** - 武器效果组合
4. **粒子效果** - 组合基础粒子行为

#### 基本实现

```cpp
class Superpower {
public:
    virtual ~Superpower() {}

    // 模板方法
    void activate() {
        // 预处理
        if (!canActivate()) {
            return;
        }

        consumeEnergy();

        // 派生类实现具体效果
        performEffect();

        // 后处理
        playActivationSound();
        startCooldown();
    }

protected:
    // 沙箱方法：派生类可用的操作
    void move(double x, double y, double z) {
        // 移动角色
    }

    void playSound(SoundId sound, double volume) {
        // 播放声音
    }

    void spawnParticles(ParticleType type) {
        // 生成粒子
    }

    void createExplosion(const Vector& position, float radius, float damage) {
        // 创建爆炸
    }

    void applyBuff(BuffType buff, float duration) {
        // 应用增益效果
    }

    void shootProjectile(const Vector& direction, float speed) {
        // 发射投射物
    }

    GameObject* findNearestEnemy(float radius) {
        // 查找最近的敌人
    }

    // 派生类必须实现
    virtual void performEffect() = 0;

    // 可选的钩子方法
    virtual bool canActivate() { return energy_ >= energyCost_; }
    virtual void consumeEnergy() { energy_ -= energyCost_; }
    virtual void playActivationSound() { playSound(activationSound_, 1.0f); }
    virtual void startCooldown() { cooldownTimer_ = cooldownDuration_; }

private:
    float energy_;
    float energyCost_;
    float cooldownTimer_;
    float cooldownDuration_;
    SoundId activationSound_;
};

// 具体技能：震地
class GroundSlam : public Superpower {
protected:
    virtual void performEffect() override {
        // 1. 播放动画
        move(0, -5, 0);  // 下蹲

        // 2. 创建震波
        spawnParticles(PARTICLE_SHOCKWAVE);

        // 3. 对范围内敌人造成伤害
        auto enemies = findEnemiesInRadius(10.0f);
        for (auto enemy : enemies) {
            enemy->takeDamage(50);
            enemy->knockback(enemyPos - playerPos);
        }

        // 4. 播放音效
        playSound(SOUND_EARTHQUAKE, 1.0f);

        // 5. 屏幕震动
        shake(0.5f, 0.3f);
    }
};

// 具体技能：瞬移
class Teleport : public Superpower {
protected:
    virtual void performEffect() override {
        // 1. 保存当前位置
        Vector oldPos = getPosition();

        // 2. 粒子效果
        spawnParticles(PARTICLE_TELEPORT_OUT);

        // 3. 移动到目标位置
        Vector targetPos = getCursorPosition();
        move(targetPos.x, targetPos.y, targetPos.z);

        // 4. 到达粒子效果
        spawnParticles(PARTICLE_TELEPORT_IN);

        // 5. 短暂无敌
        applyBuff(BUFF_INVULNERABLE, 0.5f);
    }

    virtual bool canActivate() override {
        if (!Superpower::canActivate()) {
            return false;
        }

        // 额外检查：目标位置是否可达
        Vector targetPos = getCursorPosition();
        return isPositionValid(targetPos);
    }
};

// 具体技能：火球
class Fireball : public Superpower {
protected:
    virtual void performEffect() override {
        // 1. 计算方向
        Vector direction = getAimDirection();

        // 2. 发射火球
        shootProjectile(direction, 20.0f);

        // 3. 火焰轨迹
        spawnParticles(PARTICLE_FIRE_TRAIL);

        // 4. 发射音效
        playSound(SOUND_FIRE_WHOOSH, 0.8f);
    }

    // 火球有连发机制
    virtual void startCooldown() override {
        if (consecutiveShots_ < 3) {
            cooldownTimer_ = 0.2f;  // 短冷却
            consecutiveShots_++;
        } else {
            cooldownTimer_ = 3.0f;  // 长冷却
            consecutiveShots_ = 0;
        }
    }

private:
    int consecutiveShots_;
};
```

#### 优点

1. **易于添加新行为** - 只需继承并组合已有操作
2. **代码复用** - 所有技能共享基础操作
3. **一致性** - 所有技能遵循相同的激活流程
4. **安全** - 派生类只能使用受保护的操作

#### 注意事项

**避免过度膨胀基类**：

```cpp
// 不好：基类提供太多操作
class Superpower {
protected:
    void method1();
    void method2();
    // ... 100个方法
    void method100();
};

// 好：按类别组织
class Superpower {
protected:
    Audio& getAudio() { return audio_; }
    Physics& getPhysics() { return physics_; }
    Graphics& getGraphics() { return graphics_; }

private:
    Audio audio_;
    Physics physics_;
    Graphics graphics_;
};

class Fireball : public Superpower {
    virtual void performEffect() override {
        getAudio().playSound(SOUND_FIRE);
        getPhysics().shootProjectile(...);
        getGraphics().spawnParticles(...);
    }
};
```

---

### 2.3 类型对象模式 (Type Object)

#### 核心思想

创建一个类来支持新类型的灵活创建，每个类型的实例都引用同一个类型对象。

#### 使用场景

1. **怪物类型** - 不同种类的怪物共享属性模板
2. **装备系统** - 装备类型定义基础属性
3. **建筑系统** - 建筑类型定义蓝图
4. **单位系统** - RTS游戏中的单位类型

#### 问题：类爆炸

```cpp
// 糟糕的做法：每种怪物都是一个类
class Dragon : public Monster { /* ... */ };
class Troll : public Monster { /* ... */ };
class Goblin : public Monster { /* ... */ };
// ... 100种怪物 = 100个类
```

#### 解决方案：类型对象

```cpp
// 怪物类型（共享的模板）
class Breed {
public:
    Breed(int health, const std::string& attack, int damage)
        : health_(health), attack_(attack), damage_(damage) {}

    int getHealth() const { return health_; }
    const std::string& getAttack() const { return attack_; }
    int getDamage() const { return damage_; }

private:
    int health_;           // 基础生命值
    std::string attack_;   // 攻击方式描述
    int damage_;           // 基础伤害
};

// 怪物实例（引用类型）
class Monster {
public:
    Monster(Breed* breed)
        : breed_(breed),
          health_(breed->getHealth()) {}

    void attack(Monster* target) {
        std::cout << "使用 " << breed_->getAttack() << " 攻击!\n";
        target->takeDamage(breed_->getDamage());
    }

    void takeDamage(int damage) {
        health_ -= damage;
    }

    int getHealth() const { return health_; }

private:
    Breed* breed_;    // 指向类型对象
    int health_;      // 当前生命值（实例特定）
};

// 使用
int main() {
    // 定义怪物类型
    Breed dragon(230, "火焰吐息", 50);
    Breed troll(48, "巨拳", 15);
    Breed goblin(20, "匕首", 8);

    // 创建怪物实例
    Monster dragon1(&dragon);
    Monster dragon2(&dragon);  // 共享类型
    Monster troll1(&troll);
    Monster goblin1(&goblin);

    dragon1.attack(&goblin1);
}
```

#### 高级：继承类型对象

```cpp
class Breed {
public:
    Breed(Breed* parent, int health, const std::string& attack, int damage)
        : parent_(parent),
          health_(health),
          attack_(attack),
          damage_(damage) {}

    int getHealth() const {
        // 如果自己没定义，使用父类型的值
        if (health_ != 0 || parent_ == nullptr) {
            return health_;
        }
        return parent_->getHealth();
    }

    const std::string& getAttack() const {
        if (!attack_.empty() || parent_ == nullptr) {
            return attack_;
        }
        return parent_->getAttack();
    }

private:
    Breed* parent_;
    int health_;
    std::string attack_;
    int damage_;
};

// 使用继承
Breed base(nullptr, 100, "撕咬", 10);
Breed dragon(&base, 230, "火焰吐息", 50);  // 继承base，覆盖属性
Breed redDragon(&dragon, 0, "", 80);       // 继承dragon，只改伤害
```

#### 数据驱动的类型定义

```cpp
class BreedManager {
public:
    void loadFromJSON(const std::string& filename) {
        auto json = parseJSON(filename);

        for (auto& breedData : json["breeds"]) {
            std::string name = breedData["name"];
            int health = breedData["health"];
            std::string attack = breedData["attack"];
            int damage = breedData["damage"];

            Breed* parent = nullptr;
            if (breedData.contains("parent")) {
                parent = getBreed(breedData["parent"]);
            }

            breeds_[name] = new Breed(parent, health, attack, damage);
        }
    }

    Breed* getBreed(const std::string& name) {
        return breeds_[name];
    }

private:
    std::map<std::string, Breed*> breeds_;
};

// JSON配置文件
// {
//   "breeds": [
//     {
//       "name": "base_monster",
//       "health": 100,
//       "attack": "撕咬",
//       "damage": 10
//     },
//     {
//       "name": "dragon",
//       "parent": "base_monster",
//       "health": 230,
//       "attack": "火焰吐息",
//       "damage": 50
//     },
//     {
//       "name": "red_dragon",
//       "parent": "dragon",
//       "damage": 80
//     }
//   ]
// }
```

---

## 第三章：解耦模式 (Decoupling Patterns)

### 3.1 组件模式 (Component)

#### 核心思想

允许一个实体跨多个领域而不让这些领域彼此耦合。将一个对象分解为多个组件，每个组件负责一个方面。

#### 问题：上帝对象

```cpp
// 糟糕：一个类做所有事情
class GameObject {
public:
    void update() {
        // 更新物理
        velocity_ += acceleration_ * deltaTime;
        position_ += velocity_ * deltaTime;

        // 更新动画
        animation_.update();

        // 更新AI
        if (isEnemy) {
            findTarget();
            moveTowardsTarget();
        }

        // 更新渲染
        mesh_.update();
        updateShader();

        // 更新音频
        updateFootsteps();
        updateAmbientSounds();

        // 更新输入
        if (isPlayer) {
            handleInput();
        }
    }

private:
    // 物理
    Vector position_, velocity_, acceleration_;

    // 动画
    Animation animation_;

    // AI
    bool isEnemy;
    GameObject* target_;

    // 渲染
    Mesh mesh_;
    Shader shader_;

    // 音频
    Sound footsteps_, ambient_;

    // 输入
    bool isPlayer;

    // ... 更多字段
};
```

#### 解决方案：组件模式

```cpp
// 基础组件接口
class Component {
public:
    virtual ~Component() {}
    virtual void update(float deltaTime) = 0;
    virtual void render() {}
};

// 游戏对象只是组件的容器
class GameObject {
public:
    void addComponent(Component* component) {
        components_.push_back(component);
    }

    template<typename T>
    T* getComponent() {
        for (auto comp : components_) {
            T* result = dynamic_cast<T*>(comp);
            if (result) {
                return result;
            }
        }
        return nullptr;
    }

    void update(float deltaTime) {
        for (auto comp : components_) {
            comp->update(deltaTime);
        }
    }

    void render() {
        for (auto comp : components_) {
            comp->render();
        }
    }

private:
    std::vector<Component*> components_;
};

// 具体组件
class PhysicsComponent : public Component {
public:
    virtual void update(float deltaTime) override {
        velocity_ += acceleration_ * deltaTime;
        position_ += velocity_ * deltaTime;
    }

    Vector getPosition() const { return position_; }
    void setPosition(const Vector& pos) { position_ = pos; }

private:
    Vector position_;
    Vector velocity_;
    Vector acceleration_;
};

class GraphicsComponent : public Component {
public:
    GraphicsComponent(const std::string& meshFile)
        : mesh_(loadMesh(meshFile)) {}

    virtual void render() override {
        drawMesh(mesh_, getGameObject()->getComponent<PhysicsComponent>()->getPosition());
    }

private:
    Mesh mesh_;
};

class InputComponent : public Component {
public:
    virtual void update(float deltaTime) override {
        if (isKeyPressed(KEY_LEFT)) {
            auto physics = getGameObject()->getComponent<PhysicsComponent>();
            physics->applyForce(Vector(-10, 0, 0));
        }
        if (isKeyPressed(KEY_RIGHT)) {
            auto physics = getGameObject()->getComponent<PhysicsComponent>();
            physics->applyForce(Vector(10, 0, 0));
        }
    }
};

// 使用：组合不同组件创建不同类型的对象
GameObject* createPlayer() {
    auto player = new GameObject();
    player->addComponent(new PhysicsComponent());
    player->addComponent(new GraphicsComponent("player.mesh"));
    player->addComponent(new InputComponent());
    player->addComponent(new AnimationComponent());
    return player;
}

GameObject* createEnemy() {
    auto enemy = new GameObject();
    enemy->addComponent(new PhysicsComponent());
    enemy->addComponent(new GraphicsComponent("enemy.mesh"));
    enemy->addComponent(new AIComponent());
    enemy->addComponent(new AnimationComponent());
    return enemy;
}

GameObject* createStaticProp() {
    auto prop = new GameObject();
    prop->addComponent(new GraphicsComponent("prop.mesh"));
    // 静态物体只需要渲染，不需要物理和AI
    return prop;
}
```

#### 组件间通信

**方法1：直接引用其他组件**

```cpp
class AIComponent : public Component {
public:
    virtual void update(float deltaTime) override {
        auto physics = getGameObject()->getComponent<PhysicsComponent>();
        auto target = findTarget();

        if (target) {
            Vector direction = target->getPosition() - physics->getPosition();
            physics->setVelocity(direction.normalize() * speed_);
        }
    }

private:
    GameObject* findTarget();
    float speed_;
};
```

**方法2：消息系统**

```cpp
struct Message {
    enum Type {
        COLLISION,
        HEALTH_CHANGED,
        DEATH
    };

    Type type;
    void* data;
};

class Component {
public:
    virtual void receiveMessage(const Message& msg) {}
};

class GameObject {
public:
    void sendMessage(const Message& msg) {
        for (auto comp : components_) {
            comp->receiveMessage(msg);
        }
    }
};

class HealthComponent : public Component {
public:
    void takeDamage(int damage) {
        health_ -= damage;

        // 通知其他组件
        Message msg;
        msg.type = Message::HEALTH_CHANGED;
        msg.data = &health_;
        getGameObject()->sendMessage(msg);

        if (health_ <= 0) {
            Message deathMsg;
            deathMsg.type = Message::DEATH;
            getGameObject()->sendMessage(deathMsg);
        }
    }

    virtual void receiveMessage(const Message& msg) override {
        if (msg.type == Message::COLLISION) {
            takeDamage(10);
        }
    }

private:
    int health_;
};

class AnimationComponent : public Component {
public:
    virtual void receiveMessage(const Message& msg) override {
        if (msg.type == Message::DEATH) {
            playAnimation("death");
        } else if (msg.type == Message::HEALTH_CHANGED) {
            playAnimation("hurt");
        }
    }
};
```

---

### 3.2 事件队列模式 (Event Queue)

#### 核心思想

解耦发送消息或事件的时间和处理它的时间。

#### 使用场景

1. **音频系统** - 避免同时播放太多声音
2. **网络消息** - 批量处理网络事件
3. **GUI事件** - 鼠标点击、键盘输入
4. **游戏事件** - 成就解锁、任务完成

#### 基本实现

```cpp
struct Event {
    enum Type {
        SOUND_PLAY,
        PARTICLE_SPAWN,
        ENTITY_SPAWN,
        ACHIEVEMENT_UNLOCK
    };

    Type type;

    union {
        struct {
            SoundId soundId;
            float volume;
        } sound;

        struct {
            ParticleType particleType;
            Vector position;
        } particle;

        struct {
            int entityType;
            Vector position;
        } entity;

        struct {
            AchievementId id;
        } achievement;
    };
};

class EventQueue {
public:
    EventQueue() : head_(0), tail_(0) {}

    void post(const Event& event) {
        assert((tail_ + 1) % MAX_EVENTS != head_);  // 队列满
        events_[tail_] = event;
        tail_ = (tail_ + 1) % MAX_EVENTS;
    }

    bool poll(Event& event) {
        if (head_ == tail_) {
            return false;  // 队列空
        }

        event = events_[head_];
        head_ = (head_ + 1) % MAX_EVENTS;
        return true;
    }

private:
    static const int MAX_EVENTS = 256;
    Event events_[MAX_EVENTS];
    int head_;
    int tail_;
};

// 使用
EventQueue audioQueue;

// 发送事件
void playSound(SoundId sound, float volume) {
    Event event;
    event.type = Event::SOUND_PLAY;
    event.sound.soundId = sound;
    event.sound.volume = volume;
    audioQueue.post(event);
}

// 处理事件
void AudioEngine::update() {
    const int MAX_SOUNDS_PER_FRAME = 10;
    int soundsPlayed = 0;

    Event event;
    while (audioQueue.poll(event) && soundsPlayed < MAX_SOUNDS_PER_FRAME) {
        if (event.type == Event::SOUND_PLAY) {
            actuallyPlaySound(event.sound.soundId, event.sound.volume);
            soundsPlayed++;
        }
    }
}
```

#### 带优先级的事件队列

```cpp
struct PriorityEvent {
    Event event;
    int priority;

    bool operator<(const PriorityEvent& other) const {
        return priority < other.priority;
    }
};

class PriorityEventQueue {
public:
    void post(const Event& event, int priority) {
        PriorityEvent pe;
        pe.event = event;
        pe.priority = priority;
        queue_.push(pe);
    }

    bool poll(Event& event) {
        if (queue_.empty()) {
            return false;
        }

        event = queue_.top().event;
        queue_.pop();
        return true;
    }

private:
    std::priority_queue<PriorityEvent> queue_;
};
```

#### 延迟事件

```cpp
struct TimedEvent {
    Event event;
    float triggerTime;
};

class TimedEventQueue {
public:
    void schedule(const Event& event, float delay) {
        TimedEvent te;
        te.event = event;
        te.triggerTime = currentTime_ + delay;
        events_.push_back(te);
    }

    void update(float deltaTime) {
        currentTime_ += deltaTime;

        auto it = events_.begin();
        while (it != events_.end()) {
            if (it->triggerTime <= currentTime_) {
                processEvent(it->event);
                it = events_.erase(it);
            } else {
                ++it;
            }
        }
    }

private:
    float currentTime_;
    std::vector<TimedEvent> events_;
};

// 使用
eventQueue.schedule(explosionEvent, 2.0f);  // 2秒后爆炸
```

---

### 3.3 服务定位器模式 (Service Locator)

#### 核心思想

提供服务的全局访问点，而不耦合到服务的具体类。

#### 基本实现

```cpp
class Audio {
public:
    virtual ~Audio() {}
    virtual void playSound(SoundId id) = 0;
    virtual void stopSound(SoundId id) = 0;
    virtual void stopAllSounds() = 0;
};

class ServiceLocator {
public:
    static Audio& getAudio() { return *audio_; }

    static void provideAudio(Audio* audio) {
        audio_ = audio;
    }

private:
    static Audio* audio_;
};

Audio* ServiceLocator::audio_ = nullptr;

// 使用
int main() {
    ConsoleAudio audio;
    ServiceLocator::provideAudio(&audio);

    // 游戏代码可以直接使用
    ServiceLocator::getAudio().playSound(SOUND_EXPLOSION);
}
```

#### 空服务模式

```cpp
class NullAudio : public Audio {
public:
    virtual void playSound(SoundId id) override { /* 什么也不做 */ }
    virtual void stopSound(SoundId id) override { /* 什么也不做 */ }
    virtual void stopAllSounds() override { /* 什么也不做 */ }
};

class ServiceLocator {
public:
    static void initialize() {
        audio_ = &nullAudio_;
    }

    static Audio& getAudio() {
        return *audio_;
    }

    static void provideAudio(Audio* audio) {
        if (audio == nullptr) {
            audio_ = &nullAudio_;
        } else {
            audio_ = audio;
        }
    }

private:
    static NullAudio nullAudio_;
    static Audio* audio_;
};

NullAudio ServiceLocator::nullAudio_;
Audio* ServiceLocator::audio_ = &ServiceLocator::nullAudio_;
```

#### 运行时切换服务

```cpp
class ServiceLocator {
public:
    static Audio& getAudio() { return *audio_; }

    static void provideAudio(Audio* audio) {
        if (audio_ != nullptr) {
            audio_->stopAllSounds();  // 停止旧服务
        }
        audio_ = (audio != nullptr) ? audio : &nullAudio_;
    }

private:
    static NullAudio nullAudio_;
    static Audio* audio_;
};

// 使用：在游戏中途切换音频引擎
void switchToOpenAL() {
    OpenALAudio* openAL = new OpenALAudio();
    ServiceLocator::provideAudio(openAL);
}

void muteAudio() {
    ServiceLocator::provideAudio(nullptr);  // 切换到空服务
}
```

---

## 第四章：优化模式基础

### 4.1 数据局部性 (Data Locality)

#### 核心思想

合理安排数据以利用CPU缓存，提高访问速度。

#### 问题：缓存失效

```cpp
// 不好：指针跳转导致缓存失效
class GameEntity {
public:
    void update() { ai_->update(); }

private:
    AI* ai_;
    Physics* physics_;
    Render* render_;
};

std::vector<GameEntity*> entities;

void updateAll() {
    for (auto entity : entities) {
        entity->update();  // 每次都跟随指针，缓存失效
    }
}
```

#### 解决方案：连续数据

```cpp
// 好：数据连续存储
class AIComponent {
public:
    void update() { /* AI逻辑 */ }
};

class AIComponentArray {
public:
    void update() {
        for (int i = 0; i < numComponents_; i++) {
            components_[i].update();  // 连续内存，缓存友好
        }
    }

private:
    static const int MAX_COMPONENTS = 1000;
    AIComponent components_[MAX_COMPONENTS];
    int numComponents_;
};
```

#### 热/冷数据分离

```cpp
// 不好：混合热数据和冷数据
class Entity {
    Vector position_;      // 热：每帧访问
    Vector velocity_;      // 热：每帧访问
    Mesh* mesh_;          // 冷：偶尔访问
    Texture* texture_;    // 冷：偶尔访问
    std::string name_;    // 冷：很少访问
    int debugId_;         // 冷：只在调试时用
};

// 好：分离热数据和冷数据
class EntityData {
    Vector position_;
    Vector velocity_;
    int renderDataIndex_;  // 指向冷数据的索引
};

class RenderData {
    Mesh* mesh_;
    Texture* texture_;
    std::string name_;
};
```

---

### 4.2 脏标记模式 (Dirty Flag)

#### 核心思想

避免不必要的工作，直到结果真正需要时才计算。

#### 实现

```cpp
class Transform {
public:
    void setPosition(const Vector& pos) {
        position_ = pos;
        dirty_ = true;
    }

    const Matrix& getWorldTransform() {
        if (dirty_) {
            worldTransform_ = calculateWorldTransform();
            dirty_ = false;
        }
        return worldTransform_;
    }

private:
    Vector position_;
    Vector rotation_;
    Vector scale_;

    Matrix worldTransform_;
    bool dirty_;
};
```

---

### 4.3 空间分区 (Spatial Partition)

#### 核心思想

将对象存储在按位置组织的数据结构中，高效查找对象。

#### 简单网格实现

```cpp
class Grid {
public:
    Grid() {
        for (int i = 0; i < NUM_CELLS; i++) {
            cells_[i] = nullptr;
        }
    }

    void add(Unit* unit) {
        int cellIndex = getCellIndex(unit->getPosition());
        unit->next_ = cells_[cellIndex];
        cells_[cellIndex] = unit;
    }

    std::vector<Unit*> getUnitsNear(const Vector& position, float radius) {
        std::vector<Unit*> nearby;
        int cellIndex = getCellIndex(position);

        Unit* unit = cells_[cellIndex];
        while (unit != nullptr) {
            if (distance(unit->getPosition(), position) < radius) {
                nearby.push_back(unit);
            }
            unit = unit->next_;
        }

        return nearby;
    }

private:
    static const int GRID_SIZE = 100;
    static const int NUM_CELLS = GRID_SIZE * GRID_SIZE;
    Unit* cells_[NUM_CELLS];

    int getCellIndex(const Vector& pos) {
        int x = static_cast<int>(pos.x / CELL_SIZE);
        int y = static_cast<int>(pos.y / CELL_SIZE);
        return y * GRID_SIZE + x;
    }
};
```

---

## 总结

本高级篇深入讲解了：

1. **序列模式** - 管理时间和更新顺序
2. **行为模式** - 灵活定义对象行为
3. **解耦模式** - 降低系统间耦合
4. **优化模式** - 提升性能的技巧

继续学习请查看：
- [← 返回主文档](./设计模式.md)
- [实战案例 →](./设计模式-实战案例.md)
- [性能优化 →](./设计模式-性能优化.md)
