# GD32微控制器完整学习指南

## 目录

- [第1章 GD32基础入门](#第1章-gd32基础入门)
- [第2章 开发环境搭建](#第2章-开发环境搭建)
- [第3章 GPIO控制编程](#第3章-gpio控制编程)
- [第4章 定时器与PWM](#第4章-定时器与pwm)
- [第5章 串口通信](#第5章-串口通信)
- [第6章 ADC与DAC](#第6章-adc与dac)
- [第7章 SPI与I2C](#第7章-spi与i2c)
- [第8章 DMA传输](#第8章-dma传输)
- [第9章 实战项目](#第9章-实战项目)

---

## 前言

### 学习目标
- 掌握GD32系列MCU的特性和应用
- 熟练使用固件库进行开发
- 实现各类外设的控制编程
- 完成STM32到GD32的移植
- 掌握完整项目开发流程

### 环境准备
- 硬件: GD32开发板(GD32F103/GD32F407等)
- 软件: Keil MDK / GCC-ARM / System Workbench
- 调试器: J-Link / ST-Link / GD-Link
- 文档: GD32固件库和数据手册

---

## 第1章 GD32基础入门

### 1.1 GD32简介

#### 1.1.1 核心特性

GD32是兆易创新推出的32位ARM Cortex-M系列MCU。

**主要系列:**

| 系列 | 内核 | 主频 | Flash | RAM | 特点 |
|------|------|------|-------|-----|------|
| GD32F103 | Cortex-M3 | 108MHz | 64K-1M | 10K-96K | 兼容STM32F1 |
| GD32F303 | Cortex-M4F | 120MHz | 256K-3M | 32K-512K | 浮点运算 |
| GD32F407 | Cortex-M4F | 168MHz | 512K-3M | 128K-512K | 高性能 |
| GD32E103 | Cortex-M4F | 120MHz | 64K-512K | 16K-128K | 浮点增强 |
| GD32E230 | Cortex-M23 | 72MHz | 16K-64K | 4K-8K | 超低功耗 |

#### 1.1.2 GD32 vs STM32对比

```c
// GD32与STM32的主要差异

// 1. 主频优势
// GD32F103: 108MHz vs STM32F103: 72MHz
// 运算性能提升50%

// 2. Flash零等待
// GD32: 零等待周期 @108MHz
// STM32: 需要2等待周期 @72MHz

// 3. API接口兼容
// GPIO配置命名
// STM32:
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

// GD32:
GPIO_InitStructure.GPIO_Speed = GPIO_SPEED_50MHZ; // 大写命名

// 4. 成本优势
// GD32提供更高性价比
// 引脚完全兼容便于替换
```

### 1.2 芯片硬件架构

```c
// gd32f103_board.h - 硬件配置定义
#ifndef GD32F103_BOARD_H
#define GD32F103_BOARD_H

#include "gd32f10x.h"

// LED定义
#define LED1_PIN                   GPIO_PIN_0
#define LED1_GPIO_PORT             GPIOA
#define LED1_GPIO_CLK              RCU_GPIOA

#define LED2_PIN                   GPIO_PIN_1
#define LED2_GPIO_PORT             GPIOA
#define LED2_GPIO_CLK              RCU_GPIOA

// 按键定义
#define KEY1_PIN                   GPIO_PIN_0
#define KEY1_GPIO_PORT             GPIOB
#define KEY1_GPIO_CLK              RCU_GPIOB
#define KEY1_EXTI_LINE             EXTI_0
#define KEY1_EXTI_PORT_SOURCE      GPIO_PORT_SOURCE_GPIOB
#define KEY1_EXTI_PIN_SOURCE       GPIO_PIN_SOURCE_0
#define KEY1_EXTI_IRQn             EXTI0_IRQn

// 串口定义
#define DEBUG_USART                USART0
#define DEBUG_USART_CLK            RCU_USART0
#define DEBUG_USART_TX_PIN         GPIO_PIN_9
#define DEBUG_USART_RX_PIN         GPIO_PIN_10
#define DEBUG_USART_GPIO_PORT      GPIOA
#define DEBUG_USART_GPIO_CLK       RCU_GPIOA

#endif
```

### 1.3 时钟系统配置

```c
// system_clock.c - 时钟配置
#include "gd32f10x.h"

/*!
    \brief      配置系统时钟为108MHz
    \param[in]  none
    \param[out] none
    \retval     none
*/
void system_clock_108m_hxtal(void)
{
    uint32_t timeout = 0U;
    uint32_t stab_flag = 0U;

    /* 使能外部高速晶振HXTAL (8MHz) */
    RCU_CTL |= RCU_CTL_HXTALEN;

    /* 等待HXTAL稳定 */
    do {
        timeout++;
        stab_flag = (RCU_CTL & RCU_CTL_HXTALSTB);
    } while((0U == stab_flag) && (HXTAL_STARTUP_TIMEOUT != timeout));

    if(0U != (RCU_CTL & RCU_CTL_HXTALSTB)) {
        /* AHB = SYSCLK */
        RCU_CFG0 |= RCU_AHB_CKSYS_DIV1;

        /* APB2 = AHB/1 */
        RCU_CFG0 |= RCU_APB2_CKAHB_DIV1;

        /* APB1 = AHB/2 */
        RCU_CFG0 |= RCU_APB1_CKAHB_DIV2;

        /* 配置PLL: 8MHz * 27 / 2 = 108MHz */
        RCU_CFG0 &= ~(RCU_CFG0_PLLMF | RCU_CFG0_PLLMF_4);
        RCU_CFG0 |= (RCU_PLLSRC_HXTAL | RCU_PLL_MUL27);

        /* 使能PLL */
        RCU_CTL |= RCU_CTL_PLLEN;

        /* 等待PLL稳定 */
        while(0U == (RCU_CTL & RCU_CTL_PLLSTB));

        /* 选择PLL作为系统时钟 */
        RCU_CFG0 &= ~RCU_CFG0_SCS;
        RCU_CFG0 |= RCU_CKSYSSRC_PLL;

        /* 等待PLL作为系统时钟 */
        while(0U == (RCU_CFG0 & RCU_SCSS_PLL));
    } else {
        /* HXTAL启动失败，使用内部时钟 */
        while(1);
    }
}

// 获取系统时钟频率
uint32_t system_clock_get(void)
{
    uint32_t sysclk = 0U;
    uint32_t pll_mul = 0U;

    uint32_t scss = (RCU_CFG0 & RCU_CFG0_SCSS) >> 2;

    switch(scss) {
    case 0:  // IRC8M
        sysclk = IRC8M_VALUE;
        break;
    case 1:  // HXTAL
        sysclk = HXTAL_VALUE;
        break;
    case 2:  // PLL
        pll_mul = GET_BITS(RCU_CFG0, 18, 21);
        sysclk = HXTAL_VALUE * (pll_mul + 2) / 2;
        break;
    default:
        sysclk = IRC8M_VALUE;
        break;
    }

    return sysclk;
}
```

---

## 第2章 开发环境搭建

### 2.1 Keil MDK配置

#### 2.1.1 安装配置

```bash
# 1. 安装Keil MDK-ARM
# 下载地址: https://www.keil.com/download/product/

# 2. 安装GD32芯片包
# 下载: GigaDevice.GD32F10x_DFP.x.x.x.pack
# 双击安装或通过Pack Installer安装

# 3. 创建工程
# File -> New Project
# 选择芯片: GD32F103VET6

# 4. 配置工程选项
# Project -> Options for Target
# - C/C++: 添加Include路径
# - Debug: 选择调试器(J-Link/ST-Link)
# - Utilities: 配置下载算法
```

#### 2.1.2 Hello World

```c
// main.c - GD32 Hello World
#include "gd32f10x.h"
#include "systick.h"

// LED初始化
void led_init(void)
{
    // 使能GPIO时钟
    rcu_periph_clock_enable(RCU_GPIOA);

    // 配置GPIO为推挽输出
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // LED初始状态为熄灭
    gpio_bit_set(GPIOA, GPIO_PIN_0);
}

int main(void)
{
    // 配置系统时钟
    systick_config();

    // 初始化LED
    led_init();

    while(1) {
        // LED闪烁
        gpio_bit_toggle(GPIOA, GPIO_PIN_0);
        delay_1ms(500);
    }
}
```

### 2.2 GCC开发环境

```makefile
# Makefile - GCC编译配置
TARGET = gd32f103_app

# 编译工具定义
CROSS_COMPILE = arm-none-eabi-
CC = $(CROSS_COMPILE)gcc
AS = $(CROSS_COMPILE)as
LD = $(CROSS_COMPILE)ld
OBJCOPY = $(CROSS_COMPILE)objcopy
SIZE = $(CROSS_COMPILE)size

# MCU定义
MCU = -mcpu=cortex-m3 -mthumb

# 编译选项
CFLAGS = $(MCU)
CFLAGS += -Wall -Wextra
CFLAGS += -O2 -g
CFLAGS += -ffunction-sections -fdata-sections

# 链接选项
LDFLAGS = $(MCU)
LDFLAGS += -specs=nano.specs
LDFLAGS += -Wl,--gc-sections
LDFLAGS += -Wl,-Map=$(TARGET).map

# 源文件
SOURCES = main.c
SOURCES += system_gd32f10x.c
SOURCES += startup_gd32f10x_hd.s

# 固件库源文件
FIRMWARE_DIR = Firmware
SOURCES += $(FIRMWARE_DIR)/Source/gd32f10x_gpio.c
SOURCES += $(FIRMWARE_DIR)/Source/gd32f10x_rcu.c
SOURCES += $(FIRMWARE_DIR)/Source/gd32f10x_usart.c

# 包含路径
INCLUDES = -I.
INCLUDES += -I$(FIRMWARE_DIR)/Include
INCLUDES += -ICMSIS

# 构建目标
all: $(TARGET).bin $(TARGET).hex
	$(SIZE) $(TARGET).elf

$(TARGET).bin: $(TARGET).elf
	$(OBJCOPY) -O binary $< $@

$(TARGET).hex: $(TARGET).elf
	$(OBJCOPY) -O ihex $< $@

$(TARGET).elf: $(SOURCES)
	$(CC) $(CFLAGS) $(LDFLAGS) $(INCLUDES) $^ -o $@

clean:
	rm -f *.o *.elf *.bin *.hex *.map

# 烧录
flash: $(TARGET).bin
	openocd -f interface/jlink.cfg -f target/stm32f1x.cfg \
		-c "program $(TARGET).bin 0x08000000 verify reset exit"

.PHONY: all clean flash
```

### 2.3 固件库结构

```c
// firmware_structure.c - 固件库结构说明

/*
GD32F10x固件库目录结构:

GD32F10x_Firmware_Library/
├── CMSIS/                    # ARM CMSIS标准接口
│   ├── core_cm3.h           # Cortex-M3核心定义
│   ├── system_gd32f10x.c    # 系统初始化
│   └── gd32f10x.h           # 芯片寄存器定义
│
├── GD32F10x_standard_peripheral/
│   ├── Include/             # 外设驱动头文件
│   │   ├── gd32f10x_gpio.h  # GPIO驱动
│   │   ├── gd32f10x_rcu.h   # 时钟驱动
│   │   ├── gd32f10x_usart.h # 串口驱动
│   │   ├── gd32f10x_adc.h   # ADC驱动
│   │   ├── gd32f10x_timer.h # 定时器驱动
│   │   ├── gd32f10x_dma.h   # DMA驱动
│   │   └── ...
│   │
│   └── Source/              # 外设驱动实现
│       ├── gd32f10x_gpio.c
│       ├── gd32f10x_rcu.c
│       └── ...
│
└── Examples/                # 例程代码
    ├── GPIO/
    ├── USART/
    ├── TIMER/
    └── ...

主要API命名规则:
- rcu_xxxx:  时钟控制函数
- gpio_xxxx: GPIO控制函数
- timer_xxxx: 定时器函数
- usart_xxxx: 串口函数
- adc_xxxx:   ADC函数
- spi_xxxx:   SPI函数
- i2c_xxxx:   I2C函数
*/
```

---

## 第3章 GPIO控制编程

### 3.1 GPIO基本操作

```c
// gpio_example.c - GPIO基础示例
#include "gd32f10x.h"

// GPIO初始化
void gpio_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_GPIOB);

    // 配置PA0为推挽输出(LED)
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 配置PB0为上拉输入(按键)
    gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 配置PA8为复用推挽(PWM)
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);
}

// GPIO基本操作
void gpio_operations(void)
{
    // 设置引脚为高电平
    gpio_bit_set(GPIOA, GPIO_PIN_0);

    // 设置引脚为低电平
    gpio_bit_reset(GPIOA, GPIO_PIN_0);

    // 翻转引脚
    gpio_bit_toggle(GPIOA, GPIO_PIN_0);

    // 读取输入状态
    FlagStatus key_state = gpio_input_bit_get(GPIOB, GPIO_PIN_0);
    if(SET == key_state) {
        // 按键按下
    }

    // 读取整个端口
    uint16_t port_value = gpio_input_port_get(GPIOB);
}
```

### 3.2 外部中断

```c
// exti_example.c - 外部中断示例
#include "gd32f10x.h"

// 外部中断配置
void exti_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOB);
    rcu_periph_clock_enable(RCU_AF);

    // 配置GPIO为输入
    gpio_init(GPIOB, GPIO_MODE_IPU, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 连接EXTI线到GPIO
    gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOB, GPIO_PIN_SOURCE_0);

    // 配置EXTI线
    exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);
    exti_interrupt_flag_clear(EXTI_0);

    // 配置NVIC
    nvic_irq_enable(EXTI0_IRQn, 2, 0);
}

// EXTI中断处理函数
void EXTI0_IRQHandler(void)
{
    if(RESET != exti_interrupt_flag_get(EXTI_0)) {
        // 中断处理
        gpio_bit_toggle(GPIOA, GPIO_PIN_0);

        // 清除中断标志
        exti_interrupt_flag_clear(EXTI_0);
    }
}
```

### 3.3 按键消抖

```c
// key_debounce.c - 按键消抖
#include "gd32f10x.h"
#include "systick.h"

#define KEY_PIN  GPIO_PIN_0
#define KEY_PORT GPIOB

typedef enum {
    KEY_RELEASED = 0,
    KEY_PRESSED = 1
} key_state_t;

// 按键扫描(软件消抖)
key_state_t key_scan(void)
{
    static uint8_t key_filter = 0;
    static key_state_t key_state = KEY_RELEASED;

    // 读取按键
    if(RESET == gpio_input_bit_get(KEY_PORT, KEY_PIN)) {
        // 按键按下
        key_filter++;
        if(key_filter >= 3) {  // 连续3次检测到低电平
            key_filter = 3;
            if(key_state == KEY_RELEASED) {
                key_state = KEY_PRESSED;
                return KEY_PRESSED;
            }
        }
    } else {
        // 按键释放
        key_filter = 0;
        key_state = KEY_RELEASED;
    }

    return KEY_RELEASED;
}

// 使用示例
int main(void)
{
    systick_config();
    gpio_config();

    while(1) {
        if(key_scan() == KEY_PRESSED) {
            // 按键动作
            gpio_bit_toggle(GPIOA, GPIO_PIN_0);
        }
        delay_1ms(10);  // 扫描周期10ms
    }
}
```

---

## 第4章 定时器与PWM

### 4.1 基本定时器

```c
// timer_example.c - 定时器示例
#include "gd32f10x.h"

// 定时器配置(1ms中断)
void timer_config(void)
{
    timer_parameter_struct timer_initpara;

    // 使能定时器时钟
    rcu_periph_clock_enable(RCU_TIMER1);

    // 复位定时器
    timer_deinit(TIMER1);

    // 配置定时器参数
    timer_initpara.prescaler = 10800 - 1;  // 108MHz / 10800 = 10kHz
    timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
    timer_initpara.counterdirection = TIMER_COUNTER_UP;
    timer_initpara.period = 10 - 1;  // 10kHz / 10 = 1kHz (1ms)
    timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
    timer_init(TIMER1, &timer_initpara);

    // 使能定时器中断
    timer_interrupt_enable(TIMER1, TIMER_INT_UP);

    // 配置NVIC
    nvic_irq_enable(TIMER1_IRQn, 1, 0);

    // 启动定时器
    timer_enable(TIMER1);
}

// 定时器中断处理函数
void TIMER1_IRQHandler(void)
{
    if(SET == timer_interrupt_flag_get(TIMER1, TIMER_INT_FLAG_UP)) {
        // 清除中断标志
        timer_interrupt_flag_clear(TIMER1, TIMER_INT_FLAG_UP);

        // 1ms定时任务
        static uint32_t count = 0;
        count++;
        if(count >= 1000) {  // 1秒
            count = 0;
            gpio_bit_toggle(GPIOA, GPIO_PIN_0);
        }
    }
}
```

### 4.2 PWM输出

```c
// pwm_example.c - PWM输出示例
#include "gd32f10x.h"

// PWM配置(1kHz, 50%占空比)
void pwm_config(void)
{
    timer_oc_parameter_struct timer_ocintpara;
    timer_parameter_struct timer_initpara;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_TIMER0);

    // 配置GPIO为复用推挽
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_8);

    // 配置定时器
    timer_deinit(TIMER0);
    timer_initpara.prescaler = 108 - 1;  // 108MHz / 108 = 1MHz
    timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
    timer_initpara.counterdirection = TIMER_COUNTER_UP;
    timer_initpara.period = 1000 - 1;  // 1MHz / 1000 = 1kHz
    timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
    timer_init(TIMER0, &timer_initpara);

    // 配置PWM模式
    timer_ocintpara.outputstate = TIMER_CCX_ENABLE;
    timer_ocintpara.outputnstate = TIMER_CCXN_DISABLE;
    timer_ocintpara.ocpolarity = TIMER_OC_POLARITY_HIGH;
    timer_ocintpara.ocnpolarity = TIMER_OCN_POLARITY_HIGH;
    timer_ocintpara.ocidlestate = TIMER_OC_IDLE_STATE_LOW;
    timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
    timer_channel_output_config(TIMER0, TIMER_CH_0, &timer_ocintpara);

    timer_channel_output_pulse_value_config(TIMER0, TIMER_CH_0, 500); // 50%占空比
    timer_channel_output_mode_config(TIMER0, TIMER_CH_0, TIMER_OC_MODE_PWM0);
    timer_channel_output_shadow_config(TIMER0, TIMER_CH_0, TIMER_OC_SHADOW_DISABLE);

    timer_primary_output_config(TIMER0, ENABLE);
    timer_auto_reload_shadow_enable(TIMER0);
    timer_enable(TIMER0);
}

// 设置占空比(0-1000)
void pwm_set_duty(uint16_t duty)
{
    timer_channel_output_pulse_value_config(TIMER0, TIMER_CH_0, duty);
}

// 呼吸灯效果
void breathing_led_demo(void)
{
    uint16_t duty = 0;
    int8_t direction = 1;

    while(1) {
        pwm_set_duty(duty);

        duty += direction * 10;

        if(duty >= 1000) {
            direction = -1;
        } else if(duty <= 0) {
            direction = 1;
        }

        delay_1ms(20);
    }
}
```

### 4.3 输入捕获

```c
// input_capture.c - 输入捕获测量频率
#include "gd32f10x.h"

volatile uint32_t captured_value = 0;
volatile uint32_t frequency = 0;

// 输入捕获配置
void input_capture_config(void)
{
    timer_ic_parameter_struct timer_icinitpara;
    timer_parameter_struct timer_initpara;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_TIMER1);

    // 配置GPIO为浮空输入
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 配置定时器
    timer_deinit(TIMER1);
    timer_initpara.prescaler = 108 - 1;  // 1MHz计数频率
    timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
    timer_initpara.counterdirection = TIMER_COUNTER_UP;
    timer_initpara.period = 65535;
    timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
    timer_init(TIMER1, &timer_initpara);

    // 配置输入捕获
    timer_icinitpara.icpolarity = TIMER_IC_POLARITY_RISING;
    timer_icinitpara.icselection = TIMER_IC_SELECTION_DIRECTTI;
    timer_icinitpara.icprescaler = TIMER_IC_PSC_DIV1;
    timer_icinitpara.icfilter = 0x0;
    timer_input_capture_config(TIMER1, TIMER_CH_0, &timer_icinitpara);

    // 使能捕获中断
    timer_interrupt_enable(TIMER1, TIMER_INT_CH0);
    nvic_irq_enable(TIMER1_IRQn, 1, 0);

    // 启动定时器
    timer_enable(TIMER1);
}

// 定时器中断处理
void TIMER1_IRQHandler(void)
{
    if(SET == timer_interrupt_flag_get(TIMER1, TIMER_INT_FLAG_CH0)) {
        timer_interrupt_flag_clear(TIMER1, TIMER_INT_FLAG_CH0);

        static uint32_t last_captured = 0;
        captured_value = timer_channel_capture_value_register_read(TIMER1, TIMER_CH_0);

        if(captured_value > last_captured) {
            uint32_t delta = captured_value - last_captured;
            frequency = 1000000 / delta;  // 计数频率1MHz
        }

        last_captured = captured_value;
    }
}
```

---

## 第5章 串口通信

### 5.1 USART基本配置

```c
// usart_example.c - 串口示例
#include "gd32f10x.h"
#include <stdio.h>

// USART配置
void usart_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_USART0);

    // 配置GPIO
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_9);  // TX
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_10);  // RX

    // 配置USART参数
    usart_deinit(USART0);
    usart_baudrate_set(USART0, 115200);
    usart_word_length_set(USART0, USART_WL_8BIT);
    usart_stop_bit_set(USART0, USART_STB_1BIT);
    usart_parity_config(USART0, USART_PM_NONE);
    usart_hardware_flow_rts_config(USART0, USART_RTS_DISABLE);
    usart_hardware_flow_cts_config(USART0, USART_CTS_DISABLE);
    usart_receive_config(USART0, USART_RECEIVE_ENABLE);
    usart_transmit_config(USART0, USART_TRANSMIT_ENABLE);

    // 使能USART
    usart_enable(USART0);
}

// 发送单字节
void usart_send_byte(uint8_t data)
{
    usart_data_transmit(USART0, data);
    while(RESET == usart_flag_get(USART0, USART_FLAG_TBE));
}

// 接收单字节
uint8_t usart_receive_byte(void)
{
    while(RESET == usart_flag_get(USART0, USART_FLAG_RBNE));
    return (uint8_t)usart_data_receive(USART0);
}

// 发送字符串
void usart_send_string(char *str)
{
    while(*str) {
        usart_send_byte(*str++);
    }
}

// 重定向printf到USART
int fputc(int ch, FILE *f)
{
    usart_send_byte((uint8_t)ch);
    return ch;
}
```

### 5.2 USART中断接收

```c
// usart_interrupt.c - 串口中断接收
#include "gd32f10x.h"

#define BUFFER_SIZE 128
uint8_t rx_buffer[BUFFER_SIZE];
volatile uint16_t rx_index = 0;

// USART中断配置
void usart_interrupt_config(void)
{
    usart_config();  // 基本配置

    // 使能接收中断
    usart_interrupt_enable(USART0, USART_INT_RBNE);

    // 配置NVIC
    nvic_irq_enable(USART0_IRQn, 0, 0);
}

// USART中断处理函数
void USART0_IRQHandler(void)
{
    if(RESET != usart_interrupt_flag_get(USART0, USART_INT_FLAG_RBNE)) {
        // 读取数据
        uint8_t data = (uint8_t)usart_data_receive(USART0);

        // 存入缓冲区
        rx_buffer[rx_index++] = data;
        if(rx_index >= BUFFER_SIZE) {
            rx_index = 0;
        }

        // 回显
        usart_data_transmit(USART0, data);
    }
}
```

### 5.3 USART+DMA高速传输

```c
// usart_dma.c - USART DMA传输
#include "gd32f10x.h"

uint8_t tx_buffer[256];
uint8_t rx_buffer[256];

// USART DMA配置
void usart_dma_config(void)
{
    dma_parameter_struct dma_init_struct;

    // 使能DMA时钟
    rcu_periph_clock_enable(RCU_DMA0);

    // 配置USART
    usart_config();

    // 配置DMA发送通道
    dma_deinit(DMA0, DMA_CH3);
    dma_init_struct.direction = DMA_MEMORY_TO_PERIPHERAL;
    dma_init_struct.memory_addr = (uint32_t)tx_buffer;
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.memory_width = DMA_MEMORY_WIDTH_8BIT;
    dma_init_struct.number = sizeof(tx_buffer);
    dma_init_struct.periph_addr = (uint32_t)&USART_DATA(USART0);
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;
    dma_init_struct.priority = DMA_PRIORITY_HIGH;
    dma_init(DMA0, DMA_CH3, &dma_init_struct);

    // 配置DMA接收通道
    dma_deinit(DMA0, DMA_CH4);
    dma_init_struct.direction = DMA_PERIPHERAL_TO_MEMORY;
    dma_init_struct.memory_addr = (uint32_t)rx_buffer;
    dma_init_struct.number = sizeof(rx_buffer);
    dma_init(DMA0, DMA_CH4, &dma_init_struct);

    // 使能USART DMA
    usart_dma_transmit_config(USART0, USART_TRANSMIT_DMA_ENABLE);
    usart_dma_receive_config(USART0, USART_RECEIVE_DMA_ENABLE);

    // 启动DMA接收
    dma_channel_enable(DMA0, DMA_CH4);
}

// 启动DMA发送
void usart_dma_transmit(uint16_t length)
{
    dma_channel_disable(DMA0, DMA_CH3);
    dma_transfer_number_config(DMA0, DMA_CH3, length);
    dma_channel_enable(DMA0, DMA_CH3);
}
```

---

## 第6章 ADC与DAC

### 6.1 ADC配置

```c
// adc_example.c - ADC示例
#include "gd32f10x.h"

// ADC配置
void adc_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_ADC0);
    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV8);  // ADC时钟

    // 配置GPIO为模拟输入
    gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_0);

    // 复位ADC
    adc_deinit(ADC0);

    // 配置ADC模式
    adc_mode_config(ADC_MODE_FREE);
    adc_special_function_config(ADC0, ADC_SCAN_MODE, DISABLE);
    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);
    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);
    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 1);

    // 配置通道
    adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_0, ADC_SAMPLETIME_55POINT5);

    // 配置触发源
    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE);
    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);

    // 使能ADC
    adc_enable(ADC0);
    delay_1ms(1);

    // ADC校准
    adc_calibration_enable(ADC0);

    // 启动转换
    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
}

// 读取ADC值
uint16_t adc_read(void)
{
    while(!adc_flag_get(ADC0, ADC_FLAG_EOC));
    return adc_regular_data_read(ADC0);
}

// 读取电压值(mV)
uint32_t adc_read_voltage(void)
{
    uint16_t adc_value = adc_read();
    return (uint32_t)(adc_value * 3300 / 4096);
}
```

### 6.2 多通道ADC

```c
// adc_multi_channel.c - 多通道ADC
#include "gd32f10x.h"

#define ADC_CHANNEL_NUM 4
uint16_t adc_value[ADC_CHANNEL_NUM];

// 多通道ADC配置
void adc_multi_channel_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_ADC0);
    rcu_periph_clock_enable(RCU_DMA0);
    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV8);

    // 配置GPIO
    gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ,
              GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3);

    // 配置DMA
    dma_parameter_struct dma_init_struct;
    dma_deinit(DMA0, DMA_CH0);
    dma_init_struct.direction = DMA_PERIPHERAL_TO_MEMORY;
    dma_init_struct.memory_addr = (uint32_t)adc_value;
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.memory_width = DMA_MEMORY_WIDTH_16BIT;
    dma_init_struct.number = ADC_CHANNEL_NUM;
    dma_init_struct.periph_addr = (uint32_t)&ADC_RDATA(ADC0);
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;
    dma_init_struct.priority = DMA_PRIORITY_HIGH;
    dma_init(DMA0, DMA_CH0, &dma_init_struct);
    dma_circulation_enable(DMA0, DMA_CH0);
    dma_channel_enable(DMA0, DMA_CH0);

    // 配置ADC
    adc_deinit(ADC0);
    adc_mode_config(ADC_MODE_FREE);
    adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE);
    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);
    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);
    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, ADC_CHANNEL_NUM);

    // 配置通道
    adc_regular_channel_config(ADC0, 0, ADC_CHANNEL_0, ADC_SAMPLETIME_55POINT5);
    adc_regular_channel_config(ADC0, 1, ADC_CHANNEL_1, ADC_SAMPLETIME_55POINT5);
    adc_regular_channel_config(ADC0, 2, ADC_CHANNEL_2, ADC_SAMPLETIME_55POINT5);
    adc_regular_channel_config(ADC0, 3, ADC_CHANNEL_3, ADC_SAMPLETIME_55POINT5);

    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE);
    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);

    // 使能ADC DMA
    adc_dma_mode_enable(ADC0);

    // 使能ADC
    adc_enable(ADC0);
    delay_1ms(1);
    adc_calibration_enable(ADC0);

    // 启动转换
    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);
}
```

### 6.3 DAC配置

```c
// dac_example.c - DAC示例
#include "gd32f10x.h"

// DAC配置
void dac_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_DAC);

    // 配置GPIO为模拟输出
    gpio_init(GPIOA, GPIO_MODE_AIN, GPIO_OSPEED_50MHZ, GPIO_PIN_4);

    // 配置DAC
    dac_deinit();
    dac_trigger_disable(DAC0);
    dac_wave_mode_config(DAC0, DAC_WAVE_DISABLE);
    dac_output_buffer_enable(DAC0);

    // 使能DAC
    dac_enable(DAC0);
}

// 设置DAC输出值(0-4095)
void dac_set_value(uint16_t value)
{
    dac_data_set(DAC0, DAC_ALIGN_12B_R, value);
}

// 设置DAC输出电压(mV)
void dac_set_voltage(uint32_t voltage_mv)
{
    uint16_t value = (uint16_t)(voltage_mv * 4096 / 3300);
    dac_set_value(value);
}

// 产生正弦波
void dac_sine_wave(void)
{
    const uint16_t sine_table[256] = {
        2048, 2098, 2148, 2198, 2248, 2298, 2348, 2398,
        // ... 正弦表数据
    };

    uint8_t index = 0;
    while(1) {
        dac_set_value(sine_table[index++]);
        delay_1ms(1);
    }
}
```

---

## 第7章 SPI与I2C

### 7.1 SPI通信

```c
// spi_example.c - SPI示例
#include "gd32f10x.h"

// SPI配置
void spi_config(void)
{
    spi_parameter_struct spi_init_struct;

    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_SPI0);

    // 配置GPIO
    gpio_init(GPIOA, GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_5 | GPIO_PIN_7);  // SCK, MOSI
    gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, GPIO_PIN_6);  // MISO
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_4);  // CS
    gpio_bit_set(GPIOA, GPIO_PIN_4);  // CS拉高

    // 配置SPI参数
    spi_init_struct.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
    spi_init_struct.device_mode = SPI_MASTER;
    spi_init_struct.frame_size = SPI_FRAMESIZE_8BIT;
    spi_init_struct.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;
    spi_init_struct.nss = SPI_NSS_SOFT;
    spi_init_struct.prescale = SPI_PSC_8;
    spi_init_struct.endian = SPI_ENDIAN_MSB;
    spi_init(SPI0, &spi_init_struct);

    // 使能SPI
    spi_enable(SPI0);
}

// SPI收发单字节
uint8_t spi_transmit_receive(uint8_t data)
{
    while(RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_TBE));
    spi_i2s_data_transmit(SPI0, data);

    while(RESET == spi_i2s_flag_get(SPI0, SPI_FLAG_RBNE));
    return spi_i2s_data_receive(SPI0);
}

// SPI写数据
void spi_write(uint8_t *data, uint16_t len)
{
    gpio_bit_reset(GPIOA, GPIO_PIN_4);  // CS拉低

    for(uint16_t i = 0; i < len; i++) {
        spi_transmit_receive(data[i]);
    }

    gpio_bit_set(GPIOA, GPIO_PIN_4);  // CS拉高
}

// SPI读数据
void spi_read(uint8_t *data, uint16_t len)
{
    gpio_bit_reset(GPIOA, GPIO_PIN_4);  // CS拉低

    for(uint16_t i = 0; i < len; i++) {
        data[i] = spi_transmit_receive(0xFF);
    }

    gpio_bit_set(GPIOA, GPIO_PIN_4);  // CS拉高
}
```

### 7.2 I2C通信

```c
// i2c_example.c - I2C示例
#include "gd32f10x.h"

#define I2C_SPEED 100000  // 100kHz

// I2C配置
void i2c_config(void)
{
    // 使能时钟
    rcu_periph_clock_enable(RCU_GPIOB);
    rcu_periph_clock_enable(RCU_I2C0);

    // 配置GPIO
    gpio_init(GPIOB, GPIO_MODE_AF_OD, GPIO_OSPEED_50MHZ, GPIO_PIN_6 | GPIO_PIN_7);

    // 配置I2C
    i2c_clock_config(I2C0, I2C_SPEED, I2C_DTCY_2);
    i2c_mode_addr_config(I2C0, I2C_I2CMODE_ENABLE, I2C_ADDFORMAT_7BITS, 0x00);
    i2c_enable(I2C0);
    i2c_ack_config(I2C0, I2C_ACK_ENABLE);
}

// I2C写数据
void i2c_write(uint8_t addr, uint8_t reg, uint8_t *data, uint16_t len)
{
    // 等待I2C总线空闲
    while(i2c_flag_get(I2C0, I2C_FLAG_I2CBSY));

    // 发送起始位
    i2c_start_on_bus(I2C0);
    while(!i2c_flag_get(I2C0, I2C_FLAG_SBSEND));

    // 发送设备地址
    i2c_master_addressing(I2C0, addr, I2C_TRANSMITTER);
    while(!i2c_flag_get(I2C0, I2C_FLAG_ADDSEND));
    i2c_flag_clear(I2C0, I2C_FLAG_ADDSEND);

    // 发送寄存器地址
    i2c_data_transmit(I2C0, reg);
    while(!i2c_flag_get(I2C0, I2C_FLAG_TBE));

    // 写数据
    for(uint16_t i = 0; i < len; i++) {
        i2c_data_transmit(I2C0, data[i]);
        while(!i2c_flag_get(I2C0, I2C_FLAG_TBE));
    }

    // 发送停止位
    i2c_stop_on_bus(I2C0);
    while(I2C_CTL0(I2C0) & 0x0200);
}

// I2C读数据
void i2c_read(uint8_t addr, uint8_t reg, uint8_t *data, uint16_t len)
{
    // 等待I2C总线空闲
    while(i2c_flag_get(I2C0, I2C_FLAG_I2CBSY));

    // 发送起始位
    i2c_start_on_bus(I2C0);
    while(!i2c_flag_get(I2C0, I2C_FLAG_SBSEND));

    // 发送设备地址(写)
    i2c_master_addressing(I2C0, addr, I2C_TRANSMITTER);
    while(!i2c_flag_get(I2C0, I2C_FLAG_ADDSEND));
    i2c_flag_clear(I2C0, I2C_FLAG_ADDSEND);

    // 发送寄存器地址
    i2c_data_transmit(I2C0, reg);
    while(!i2c_flag_get(I2C0, I2C_FLAG_TBE));

    // 重启
    i2c_start_on_bus(I2C0);
    while(!i2c_flag_get(I2C0, I2C_FLAG_SBSEND));

    // 发送设备地址(读)
    i2c_master_addressing(I2C0, addr, I2C_RECEIVER);
    while(!i2c_flag_get(I2C0, I2C_FLAG_ADDSEND));
    i2c_flag_clear(I2C0, I2C_FLAG_ADDSEND);

    // 读取数据
    for(uint16_t i = 0; i < len; i++) {
        if(i == len - 1) {
            i2c_ack_config(I2C0, I2C_ACK_DISABLE);
        }
        while(!i2c_flag_get(I2C0, I2C_FLAG_RBNE));
        data[i] = i2c_data_receive(I2C0);
    }

    // 发送停止位
    i2c_stop_on_bus(I2C0);
    while(I2C_CTL0(I2C0) & 0x0200);
    i2c_ack_config(I2C0, I2C_ACK_ENABLE);
}
```

---

## 第8章 DMA传输

```c
// dma_example.c - DMA传输示例
#include "gd32f10x.h"

#define BUFFER_SIZE 32
uint8_t src_buffer[BUFFER_SIZE];
uint8_t dst_buffer[BUFFER_SIZE];

// DMA配置(内存到内存)
void dma_config(void)
{
    dma_parameter_struct dma_init_struct;

    // 使能DMA时钟
    rcu_periph_clock_enable(RCU_DMA0);

    // 复位DMA通道
    dma_deinit(DMA0, DMA_CH0);

    dma_init_struct.direction = DMA_MEMORY_TO_MEMORY;
    dma_init_struct.memory_addr = (uint32_t)dst_buffer;
    dma_init_struct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.memory_width = DMA_MEMORY_WIDTH_8BIT;
    dma_init_struct.number = BUFFER_SIZE;
    dma_init_struct.periph_addr = (uint32_t)src_buffer;
    dma_init_struct.periph_inc = DMA_PERIPH_INCREASE_ENABLE;
    dma_init_struct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;
    dma_init_struct.priority = DMA_PRIORITY_ULTRA_HIGH;
    dma_init(DMA0, DMA_CH0, &dma_init_struct);

    // 配置DMA模式
    dma_circulation_disable(DMA0, DMA_CH0);
    dma_memory_to_memory_enable(DMA0, DMA_CH0);
}

// 启动DMA传输
void dma_transfer_start(void)
{
    // 重新配置传输数量
    dma_channel_disable(DMA0, DMA_CH0);
    dma_transfer_number_config(DMA0, DMA_CH0, BUFFER_SIZE);
    dma_channel_enable(DMA0, DMA_CH0);

    // 等待传输完成
    while(!dma_flag_get(DMA0, DMA_CH0, DMA_FLAG_FTF));
    dma_flag_clear(DMA0, DMA_CH0, DMA_FLAG_FTF);
}

// DMA中断方式
void dma_interrupt_config(void)
{
    dma_config();

    // 使能传输完成中断
    dma_interrupt_enable(DMA0, DMA_CH0, DMA_INT_FTF);
    nvic_irq_enable(DMA0_Channel0_IRQn, 0, 0);

    dma_channel_enable(DMA0, DMA_CH0);
}

// DMA中断处理
void DMA0_Channel0_IRQHandler(void)
{
    if(dma_interrupt_flag_get(DMA0, DMA_CH0, DMA_INT_FLAG_FTF)) {
        dma_interrupt_flag_clear(DMA0, DMA_CH0, DMA_INT_FLAG_FTF);

        // 传输完成处理
        printf("DMA transfer complete\r\n");
    }
}
```

---

## 第9章 实战项目

### 9.1 智能温控风扇系统

```c
// temp_fan_control.c - 温控风扇系统
#include "gd32f10x.h"

#define TEMP_THRESHOLD_LOW   25  // 低温阈值
#define TEMP_THRESHOLD_HIGH  30  // 高温阈值

uint16_t current_temp = 0;
uint16_t fan_speed = 0;  // 0-1000

// 系统初始化
void system_init(void)
{
    systick_config();
    usart_config();
    adc_config();   // 温度传感器ADC
    pwm_config();   // 风扇PWM控制
}

// 温度读取(假设使用LM35温度传感器)
uint16_t read_temperature(void)
{
    uint32_t voltage_mv = adc_read_voltage();
    // LM35温度传感器:10mV/°C
    return (uint16_t)(voltage_mv / 10);
}

// 风扇控制
void fan_control(uint16_t temp)
{
    if(temp < TEMP_THRESHOLD_LOW) {
        // 低温关闭风扇
        fan_speed = 0;
    } else if(temp > TEMP_THRESHOLD_HIGH) {
        // 高温风扇全速
        fan_speed = 1000;
    } else {
        // 中温风扇调速
        fan_speed = (temp - TEMP_THRESHOLD_LOW) * 1000 /
                   (TEMP_THRESHOLD_HIGH - TEMP_THRESHOLD_LOW);
    }

    pwm_set_duty(fan_speed);
}

int main(void)
{
    system_init();

    printf("Temperature Fan Control System\r\n");

    while(1) {
        // 读取温度
        current_temp = read_temperature();

        // 控制风扇
        fan_control(current_temp);

        // 串口输出
        printf("Temp: %d C, Fan: %d%%\r\n",
               current_temp, fan_speed / 10);

        delay_1ms(1000);
    }
}
```

### 9.2 STM32到GD32移植指南

```c
// migration_guide.c - STM32到GD32移植

/*
移植步骤:

1. 替换头文件
   STM32: #include "stm32f10x.h"
   GD32:  #include "gd32f10x.h"

2. 修改命名大小写
   STM32: GPIO_InitTypeDef GPIO_InitStructure;
   GD32:  GPIO_InitTypeDef GPIO_InitStructure;  // 类型定义相同

   STM32: GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   GD32:  GPIO_InitStructure.GPIO_Speed = GPIO_SPEED_50MHZ;  // 枚举值大写

3. 时钟配置调整
   STM32: 最高72MHz
   GD32:  最高108MHz，需要调整PLL倍频系数

4. 固件库函数差异
   STM32: RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   GD32:  rcu_periph_clock_enable(RCU_GPIOA);  // 函数名简化

5. 中断优先级配置
   基本相同，但要注意GD32有4位优先级

6. Flash操作
   GD32支持零等待周期，性能更好

7. 特殊外设差异
   - USB: GD32有增强
   - CAN: 基本相同
   - Ethernet: 仅部分型号支持
*/

// 移植示例: LED闪烁
// STM32代码
void STM32_LED_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
}

// GD32代码
void GD32_LED_Init(void)
{
    // 使能时钟(函数名简化)
    rcu_periph_clock_enable(RCU_GPIOA);

    // 配置GPIO(函数参数顺序不同)
    gpio_init(GPIOA, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0);
}
```

### 9.3 学习效果验证

**验证标准:**

1. **基础知识(20分)**
   - [ ] 掌握GD32系列MCU特性
   - [ ] 理解固件库架构
   - [ ] 熟悉开发工具

2. **外设编程(40分)**
   - [ ] 掌握GPIO、定时器、串口
   - [ ] 掌握ADC、DAC、SPI、I2C
   - [ ] 掌握DMA传输

3. **实战项目(30分)**
   - [ ] 完成完整项目开发
   - [ ] 实现STM32迁移
   - [ ] 调试优化

4. **进阶应用(10分)**
   - [ ] 掌握RTOS集成
   - [ ] USB通信
   - [ ] CAN总线

### 9.4 进阶学习资源

**官方资源:**
- GD32官网: http://www.gigadevice.com
- 技术论坛: http://www.gd32mcu.com
- 固件库下载和例程

**推荐文档:**
- GD32F10x数据手册
- GD32F10x固件库手册
- 应用笔记

**进阶方向:**
- RTOS集成(FreeRTOS/RT-Thread)
- USB设备开发
- CAN总线通信
- Ethernet网络应用

---

## 总结

通过本指南学习，您已掌握:

1. GD32系列MCU的特性和应用
2. 开发环境的搭建和配置
3. GPIO、定时器、串口等基本外设
4. ADC、DAC、SPI、I2C等接口
5. DMA数据传输
6. 完整项目开发流程

**进阶方向建议:**
- 深入学习RTOS应用
- 掌握USB和网络通信
- 了解电机控制和电源管理
- 参与开源项目实践

祝学习愉快！
