# è‡ªåˆ¶C++æ¸¸æˆå¼•æ“å®Œå…¨æŒ‡å—

## å­¦ä¹ è€…è§’è‰²å®šä½
- **ç›®æ ‡ç¾¤ä½“**: æœ‰C++åŸºç¡€çš„å¼€å‘è€…ã€æ¸¸æˆå¼•æ“çˆ±å¥½è€…ã€è®¡ç®—æœºå›¾å½¢å­¦å­¦ä¹ è€…ã€æƒ³æ·±å…¥ç†è§£å¼•æ“åŸç†çš„å¼€å‘è€…
- **å‰ç½®çŸ¥è¯†**: C++11/14åŸºç¡€ã€æ•°æ®ç»“æ„ä¸ç®—æ³•ã€çº¿æ€§ä»£æ•°ã€è®¡ç®—æœºå›¾å½¢å­¦åŸºç¡€æ¦‚å¿µ
- **å­¦ä¹ ç›®æ ‡**: ä»é›¶å¼€å§‹æ„å»ºä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„2D/3Dæ¸¸æˆå¼•æ“ï¼Œæ·±å…¥ç†è§£å¼•æ“æ¶æ„å’Œåº•å±‚å®ç°åŸç†

## æŠ€æœ¯æ¦‚è¿°

### ä¸ºä»€ä¹ˆè¦è‡ªåˆ¶æ¸¸æˆå¼•æ“

#### å­¦ä¹ ä»·å€¼
- **æ·±å…¥ç†è§£åŸç†**: ç†è§£å•†ä¸šå¼•æ“ï¼ˆUnityã€Unrealï¼‰çš„åº•å±‚å®ç°
- **æŠ€æœ¯èƒ½åŠ›æå‡**: ç»¼åˆè¿ç”¨C++ã€å›¾å½¢å­¦ã€æ¶æ„è®¾è®¡ç­‰çŸ¥è¯†
- **ä¼˜åŒ–èƒ½åŠ›**: æŒæ¡æ€§èƒ½ä¼˜åŒ–çš„æœ¬è´¨ï¼Œè€Œéä»…ä¾èµ–å¼•æ“è®¾ç½®
- **å®šåˆ¶åŒ–æ§åˆ¶**: å®Œå…¨æŒæ§å¼•æ“çš„æ¯ä¸€ä¸ªç»†èŠ‚

#### å®é™…åº”ç”¨åœºæ™¯
- ç‹¬ç«‹æ¸¸æˆå¼€å‘ï¼ˆéœ€è¦ç‰¹æ®ŠåŠŸèƒ½ï¼‰
- æ•™è‚²å’Œç ”ç©¶é¡¹ç›®
- åµŒå…¥å¼æ¸¸æˆå¼•æ“
- ç‰¹å®šé¢†åŸŸçš„ä»¿çœŸç³»ç»Ÿ
- æŠ€æœ¯Demoå’ŒåŸå‹éªŒè¯

### æ¸¸æˆå¼•æ“æ ¸å¿ƒæ¶æ„

```
æ¸¸æˆå¼•æ“å±‚çº§æ¶æ„
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     æ¸¸æˆå±‚ï¼ˆGame Layerï¼‰                â”‚
â”‚  - æ¸¸æˆé€»è¾‘ã€å…³å¡ã€ç©æ³•ç³»ç»Ÿ              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ¡†æ¶å±‚ï¼ˆFramework Layerï¼‰             â”‚
â”‚  - åœºæ™¯ç®¡ç†ã€å®ä½“ç»„ä»¶ç³»ç»Ÿã€è„šæœ¬ç³»ç»Ÿ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ ¸å¿ƒç³»ç»Ÿå±‚ï¼ˆCore Systems Layerï¼‰      â”‚
â”‚  - æ¸²æŸ“ã€ç‰©ç†ã€éŸ³é¢‘ã€è¾“å…¥ã€èµ„æºç®¡ç†      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å¹³å°æŠ½è±¡å±‚ï¼ˆPlatform Layerï¼‰          â”‚
â”‚  - çª—å£ç³»ç»Ÿã€æ–‡ä»¶IOã€çº¿ç¨‹ã€ç½‘ç»œ          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç¬¬ä¸‰æ–¹åº“ï¼ˆThird-Party Librariesï¼‰     â”‚
â”‚  - SDL/GLFWã€OpenGL/Vulkanã€PhysXç­‰    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆé€‰æ‹©

#### æ ¸å¿ƒåº“æ¨è
| åŠŸèƒ½æ¨¡å— | æ¨èåº“ | è¯´æ˜ |
|---------|--------|------|
| çª—å£/è¾“å…¥ | GLFW/SDL2 | è·¨å¹³å°çª—å£å’Œè¾“å…¥å¤„ç† |
| å›¾å½¢API | OpenGL 3.3+ | æ˜“å­¦ï¼Œè·¨å¹³å° |
| æ•°å­¦åº“ | GLM | OpenGLæ•°å­¦åº“ |
| å›¾åƒåŠ è½½ | stb_image | è½»é‡çº§ï¼Œä»…å¤´æ–‡ä»¶ |
| ç‰©ç†å¼•æ“ | Box2D/Bullet | 2Dç”¨Box2Dï¼Œ3Dç”¨Bullet |
| éŸ³é¢‘ | OpenAL/miniaudio | 3DéŸ³é¢‘æ”¯æŒ |
| è„šæœ¬ | Lua/ChaiScript | è½»é‡çº§è„šæœ¬è¯­è¨€ |

---

## æ¨¡å—ä¸€ï¼šå¼•æ“åŸºç¡€æ¶æ„è®¾è®¡

### 1.1 é¡¹ç›®ç»“æ„è§„åˆ’

#### æ¨èç›®å½•ç»“æ„
```
GameEngine/
â”œâ”€â”€ Engine/                  # å¼•æ“æ ¸å¿ƒä»£ç 
â”‚   â”œâ”€â”€ Core/               # æ ¸å¿ƒç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ Application.h/cpp
â”‚   â”‚   â”œâ”€â”€ Window.h/cpp
â”‚   â”‚   â”œâ”€â”€ Time.h/cpp
â”‚   â”‚   â””â”€â”€ Logger.h/cpp
â”‚   â”œâ”€â”€ Renderer/           # æ¸²æŸ“ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ Renderer.h/cpp
â”‚   â”‚   â”œâ”€â”€ Shader.h/cpp
â”‚   â”‚   â”œâ”€â”€ Texture.h/cpp
â”‚   â”‚   â””â”€â”€ Camera.h/cpp
â”‚   â”œâ”€â”€ Physics/            # ç‰©ç†ç³»ç»Ÿ
â”‚   â”œâ”€â”€ Audio/              # éŸ³é¢‘ç³»ç»Ÿ
â”‚   â”œâ”€â”€ Input/              # è¾“å…¥ç³»ç»Ÿ
â”‚   â””â”€â”€ Scene/              # åœºæ™¯ç®¡ç†
â”œâ”€â”€ Game/                   # æ¸¸æˆå±‚ä»£ç 
â”œâ”€â”€ Assets/                 # èµ„æºæ–‡ä»¶
â”‚   â”œâ”€â”€ Textures/
â”‚   â”œâ”€â”€ Shaders/
â”‚   â”œâ”€â”€ Models/
â”‚   â””â”€â”€ Sounds/
â”œâ”€â”€ ThirdParty/             # ç¬¬ä¸‰æ–¹åº“
â””â”€â”€ Build/                  # æ„å»ºè¾“å‡º
```

### 1.2 æ ¸å¿ƒåŸºç±»è®¾è®¡

#### Application ç±»ï¼ˆå¼•æ“å…¥å£ï¼‰
```cpp
// Application.h
#pragma once
#include <memory>
#include "Window.h"
#include "Renderer/Renderer.h"

namespace Engine {

class Application {
public:
    Application(const std::string& name = "Game Engine");
    virtual ~Application();

    void Run();
    void Close();

    Window& GetWindow() { return *m_Window; }
    static Application& Get() { return *s_Instance; }

protected:
    virtual void OnInit() {}
    virtual void OnUpdate(float deltaTime) {}
    virtual void OnRender() {}
    virtual void OnShutdown() {}

private:
    void Init();
    void Shutdown();

    std::unique_ptr<Window> m_Window;
    std::unique_ptr<Renderer> m_Renderer;
    
    bool m_Running = true;
    float m_LastFrameTime = 0.0f;

    static Application* s_Instance;
};

// åœ¨å®¢æˆ·ç«¯å®šä¹‰
Application* CreateApplication();

} // namespace Engine
```

```cpp
// Application.cpp
#include "Application.h"
#include "Time.h"
#include <GLFW/glfw3.h>

namespace Engine {

Application* Application::s_Instance = nullptr;

Application::Application(const std::string& name) {
    s_Instance = this;
    
    // åˆå§‹åŒ–GLFW
    if (!glfwInit()) {
        throw std::runtime_error("Failed to initialize GLFW");
    }

    // åˆ›å»ºçª—å£
    m_Window = std::make_unique<Window>(name, 1280, 720);
    
    // åˆå§‹åŒ–æ¸²æŸ“å™¨
    m_Renderer = std::make_unique<Renderer>();
    
    // è°ƒç”¨ç”¨æˆ·åˆå§‹åŒ–
    OnInit();
}

Application::~Application() {
    OnShutdown();
    m_Renderer.reset();
    m_Window.reset();
    glfwTerminate();
}

void Application::Run() {
    while (m_Running && !m_Window->ShouldClose()) {
        float time = static_cast<float>(glfwGetTime());
        float deltaTime = time - m_LastFrameTime;
        m_LastFrameTime = time;

        // æ›´æ–°é€»è¾‘
        OnUpdate(deltaTime);

        // æ¸²æŸ“
        m_Renderer->Clear();
        OnRender();
        
        // äº¤æ¢ç¼“å†²åŒº
        m_Window->SwapBuffers();
        m_Window->PollEvents();
    }
}

void Application::Close() {
    m_Running = false;
}

} // namespace Engine
```

#### Window ç±»ï¼ˆçª—å£ç®¡ç†ï¼‰
```cpp
// Window.h
#pragma once
#include <string>
#include <functional>

struct GLFWwindow;

namespace Engine {

struct WindowProps {
    std::string Title;
    unsigned int Width;
    unsigned int Height;
    bool VSync;

    WindowProps(const std::string& title = "Game Engine",
                unsigned int width = 1280,
                unsigned int height = 720)
        : Title(title), Width(width), Height(height), VSync(true) {}
};

class Window {
public:
    using EventCallbackFn = std::function<void(class Event&)>;

    Window(const std::string& title, unsigned int width, unsigned int height);
    ~Window();

    void SwapBuffers();
    void PollEvents();
    
    unsigned int GetWidth() const { return m_Data.Width; }
    unsigned int GetHeight() const { return m_Data.Height; }
    
    bool ShouldClose() const;
    void SetVSync(bool enabled);
    bool IsVSync() const { return m_Data.VSync; }

    GLFWwindow* GetNativeWindow() const { return m_Window; }

private:
    void Init(const WindowProps& props);
    void Shutdown();

    GLFWwindow* m_Window;

    struct WindowData {
        std::string Title;
        unsigned int Width, Height;
        bool VSync;
    };

    WindowData m_Data;
};

} // namespace Engine
```

```cpp
// Window.cpp
#include "Window.h"
#include <GLFW/glfw3.h>
#include <glad/glad.h>
#include <stdexcept>

namespace Engine {

Window::Window(const std::string& title, unsigned int width, unsigned int height) {
    WindowProps props(title, width, height);
    Init(props);
}

Window::~Window() {
    Shutdown();
}

void Window::Init(const WindowProps& props) {
    m_Data.Title = props.Title;
    m_Data.Width = props.Width;
    m_Data.Height = props.Height;
    m_Data.VSync = props.VSync;

    // è®¾ç½®OpenGLç‰ˆæœ¬
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

    // åˆ›å»ºçª—å£
    m_Window = glfwCreateWindow(m_Data.Width, m_Data.Height, 
                                 m_Data.Title.c_str(), nullptr, nullptr);
    
    if (!m_Window) {
        throw std::runtime_error("Failed to create GLFW window");
    }

    glfwMakeContextCurrent(m_Window);

    // åˆå§‹åŒ–GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        throw std::runtime_error("Failed to initialize GLAD");
    }

    // è®¾ç½®è§†å£
    glViewport(0, 0, m_Data.Width, m_Data.Height);

    // è®¾ç½®å›è°ƒ
    glfwSetFramebufferSizeCallback(m_Window, [](GLFWwindow* window, int width, int height) {
        glViewport(0, 0, width, height);
    });

    SetVSync(m_Data.VSync);
}

void Window::Shutdown() {
    if (m_Window) {
        glfwDestroyWindow(m_Window);
        m_Window = nullptr;
    }
}

void Window::SwapBuffers() {
    glfwSwapBuffers(m_Window);
}

void Window::PollEvents() {
    glfwPollEvents();
}

bool Window::ShouldClose() const {
    return glfwWindowShouldClose(m_Window);
}

void Window::SetVSync(bool enabled) {
    glfwSwapInterval(enabled ? 1 : 0);
    m_Data.VSync = enabled;
}

} // namespace Engine
```

### 1.3 ä¸»å‡½æ•°å…¥å£è®¾è®¡

```cpp
// Main.cpp
#include "Engine/Core/Application.h"

// æ¸¸æˆåº”ç”¨ç±»
class MyGame : public Engine::Application {
public:
    MyGame() : Application("My Game") {}

    void OnInit() override {
        // åˆå§‹åŒ–æ¸¸æˆèµ„æº
    }

    void OnUpdate(float deltaTime) override {
        // æ›´æ–°æ¸¸æˆé€»è¾‘
    }

    void OnRender() override {
        // æ¸²æŸ“æ¸¸æˆç”»é¢
    }

    void OnShutdown() override {
        // æ¸…ç†æ¸¸æˆèµ„æº
    }
};

// åˆ›å»ºåº”ç”¨å®ä¾‹
Engine::Application* Engine::CreateApplication() {
    return new MyGame();
}

// ä¸»å‡½æ•°
int main(int argc, char** argv) {
    auto app = Engine::CreateApplication();
    app->Run();
    delete app;
    return 0;
}
```

---

## æ¨¡å—äºŒï¼šæ¸²æŸ“ç³»ç»Ÿå®ç°

### 2.1 Shader ç€è‰²å™¨ç®¡ç†

#### Shader ç±»è®¾è®¡
```cpp
// Shader.h
#pragma once
#include <string>
#include <unordered_map>
#include <glm/glm.hpp>

namespace Engine {

class Shader {
public:
    Shader(const std::string& vertexSrc, const std::string& fragmentSrc);
    ~Shader();

    void Bind() const;
    void Unbind() const;

    // Uniformè®¾ç½®
    void SetInt(const std::string& name, int value);
    void SetFloat(const std::string& name, float value);
    void SetVec2(const std::string& name, const glm::vec2& value);
    void SetVec3(const std::string& name, const glm::vec3& value);
    void SetVec4(const std::string& name, const glm::vec4& value);
    void SetMat3(const std::string& name, const glm::mat3& value);
    void SetMat4(const std::string& name, const glm::mat4& value);

    static std::shared_ptr<Shader> Create(const std::string& vertexSrc, 
                                           const std::string& fragmentSrc);
    static std::shared_ptr<Shader> CreateFromFile(const std::string& filepath);

private:
    unsigned int CompileShader(unsigned int type, const std::string& source);
    int GetUniformLocation(const std::string& name);

    unsigned int m_RendererID;
    std::unordered_map<std::string, int> m_UniformLocationCache;
};

} // namespace Engine
```

```cpp
// Shader.cpp
#include "Shader.h"
#include <glad/glad.h>
#include <fstream>
#include <sstream>
#include <iostream>

namespace Engine {

Shader::Shader(const std::string& vertexSrc, const std::string& fragmentSrc) {
    // ç¼–è¯‘ç€è‰²å™¨
    unsigned int vertex = CompileShader(GL_VERTEX_SHADER, vertexSrc);
    unsigned int fragment = CompileShader(GL_FRAGMENT_SHADER, fragmentSrc);

    // é“¾æ¥ç¨‹åº
    m_RendererID = glCreateProgram();
    glAttachShader(m_RendererID, vertex);
    glAttachShader(m_RendererID, fragment);
    glLinkProgram(m_RendererID);

    // æ£€æŸ¥é“¾æ¥é”™è¯¯
    int success;
    char infoLog[512];
    glGetProgramiv(m_RendererID, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(m_RendererID, 512, nullptr, infoLog);
        std::cerr << "Shader linking failed: " << infoLog << std::endl;
    }

    // åˆ é™¤ç€è‰²å™¨
    glDeleteShader(vertex);
    glDeleteShader(fragment);
}

Shader::~Shader() {
    glDeleteProgram(m_RendererID);
}

unsigned int Shader::CompileShader(unsigned int type, const std::string& source) {
    unsigned int shader = glCreateShader(type);
    const char* src = source.c_str();
    glShaderSource(shader, 1, &src, nullptr);
    glCompileShader(shader);

    // æ£€æŸ¥ç¼–è¯‘é”™è¯¯
    int success;
    char infoLog[512];
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(shader, 512, nullptr, infoLog);
        std::cerr << "Shader compilation failed: " << infoLog << std::endl;
    }

    return shader;
}

void Shader::Bind() const {
    glUseProgram(m_RendererID);
}

void Shader::Unbind() const {
    glUseProgram(0);
}

int Shader::GetUniformLocation(const std::string& name) {
    if (m_UniformLocationCache.find(name) != m_UniformLocationCache.end()) {
        return m_UniformLocationCache[name];
    }

    int location = glGetUniformLocation(m_RendererID, name.c_str());
    m_UniformLocationCache[name] = location;
    return location;
}

void Shader::SetInt(const std::string& name, int value) {
    glUniform1i(GetUniformLocation(name), value);
}

void Shader::SetFloat(const std::string& name, float value) {
    glUniform1f(GetUniformLocation(name), value);
}

void Shader::SetVec3(const std::string& name, const glm::vec3& value) {
    glUniform3f(GetUniformLocation(name), value.x, value.y, value.z);
}

void Shader::SetMat4(const std::string& name, const glm::mat4& value) {
    glUniformMatrix4fv(GetUniformLocation(name), 1, GL_FALSE, &value[0][0]);
}

std::shared_ptr<Shader> Shader::Create(const std::string& vertexSrc, 
                                        const std::string& fragmentSrc) {
    return std::make_shared<Shader>(vertexSrc, fragmentSrc);
}

} // namespace Engine
```

#### åŸºç¡€ç€è‰²å™¨ç¤ºä¾‹
```cpp
// é¡¶ç‚¹ç€è‰²å™¨
const char* vertexShaderSrc = R"(
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 u_ViewProjection;
uniform mat4 u_Transform;

void main() {
    gl_Position = u_ViewProjection * u_Transform * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
)";

// ç‰‡æ®µç€è‰²å™¨
const char* fragmentShaderSrc = R"(
#version 330 core
out vec4 FragColor;

in vec2 TexCoord;

uniform vec4 u_Color;
uniform sampler2D u_Texture;

void main() {
    FragColor = texture(u_Texture, TexCoord) * u_Color;
}
)";
```

### 2.2 Texture çº¹ç†ç®¡ç†

```cpp
// Texture.h
#pragma once
#include <string>
#include <memory>

namespace Engine {

class Texture {
public:
    virtual ~Texture() = default;

    virtual unsigned int GetWidth() const = 0;
    virtual unsigned int GetHeight() const = 0;
    virtual unsigned int GetRendererID() const = 0;

    virtual void Bind(unsigned int slot = 0) const = 0;
    virtual void Unbind() const = 0;
};

class Texture2D : public Texture {
public:
    Texture2D(const std::string& path);
    Texture2D(unsigned int width, unsigned int height);
    virtual ~Texture2D();

    unsigned int GetWidth() const override { return m_Width; }
    unsigned int GetHeight() const override { return m_Height; }
    unsigned int GetRendererID() const override { return m_RendererID; }

    void SetData(void* data, unsigned int size);

    void Bind(unsigned int slot = 0) const override;
    void Unbind() const override;

    static std::shared_ptr<Texture2D> Create(const std::string& path);
    static std::shared_ptr<Texture2D> Create(unsigned int width, unsigned int height);

private:
    std::string m_Path;
    unsigned int m_Width, m_Height;
    unsigned int m_RendererID;
    unsigned int m_InternalFormat, m_DataFormat;
};

} // namespace Engine
```

```cpp
// Texture.cpp
#include "Texture.h"
#include <glad/glad.h>
#include <stb_image.h>

namespace Engine {

Texture2D::Texture2D(const std::string& path) : m_Path(path) {
    int width, height, channels;
    stbi_set_flip_vertically_on_load(1);
    stbi_uc* data = stbi_load(path.c_str(), &width, &height, &channels, 0);

    if (!data) {
        throw std::runtime_error("Failed to load texture: " + path);
    }

    m_Width = width;
    m_Height = height;

    // ç¡®å®šæ ¼å¼
    GLenum internalFormat = 0, dataFormat = 0;
    if (channels == 4) {
        internalFormat = GL_RGBA8;
        dataFormat = GL_RGBA;
    } else if (channels == 3) {
        internalFormat = GL_RGB8;
        dataFormat = GL_RGB;
    }

    m_InternalFormat = internalFormat;
    m_DataFormat = dataFormat;

    // åˆ›å»ºçº¹ç†
    glGenTextures(1, &m_RendererID);
    glBindTexture(GL_TEXTURE_2D, m_RendererID);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, m_Width, m_Height, 
                 0, dataFormat, GL_UNSIGNED_BYTE, data);

    stbi_image_free(data);
}

Texture2D::Texture2D(unsigned int width, unsigned int height)
    : m_Width(width), m_Height(height) {
    m_InternalFormat = GL_RGBA8;
    m_DataFormat = GL_RGBA;

    glGenTextures(1, &m_RendererID);
    glBindTexture(GL_TEXTURE_2D, m_RendererID);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
}

Texture2D::~Texture2D() {
    glDeleteTextures(1, &m_RendererID);
}

void Texture2D::SetData(void* data, unsigned int size) {
    unsigned int bpp = m_DataFormat == GL_RGBA ? 4 : 3;
    if (size != m_Width * m_Height * bpp) {
        throw std::runtime_error("Data must cover entire texture");
    }

    glBindTexture(GL_TEXTURE_2D, m_RendererID);
    glTexImage2D(GL_TEXTURE_2D, 0, m_InternalFormat, m_Width, m_Height,
                 0, m_DataFormat, GL_UNSIGNED_BYTE, data);
}

void Texture2D::Bind(unsigned int slot) const {
    glActiveTexture(GL_TEXTURE0 + slot);
    glBindTexture(GL_TEXTURE_2D, m_RendererID);
}

void Texture2D::Unbind() const {
    glBindTexture(GL_TEXTURE_2D, 0);
}

std::shared_ptr<Texture2D> Texture2D::Create(const std::string& path) {
    return std::make_shared<Texture2D>(path);
}

std::shared_ptr<Texture2D> Texture2D::Create(unsigned int width, unsigned int height) {
    return std::make_shared<Texture2D>(width, height);
}

} // namespace Engine
```

### 2.3 Camera æ‘„åƒæœºç³»ç»Ÿ

```cpp
// Camera.h
#pragma once
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

namespace Engine {

class Camera {
public:
    Camera(float left, float right, float bottom, float top);

    void SetProjection(float left, float right, float bottom, float top);
    void SetPosition(const glm::vec3& position);
    void SetRotation(float rotation);

    const glm::vec3& GetPosition() const { return m_Position; }
    float GetRotation() const { return m_Rotation; }

    const glm::mat4& GetProjectionMatrix() const { return m_ProjectionMatrix; }
    const glm::mat4& GetViewMatrix() const { return m_ViewMatrix; }
    const glm::mat4& GetViewProjectionMatrix() const { return m_ViewProjectionMatrix; }

private:
    void RecalculateViewMatrix();

    glm::mat4 m_ProjectionMatrix;
    glm::mat4 m_ViewMatrix;
    glm::mat4 m_ViewProjectionMatrix;

    glm::vec3 m_Position = {0.0f, 0.0f, 0.0f};
    float m_Rotation = 0.0f;
};

// é€è§†æ‘„åƒæœºï¼ˆ3Dï¼‰
class PerspectiveCamera {
public:
    PerspectiveCamera(float fov, float aspectRatio, float nearClip, float farClip);

    void SetPosition(const glm::vec3& position);
    void SetRotation(const glm::vec3& rotation);

    const glm::mat4& GetViewProjectionMatrix() const { return m_ViewProjectionMatrix; }

private:
    void RecalculateViewMatrix();

    glm::mat4 m_ProjectionMatrix;
    glm::mat4 m_ViewMatrix;
    glm::mat4 m_ViewProjectionMatrix;

    glm::vec3 m_Position = {0.0f, 0.0f, 0.0f};
    glm::vec3 m_Rotation = {0.0f, 0.0f, 0.0f};
};

} // namespace Engine
```

```cpp
// Camera.cpp
#include "Camera.h"

namespace Engine {

// æ­£äº¤æ‘„åƒæœºï¼ˆ2Dï¼‰
Camera::Camera(float left, float right, float bottom, float top)
    : m_ProjectionMatrix(glm::ortho(left, right, bottom, top, -1.0f, 1.0f)),
      m_ViewMatrix(1.0f) {
    m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
}

void Camera::SetProjection(float left, float right, float bottom, float top) {
    m_ProjectionMatrix = glm::ortho(left, right, bottom, top, -1.0f, 1.0f);
    m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
}

void Camera::SetPosition(const glm::vec3& position) {
    m_Position = position;
    RecalculateViewMatrix();
}

void Camera::SetRotation(float rotation) {
    m_Rotation = rotation;
    RecalculateViewMatrix();
}

void Camera::RecalculateViewMatrix() {
    glm::mat4 transform = glm::translate(glm::mat4(1.0f), m_Position) *
                          glm::rotate(glm::mat4(1.0f), glm::radians(m_Rotation), 
                                      glm::vec3(0, 0, 1));

    m_ViewMatrix = glm::inverse(transform);
    m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
}

// é€è§†æ‘„åƒæœºï¼ˆ3Dï¼‰
PerspectiveCamera::PerspectiveCamera(float fov, float aspectRatio, 
                                     float nearClip, float farClip)
    : m_ProjectionMatrix(glm::perspective(glm::radians(fov), aspectRatio, 
                                          nearClip, farClip)),
      m_ViewMatrix(1.0f) {
    m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
}

void PerspectiveCamera::SetPosition(const glm::vec3& position) {
    m_Position = position;
    RecalculateViewMatrix();
}

void PerspectiveCamera::SetRotation(const glm::vec3& rotation) {
    m_Rotation = rotation;
    RecalculateViewMatrix();
}

void PerspectiveCamera::RecalculateViewMatrix() {
    glm::mat4 transform = glm::translate(glm::mat4(1.0f), m_Position);
    transform = glm::rotate(transform, glm::radians(m_Rotation.x), glm::vec3(1, 0, 0));
    transform = glm::rotate(transform, glm::radians(m_Rotation.y), glm::vec3(0, 1, 0));
    transform = glm::rotate(transform, glm::radians(m_Rotation.z), glm::vec3(0, 0, 1));

    m_ViewMatrix = glm::inverse(transform);
    m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
}

} // namespace Engine
```

---

## æ¨¡å—ä¸‰ï¼šå®ä½“ç»„ä»¶ç³»ç»Ÿï¼ˆECSï¼‰

### 3.1 ECS æ¶æ„è®¾è®¡

#### æ ¸å¿ƒæ¦‚å¿µ
```cpp
// Entity: å”¯ä¸€ID
using Entity = uint32_t;

// Component: çº¯æ•°æ®ç»“æ„
struct TransformComponent {
    glm::vec3 Position = {0.0f, 0.0f, 0.0f};
    glm::vec3 Rotation = {0.0f, 0.0f, 0.0f};
    glm::vec3 Scale = {1.0f, 1.0f, 1.0f};

    glm::mat4 GetTransform() const {
        glm::mat4 transform = glm::translate(glm::mat4(1.0f), Position);
        transform = glm::rotate(transform, Rotation.x, glm::vec3(1, 0, 0));
        transform = glm::rotate(transform, Rotation.y, glm::vec3(0, 1, 0));
        transform = glm::rotate(transform, Rotation.z, glm::vec3(0, 0, 1));
        transform = glm::scale(transform, Scale);
        return transform;
    }
};

struct SpriteComponent {
    glm::vec4 Color = {1.0f, 1.0f, 1.0f, 1.0f};
    std::shared_ptr<Texture2D> Texture;
};

struct CameraComponent {
    Camera Camera;
    bool Primary = true;
    bool FixedAspectRatio = false;

    CameraComponent() = default;
    CameraComponent(const CameraComponent&) = default;
};

// System: å¤„ç†æ‹¥æœ‰ç‰¹å®šç»„ä»¶çš„å®ä½“
class RenderSystem {
public:
    void Update(EntityManager& entities) {
        // éå†æ‰€æœ‰æ‹¥æœ‰ Transform å’Œ Sprite ç»„ä»¶çš„å®ä½“
        for (auto entity : entities.GetEntitiesWith<TransformComponent, SpriteComponent>()) {
            auto& transform = entities.GetComponent<TransformComponent>(entity);
            auto& sprite = entities.GetComponent<SpriteComponent>(entity);
            
            // æ¸²æŸ“é€»è¾‘
            Renderer::DrawQuad(transform.GetTransform(), sprite.Color, sprite.Texture);
        }
    }
};
```

### 3.2 ç®€åŒ–çš„ ECS å®ç°

```cpp
// Scene.h
#pragma once
#include <vector>
#include <memory>
#include <unordered_map>
#include <typeindex>

namespace Engine {

class Scene;

class Entity {
public:
    Entity() = default;
    Entity(uint32_t handle, Scene* scene) : m_EntityHandle(handle), m_Scene(scene) {}

    template<typename T, typename... Args>
    T& AddComponent(Args&&... args);

    template<typename T>
    T& GetComponent();

    template<typename T>
    bool HasComponent();

    template<typename T>
    void RemoveComponent();

    operator bool() const { return m_EntityHandle != 0; }
    operator uint32_t() const { return m_EntityHandle; }

private:
    uint32_t m_EntityHandle = 0;
    Scene* m_Scene = nullptr;
};

class Scene {
public:
    Scene() = default;
    ~Scene() = default;

    Entity CreateEntity(const std::string& name = "Entity");
    void DestroyEntity(Entity entity);

    void Update(float deltaTime);
    void Render();

private:
    std::unordered_map<std::type_index, std::shared_ptr<void>> m_ComponentArrays;
    std::vector<uint32_t> m_Entities;
    uint32_t m_EntityCounter = 0;

    friend class Entity;
};

} // namespace Engine
```

---

## æ¨¡å—å››ï¼šèµ„æºç®¡ç†ç³»ç»Ÿ

### 4.1 èµ„æºç®¡ç†å™¨è®¾è®¡

```cpp
// ResourceManager.h
#pragma once
#include <string>
#include <unordered_map>
#include <memory>
#include "Shader.h"
#include "Texture.h"

namespace Engine {

class ResourceManager {
public:
    // ç€è‰²å™¨ç®¡ç†
    static std::shared_ptr<Shader> LoadShader(const std::string& name, 
                                                const std::string& vertexPath,
                                                const std::string& fragmentPath);
    static std::shared_ptr<Shader> GetShader(const std::string& name);

    // çº¹ç†ç®¡ç†
    static std::shared_ptr<Texture2D> LoadTexture(const std::string& name, 
                                                    const std::string& path);
    static std::shared_ptr<Texture2D> GetTexture(const std::string& name);

    // æ¸…ç†èµ„æº
    static void Clear();

private:
    static std::unordered_map<std::string, std::shared_ptr<Shader>> s_Shaders;
    static std::unordered_map<std::string, std::shared_ptr<Texture2D>> s_Textures;
};

} // namespace Engine
```

```cpp
// ResourceManager.cpp
#include "ResourceManager.h"
#include <fstream>
#include <sstream>

namespace Engine {

std::unordered_map<std::string, std::shared_ptr<Shader>> ResourceManager::s_Shaders;
std::unordered_map<std::string, std::shared_ptr<Texture2D>> ResourceManager::s_Textures;

std::shared_ptr<Shader> ResourceManager::LoadShader(const std::string& name,
                                                      const std::string& vertexPath,
                                                      const std::string& fragmentPath) {
    // è¯»å–ç€è‰²å™¨æºç 
    std::string vertexCode, fragmentCode;
    std::ifstream vShaderFile, fShaderFile;

    vShaderFile.open(vertexPath);
    fShaderFile.open(fragmentPath);

    std::stringstream vShaderStream, fShaderStream;
    vShaderStream << vShaderFile.rdbuf();
    fShaderStream << fShaderFile.rdbuf();

    vShaderFile.close();
    fShaderFile.close();

    vertexCode = vShaderStream.str();
    fragmentCode = fShaderStream.str();

    // åˆ›å»ºç€è‰²å™¨
    auto shader = Shader::Create(vertexCode, fragmentCode);
    s_Shaders[name] = shader;
    return shader;
}

std::shared_ptr<Shader> ResourceManager::GetShader(const std::string& name) {
    return s_Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const std::string& name,
                                                          const std::string& path) {
    auto texture = Texture2D::Create(path);
    s_Textures[name] = texture;
    return texture;
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(const std::string& name) {
    return s_Textures[name];
}

void ResourceManager::Clear() {
    s_Shaders.clear();
    s_Textures.clear();
}

} // namespace Engine
```

---

## æ¨¡å—äº”ï¼šå®Œæ•´ç¤ºä¾‹é¡¹ç›®

### 5.1 2D æ¸¸æˆç¤ºä¾‹ï¼šæ‰“ç –å—

```cpp
// BreakoutGame.cpp
#include "Engine/Core/Application.h"
#include "Engine/Renderer/Renderer.h"
#include "Engine/Renderer/Shader.h"
#include "Engine/Renderer/Texture.h"
#include "Engine/Core/ResourceManager.h"
#include <glm/gtc/matrix_transform.hpp>

using namespace Engine;

class BreakoutGame : public Application {
public:
    BreakoutGame() : Application("Breakout") {}

    void OnInit() override {
        // åŠ è½½èµ„æº
        ResourceManager::LoadShader("sprite", 
                                     "assets/shaders/sprite.vert", 
                                     "assets/shaders/sprite.frag");
        ResourceManager::LoadTexture("paddle", "assets/textures/paddle.png");
        ResourceManager::LoadTexture("ball", "assets/textures/ball.png");
        ResourceManager::LoadTexture("brick", "assets/textures/brick.png");

        // åˆå§‹åŒ–æ¸¸æˆå¯¹è±¡
        m_PaddlePos = glm::vec2(350.0f, 550.0f);
        m_BallPos = glm::vec2(400.0f, 500.0f);
        m_BallVelocity = glm::vec2(100.0f, -350.0f);

        // åˆ›å»ºç –å—
        InitBricks();
    }

    void OnUpdate(float deltaTime) override {
        // ç§»åŠ¨æŒ¡æ¿
        float velocity = 500.0f * deltaTime;
        if (Input::IsKeyPressed(Key::Left)) {
            m_PaddlePos.x -= velocity;
            if (m_PaddlePos.x < 0.0f)
                m_PaddlePos.x = 0.0f;
        }
        if (Input::IsKeyPressed(Key::Right)) {
            m_PaddlePos.x += velocity;
            if (m_PaddlePos.x > 700.0f)
                m_PaddlePos.x = 700.0f;
        }

        // ç§»åŠ¨çƒ
        m_BallPos += m_BallVelocity * deltaTime;

        // çƒçš„ç¢°æ’æ£€æµ‹
        CheckCollisions();
    }

    void OnRender() override {
        Renderer::BeginScene(m_Camera);

        auto shader = ResourceManager::GetShader("sprite");
        shader->Bind();

        // æ¸²æŸ“ç –å—
        for (auto& brick : m_Bricks) {
            if (!brick.Destroyed) {
                RenderSprite(ResourceManager::GetTexture("brick"), 
                             brick.Position, 
                             glm::vec2(100.0f, 30.0f),
                             0.0f,
                             brick.Color);
            }
        }

        // æ¸²æŸ“æŒ¡æ¿
        RenderSprite(ResourceManager::GetTexture("paddle"),
                     m_PaddlePos,
                     glm::vec2(100.0f, 20.0f),
                     0.0f);

        // æ¸²æŸ“çƒ
        RenderSprite(ResourceManager::GetTexture("ball"),
                     m_BallPos,
                     glm::vec2(20.0f, 20.0f),
                     0.0f);

        Renderer::EndScene();
    }

private:
    struct Brick {
        glm::vec2 Position;
        glm::vec4 Color;
        bool Destroyed = false;
    };

    void InitBricks() {
        // åˆ›å»º5è¡Œ12åˆ—çš„ç –å—
        for (int row = 0; row < 5; row++) {
            for (int col = 0; col < 12; col++) {
                Brick brick;
                brick.Position = glm::vec2(col * 110.0f + 5.0f, row * 40.0f + 5.0f);
                
                // ä¸åŒè¡Œä¸åŒé¢œè‰²
                if (row == 0)
                    brick.Color = glm::vec4(1.0f, 0.0f, 0.0f, 1.0f);
                else if (row == 1)
                    brick.Color = glm::vec4(1.0f, 0.5f, 0.0f, 1.0f);
                else if (row == 2)
                    brick.Color = glm::vec4(1.0f, 1.0f, 0.0f, 1.0f);
                else if (row == 3)
                    brick.Color = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f);
                else
                    brick.Color = glm::vec4(0.0f, 0.5f, 1.0f, 1.0f);

                m_Bricks.push_back(brick);
            }
        }
    }

    void CheckCollisions() {
        // å¢™å£ç¢°æ’
        if (m_BallPos.x <= 0.0f) {
            m_BallVelocity.x = -m_BallVelocity.x;
            m_BallPos.x = 0.0f;
        }
        if (m_BallPos.x >= 780.0f) {
            m_BallVelocity.x = -m_BallVelocity.x;
            m_BallPos.x = 780.0f;
        }
        if (m_BallPos.y <= 0.0f) {
            m_BallVelocity.y = -m_BallVelocity.y;
            m_BallPos.y = 0.0f;
        }

        // æŒ¡æ¿ç¢°æ’
        if (CheckCollision(m_BallPos, glm::vec2(20.0f), m_PaddlePos, glm::vec2(100.0f, 20.0f))) {
            m_BallVelocity.y = -std::abs(m_BallVelocity.y);
        }

        // ç –å—ç¢°æ’
        for (auto& brick : m_Bricks) {
            if (!brick.Destroyed) {
                if (CheckCollision(m_BallPos, glm::vec2(20.0f), brick.Position, glm::vec2(100.0f, 30.0f))) {
                    brick.Destroyed = true;
                    m_BallVelocity.y = -m_BallVelocity.y;
                }
            }
        }
    }

    bool CheckCollision(glm::vec2 posA, glm::vec2 sizeA, glm::vec2 posB, glm::vec2 sizeB) {
        bool collisionX = posA.x + sizeA.x >= posB.x && posB.x + sizeB.x >= posA.x;
        bool collisionY = posA.y + sizeA.y >= posB.y && posB.y + sizeB.y >= posA.y;
        return collisionX && collisionY;
    }

    void RenderSprite(std::shared_ptr<Texture2D> texture, 
                      glm::vec2 position, 
                      glm::vec2 size,
                      float rotation,
                      glm::vec4 color = glm::vec4(1.0f)) {
        // æ¸²æŸ“ç²¾çµçš„ä»£ç 
        // ä½¿ç”¨ Renderer::DrawQuad æˆ–è‡ªå®šä¹‰æ¸²æŸ“é€»è¾‘
    }

    Camera m_Camera;
    glm::vec2 m_PaddlePos;
    glm::vec2 m_BallPos;
    glm::vec2 m_BallVelocity;
    std::vector<Brick> m_Bricks;
};

Application* CreateApplication() {
    return new BreakoutGame();
}
```

---

## å­¦ä¹ æ•ˆæœéªŒè¯æ ‡å‡†

### 1. åŸºç¡€èƒ½åŠ›éªŒè¯
- [ ] èƒ½å¤Ÿæ­å»ºå®Œæ•´çš„C++æ¸¸æˆå¼•æ“é¡¹ç›®ç»“æ„
- [ ] ç†è§£æ¸¸æˆå¼•æ“çš„å±‚çº§æ¶æ„å’Œæ¨¡å—åˆ’åˆ†
- [ ] æŒæ¡OpenGL/GLFWçš„åŸºç¡€ä½¿ç”¨
- [ ] èƒ½å¤Ÿå®ç°çª—å£ã€è¾“å…¥ã€æ¸²æŸ“çš„åŸºç¡€æ¡†æ¶

### 2. æ ¸å¿ƒç³»ç»ŸéªŒè¯
- [ ] å®ç°Shaderã€Textureç®¡ç†ç³»ç»Ÿ
- [ ] å®ç°2D/3Dæ‘„åƒæœºç³»ç»Ÿ
- [ ] å®ç°åŸºç¡€çš„æ¸²æŸ“å™¨ï¼ˆæ”¯æŒç»˜åˆ¶åŸºæœ¬å›¾å½¢ï¼‰
- [ ] å®ç°èµ„æºç®¡ç†ç³»ç»Ÿï¼ˆçº¹ç†ã€ç€è‰²å™¨ï¼‰

### 3. é«˜çº§åŠŸèƒ½éªŒè¯
- [ ] å®ç°å®ä½“ç»„ä»¶ç³»ç»Ÿï¼ˆECSï¼‰
- [ ] é›†æˆç‰©ç†å¼•æ“ï¼ˆBox2Dæˆ–Bulletï¼‰
- [ ] å®ç°åœºæ™¯ç®¡ç†å’Œåºåˆ—åŒ–
- [ ] å®ç°è„šæœ¬ç³»ç»Ÿé›†æˆï¼ˆLua/ChaiScriptï¼‰

### 4. é¡¹ç›®å®æˆ˜éªŒè¯
- [ ] å¼€å‘å®Œæ•´çš„2Dæ¸¸æˆï¼ˆå¦‚æ‰“ç –å—ã€è´ªåƒè›‡ï¼‰
- [ ] å¼€å‘ç®€å•çš„3Dæ¼”ç¤ºç¨‹åº
- [ ] å®ç°æ¸¸æˆç¼–è¾‘å™¨åŸºç¡€åŠŸèƒ½
- [ ] æ€§èƒ½åˆ†æå’Œä¼˜åŒ–å®è·µ

### 5. ç»¼åˆèƒ½åŠ›éªŒè¯
- [ ] èƒ½å¤Ÿç‹¬ç«‹è®¾è®¡å¼•æ“æ¶æ„
- [ ] æŒæ¡ç°ä»£C++ç‰¹æ€§åº”ç”¨ï¼ˆæ™ºèƒ½æŒ‡é’ˆã€æ¨¡æ¿ã€lambdaï¼‰
- [ ] ç†è§£å›¾å½¢ç®¡çº¿å’Œæ¸²æŸ“ä¼˜åŒ–
- [ ] èƒ½å¤Ÿé˜…è¯»å’Œç†è§£å•†ä¸šå¼•æ“æºç 

---

## è¿›é˜¶å­¦ä¹ è·¯å¾„

### é˜¶æ®µä¸€ï¼šåŸºç¡€æ¶æ„ï¼ˆ1-2æœˆï¼‰
1. **C++ç°ä»£ç‰¹æ€§**
   - æ™ºèƒ½æŒ‡é’ˆï¼ˆunique_ptrã€shared_ptrï¼‰
   - RAIIèµ„æºç®¡ç†
   - æ¨¡æ¿ç¼–ç¨‹
   - Lambdaè¡¨è¾¾å¼

2. **å¼•æ“æ¡†æ¶æ­å»º**
   - Applicationå±‚è®¾è®¡
   - çª—å£å’Œè¾“å…¥ç³»ç»Ÿ
   - åŸºç¡€æ¸²æŸ“å™¨
   - èµ„æºç®¡ç†å™¨

### é˜¶æ®µäºŒï¼šæ ¸å¿ƒç³»ç»Ÿï¼ˆ2-4æœˆï¼‰
1. **æ¸²æŸ“ç³»ç»Ÿ**
   - OpenGLæ·±å…¥å­¦ä¹ 
   - ç€è‰²å™¨ç¼–ç¨‹ï¼ˆGLSLï¼‰
   - çº¹ç†å’Œæè´¨ç³»ç»Ÿ
   - æ‰¹æ¸²æŸ“ä¼˜åŒ–

2. **åœºæ™¯ç®¡ç†**
   - ECSæ¶æ„å®ç°
   - åœºæ™¯å›¾ï¼ˆScene Graphï¼‰
   - ç©ºé—´åˆ†åŒºï¼ˆå››å‰æ ‘ã€å…«å‰æ ‘ï¼‰

### é˜¶æ®µä¸‰ï¼šé«˜çº§åŠŸèƒ½ï¼ˆ4-6æœˆï¼‰
1. **ç‰©ç†é›†æˆ**
   - Box2D/Bulleté›†æˆ
   - ç¢°æ’æ£€æµ‹ä¼˜åŒ–
   - ç‰©ç†æè´¨ç³»ç»Ÿ

2. **è„šæœ¬ç³»ç»Ÿ**
   - Lua/ChaiScripté›†æˆ
   - çƒ­é‡è½½æ”¯æŒ
   - è°ƒè¯•æ¥å£

### é˜¶æ®µå››ï¼šå·¥å…·é“¾ï¼ˆ6-9æœˆï¼‰
1. **ç¼–è¾‘å™¨å¼€å‘**
   - ImGuié›†æˆ
   - åœºæ™¯ç¼–è¾‘å™¨
   - èµ„æºæµè§ˆå™¨
   - å±æ€§é¢æ¿

2. **åºåˆ—åŒ–ç³»ç»Ÿ**
   - åœºæ™¯ä¿å­˜/åŠ è½½
   - èµ„æºæ‰“åŒ…
   - é…ç½®æ–‡ä»¶ç®¡ç†

---

## æ‰©å±•èµ„æº

### å¼€æºå¼•æ“å­¦ä¹ 
- **Hazel Engine** (https://github.com/TheCherno/Hazel)
  - ä¼˜ç§€çš„C++æ¸¸æˆå¼•æ“æ•™ç¨‹é¡¹ç›®
  - YouTubeé¢‘é“ï¼šThe Cherno
  
- **Sparky Engine** (https://github.com/TheCherno/Sparky)
  - 2Dæ¸¸æˆå¼•æ“ç¤ºä¾‹

- **Godot Engine** (https://github.com/godotengine/godot)
  - å¼€æº3Då¼•æ“ï¼Œå­¦ä¹ ç”Ÿäº§çº§ä»£ç 

### å›¾å½¢ç¼–ç¨‹èµ„æº
- **LearnOpenGL** (https://learnopengl.com/)
  - OpenGLæƒå¨æ•™ç¨‹ï¼Œä¸­æ–‡ç‰ˆï¼šlearnopengl-cn.github.io
  
- **OpenGL SuperBible**
  - OpenGLç¼–ç¨‹åœ£ç»

- **Real-Time Rendering**
  - å®æ—¶æ¸²æŸ“ç†è®ºä¹¦ç±

### C++èµ„æº
- **Effective Modern C++**
  - ç°ä»£C++æœ€ä½³å®è·µ
  
- **C++ Primer Plus**
  - C++å…¥é—¨ç»å…¸

### æ¸¸æˆå¼•æ“æ¶æ„
- **Game Engine Architecture** (Jason Gregory)
  - æ¸¸æˆå¼•æ“æ¶æ„åœ£ç»
  
- **Game Programming Patterns** (Robert Nystrom)
  - æ¸¸æˆç¼–ç¨‹æ¨¡å¼

### åœ¨çº¿è¯¾ç¨‹
- **Udemy**: C++ Game Engine Programming
- **Coursera**: Computer Graphics
- **YouTube**: The Cherno Game Engine Series

---

## å¸¸è§é—®é¢˜è§£ç­”

### Q1: éœ€è¦ä»€ä¹ˆçº§åˆ«çš„C++çŸ¥è¯†ï¼Ÿ
**ç­”**: 
- åŸºç¡€ï¼šç±»ã€ç»§æ‰¿ã€å¤šæ€ã€æ¨¡æ¿åŸºç¡€
- è¿›é˜¶ï¼šæ™ºèƒ½æŒ‡é’ˆã€RAIIã€ç§»åŠ¨è¯­ä¹‰
- æ¨èå…ˆå­¦ä¹ ç°ä»£C++ï¼ˆC++11/14ï¼‰

### Q2: é€‰æ‹©OpenGLè¿˜æ˜¯DirectXï¼Ÿ
**ç­”**:
- **OpenGL**: è·¨å¹³å°ï¼Œæ˜“å­¦ï¼Œèµ„æ–™ä¸°å¯Œï¼ˆæ¨èåˆå­¦ï¼‰
- **DirectX**: Windowså¹³å°æ€§èƒ½æ›´å¥½ï¼Œä½†ä»…é™Windows
- **Vulkan**: ç°ä»£APIï¼Œæ€§èƒ½æœ€ä½³ï¼Œä½†å­¦ä¹ æ›²çº¿é™¡

### Q3: ä»2Dè¿˜æ˜¯3Då¼€å§‹ï¼Ÿ
**ç­”**:
- æ¨èä»2Då¼€å§‹ï¼š
  - æ¦‚å¿µæ›´ç®€å•ï¼ˆæ— Zè½´ã€æ— å¤æ‚å…‰ç…§ï¼‰
  - æ¸²æŸ“æ›´ç®€å•ï¼ˆæ­£äº¤æŠ•å½±ï¼‰
  - æ›´å¿«çœ‹åˆ°æˆæœ
- 2Då¼•æ“åŸºç¡€åŒæ ·é€‚ç”¨äº3D

### Q4: éœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿ
**ç­”**:
- åŸºç¡€æ¡†æ¶ï¼š1-2æœˆ
- å¯ç”¨å¼•æ“ï¼š3-6æœˆ
- åŠŸèƒ½å®Œå–„ï¼š6-12æœˆ
- å–å†³äºæ¯å¤©æŠ•å…¥æ—¶é—´å’ŒC++åŸºç¡€

### Q5: æ˜¯å¦è¦å…¨éƒ¨ä»é›¶å®ç°ï¼Ÿ
**ç­”**:
- **ä¸æ¨è**å…¨éƒ¨ä»é›¶å®ç°
- ä½¿ç”¨æˆç†Ÿç¬¬ä¸‰æ–¹åº“ï¼š
  - çª—å£ï¼šGLFW/SDL
  - å›¾åƒï¼šstb_image
  - æ•°å­¦ï¼šGLM
  - ç‰©ç†ï¼šBox2D/Bullet
- é‡ç‚¹æ”¾åœ¨å¼•æ“æ¶æ„è®¾è®¡å’Œé›†æˆ

---

## å®æˆ˜é¡¹ç›®å»ºè®®

### é¡¹ç›®1: 2Dç²¾çµå¼•æ“ï¼ˆéš¾åº¦ï¼šâ˜…â˜…â˜†â˜†â˜†ï¼‰
**åŠŸèƒ½**:
- ç²¾çµæ¸²æŸ“
- åŠ¨ç”»ç³»ç»Ÿ
- ç¢°æ’æ£€æµ‹
- ç®€å•ç²’å­ç³»ç»Ÿ

**å‚è€ƒæ¸¸æˆ**: æ‰“ç –å—ã€è´ªåƒè›‡

### é¡¹ç›®2: 2Då¹³å°æ¸¸æˆå¼•æ“ï¼ˆéš¾åº¦ï¼šâ˜…â˜…â˜…â˜†â˜†ï¼‰
**åŠŸèƒ½**:
- ç“¦ç‰‡åœ°å›¾
- ç‰©ç†å¼•æ“é›†æˆ
- ç›¸æœºè·Ÿéš
- å…³å¡ç¼–è¾‘å™¨

**å‚è€ƒæ¸¸æˆ**: é©¬é‡Œå¥¥ã€Celeste

### é¡¹ç›®3: ç®€å•3Då¼•æ“ï¼ˆéš¾åº¦ï¼šâ˜…â˜…â˜…â˜…â˜†ï¼‰
**åŠŸèƒ½**:
- 3Dæ¨¡å‹åŠ è½½
- å…‰ç…§ç³»ç»Ÿ
- æè´¨ç³»ç»Ÿ
- é˜´å½±

**å‚è€ƒ**: Minecrafté£æ ¼æ¸²æŸ“

### é¡¹ç›®4: ECSæ¶æ„å¼•æ“ï¼ˆéš¾åº¦ï¼šâ˜…â˜…â˜…â˜…â˜…ï¼‰
**åŠŸèƒ½**:
- å®Œæ•´ECSå®ç°
- åœºæ™¯åºåˆ—åŒ–
- è„šæœ¬é›†æˆ
- å¤šçº¿ç¨‹æ¸²æŸ“

---

## æ€»ç»“

è‡ªåˆ¶C++æ¸¸æˆå¼•æ“æ˜¯ä¸€ä¸ªå……æ»¡æŒ‘æˆ˜ä½†æå…·ä»·å€¼çš„å­¦ä¹ è¿‡ç¨‹ï¼š

**æ ¸å¿ƒæ”¶è·**:
- æ·±å…¥ç†è§£æ¸¸æˆå¼•æ“åŸç†
- æŒæ¡ç°ä»£C++ç¼–ç¨‹
- å›¾å½¢ç¼–ç¨‹å®æˆ˜èƒ½åŠ›
- è½¯ä»¶æ¶æ„è®¾è®¡ç»éªŒ

**å­¦ä¹ ç­–ç•¥**:
1. å¾ªåºæ¸è¿›ï¼Œå…ˆ2Då3D
2. é‡è§†æ¶æ„è®¾è®¡ï¼Œé¿å…è¿‡æ—©ä¼˜åŒ–
3. å‚è€ƒä¼˜ç§€å¼€æºé¡¹ç›®
4. å¤šåšé¡¹ç›®å®è·µ

**é€‚åˆäººç¾¤**:
- æƒ³æ·±å…¥ç†è§£å¼•æ“çš„å¼€å‘è€…
- è¿½æ±‚æŠ€æœ¯æ·±åº¦çš„å­¦ä¹ è€…
- æœ‰å……è¶³æ—¶é—´æŠ•å…¥çš„å­¦ç”Ÿ
- ç‹¬ç«‹æ¸¸æˆå¼€å‘è€…

è®°ä½ï¼šåˆ¶ä½œå¼•æ“ä¸æ˜¯ç›®çš„ï¼Œé€šè¿‡åˆ¶ä½œå¼•æ“å­¦ä¹ åº•å±‚æŠ€æœ¯ã€æå‡ç¼–ç¨‹èƒ½åŠ›æ‰æ˜¯æ ¸å¿ƒä»·å€¼ï¼

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:
1. æ­å»ºåŸºç¡€é¡¹ç›®æ¡†æ¶ï¼ˆCMake + GLFW + GLADï¼‰
2. å®ç°çª—å£å’ŒåŸºç¡€æ¸²æŸ“
3. å®Œæˆä¸€ä¸ªç®€å•çš„2Dæ¸¸æˆï¼ˆå¦‚æ‰“ç –å—ï¼‰
4. é€æ­¥æ·»åŠ æ›´å¤šç³»ç»Ÿï¼ˆç‰©ç†ã€éŸ³é¢‘ã€è„šæœ¬ï¼‰
5. å¼€å‘è‡ªå·±çš„å®Œæ•´æ¸¸æˆä½œå“

ç¥ä½ åœ¨æ¸¸æˆå¼•æ“å¼€å‘ä¹‹æ—…ä¸­æ”¶è·æ»¡æ»¡ï¼ğŸš€
