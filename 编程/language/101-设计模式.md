# 设计模式完整学习笔记

## 学习目标定位
- **目标群体**: 有面向对象编程基础的开发者
- **学习周期**: 6-8周
- **前置要求**: 熟悉Python或Java等面向对象语言
- **学习成果**: 掌握23种经典设计模式，能在实际项目中灵活应用

## 学习路径

```
设计原则(Week 1) → 创建型模式(Week 2-3) → 结构型模式(Week 4-5)
→ 行为型模式(Week 6-7) → 实战项目(Week 8)
```

---

## 第一模块：设计模式基础

### 1.1 什么是设计模式

**定义**：
- 在软件设计中针对特定问题的经典解决方案
- 可复用的代码结构和设计思想
- 前人经验的总结和提炼

**设计模式的三要素**：
1. **问题**：在什么情况下使用这个模式
2. **解决方案**：模式的组成部分、结构和协作方式
3. **效果**：使用模式的优缺点和权衡

**GOF 23种设计模式分类**：
```
创建型模式（5种）
├─ 单例模式（Singleton）
├─ 工厂方法（Factory Method）
├─ 抽象工厂（Abstract Factory）
├─ 建造者模式（Builder）
└─ 原型模式（Prototype）

结构型模式（7种）
├─ 适配器模式（Adapter）
├─ 桥接模式（Bridge）
├─ 组合模式（Composite）
├─ 装饰器模式（Decorator）
├─ 外观模式（Facade）
├─ 享元模式（Flyweight）
└─ 代理模式（Proxy）

行为型模式（11种）
├─ 责任链模式（Chain of Responsibility）
├─ 命令模式（Command）
├─ 解释器模式（Interpreter）
├─ 迭代器模式（Iterator）
├─ 中介者模式（Mediator）
├─ 备忘录模式（Memento）
├─ 观察者模式（Observer）
├─ 状态模式（State）
├─ 策略模式（Strategy）
├─ 模板方法（Template Method）
└─ 访问者模式（Visitor）
```

### 1.2 SOLID设计原则

#### 单一职责原则（SRP）
**定义**：一个类应该只有一个引起它变化的原因

```python
# ❌ 违反SRP：一个类负责多个职责
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def save_to_database(self):
        # 数据库操作
        pass

    def send_email(self):
        # 邮件发送
        pass

# ✅ 遵循SRP：职责分离
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserRepository:
    def save(self, user):
        # 数据库操作
        pass

class EmailService:
    def send(self, email, message):
        # 邮件发送
        pass
```

#### 开闭原则（OCP）
**定义**：软件实体应该对扩展开放，对修改关闭

```python
# ❌ 违反OCP：每次新增形状都要修改
class AreaCalculator:
    def calculate(self, shapes):
        total = 0
        for shape in shapes:
            if isinstance(shape, Circle):
                total += 3.14 * shape.radius ** 2
            elif isinstance(shape, Rectangle):
                total += shape.width * shape.height
        return total

# ✅ 遵循OCP：使用多态
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class AreaCalculator:
    def calculate(self, shapes):
        return sum(shape.area() for shape in shapes)
```

#### 里氏替换原则（LSP）
**定义**：子类必须能够替换其基类

```python
# ❌ 违反LSP：正方形不能完全替代矩形
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def set_width(self, width):
        self.width = width

    def set_height(self, height):
        self.height = height

    def area(self):
        return self.width * self.height

class Square(Rectangle):
    def set_width(self, width):
        self.width = width
        self.height = width  # 强制宽高一致

    def set_height(self, height):
        self.width = height
        self.height = height

# ✅ 遵循LSP：分离接口
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side ** 2
```

#### 接口隔离原则（ISP）
**定义**：不应该强迫客户依赖它们不使用的方法

```python
# ❌ 违反ISP：接口过于庞大
from abc import ABC, abstractmethod

class Worker(ABC):
    @abstractmethod
    def work(self):
        pass

    @abstractmethod
    def eat(self):
        pass

class HumanWorker(Worker):
    def work(self):
        print("工作中...")

    def eat(self):
        print("吃饭中...")

class RobotWorker(Worker):
    def work(self):
        print("工作中...")

    def eat(self):
        pass  # 机器人不需要吃饭

# ✅ 遵循ISP：接口细分
class Workable(ABC):
    @abstractmethod
    def work(self):
        pass

class Eatable(ABC):
    @abstractmethod
    def eat(self):
        pass

class HumanWorker(Workable, Eatable):
    def work(self):
        print("工作中...")

    def eat(self):
        print("吃饭中...")

class RobotWorker(Workable):
    def work(self):
        print("工作中...")
```

#### 依赖倒置原则（DIP）
**定义**：高层模块不应该依赖低层模块，两者都应该依赖抽象

```python
# ❌ 违反DIP：高层模块直接依赖低层模块
class MySQLDatabase:
    def save(self, data):
        print("保存到MySQL")

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # 紧耦合

    def create_user(self, user):
        self.db.save(user)

# ✅ 遵循DIP：依赖抽象
from abc import ABC, abstractmethod

class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

class MySQLDatabase(Database):
    def save(self, data):
        print("保存到MySQL")

class MongoDatabase(Database):
    def save(self, data):
        print("保存到MongoDB")

class UserService:
    def __init__(self, database: Database):
        self.db = database  # 依赖抽象

    def create_user(self, user):
        self.db.save(user)

# 使用
mysql_db = MySQLDatabase()
user_service = UserService(mysql_db)
```

---

## 第二模块：创建型模式

### 2.1 单例模式（Singleton）

#### 模式意图
确保一个类只有一个实例，并提供全局访问点。

#### 适用场景
- 需要全局唯一的配置对象
- 数据库连接池
- 日志记录器
- 线程池

#### Python实现方式

**方法1：使用`__new__`方法**
```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        self.value = None

# 测试
s1 = Singleton()
s2 = Singleton()
print(s1 is s2)  # True

s1.value = 100
print(s2.value)  # 100
```

**方法2：装饰器实现**
```python
def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class DatabaseConnection:
    def __init__(self):
        self.connection = "Connected"

# 测试
db1 = DatabaseConnection()
db2 = DatabaseConnection()
print(db1 is db2)  # True
```

**方法3：元类实现（最Pythonic）**
```python
class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Logger(metaclass=SingletonMeta):
    def __init__(self):
        self.logs = []

    def log(self, message):
        self.logs.append(message)
        print(f"[LOG] {message}")

# 测试
logger1 = Logger()
logger2 = Logger()
print(logger1 is logger2)  # True

logger1.log("系统启动")
logger2.log("用户登录")
print(logger1.logs)  # ['系统启动', '用户登录']
```

**方法4：模块级单例（推荐）**
```python
# config.py
class Config:
    def __init__(self):
        self.database_url = "localhost:5432"
        self.debug = True

config = Config()  # 模块级单例

# 使用
from config import config
print(config.database_url)
```

#### 线程安全的单例
```python
import threading

class ThreadSafeSingleton:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            with cls._lock:
                # 双重检查锁定
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
```

### 2.2 工厂方法模式（Factory Method）

#### 模式意图
定义创建对象的接口，让子类决定实例化哪个类。

#### 适用场景
- 不知道确切需要创建哪个类的实例
- 希望子类指定创建对象
- 将创建逻辑委托给子类

#### Python实现
```python
from abc import ABC, abstractmethod

# 产品接口
class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

# 具体产品
class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class Cow(Animal):
    def speak(self):
        return "Moo!"

# 工厂接口
class AnimalFactory(ABC):
    @abstractmethod
    def create_animal(self) -> Animal:
        pass

    def interact(self):
        animal = self.create_animal()
        print(f"Animal says: {animal.speak()}")

# 具体工厂
class DogFactory(AnimalFactory):
    def create_animal(self):
        return Dog()

class CatFactory(AnimalFactory):
    def create_animal(self):
        return Cat()

# 使用
def client_code(factory: AnimalFactory):
    factory.interact()

print("Using Dog Factory:")
client_code(DogFactory())

print("\nUsing Cat Factory:")
client_code(CatFactory())
```

#### 简化版工厂（静态工厂方法）
```python
class ShapeFactory:
    @staticmethod
    def create_shape(shape_type):
        shapes = {
            'circle': Circle,
            'rectangle': Rectangle,
            'triangle': Triangle
        }

        shape_class = shapes.get(shape_type.lower())
        if shape_class:
            return shape_class()
        raise ValueError(f"Unknown shape: {shape_type}")

# 使用
shape = ShapeFactory.create_shape('circle')
```

### 2.3 抽象工厂模式（Abstract Factory）

#### 模式意图
提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。

#### 适用场景
- 需要创建一系列相关对象
- 系统需要独立于产品创建、组合和表示
- 强调产品家族的一致性

#### Python实现
```python
from abc import ABC, abstractmethod

# 抽象产品：按钮
class Button(ABC):
    @abstractmethod
    def render(self):
        pass

# 抽象产品：输入框
class Input(ABC):
    @abstractmethod
    def render(self):
        pass

# 具体产品：Windows风格
class WindowsButton(Button):
    def render(self):
        return "Rendering Windows Button"

class WindowsInput(Input):
    def render(self):
        return "Rendering Windows Input"

# 具体产品：Mac风格
class MacButton(Button):
    def render(self):
        return "Rendering Mac Button"

class MacInput(Input):
    def render(self):
        return "Rendering Mac Input"

# 抽象工厂
class GUIFactory(ABC):
    @abstractmethod
    def create_button(self) -> Button:
        pass

    @abstractmethod
    def create_input(self) -> Input:
        pass

# 具体工厂
class WindowsFactory(GUIFactory):
    def create_button(self):
        return WindowsButton()

    def create_input(self):
        return WindowsInput()

class MacFactory(GUIFactory):
    def create_button(self):
        return MacButton()

    def create_input(self):
        return MacInput()

# 客户端代码
def create_ui(factory: GUIFactory):
    button = factory.create_button()
    input_field = factory.create_input()

    print(button.render())
    print(input_field.render())

# 使用
import platform

if platform.system() == "Windows":
    factory = WindowsFactory()
else:
    factory = MacFactory()

create_ui(factory)
```

### 2.4 建造者模式（Builder）

#### 模式意图
将复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。

#### 适用场景
- 需要创建复杂对象（多个步骤、多个参数）
- 希望构建过程独立于组成部分
- 需要生成不同表示的产品

#### Python实现
```python
# 产品
class Computer:
    def __init__(self):
        self.cpu = None
        self.memory = None
        self.storage = None
        self.gpu = None

    def __str__(self):
        return f"""Computer Configuration:
- CPU: {self.cpu}
- Memory: {self.memory}
- Storage: {self.storage}
- GPU: {self.gpu}"""

# 建造者接口
from abc import ABC, abstractmethod

class ComputerBuilder(ABC):
    def __init__(self):
        self.computer = Computer()

    @abstractmethod
    def build_cpu(self):
        pass

    @abstractmethod
    def build_memory(self):
        pass

    @abstractmethod
    def build_storage(self):
        pass

    @abstractmethod
    def build_gpu(self):
        pass

    def get_computer(self):
        return self.computer

# 具体建造者：游戏电脑
class GamingComputerBuilder(ComputerBuilder):
    def build_cpu(self):
        self.computer.cpu = "Intel i9-13900K"
        return self

    def build_memory(self):
        self.computer.memory = "32GB DDR5"
        return self

    def build_storage(self):
        self.computer.storage = "2TB NVMe SSD"
        return self

    def build_gpu(self):
        self.computer.gpu = "NVIDIA RTX 4090"
        return self

# 具体建造者：办公电脑
class OfficeComputerBuilder(ComputerBuilder):
    def build_cpu(self):
        self.computer.cpu = "Intel i5-12400"
        return self

    def build_memory(self):
        self.computer.memory = "16GB DDR4"
        return self

    def build_storage(self):
        self.computer.storage = "512GB SSD"
        return self

    def build_gpu(self):
        self.computer.gpu = "Integrated Graphics"
        return self

# 指挥者（可选）
class ComputerDirector:
    def __init__(self, builder: ComputerBuilder):
        self.builder = builder

    def construct(self):
        return (self.builder
                .build_cpu()
                .build_memory()
                .build_storage()
                .build_gpu()
                .get_computer())

# 使用示例1：使用指挥者
director = ComputerDirector(GamingComputerBuilder())
gaming_pc = director.construct()
print(gaming_pc)

# 使用示例2：链式调用（更Pythonic）
office_pc = (OfficeComputerBuilder()
             .build_cpu()
             .build_memory()
             .build_storage()
             .build_gpu()
             .get_computer())
print(office_pc)
```

### 2.5 原型模式（Prototype）

#### 模式意图
通过复制现有实例来创建新对象，而不是通过new关键字。

#### 适用场景
- 创建对象成本较大
- 需要避免创建与产品类层次平行的工厂类
- 对象的类在运行时确定

#### Python实现
```python
import copy
from abc import ABC, abstractmethod

class Prototype(ABC):
    @abstractmethod
    def clone(self):
        pass

class Person(Prototype):
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address  # 假设address是可变对象

    def clone(self):
        # 浅拷贝
        return copy.copy(self)

    def deep_clone(self):
        # 深拷贝
        return copy.deepcopy(self)

    def __str__(self):
        return f"Person(name={self.name}, age={self.age}, address={self.address})"

# 使用
original = Person("Alice", 25, {"city": "Beijing", "street": "Main St"})
print(f"Original: {original}")

# 浅拷贝
shallow_copy = original.clone()
shallow_copy.name = "Bob"
shallow_copy.address["city"] = "Shanghai"  # 会影响原对象
print(f"Original after shallow copy: {original}")
print(f"Shallow copy: {shallow_copy}")

# 深拷贝
deep_copy = original.deep_clone()
deep_copy.name = "Charlie"
deep_copy.address["city"] = "Guangzhou"  # 不影响原对象
print(f"Original after deep copy: {original}")
print(f"Deep copy: {deep_copy}")
```

#### 原型管理器
```python
class PrototypeManager:
    def __init__(self):
        self._prototypes = {}

    def register(self, name, prototype):
        self._prototypes[name] = prototype

    def unregister(self, name):
        del self._prototypes[name]

    def clone(self, name):
        prototype = self._prototypes.get(name)
        if prototype:
            return copy.deepcopy(prototype)
        raise ValueError(f"Prototype '{name}' not found")

# 使用
manager = PrototypeManager()
manager.register("default_person", Person("Default", 20, {"city": "Beijing"}))

# 克隆并修改
person1 = manager.clone("default_person")
person1.name = "Alice"

person2 = manager.clone("default_person")
person2.name = "Bob"
```

---

## 第三模块：结构型模式

### 3.1 适配器模式（Adapter）

#### 模式意图
将一个类的接口转换为客户期望的另一个接口，使原本不兼容的类可以一起工作。

#### 适用场景
- 想使用现有类，但接口不符合需求
- 创建可复用的类，与不相关的类协作
- 需要使用多个子类，但不能逐个适配接口

#### Python实现

**类适配器（使用继承）**
```python
# 目标接口
class Target:
    def request(self):
        return "Target: Default behavior"

# 需要适配的类
class Adaptee:
    def specific_request(self):
        return "Adaptee: Specific behavior"

# 类适配器
class Adapter(Target, Adaptee):
    def request(self):
        return f"Adapter: {self.specific_request()}"

# 使用
def client_code(target: Target):
    print(target.request())

print("Client can work with Target objects:")
target = Target()
client_code(target)

print("\nAdaptee has incompatible interface:")
adaptee = Adaptee()
print(f"Adaptee: {adaptee.specific_request()}")

print("\nAdapter makes Adaptee compatible:")
adapter = Adapter()
client_code(adapter)
```

**对象适配器（使用组合，推荐）**
```python
class ObjectAdapter(Target):
    def __init__(self, adaptee: Adaptee):
        self.adaptee = adaptee

    def request(self):
        return f"Adapter: {self.adaptee.specific_request()}"

# 使用
adaptee = Adaptee()
adapter = ObjectAdapter(adaptee)
client_code(adapter)
```

#### 实际应用：数据库适配器
```python
from abc import ABC, abstractmethod

# 统一数据库接口
class Database(ABC):
    @abstractmethod
    def connect(self):
        pass

    @abstractmethod
    def query(self, sql):
        pass

# MySQL原始实现
class MySQLDatabase:
    def mysql_connect(self, host, user, password):
        return f"MySQL connected to {host}"

    def execute_sql(self, sql):
        return f"MySQL executed: {sql}"

# PostgreSQL原始实现
class PostgreSQLDatabase:
    def pg_connect(self, connection_string):
        return f"PostgreSQL connected: {connection_string}"

    def run_query(self, query):
        return f"PostgreSQL executed: {query}"

# MySQL适配器
class MySQLAdapter(Database):
    def __init__(self, mysql_db: MySQLDatabase):
        self.mysql_db = mysql_db

    def connect(self):
        return self.mysql_db.mysql_connect("localhost", "root", "password")

    def query(self, sql):
        return self.mysql_db.execute_sql(sql)

# PostgreSQL适配器
class PostgreSQLAdapter(Database):
    def __init__(self, pg_db: PostgreSQLDatabase):
        self.pg_db = pg_db

    def connect(self):
        return self.pg_db.pg_connect("postgresql://localhost:5432")

    def query(self, sql):
        return self.pg_db.run_query(sql)

# 使用统一接口
def database_operations(db: Database):
    print(db.connect())
    print(db.query("SELECT * FROM users"))

# 测试
mysql = MySQLAdapter(MySQLDatabase())
postgres = PostgreSQLAdapter(PostgreSQLDatabase())

database_operations(mysql)
database_operations(postgres)
```

### 3.2 装饰器模式（Decorator）

#### 模式意图
动态地给对象添加额外的职责，而不改变其结构。

#### 适用场景
- 需要动态、透明地给对象添加职责
- 职责可以撤销
- 不能使用子类扩展（类定义被隐藏或不能生成子类）

#### Python实现

**基础装饰器模式**
```python
from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    @abstractmethod
    def operation(self) -> str:
        pass

# 具体组件
class ConcreteComponent(Component):
    def operation(self):
        return "ConcreteComponent"

# 装饰器基类
class Decorator(Component):
    def __init__(self, component: Component):
        self._component = component

    def operation(self):
        return self._component.operation()

# 具体装饰器A
class ConcreteDecoratorA(Decorator):
    def operation(self):
        return f"ConcreteDecoratorA({self._component.operation()})"

# 具体装饰器B
class ConcreteDecoratorB(Decorator):
    def operation(self):
        return f"ConcreteDecoratorB({self._component.operation()})"

# 使用
component = ConcreteComponent()
print(f"Client: {component.operation()}")

decorator1 = ConcreteDecoratorA(component)
print(f"Client: {decorator1.operation()}")

decorator2 = ConcreteDecoratorB(decorator1)
print(f"Client: {decorator2.operation()}")
```

#### Python装饰器语法实现
```python
from functools import wraps
import time

# 计时装饰器
def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f}s")
        return result
    return wrapper

# 日志装饰器
def logger(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper

# 缓存装饰器
def memoize(func):
    cache = {}

    @wraps(func)
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper

# 使用多个装饰器
@timer
@logger
@memoize
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 测试
print(fibonacci(10))
```

#### 实际应用：Web路由装饰器
```python
class WebApp:
    def __init__(self):
        self.routes = {}

    def route(self, path):
        def decorator(func):
            self.routes[path] = func
            return func
        return decorator

    def handle_request(self, path):
        handler = self.routes.get(path)
        if handler:
            return handler()
        return "404 Not Found"

app = WebApp()

@app.route("/")
def home():
    return "Home Page"

@app.route("/about")
def about():
    return "About Page"

# 测试
print(app.handle_request("/"))      # Home Page
print(app.handle_request("/about"))  # About Page
print(app.handle_request("/404"))    # 404 Not Found
```

### 3.3 外观模式（Facade）

#### 模式意图
为子系统中的一组接口提供统一的高层接口，使子系统更易用。

#### 适用场景
- 需要为复杂子系统提供简单接口
- 客户程序与抽象类的实现部分之间存在很大依赖性
- 需要构建分层系统

#### Python实现
```python
# 子系统类
class CPU:
    def freeze(self):
        print("CPU: Freezing processor")

    def jump(self, position):
        print(f"CPU: Jumping to position {position}")

    def execute(self):
        print("CPU: Executing instructions")

class Memory:
    def load(self, position, data):
        print(f"Memory: Loading data '{data}' at position {position}")

class HardDrive:
    def read(self, lba, size):
        return f"Data from sector {lba}, size {size}"

# 外观类
class ComputerFacade:
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.hard_drive = HardDrive()

    def start(self):
        """简化的启动过程"""
        print("Starting computer...")
        self.cpu.freeze()

        # 从硬盘读取启动扇区
        boot_data = self.hard_drive.read(lba=0, size=1024)
        self.memory.load(position=0, data=boot_data)

        self.cpu.jump(position=0)
        self.cpu.execute()
        print("Computer started!\n")

# 客户端代码
computer = ComputerFacade()
computer.start()  # 一行代码完成复杂启动过程
```

#### 实际应用：多媒体转换外观
```python
class VideoFile:
    def __init__(self, filename):
        self.filename = filename

    def decode(self):
        return f"Decoded video: {self.filename}"

class AudioMixer:
    def mix(self, audio_data):
        return f"Mixed audio: {audio_data}"

class BitrateReader:
    def read(self, file):
        return f"Bitrate data from {file}"

class VideoConverter:
    def convert(self, filename):
        return f"Converted: {filename}"

# 外观
class MediaConversionFacade:
    def __init__(self):
        self.video_file = None
        self.audio_mixer = AudioMixer()
        self.bitrate_reader = BitrateReader()
        self.converter = VideoConverter()

    def convert_video(self, input_file, output_format):
        """简化的视频转换流程"""
        print(f"Converting {input_file} to {output_format}...")

        # 复杂的内部处理
        self.video_file = VideoFile(input_file)
        decoded = self.video_file.decode()

        bitrate = self.bitrate_reader.read(input_file)
        audio = self.audio_mixer.mix(decoded)

        result = self.converter.convert(input_file)

        print(f"Conversion complete: {result}\n")
        return result

# 使用
facade = MediaConversionFacade()
facade.convert_video("movie.mp4", "avi")
```

### 3.4 代理模式（Proxy）

#### 模式意图
为其他对象提供一种代理以控制对这个对象的访问。

#### 适用场景
- **远程代理**：为远程对象提供本地代表
- **虚拟代理**：延迟创建开销大的对象
- **保护代理**：控制对原对象的访问权限
- **智能引用**：在访问对象时执行额外操作

#### Python实现

**虚拟代理（延迟加载）**
```python
from abc import ABC, abstractmethod

class Image(ABC):
    @abstractmethod
    def display(self):
        pass

class RealImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self.load_from_disk()

    def load_from_disk(self):
        print(f"Loading image: {self.filename}")

    def display(self):
        print(f"Displaying image: {self.filename}")

class ProxyImage(Image):
    def __init__(self, filename):
        self.filename = filename
        self.real_image = None

    def display(self):
        if self.real_image is None:
            self.real_image = RealImage(self.filename)
        self.real_image.display()

# 使用
print("Creating proxy...")
image = ProxyImage("photo.jpg")

print("\nFirst display (loads image):")
image.display()

print("\nSecond display (uses cached image):")
image.display()
```

**保护代理（权限控制）**
```python
from abc import ABC, abstractmethod

class Subject(ABC):
    @abstractmethod
    def request(self):
        pass

class RealSubject(Subject):
    def request(self):
        return "RealSubject: Handling request"

class ProtectionProxy(Subject):
    def __init__(self, real_subject: RealSubject, access_level):
        self.real_subject = real_subject
        self.access_level = access_level

    def check_access(self):
        return self.access_level >= 5

    def request(self):
        if self.check_access():
            return self.real_subject.request()
        return "Access Denied: Insufficient permissions"

# 使用
real_subject = RealSubject()

print("With high access level:")
proxy_allowed = ProtectionProxy(real_subject, access_level=10)
print(proxy_allowed.request())

print("\nWith low access level:")
proxy_denied = ProtectionProxy(real_subject, access_level=1)
print(proxy_denied.request())
```

**智能引用代理（引用计数）**
```python
class RealObject:
    def operation(self):
        return "Performing operation"

class SmartProxy:
    _ref_count = 0

    def __init__(self, real_object):
        self.real_object = real_object
        SmartProxy._ref_count += 1
        print(f"Proxy created. Reference count: {SmartProxy._ref_count}")

    def __del__(self):
        SmartProxy._ref_count -= 1
        print(f"Proxy destroyed. Reference count: {SmartProxy._ref_count}")

    def operation(self):
        return self.real_object.operation()

# 使用
real_obj = RealObject()
proxy1 = SmartProxy(real_obj)
proxy2 = SmartProxy(real_obj)

print(proxy1.operation())
del proxy1
del proxy2
```

### 3.5 组合模式（Composite）

#### 模式意图
将对象组合成树形结构以表示"部分-整体"的层次结构，使客户对单个对象和组合对象的使用具有一致性。

#### 适用场景
- 表示对象的部分-整体层次结构
- 希望客户忽略组合对象与单个对象的差异
- 需要统一处理集合中的所有对象

#### Python实现
```python
from abc import ABC, abstractmethod

# 组件接口
class Component(ABC):
    def __init__(self, name):
        self.name = name

    @abstractmethod
    def operation(self, indent=0):
        pass

    def add(self, component):
        pass

    def remove(self, component):
        pass

# 叶子节点
class Leaf(Component):
    def operation(self, indent=0):
        print("  " * indent + f"Leaf: {self.name}")

# 组合节点
class Composite(Component):
    def __init__(self, name):
        super().__init__(name)
        self.children = []

    def add(self, component):
        self.children.append(component)

    def remove(self, component):
        self.children.remove(component)

    def operation(self, indent=0):
        print("  " * indent + f"Composite: {self.name}")
        for child in self.children:
            child.operation(indent + 1)

# 使用：构建文件系统树
root = Composite("root")

home = Composite("home")
root.add(home)

user1 = Composite("user1")
home.add(user1)

user1.add(Leaf("file1.txt"))
user1.add(Leaf("file2.txt"))

documents = Composite("documents")
user1.add(documents)
documents.add(Leaf("report.pdf"))

etc = Composite("etc")
root.add(etc)
etc.add(Leaf("config.conf"))

# 统一处理
root.operation()
```

#### 实际应用：UI组件树
```python
class UIComponent(ABC):
    def __init__(self, name):
        self.name = name

    @abstractmethod
    def render(self, indent=0):
        pass

class Button(UIComponent):
    def render(self, indent=0):
        print("  " * indent + f"<Button>{self.name}</Button>")

class TextInput(UIComponent):
    def render(self, indent=0):
        print("  " * indent + f"<Input>{self.name}</Input>")

class Container(UIComponent):
    def __init__(self, name):
        super().__init__(name)
        self.children = []

    def add(self, component):
        self.children.append(component)

    def render(self, indent=0):
        print("  " * indent + f"<Container name='{self.name}'>")
        for child in self.children:
            child.render(indent + 1)
        print("  " * indent + "</Container>")

# 构建UI
window = Container("MainWindow")

header = Container("Header")
header.add(Button("Logo"))
header.add(Button("Menu"))
window.add(header)

content = Container("Content")
content.add(TextInput("Username"))
content.add(TextInput("Password"))
content.add(Button("Login"))
window.add(content)

window.render()
```

### 3.6 桥接模式（Bridge）

#### 模式意图
将抽象部分与实现部分分离，使它们都可以独立变化。

#### 适用场景
- 不希望抽象和实现之间有固定的绑定关系
- 抽象和实现都应该可以通过子类扩展
- 对抽象的实现修改不应影响客户代码

#### Python实现
```python
from abc import ABC, abstractmethod

# 实现接口
class DrawingAPI(ABC):
    @abstractmethod
    def draw_circle(self, x, y, radius):
        pass

# 具体实现A
class DrawingAPI1(DrawingAPI):
    def draw_circle(self, x, y, radius):
        print(f"API1: Drawing circle at ({x}, {y}) with radius {radius}")

# 具体实现B
class DrawingAPI2(DrawingAPI):
    def draw_circle(self, x, y, radius):
        print(f"API2: Drawing circle at ({x}, {y}) with radius {radius}")

# 抽象部分
class Shape(ABC):
    def __init__(self, drawing_api: DrawingAPI):
        self.drawing_api = drawing_api

    @abstractmethod
    def draw(self):
        pass

# 扩展抽象部分
class Circle(Shape):
    def __init__(self, x, y, radius, drawing_api: DrawingAPI):
        super().__init__(drawing_api)
        self.x = x
        self.y = y
        self.radius = radius

    def draw(self):
        self.drawing_api.draw_circle(self.x, self.y, self.radius)

# 使用
shapes = [
    Circle(1, 2, 3, DrawingAPI1()),
    Circle(5, 7, 11, DrawingAPI2())
]

for shape in shapes:
    shape.draw()
```

#### 实际应用：跨平台消息发送
```python
# 实现接口：消息发送方式
class MessageSender(ABC):
    @abstractmethod
    def send(self, message):
        pass

class EmailSender(MessageSender):
    def send(self, message):
        print(f"Sending via Email: {message}")

class SMSSender(MessageSender):
    def send(self, message):
        print(f"Sending via SMS: {message}")

class PushNotificationSender(MessageSender):
    def send(self, message):
        print(f"Sending via Push Notification: {message}")

# 抽象部分：消息类型
class Message(ABC):
    def __init__(self, sender: MessageSender):
        self.sender = sender

    @abstractmethod
    def send(self):
        pass

class TextMessage(Message):
    def __init__(self, content, sender: MessageSender):
        super().__init__(sender)
        self.content = content

    def send(self):
        self.sender.send(f"Text: {self.content}")

class UrgentMessage(Message):
    def __init__(self, content, sender: MessageSender):
        super().__init__(sender)
        self.content = content

    def send(self):
        self.sender.send(f"URGENT: {self.content}")

# 使用：消息类型和发送方式可以独立变化
messages = [
    TextMessage("Hello", EmailSender()),
    UrgentMessage("Server down!", SMSSender()),
    TextMessage("New feature", PushNotificationSender())
]

for msg in messages:
    msg.send()
```

### 3.7 享元模式（Flyweight）

#### 模式意图
运用共享技术有效地支持大量细粒度对象的复用。

#### 适用场景
- 程序使用大量对象
- 多数对象状态可变为外部状态
- 去除外部状态后，可用较少共享对象替代多组对象

#### Python实现
```python
class Flyweight:
    """享元类：存储内部状态"""
    def __init__(self, shared_state):
        self.shared_state = shared_state

    def operation(self, unique_state):
        shared = ", ".join(self.shared_state)
        unique = ", ".join(unique_state)
        print(f"Flyweight: Shared ({shared}) | Unique ({unique})")

class FlyweightFactory:
    """享元工厂：管理享元对象池"""
    def __init__(self):
        self._flyweights = {}

    def get_flyweight(self, shared_state):
        key = "".join(sorted(shared_state))

        if key not in self._flyweights:
            print(f"Creating new flyweight for: {shared_state}")
            self._flyweights[key] = Flyweight(shared_state)
        else:
            print(f"Reusing existing flyweight for: {shared_state}")

        return self._flyweights[key]

    def list_flyweights(self):
        count = len(self._flyweights)
        print(f"\nFlyweightFactory: I have {count} flyweights:")
        for key in self._flyweights:
            print(key)

# 使用
factory = FlyweightFactory()

# 添加汽车到数据库
def add_car(factory, plates, owner, brand, model, color):
    flyweight = factory.get_flyweight([brand, model, color])
    flyweight.operation([plates, owner])

add_car(factory, "CL234IR", "James", "Chevrolet", "Camaro", "pink")
add_car(factory, "CL234IR", "James", "Chevrolet", "Camaro", "pink")
add_car(factory, "EA123CX", "Alice", "BMW", "M5", "red")
add_car(factory, "EA123CX", "Alice", "BMW", "M5", "red")

factory.list_flyweights()
```

#### 实际应用：文本编辑器字符对象
```python
class CharacterFlyweight:
    """字符享元：共享字体、大小、样式"""
    def __init__(self, font, size, style):
        self.font = font
        self.size = size
        self.style = style

    def render(self, char, position):
        print(f"Rendering '{char}' at {position} "
              f"(font={self.font}, size={self.size}, style={self.style})")

class CharacterFactory:
    def __init__(self):
        self._characters = {}

    def get_character(self, font, size, style):
        key = (font, size, style)
        if key not in self._characters:
            self._characters[key] = CharacterFlyweight(font, size, style)
        return self._characters[key]

# 使用
factory = CharacterFactory()

# 渲染文本：大部分字符共享相同格式
text = "Hello World"
positions = [(i, 0) for i in range(len(text))]

for char, pos in zip(text, positions):
    character = factory.get_character("Arial", 12, "normal")
    character.render(char, pos)

print(f"\nTotal flyweight objects: {len(factory._characters)}")  # 只有1个
```

---

## 第四模块：行为型模式

### 4.1 观察者模式（Observer）

#### 模式意图
定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会收到通知并自动更新。

#### 适用场景
- 一个对象改变需要同时改变其他对象
- 一个对象必须通知其他对象，但不知道对方具体是谁
- 需要事件驱动的系统

#### Python实现
```python
from abc import ABC, abstractmethod

# 观察者接口
class Observer(ABC):
    @abstractmethod
    def update(self, subject):
        pass

# 主题（被观察者）
class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, observer: Observer):
        print(f"Subject: Attached an observer")
        self._observers.append(observer)

    def detach(self, observer: Observer):
        self._observers.remove(observer)

    def notify(self):
        print("Subject: Notifying observers...")
        for observer in self._observers:
            observer.update(self)

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        print(f"Subject: My state has changed to: {value}")
        self._state = value
        self.notify()

# 具体观察者
class ConcreteObserverA(Observer):
    def update(self, subject: Subject):
        if subject.state < 3:
            print("ConcreteObserverA: Reacted to the event")

class ConcreteObserverB(Observer):
    def update(self, subject: Subject):
        if subject.state >= 3:
            print("ConcreteObserverB: Reacted to the event")

# 使用
subject = Subject()

observer_a = ConcreteObserverA()
subject.attach(observer_a)

observer_b = ConcreteObserverB()
subject.attach(observer_b)

subject.state = 2
subject.state = 5
```

#### 实际应用：新闻订阅系统
```python
class NewsPublisher:
    """新闻发布者"""
    def __init__(self):
        self._subscribers = []
        self._news = []

    def subscribe(self, subscriber):
        self._subscribers.append(subscriber)

    def unsubscribe(self, subscriber):
        self._subscribers.remove(subscriber)

    def publish_news(self, news):
        print(f"\nPublishing news: {news}")
        self._news.append(news)
        self._notify_subscribers(news)

    def _notify_subscribers(self, news):
        for subscriber in self._subscribers:
            subscriber.receive_news(news)

class Subscriber:
    """订阅者"""
    def __init__(self, name):
        self.name = name

    def receive_news(self, news):
        print(f"{self.name} received: {news}")

# 使用
publisher = NewsPublisher()

alice = Subscriber("Alice")
bob = Subscriber("Bob")
charlie = Subscriber("Charlie")

publisher.subscribe(alice)
publisher.subscribe(bob)

publisher.publish_news("Python 3.12 Released!")

publisher.subscribe(charlie)
publisher.publish_news("New Framework Announced!")

publisher.unsubscribe(bob)
publisher.publish_news("Important Update!")
```

### 4.2 策略模式（Strategy）

#### 模式意图
定义算法家族，分别封装，使它们可以互相替换。策略模式使算法变化独立于使用算法的客户。

#### 适用场景
- 需要使用一个算法的不同变体
- 有许多相关类仅行为有差异
- 算法使用客户不应知道的数据

#### Python实现
```python
from abc import ABC, abstractmethod

# 策略接口
class Strategy(ABC):
    @abstractmethod
    def execute(self, data):
        pass

# 具体策略
class BubbleSortStrategy(Strategy):
    def execute(self, data):
        print("Sorting using bubble sort")
        return sorted(data)  # 简化实现

class QuickSortStrategy(Strategy):
    def execute(self, data):
        print("Sorting using quick sort")
        return sorted(data)

class MergeSortStrategy(Strategy):
    def execute(self, data):
        print("Sorting using merge sort")
        return sorted(data)

# 上下文
class Sorter:
    def __init__(self, strategy: Strategy):
        self._strategy = strategy

    def set_strategy(self, strategy: Strategy):
        self._strategy = strategy

    def sort(self, data):
        return self._strategy.execute(data)

# 使用
data = [5, 2, 9, 1, 7]

sorter = Sorter(BubbleSortStrategy())
print(sorter.sort(data))

sorter.set_strategy(QuickSortStrategy())
print(sorter.sort(data))
```

#### Python函数作为策略（更Pythonic）
```python
def bubble_sort(data):
    print("Bubble sort")
    return sorted(data)

def quick_sort(data):
    print("Quick sort")
    return sorted(data)

class Sorter:
    def __init__(self, strategy):
        self.strategy = strategy

    def sort(self, data):
        return self.strategy(data)

# 使用
sorter = Sorter(bubble_sort)
print(sorter.sort([5, 2, 9, 1, 7]))

sorter.strategy = quick_sort
print(sorter.sort([5, 2, 9, 1, 7]))
```

#### 实际应用：支付策略
```python
class PaymentStrategy(ABC):
    @abstractmethod
    def pay(self, amount):
        pass

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number):
        self.card_number = card_number

    def pay(self, amount):
        print(f"Paid ${amount} using Credit Card {self.card_number}")

class PayPalPayment(PaymentStrategy):
    def __init__(self, email):
        self.email = email

    def pay(self, amount):
        print(f"Paid ${amount} using PayPal account {self.email}")

class CryptoPayment(PaymentStrategy):
    def __init__(self, wallet_address):
        self.wallet_address = wallet_address

    def pay(self, amount):
        print(f"Paid ${amount} using Crypto wallet {self.wallet_address}")

class ShoppingCart:
    def __init__(self):
        self.items = []
        self.payment_strategy = None

    def add_item(self, item, price):
        self.items.append((item, price))

    def set_payment_strategy(self, strategy: PaymentStrategy):
        self.payment_strategy = strategy

    def checkout(self):
        total = sum(price for _, price in self.items)

        if self.payment_strategy:
            self.payment_strategy.pay(total)
        else:
            print("Please set a payment method")

# 使用
cart = ShoppingCart()
cart.add_item("Book", 29.99)
cart.add_item("Pen", 5.99)

cart.set_payment_strategy(CreditCardPayment("1234-5678-9012-3456"))
cart.checkout()

cart.set_payment_strategy(PayPalPayment("user@example.com"))
cart.checkout()
```

### 4.3 命令模式（Command）

#### 模式意图
将请求封装为对象，从而可用不同的请求对客户进行参数化；对请求排队或记录日志；支持可撤销的操作。

#### 适用场景
- 需要参数化对象执行的动作
- 需要在不同时间指定、排列和执行请求
- 需要支持撤销操作
- 需要支持日志记录

#### Python实现
```python
from abc import ABC, abstractmethod

# 命令接口
class Command(ABC):
    @abstractmethod
    def execute(self):
        pass

    @abstractmethod
    def undo(self):
        pass

# 接收者
class Light:
    def on(self):
        print("Light is ON")

    def off(self):
        print("Light is OFF")

# 具体命令
class LightOnCommand(Command):
    def __init__(self, light: Light):
        self.light = light

    def execute(self):
        self.light.on()

    def undo(self):
        self.light.off()

class LightOffCommand(Command):
    def __init__(self, light: Light):
        self.light = light

    def execute(self):
        self.light.off()

    def undo(self):
        self.light.on()

# 调用者
class RemoteControl:
    def __init__(self):
        self.command = None
        self.history = []

    def set_command(self, command: Command):
        self.command = command

    def press_button(self):
        if self.command:
            self.command.execute()
            self.history.append(self.command)

    def press_undo(self):
        if self.history:
            command = self.history.pop()
            command.undo()

# 使用
light = Light()
light_on = LightOnCommand(light)
light_off = LightOffCommand(light)

remote = RemoteControl()

remote.set_command(light_on)
remote.press_button()  # Light is ON

remote.set_command(light_off)
remote.press_button()  # Light is OFF

remote.press_undo()  # Light is ON (撤销off命令)
remote.press_undo()  # Light is OFF (撤销on命令)
```

#### 实际应用：文本编辑器
```python
class TextEditor:
    """接收者"""
    def __init__(self):
        self.content = ""

    def insert(self, text):
        self.content += text
        print(f"Content: '{self.content}'")

    def delete(self, length):
        self.content = self.content[:-length]
        print(f"Content: '{self.content}'")

class InsertCommand(Command):
    def __init__(self, editor: TextEditor, text):
        self.editor = editor
        self.text = text

    def execute(self):
        self.editor.insert(self.text)

    def undo(self):
        self.editor.delete(len(self.text))

class DeleteCommand(Command):
    def __init__(self, editor: TextEditor, length):
        self.editor = editor
        self.length = length
        self.deleted_text = ""

    def execute(self):
        self.deleted_text = self.editor.content[-self.length:]
        self.editor.delete(self.length)

    def undo(self):
        self.editor.insert(self.deleted_text)

class CommandManager:
    """命令管理器：支持撤销/重做"""
    def __init__(self):
        self.history = []
        self.current = -1

    def execute_command(self, command: Command):
        # 清除当前位置之后的历史
        self.history = self.history[:self.current + 1]

        command.execute()
        self.history.append(command)
        self.current += 1

    def undo(self):
        if self.current >= 0:
            command = self.history[self.current]
            command.undo()
            self.current -= 1

    def redo(self):
        if self.current < len(self.history) - 1:
            self.current += 1
            command = self.history[self.current]
            command.execute()

# 使用
editor = TextEditor()
manager = CommandManager()

manager.execute_command(InsertCommand(editor, "Hello"))
manager.execute_command(InsertCommand(editor, " World"))
manager.execute_command(DeleteCommand(editor, 6))

print("\nUndo:")
manager.undo()

print("\nRedo:")
manager.redo()
```

### 4.4 模板方法模式（Template Method）

#### 模式意图
在一个方法中定义算法骨架，将某些步骤延迟到子类。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。

#### 适用场景
- 一次性实现算法不变部分，可变部分由子类实现
- 各子类中公共行为应被提取出来集中到公共父类，避免代码重复
- 控制子类扩展

#### Python实现
```python
from abc import ABC, abstractmethod

class DataMiner(ABC):
    """模板方法类"""

    def mine(self, path):
        """模板方法：定义算法骨架"""
        self.open_file(path)
        raw_data = self.extract_data()
        processed_data = self.analyze_data(raw_data)
        self.send_report(processed_data)
        self.close_file()

    @abstractmethod
    def open_file(self, path):
        pass

    @abstractmethod
    def extract_data(self):
        pass

    def analyze_data(self, raw_data):
        """默认实现（钩子方法）"""
        return f"Analyzed: {raw_data}"

    @abstractmethod
    def send_report(self, data):
        pass

    def close_file(self):
        """具体实现"""
        print("File closed\n")

# 具体类：PDF数据挖掘
class PDFDataMiner(DataMiner):
    def open_file(self, path):
        print(f"Opening PDF file: {path}")

    def extract_data(self):
        print("Extracting data from PDF")
        return "PDF Data"

    def send_report(self, data):
        print(f"Sending PDF report: {data}")

# 具体类：CSV数据挖掘
class CSVDataMiner(DataMiner):
    def open_file(self, path):
        print(f"Opening CSV file: {path}")

    def extract_data(self):
        print("Extracting data from CSV")
        return "CSV Data"

    def analyze_data(self, raw_data):
        # 重写分析方法
        return f"Custom CSV Analysis: {raw_data}"

    def send_report(self, data):
        print(f"Sending CSV report: {data}")

# 使用
print("Mining PDF:")
pdf_miner = PDFDataMiner()
pdf_miner.mine("data.pdf")

print("Mining CSV:")
csv_miner = CSVDataMiner()
csv_miner.mine("data.csv")
```

#### 实际应用：Web框架视图处理
```python
class View(ABC):
    """视图模板"""

    def dispatch(self, request):
        """模板方法"""
        # 请求预处理
        if not self.check_permissions(request):
            return "Permission Denied"

        # 根据HTTP方法分发
        if request.method == "GET":
            response = self.get(request)
        elif request.method == "POST":
            response = self.post(request)
        else:
            response = "Method Not Allowed"

        # 响应后处理
        return self.finalize_response(response)

    def check_permissions(self, request):
        """钩子：权限检查"""
        return True

    @abstractmethod
    def get(self, request):
        pass

    @abstractmethod
    def post(self, request):
        pass

    def finalize_response(self, response):
        """钩子：响应最终处理"""
        return response

class UserListView(View):
    def get(self, request):
        return "User List"

    def post(self, request):
        return "User Created"

    def check_permissions(self, request):
        # 自定义权限检查
        return request.get("is_authenticated", False)

# 模拟请求
class Request:
    def __init__(self, method, **kwargs):
        self.method = method
        self.__dict__.update(kwargs)

    def get(self, key, default=None):
        return self.__dict__.get(key, default)

# 使用
view = UserListView()

print(view.dispatch(Request("GET", is_authenticated=True)))
print(view.dispatch(Request("POST", is_authenticated=False)))
```

### 4.5 状态模式（State）

#### 模式意图
允许对象在内部状态改变时改变其行为，对象看起来好像修改了它的类。

#### 适用场景
- 对象行为取决于它的状态，并且必须在运行时根据状态改变行为
- 操作中含有庞大的多分支条件语句，且这些分支依赖于对象状态

#### Python实现
```python
from abc import ABC, abstractmethod

# 状态接口
class State(ABC):
    @abstractmethod
    def handle(self, context):
        pass

# 具体状态
class ConcreteStateA(State):
    def handle(self, context):
        print("State A handling request")
        print("State A changing context state to B")
        context.state = ConcreteStateB()

class ConcreteStateB(State):
    def handle(self, context):
        print("State B handling request")
        print("State B changing context state to A")
        context.state = ConcreteStateA()

# 上下文
class Context:
    def __init__(self, state: State):
        self._state = state

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, state: State):
        print(f"Context: Transitioning to {state.__class__.__name__}")
        self._state = state

    def request(self):
        self._state.handle(self)

# 使用
context = Context(ConcreteStateA())
context.request()
context.request()
context.request()
```

#### 实际应用：TCP连接状态
```python
class TCPConnection:
    """TCP连接上下文"""
    def __init__(self):
        self._state = ClosedState()

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, state):
        print(f"Transitioning to {state.__class__.__name__}")
        self._state = state

    def open(self):
        self._state.open(self)

    def close(self):
        self._state.close(self)

    def acknowledge(self):
        self._state.acknowledge(self)

class TCPState(ABC):
    @abstractmethod
    def open(self, connection):
        pass

    @abstractmethod
    def close(self, connection):
        pass

    @abstractmethod
    def acknowledge(self, connection):
        pass

class ClosedState(TCPState):
    def open(self, connection):
        print("Opening connection...")
        connection.state = ListenState()

    def close(self, connection):
        print("Already closed")

    def acknowledge(self, connection):
        print("Cannot acknowledge: connection closed")

class ListenState(TCPState):
    def open(self, connection):
        print("Already open")

    def close(self, connection):
        print("Closing connection...")
        connection.state = ClosedState()

    def acknowledge(self, connection):
        print("Acknowledgement received")
        connection.state = EstablishedState()

class EstablishedState(TCPState):
    def open(self, connection):
        print("Connection already established")

    def close(self, connection):
        print("Closing established connection...")
        connection.state = ClosedState()

    def acknowledge(self, connection):
        print("Data transfer in progress")

# 使用
connection = TCPConnection()
connection.open()
connection.acknowledge()
connection.close()
connection.acknowledge()
```

---

## 第五模块：Python特有实现技巧

### 5.1 使用装饰器实现单例
```python
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class Database:
    def __init__(self):
        self.connection = "Connected"

db1 = Database()
db2 = Database()
print(db1 is db2)  # True
```

### 5.2 使用上下文管理器实现资源管理
```python
from contextlib import contextmanager

@contextmanager
def managed_resource(*args, **kwargs):
    resource = acquire_resource(*args, **kwargs)
    try:
        yield resource
    finally:
        release_resource(resource)

# 使用
with managed_resource() as resource:
    use_resource(resource)
```

### 5.3 使用描述符实现观察者模式
```python
class Observable:
    def __init__(self, initial_value):
        self.value = initial_value
        self.observers = []

    def __get__(self, obj, objtype=None):
        return self.value

    def __set__(self, obj, value):
        self.value = value
        for observer in self.observers:
            observer(value)

    def add_observer(self, observer):
        self.observers.append(observer)

class MyClass:
    temperature = Observable(20)

    def __init__(self):
        self.temperature.add_observer(self.on_temperature_change)

    def on_temperature_change(self, new_temp):
        print(f"Temperature changed to {new_temp}")

obj = MyClass()
obj.temperature = 25  # 触发观察者
```

### 5.4 使用生成器实现迭代器模式
```python
class Range:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        current = self.start
        while current < self.end:
            yield current
            current += 1

# 使用
for i in Range(0, 5):
    print(i)
```

---

## 第六模块：实战项目

### 6.1 简易计算器（策略+命令模式）

```python
from abc import ABC, abstractmethod

# 策略模式：操作策略
class OperationStrategy(ABC):
    @abstractmethod
    def execute(self, a, b):
        pass

class AddStrategy(OperationStrategy):
    def execute(self, a, b):
        return a + b

class SubtractStrategy(OperationStrategy):
    def execute(self, a, b):
        return a - b

class MultiplyStrategy(OperationStrategy):
    def execute(self, a, b):
        return a * b

class DivideStrategy(OperationStrategy):
    def execute(self, a, b):
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b

# 命令模式：可撤销的计算命令
class CalculatorCommand:
    def __init__(self, strategy: OperationStrategy, a, b):
        self.strategy = strategy
        self.a = a
        self.b = b
        self.result = None

    def execute(self):
        self.result = self.strategy.execute(self.a, self.b)
        return self.result

    def undo(self):
        # 简化：返回操作数
        return self.a

# 计算器（使用命令模式管理历史）
class Calculator:
    def __init__(self):
        self.history = []
        self.current_value = 0

    def calculate(self, strategy: OperationStrategy, b):
        command = CalculatorCommand(strategy, self.current_value, b)
        self.current_value = command.execute()
        self.history.append(command)
        return self.current_value

    def undo(self):
        if self.history:
            command = self.history.pop()
            self.current_value = command.undo()
        return self.current_value

    def get_value(self):
        return self.current_value

# 使用
calc = Calculator()
print(calc.calculate(AddStrategy(), 5))       # 5
print(calc.calculate(MultiplyStrategy(), 3))  # 15
print(calc.calculate(SubtractStrategy(), 5))  # 10
print(calc.undo())                             # 15
print(calc.undo())                             # 5
```

### 6.2 简易日志系统（单例+责任链模式）

```python
from abc import ABC, abstractmethod
import time

# 单例模式：日志管理器
class LoggerSingleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

# 责任链模式：日志级别处理
class LogLevel:
    DEBUG = 1
    INFO = 2
    WARNING = 3
    ERROR = 4

class LogHandler(ABC):
    def __init__(self, level):
        self.level = level
        self.next_handler = None

    def set_next(self, handler):
        self.next_handler = handler
        return handler

    def handle(self, level, message):
        if level >= self.level:
            self.write(message)

        if self.next_handler:
            self.next_handler.handle(level, message)

    @abstractmethod
    def write(self, message):
        pass

class ConsoleHandler(LogHandler):
    def write(self, message):
        print(f"[CONSOLE] {message}")

class FileHandler(LogHandler):
    def __init__(self, level, filename):
        super().__init__(level)
        self.filename = filename

    def write(self, message):
        with open(self.filename, 'a') as f:
            f.write(f"{message}\n")
        print(f"[FILE] Written to {self.filename}")

class EmailHandler(LogHandler):
    def write(self, message):
        print(f"[EMAIL] Sending email: {message}")

# 日志系统
class Logger(metaclass=LoggerSingleton):
    def __init__(self):
        # 构建责任链
        self.console = ConsoleHandler(LogLevel.DEBUG)
        self.file = FileHandler(LogLevel.WARNING, "app.log")
        self.email = EmailHandler(LogLevel.ERROR)

        self.console.set_next(self.file).set_next(self.email)

    def log(self, level, message):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        formatted = f"[{timestamp}] {message}"
        self.console.handle(level, formatted)

    def debug(self, message):
        self.log(LogLevel.DEBUG, f"DEBUG: {message}")

    def info(self, message):
        self.log(LogLevel.INFO, f"INFO: {message}")

    def warning(self, message):
        self.log(LogLevel.WARNING, f"WARNING: {message}")

    def error(self, message):
        self.log(LogLevel.ERROR, f"ERROR: {message}")

# 使用
logger1 = Logger()
logger2 = Logger()

print(logger1 is logger2)  # True (单例)

logger1.debug("This is a debug message")
logger1.info("This is an info message")
logger1.warning("This is a warning")
logger1.error("This is an error!")
```

---

## 学习验证标准

### 基础验证（Week 1-2）
- [ ] 理解SOLID五大设计原则
- [ ] 掌握创建型模式中的单例、工厂方法
- [ ] 能够识别代码中的设计模式

### 中级验证（Week 3-5）
- [ ] 熟练使用7种结构型模式
- [ ] 理解装饰器、适配器、代理的区别
- [ ] 能够在实际项目中应用合适的模式

### 高级验证（Week 6-7）
- [ ] 掌握11种行为型模式
- [ ] 理解观察者、策略、命令的应用场景
- [ ] 能够重构现有代码使用设计模式

### 项目验证（Week 8）
- [ ] 完成至少一个综合项目，应用3种以上设计模式
- [ ] 能够说明为什么选择这些模式
- [ ] 代码符合SOLID原则

---

## 常见错误与解决

### 1. 过度设计
```python
# ❌ 错误：为简单场景引入复杂模式
class SimpleMath:
    def add(self, a, b):
        strategy = AdditionStrategy()
        factory = OperationFactory()
        # 过度复杂
        return factory.create(strategy).execute(a, b)

# ✅ 正确：保持简单
class SimpleMath:
    def add(self, a, b):
        return a + b
```

### 2. 滥用单例
```python
# ❌ 错误：所有类都用单例
@singleton
class User:  # 用户对象不应该是单例
    pass

# ✅ 正确：只在真正需要全局唯一时使用
@singleton
class DatabaseConnection:
    pass
```

### 3. 忘记考虑Python特性
```python
# ❌ 错误：用Java风格写装饰器模式
class Decorator:
    def __init__(self, component):
        self.component = component

    def operation(self):
        return self.component.operation()

# ✅ 正确：使用Python装饰器语法
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"Time: {time.time() - start}")
        return result
    return wrapper
```

---

## 推荐学习资源

### 经典书籍
1. **《设计模式：可复用面向对象软件的基础》** - GOF四人组
2. **《Head First 设计模式》** - 适合初学者
3. **《重构：改善既有代码的设计》** - Martin Fowler
4. **《代码整洁之道》** - Robert C. Martin

### 在线资源
- **Refactoring Guru**: https://refactoring.guru/design-patterns
- **SourceMaking**: https://sourcemaking.com/design_patterns
- **Python Design Patterns**: https://python-patterns.guide/

### 实践建议
1. 先理解问题，再选择模式
2. 优先考虑简单解决方案
3. 重构时引入设计模式
4. 阅读优秀开源项目代码（Django、Flask等）
5. 参与代码评审，学习他人的设计

---

**最后总结**：

设计模式不是银弹，而是经验总结：
- **不要为了模式而模式**：首先解决问题，然后优化设计
- **适度使用**：Python的动态特性使许多模式可以更简洁地实现
- **持续学习**：设计模式是手段，面向对象设计原则是核心
- **实践出真知**：在真实项目中应用，从错误中学习

通过系统学习和大量实践，你将能够：
1. 快速识别代码中的设计模式
2. 选择合适的模式解决设计问题
3. 编写可维护、可扩展的代码
4. 与团队有效沟通设计决策

祝学习进步！
