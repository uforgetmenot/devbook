# C++完整学习笔记

## 学习目标定位
- **目标群体**: 有C语言基础或其他编程语言经验的学习者
- **学习周期**: 10-16周
- **前置要求**: C语言基础或基础编程概念
- **学习成果**: 掌握现代C++(C++11/14/17/20)并能开发实际项目

## 学习路径

```
基础强化(Week 1-2) → 面向对象(Week 3-4) → STL(Week 5-6)
→ 模板编程(Week 7-8) → 内存管理(Week 9-10) → 并发编程(Week 11-12)
→ 现代C++特性(Week 13-14) → 实战项目(Week 15-16)
```

---

## 第一模块：C++基础强化

### 1.1 数据类型与变量

#### 1.1.1 基本数据类型
```cpp
#include <iostream>
#include <limits>
using namespace std;

void type_demo() {
    // 整型
    int a = 42;
    short b = 10;
    long c = 1000000L;
    long long d = 9223372036854775807LL;

    // 无符号类型
    unsigned int ua = 100U;
    size_t size = sizeof(int);  // 返回unsigned类型

    // 浮点型
    float f = 3.14f;
    double pi = 3.14159265;
    long double ld = 3.14159265358979L;

    // 布尔型
    bool flag = true;

    // 字符型
    char ch = 'A';
    wchar_t wch = L'中';  // 宽字符

    // 类型大小
    cout << "int: " << sizeof(int) << " bytes" << endl;
    cout << "int range: " << numeric_limits<int>::min()
         << " to " << numeric_limits<int>::max() << endl;
}

// C++11: auto类型推导
void auto_demo() {
    auto x = 42;        // int
    auto y = 3.14;      // double
    auto str = "hello"; // const char*

    vector<int> vec = {1, 2, 3};
    auto it = vec.begin();  // vector<int>::iterator
}

// C++11: decltype类型推导
void decltype_demo() {
    int x = 5;
    decltype(x) y = x;  // y的类型是int

    auto func = [](int a, int b) { return a + b; };
    decltype(func) func2 = func;  // 推导Lambda类型
}
```

#### 1.1.2 引用与指针对比
```cpp
// 指针
void pointer_demo() {
    int value = 10;
    int* ptr = &value;   // 指针存储地址
    *ptr = 20;           // 通过解引用修改值

    ptr = nullptr;       // C++11: nullptr替代NULL

    // 指针可以重新赋值
    int another = 30;
    ptr = &another;
}

// 引用
void reference_demo() {
    int value = 10;
    int& ref = value;    // 引用是别名
    ref = 20;            // 直接修改value

    // 引用必须初始化，且不能重新绑定
    // int& ref2;        // ❌ 错误：必须初始化
    // ref = another;    // ✅ 这是修改value的值，不是重新绑定
}

// 常量引用：避免拷贝的高效参数传递
void print_string(const string& str) {
    // str不能被修改，但避免了拷贝
    cout << str << endl;
}

// 右值引用（C++11）
void rvalue_demo() {
    int&& rref = 42;           // 绑定到右值
    string&& str = "hello";    // 临时字符串

    vector<int> vec1 = {1, 2, 3};
    vector<int> vec2 = std::move(vec1);  // 移动语义
    // vec1现在为空
}
```

### 1.2 函数高级特性

#### 1.2.1 函数重载
```cpp
// 同名函数，不同参数列表
void print(int x) {
    cout << "Int: " << x << endl;
}

void print(double x) {
    cout << "Double: " << x << endl;
}

void print(const string& x) {
    cout << "String: " << x << endl;
}

// 使用示例
int main() {
    print(10);        // 调用print(int)
    print(3.14);      // 调用print(double)
    print("hello");   // 调用print(const string&)
}
```

#### 1.2.2 默认参数
```cpp
// 从右向左指定默认参数
void create_window(int width = 800, int height = 600,
                   bool fullscreen = false) {
    cout << "Window: " << width << "x" << height << endl;
}

// 调用示例
create_window();                    // 800x600, 非全屏
create_window(1024);                // 1024x600, 非全屏
create_window(1920, 1080);          // 1920x1080, 非全屏
create_window(1920, 1080, true);    // 1920x1080, 全屏
```

#### 1.2.3 Lambda表达式（C++11）
```cpp
void lambda_demo() {
    // 基础Lambda
    auto add = [](int a, int b) { return a + b; };
    cout << add(3, 4) << endl;  // 7

    // 捕获外部变量
    int x = 10;
    auto print_x = [x]() { cout << x << endl; };  // 值捕获
    print_x();  // 10

    auto modify_x = [&x]() { x = 20; };  // 引用捕获
    modify_x();
    cout << x << endl;  // 20

    // 捕获所有变量
    int a = 1, b = 2;
    auto lambda1 = [=]() { return a + b; };   // 值捕获所有
    auto lambda2 = [&]() { a++; b++; };       // 引用捕获所有

    // 混合捕获
    auto lambda3 = [=, &a]() { a++; return a + b; };

    // 泛型Lambda (C++14)
    auto generic = [](auto a, auto b) { return a + b; };
    cout << generic(1, 2) << endl;      // 3
    cout << generic(1.5, 2.5) << endl;  // 4.0
}

// 实战：STL算法中使用Lambda
void lambda_with_stl() {
    vector<int> nums = {1, 2, 3, 4, 5};

    // 查找第一个大于3的数
    auto it = find_if(nums.begin(), nums.end(),
                      [](int n) { return n > 3; });

    // 遍历并打印
    for_each(nums.begin(), nums.end(),
             [](int n) { cout << n << " "; });

    // 排序（自定义比较）
    sort(nums.begin(), nums.end(),
         [](int a, int b) { return a > b; });  // 降序
}
```

### 1.3 const关键字深入

```cpp
// 1. const变量
const int MAX_SIZE = 100;  // 编译期常量
// MAX_SIZE = 200;  // ❌ 错误：不能修改

// 2. const指针
void const_pointer() {
    int value = 10;

    // 指向常量的指针
    const int* ptr1 = &value;
    // *ptr1 = 20;  // ❌ 错误：不能通过ptr1修改
    ptr1 = nullptr;  // ✅ 可以修改指针本身

    // 常量指针
    int* const ptr2 = &value;
    *ptr2 = 20;      // ✅ 可以修改值
    // ptr2 = nullptr;  // ❌ 错误：不能修改指针

    // 指向常量的常量指针
    const int* const ptr3 = &value;
    // *ptr3 = 30;      // ❌ 错误
    // ptr3 = nullptr;  // ❌ 错误
}

// 3. const成员函数
class Circle {
private:
    double radius;

public:
    Circle(double r) : radius(r) {}

    // const成员函数：承诺不修改对象
    double getRadius() const {
        return radius;
        // radius = 10;  // ❌ 错误：不能修改成员变量
    }

    void setRadius(double r) {
        radius = r;  // ✅ 非const函数可以修改
    }
};

// 4. mutable关键字：允许const函数修改
class Counter {
private:
    mutable int access_count;  // mutable成员
    int value;

public:
    int getValue() const {
        access_count++;  // ✅ 可以修改mutable成员
        return value;
    }
};
```

### 1.4 static关键字深入

```cpp
// 1. 静态局部变量
void count_calls() {
    static int count = 0;  // 只初始化一次
    count++;
    cout << "Called " << count << " times" << endl;
}

// 2. 静态成员变量
class BankAccount {
private:
    static double interest_rate;  // 声明
    double balance;

public:
    static void setInterestRate(double rate) {
        interest_rate = rate;
    }

    static double getInterestRate() {
        return interest_rate;
    }
};

// 定义并初始化静态成员
double BankAccount::interest_rate = 0.03;

// 使用示例
void static_member_demo() {
    BankAccount::setInterestRate(0.05);
    cout << BankAccount::getInterestRate() << endl;
}

// 3. 静态成员函数
class MathUtils {
public:
    static int add(int a, int b) {
        return a + b;
    }

    static double pi() {
        return 3.14159265;
    }
};

// 调用：不需要对象
int result = MathUtils::add(3, 4);
```

---

## 第二模块：面向对象编程

### 2.1 类的基础

#### 2.1.1 类的定义与使用
```cpp
class Rectangle {
private:
    double width;
    double height;

public:
    // 构造函数
    Rectangle() : width(0), height(0) {}

    Rectangle(double w, double h) : width(w), height(h) {}

    // 成员函数
    double area() const {  // const成员函数不修改对象
        return width * height;
    }

    double perimeter() const {
        return 2 * (width + height);
    }

    // Getter/Setter
    void set_width(double w) { width = w; }
    double get_width() const { return width; }

    // 析构函数
    ~Rectangle() {
        cout << "Rectangle destroyed" << endl;
    }
};

// 使用示例
void rectangle_demo() {
    Rectangle rect1;                   // 默认构造
    Rectangle rect2(10.0, 5.0);       // 参数化构造

    cout << "Area: " << rect2.area() << endl;
    cout << "Perimeter: " << rect2.perimeter() << endl;
}
```

#### 2.1.2 构造函数高级特性
```cpp
class Student {
private:
    string name;
    int age;
    vector<int> grades;

public:
    // 默认构造函数
    Student() : name(""), age(0) {}

    // 参数化构造函数
    Student(const string& n, int a) : name(n), age(a) {}

    // 初始化列表构造（C++11）
    Student(const string& n, int a, initializer_list<int> g)
        : name(n), age(a), grades(g) {}

    // 拷贝构造函数
    Student(const Student& other)
        : name(other.name), age(other.age), grades(other.grades) {
        cout << "Copy constructor called" << endl;
    }

    // 移动构造函数（C++11）
    Student(Student&& other) noexcept
        : name(std::move(other.name))
        , age(other.age)
        , grades(std::move(other.grades)) {
        cout << "Move constructor called" << endl;
    }

    // 拷贝赋值运算符
    Student& operator=(const Student& other) {
        if (this != &other) {
            name = other.name;
            age = other.age;
            grades = other.grades;
        }
        return *this;
    }

    // 移动赋值运算符（C++11）
    Student& operator=(Student&& other) noexcept {
        if (this != &other) {
            name = std::move(other.name);
            age = other.age;
            grades = std::move(other.grades);
        }
        return *this;
    }

    // 委托构造函数（C++11）
    Student(const string& n) : Student(n, 0) {}
};

// 使用示例
void student_demo() {
    Student s1("Alice", 20);
    Student s2 = s1;                           // 拷贝构造
    Student s3("Bob", 21, {85, 90, 95});      // 初始化列表
    Student s4 = std::move(s3);               // 移动构造
}
```

### 2.2 继承与多态

#### 2.2.1 继承机制
```cpp
// 基类
class Shape {
protected:
    string color;

public:
    Shape(const string& c) : color(c) {}

    virtual ~Shape() {}  // 虚析构函数

    virtual double area() const = 0;  // 纯虚函数

    virtual void draw() const {
        cout << "Drawing a " << color << " shape" << endl;
    }

    string get_color() const { return color; }
};

// 派生类：圆形
class Circle : public Shape {
private:
    double radius;

public:
    Circle(const string& c, double r)
        : Shape(c), radius(r) {}

    double area() const override {  // C++11: override关键字
        return 3.14159 * radius * radius;
    }

    void draw() const override {
        cout << "Drawing a " << color << " circle" << endl;
    }
};

// 派生类：矩形
class RectangleShape : public Shape {
private:
    double width, height;

public:
    RectangleShape(const string& c, double w, double h)
        : Shape(c), width(w), height(h) {}

    double area() const override {
        return width * height;
    }

    void draw() const override {
        cout << "Drawing a " << color << " rectangle" << endl;
    }
};

// 多态示例
void polymorphism_demo() {
    vector<unique_ptr<Shape>> shapes;
    shapes.push_back(make_unique<Circle>("red", 5.0));
    shapes.push_back(make_unique<RectangleShape>("blue", 4.0, 6.0));

    for (const auto& shape : shapes) {
        shape->draw();
        cout << "Area: " << shape->area() << endl;
    }
}
```

#### 2.2.2 运算符重载
```cpp
class Complex {
private:
    double real, imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 算术运算符重载
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }

    Complex operator*(const Complex& other) const {
        return Complex(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }

    // 复合赋值运算符
    Complex& operator+=(const Complex& other) {
        real += other.real;
        imag += other.imag;
        return *this;
    }

    // 比较运算符
    bool operator==(const Complex& other) const {
        return real == other.real && imag == other.imag;
    }

    // 流操作符重载（友元函数）
    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << c.real;
        if (c.imag >= 0) os << "+";
        os << c.imag << "i";
        return os;
    }

    friend istream& operator>>(istream& is, Complex& c) {
        is >> c.real >> c.imag;
        return is;
    }
};

// 使用示例
void complex_demo() {
    Complex c1(3, 4);
    Complex c2(1, 2);

    Complex c3 = c1 + c2;
    cout << c1 << " + " << c2 << " = " << c3 << endl;

    c1 += c2;
    cout << "After +=: " << c1 << endl;
}
```

### 2.3 多重继承与虚继承

```cpp
// 基类
class Flyable {
public:
    virtual void fly() {
        cout << "Flying..." << endl;
    }
};

class Swimmable {
public:
    virtual void swim() {
        cout << "Swimming..." << endl;
    }
};

// 多重继承
class Duck : public Flyable, public Swimmable {
public:
    void fly() override {
        cout << "Duck is flying" << endl;
    }

    void swim() override {
        cout << "Duck is swimming" << endl;
    }
};

// 菱形继承问题
class Animal {
protected:
    string name;
public:
    Animal(const string& n) : name(n) {}
};

// 虚继承解决菱形继承
class Mammal : virtual public Animal {
public:
    Mammal(const string& n) : Animal(n) {}
};

class Bird : virtual public Animal {
public:
    Bird(const string& n) : Animal(n) {}
};

class Bat : public Mammal, public Bird {
public:
    Bat(const string& n) : Animal(n), Mammal(n), Bird(n) {}
};
```

---

## 第三模块：STL（标准模板库）

### 3.1 容器详解

#### 3.1.1 序列容器
```cpp
void vector_demo() {
    // vector: 动态数组
    vector<int> vec = {1, 2, 3, 4, 5};

    vec.push_back(6);           // 尾部添加
    vec.pop_back();             // 尾部删除
    vec.insert(vec.begin(), 0); // 指定位置插入
    vec.erase(vec.begin());     // 删除元素

    // 访问元素
    cout << vec[0] << endl;     // 不检查边界
    cout << vec.at(0) << endl;  // 检查边界，抛出异常

    // 容量管理
    vec.reserve(100);           // 预分配容量
    vec.shrink_to_fit();        // 释放多余容量

    // 遍历
    for (int x : vec) {
        cout << x << " ";
    }
}

void list_demo() {
    // list: 双向链表
    list<int> lst = {1, 2, 3, 4, 5};

    lst.push_front(0);    // 头部添加
    lst.push_back(6);     // 尾部添加
    lst.pop_front();      // 头部删除
    lst.pop_back();       // 尾部删除

    // 排序和去重
    lst.sort();
    lst.unique();         // 删除连续重复元素

    // 合并两个有序链表
    list<int> lst2 = {10, 20, 30};
    lst.merge(lst2);
}

void deque_demo() {
    // deque: 双端队列
    deque<int> dq = {1, 2, 3};

    dq.push_front(0);     // 头部添加 O(1)
    dq.push_back(4);      // 尾部添加 O(1)
    dq.pop_front();       // 头部删除 O(1)
    dq.pop_back();        // 尾部删除 O(1)

    // 随机访问 O(1)
    cout << dq[1] << endl;
}

// C++11: array固定大小数组
void array_demo() {
    array<int, 5> arr = {1, 2, 3, 4, 5};

    cout << "Size: " << arr.size() << endl;
    cout << "First: " << arr.front() << endl;
    cout << "Last: " << arr.back() << endl;

    // 填充
    arr.fill(0);
}

// C++11: forward_list单向链表
void forward_list_demo() {
    forward_list<int> flist = {1, 2, 3, 4, 5};

    flist.push_front(0);
    flist.pop_front();

    // 只能向前遍历
    for (int x : flist) {
        cout << x << " ";
    }
}
```

#### 3.1.2 关联容器
```cpp
void map_demo() {
    // map: 有序键值对容器（红黑树实现）
    map<string, int> age_map;

    // 插入
    age_map["Alice"] = 25;
    age_map["Bob"] = 30;
    age_map.insert({"Charlie", 28});
    age_map.emplace("David", 35);  // C++11: 直接构造

    // 查找
    if (age_map.count("Alice") > 0) {
        cout << "Alice's age: " << age_map["Alice"] << endl;
    }

    auto it = age_map.find("Bob");
    if (it != age_map.end()) {
        cout << it->first << ": " << it->second << endl;
    }

    // 遍历（按键排序）
    for (const auto& [name, age] : age_map) {  // C++17结构化绑定
        cout << name << ": " << age << endl;
    }
}

void unordered_map_demo() {
    // unordered_map: 无序键值对容器（哈希表实现）
    unordered_map<string, int> word_count;

    string text = "hello world hello";
    istringstream iss(text);
    string word;

    while (iss >> word) {
        word_count[word]++;  // 自动初始化为0
    }

    for (const auto& [word, count] : word_count) {
        cout << word << ": " << count << endl;
    }
}

void set_demo() {
    // set: 有序唯一元素集合
    set<int> s = {3, 1, 4, 1, 5, 9, 2, 6};  // 自动去重并排序

    s.insert(7);
    s.erase(1);

    // 查找
    if (s.find(4) != s.end()) {
        cout << "4 exists" << endl;
    }

    // 范围查找
    auto lower = s.lower_bound(4);  // >= 4的第一个元素
    auto upper = s.upper_bound(6);  // > 6的第一个元素
}

void multimap_multiset_demo() {
    // multimap: 允许重复键
    multimap<string, int> scores;
    scores.insert({"Alice", 85});
    scores.insert({"Alice", 90});
    scores.insert({"Bob", 88});

    // multiset: 允许重复元素
    multiset<int> mset = {1, 2, 2, 3, 3, 3};
    cout << "Count of 3: " << mset.count(3) << endl;  // 3
}
```

#### 3.1.3 容器适配器
```cpp
void stack_demo() {
    stack<int> stk;

    stk.push(1);
    stk.push(2);
    stk.push(3);

    while (!stk.empty()) {
        cout << stk.top() << " ";  // 访问栈顶
        stk.pop();                 // 弹出
    }
}

void queue_demo() {
    queue<int> q;

    q.push(1);
    q.push(2);
    q.push(3);

    while (!q.empty()) {
        cout << q.front() << " ";  // 访问队首
        q.pop();                   // 弹出
    }
}

void priority_queue_demo() {
    // 优先队列（默认大顶堆）
    priority_queue<int> pq;

    pq.push(3);
    pq.push(1);
    pq.push(4);
    pq.push(2);

    while (!pq.empty()) {
        cout << pq.top() << " ";  // 4 3 2 1
        pq.pop();
    }

    // 小顶堆
    priority_queue<int, vector<int>, greater<int>> min_pq;
    min_pq.push(3);
    min_pq.push(1);
    min_pq.push(4);
    // top() 返回 1
}
```

### 3.2 算法库

#### 3.2.1 常用算法
```cpp
void algorithm_demo() {
    vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};

    // 查找
    auto it = find(vec.begin(), vec.end(), 5);
    if (it != vec.end()) {
        cout << "Found: " << *it << endl;
    }

    // 计数
    int count = count_if(vec.begin(), vec.end(),
                         [](int x) { return x > 3; });

    // 排序
    sort(vec.begin(), vec.end());               // 升序
    sort(vec.begin(), vec.end(), greater<>());  // 降序

    // 去重（需先排序）
    auto last = unique(vec.begin(), vec.end());
    vec.erase(last, vec.end());

    // 反转
    reverse(vec.begin(), vec.end());

    // 累加
    int sum = accumulate(vec.begin(), vec.end(), 0);

    // 转换
    vector<int> squared;
    transform(vec.begin(), vec.end(), back_inserter(squared),
              [](int x) { return x * x; });

    // 拷贝
    vector<int> vec_copy;
    copy(vec.begin(), vec.end(), back_inserter(vec_copy));

    // 填充
    fill(vec.begin(), vec.end(), 0);
}

// 二分查找（需要有序容器）
void binary_search_demo() {
    vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 判断是否存在
    if (binary_search(vec.begin(), vec.end(), 5)) {
        cout << "5 exists" << endl;
    }

    // 找到第一个不小于5的位置
    auto it = lower_bound(vec.begin(), vec.end(), 5);

    // 找到第一个大于5的位置
    auto it2 = upper_bound(vec.begin(), vec.end(), 5);
}

// 分区算法
void partition_demo() {
    vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 将奇数移到前面
    auto it = partition(vec.begin(), vec.end(),
                       [](int x) { return x % 2 == 1; });

    // stable_partition保持相对顺序
    stable_partition(vec.begin(), vec.end(),
                    [](int x) { return x % 2 == 1; });
}

// 排列算法
void permutation_demo() {
    vector<int> vec = {1, 2, 3};

    // 生成下一个排列
    do {
        for (int x : vec) cout << x << " ";
        cout << endl;
    } while (next_permutation(vec.begin(), vec.end()));
}
```

### 3.3 迭代器深入

```cpp
// 迭代器类别
void iterator_categories() {
    // 1. 输入迭代器（Input Iterator）
    // 只读，单向移动
    istream_iterator<int> in_it(cin);

    // 2. 输出迭代器（Output Iterator）
    // 只写，单向移动
    ostream_iterator<int> out_it(cout, " ");

    // 3. 前向迭代器（Forward Iterator）
    // 可读写，单向移动，可多次遍历
    forward_list<int> flist = {1, 2, 3};
    auto fit = flist.begin();

    // 4. 双向迭代器（Bidirectional Iterator）
    // 可读写，双向移动
    list<int> lst = {1, 2, 3};
    auto lit = lst.begin();
    ++lit;  // 前进
    --lit;  // 后退

    // 5. 随机访问迭代器（Random Access Iterator）
    // 可读写，支持跳跃访问
    vector<int> vec = {1, 2, 3, 4, 5};
    auto vit = vec.begin();
    vit += 3;  // 跳跃访问
    cout << vit[2] << endl;  // 下标访问
}

// 迭代器适配器
void iterator_adapters() {
    vector<int> vec = {1, 2, 3, 4, 5};

    // 反向迭代器
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
        cout << *it << " ";  // 5 4 3 2 1
    }

    // 插入迭代器
    vector<int> dest;
    copy(vec.begin(), vec.end(), back_inserter(dest));

    // 移动迭代器（C++11）
    vector<string> src = {"a", "b", "c"};
    vector<string> dst(make_move_iterator(src.begin()),
                      make_move_iterator(src.end()));
}
```

---

## 第四模块：模板编程

### 4.1 函数模板

```cpp
// 基础函数模板
template<typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// 多个类型参数
template<typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a + b) {  // C++11尾置返回类型
    return a + b;
}

// C++14: 自动推导返回类型
template<typename T1, typename T2>
auto multiply(T1 a, T2 b) {
    return a * b;
}

// 模板特化
template<typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// 针对const char*的特化
template<>
const char* max_value<const char*>(const char* a, const char* b) {
    return (strcmp(a, b) > 0) ? a : b;
}

// 使用示例
void template_demo() {
    cout << max_value(10, 20) << endl;           // int版本
    cout << max_value(3.14, 2.71) << endl;       // double版本
    cout << max_value("hello", "world") << endl; // 特化版本
}

// 非类型模板参数
template<typename T, size_t N>
void print_array(const T (&arr)[N]) {
    for (size_t i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// 使用
int arr[] = {1, 2, 3, 4, 5};
print_array(arr);  // 自动推导N=5
```

### 4.2 类模板

```cpp
// 基础类模板
template<typename T>
class Stack {
private:
    vector<T> elements;

public:
    void push(const T& elem) {
        elements.push_back(elem);
    }

    void pop() {
        if (elements.empty()) {
            throw runtime_error("Stack is empty");
        }
        elements.pop_back();
    }

    T top() const {
        if (elements.empty()) {
            throw runtime_error("Stack is empty");
        }
        return elements.back();
    }

    bool empty() const {
        return elements.empty();
    }
};

// 使用示例
void class_template_demo() {
    Stack<int> int_stack;
    int_stack.push(1);
    int_stack.push(2);
    cout << int_stack.top() << endl;

    Stack<string> str_stack;
    str_stack.push("hello");
    str_stack.push("world");
    cout << str_stack.top() << endl;
}

// 类模板特化
template<typename T>
class Container {
    T data;
public:
    void print() { cout << data << endl; }
};

// 针对bool的特化
template<>
class Container<bool> {
    bool data;
public:
    void print() {
        cout << (data ? "true" : "false") << endl;
    }
};

// 部分特化
template<typename T, typename U>
class Pair {
    T first;
    U second;
};

// 部分特化：两个类型相同
template<typename T>
class Pair<T, T> {
    T first;
    T second;
public:
    bool isSame() const { return first == second; }
};
```

### 4.3 变参模板（C++11）

```cpp
// 递归展开变参模板
template<typename T>
void print(const T& t) {
    cout << t << endl;  // 递归终止
}

template<typename T, typename... Args>
void print(const T& t, const Args&... args) {
    cout << t << " ";
    print(args...);     // 递归调用
}

// 使用示例
void variadic_template_demo() {
    print(1, 2, 3, 4, 5);
    print("hello", 3.14, 'A', true);
}

// C++17: 折叠表达式
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);  // 一元右折叠
}

template<typename... Args>
void print_all(const Args&... args) {
    (cout << ... << args) << endl;  // 一元左折叠
}

// 使用示例
void fold_expression_demo() {
    cout << sum(1, 2, 3, 4, 5) << endl;  // 15
    print_all(1, " ", 2, " ", 3);
}

// 变参模板类
template<typename... Types>
class Tuple;

// 递归继承实现tuple
template<>
class Tuple<> {};

template<typename Head, typename... Tail>
class Tuple<Head, Tail...> : private Tuple<Tail...> {
    Head head;
public:
    Tuple(Head h, Tail... t)
        : Tuple<Tail...>(t...), head(h) {}
};
```

### 4.4 模板元编程

```cpp
// 编译期计算阶乘
template<int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

// 使用
constexpr int result = Factorial<5>::value;  // 120

// SFINAE (Substitution Failure Is Not An Error)
template<typename T>
typename enable_if<is_integral<T>::value, T>::type
increment(T val) {
    return val + 1;
}

template<typename T>
typename enable_if<is_floating_point<T>::value, T>::type
increment(T val) {
    return val + 0.1;
}

// C++17: if constexpr
template<typename T>
auto increment_cpp17(T val) {
    if constexpr (is_integral_v<T>) {
        return val + 1;
    } else if constexpr (is_floating_point_v<T>) {
        return val + 0.1;
    }
}

// 类型萃取
template<typename T>
struct TypeTraits {
    static constexpr bool is_pointer = false;
};

template<typename T>
struct TypeTraits<T*> {
    static constexpr bool is_pointer = true;
    using value_type = T;
};
```

---

## 第五模块：内存管理

### 5.1 RAII与智能指针

#### 5.1.1 智能指针
```cpp
void unique_ptr_demo() {
    // unique_ptr: 独占所有权
    unique_ptr<int> ptr1 = make_unique<int>(42);
    cout << *ptr1 << endl;

    // unique_ptr<int> ptr2 = ptr1;  // ❌ 错误：不能拷贝
    unique_ptr<int> ptr2 = std::move(ptr1);  // ✅ 转移所有权

    // ptr1现在为空
    if (!ptr1) {
        cout << "ptr1 is null" << endl;
    }

    // 数组版本
    unique_ptr<int[]> arr = make_unique<int[]>(10);
    arr[0] = 1;
}

void shared_ptr_demo() {
    // shared_ptr: 共享所有权（引用计数）
    shared_ptr<int> ptr1 = make_shared<int>(42);
    cout << "Use count: " << ptr1.use_count() << endl;  // 1

    {
        shared_ptr<int> ptr2 = ptr1;  // 引用计数+1
        cout << "Use count: " << ptr1.use_count() << endl;  // 2
    }  // ptr2析构，引用计数-1

    cout << "Use count: " << ptr1.use_count() << endl;  // 1
}

void weak_ptr_demo() {
    // weak_ptr: 弱引用，不增加引用计数
    shared_ptr<int> shared = make_shared<int>(42);
    weak_ptr<int> weak = shared;

    cout << "Shared count: " << shared.use_count() << endl;  // 1

    // 使用weak_ptr访问对象
    if (auto locked = weak.lock()) {
        cout << *locked << endl;
    } else {
        cout << "Object has been destroyed" << endl;
    }
}

// 实战：解决循环引用
class Node {
public:
    shared_ptr<Node> next;
    weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
    int data;

    Node(int d) : data(d) {}
    ~Node() { cout << "Node " << data << " destroyed" << endl; }
};

void circular_reference_demo() {
    auto node1 = make_shared<Node>(1);
    auto node2 = make_shared<Node>(2);

    node1->next = node2;
    node2->prev = node1;  // weak_ptr不会增加引用计数

    // 正常析构，不会内存泄漏
}
```

#### 5.1.2 RAII模式
```cpp
// 资源获取即初始化
class FileHandler {
private:
    FILE* file;

public:
    FileHandler(const char* filename, const char* mode) {
        file = fopen(filename, mode);
        if (!file) {
            throw runtime_error("Failed to open file");
        }
    }

    ~FileHandler() {
        if (file) {
            fclose(file);
            cout << "File closed" << endl;
        }
    }

    // 禁止拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;

    FILE* get() { return file; }
};

// 使用示例
void raii_demo() {
    try {
        FileHandler fh("test.txt", "w");
        fprintf(fh.get(), "Hello, RAII!\n");
        // 异常安全：即使抛出异常，析构函数也会被调用
    } catch (const exception& e) {
        cerr << e.what() << endl;
    }
    // 文件自动关闭
}

// 锁的RAII封装
class MutexGuard {
private:
    mutex& mtx;

public:
    MutexGuard(mutex& m) : mtx(m) {
        mtx.lock();
    }

    ~MutexGuard() {
        mtx.unlock();
    }

    // 禁止拷贝
    MutexGuard(const MutexGuard&) = delete;
    MutexGuard& operator=(const MutexGuard&) = delete;
};
```

### 5.2 内存管理最佳实践

```cpp
// ❌ 常见错误
void bad_practices() {
    // 1. 内存泄漏
    int* ptr = new int(10);
    // 忘记delete

    // 2. 野指针
    int* p = new int(10);
    delete p;
    *p = 20;  // 使用已释放的内存

    // 3. 重复释放
    int* q = new int(10);
    delete q;
    delete q;  // 重复释放

    // 4. 数组delete错误
    int* arr = new int[10];
    delete arr;  // ❌ 应该用delete[]
}

// ✅ 最佳实践
void good_practices() {
    // 1. 使用智能指针
    auto ptr = make_unique<int>(10);
    // 自动释放

    // 2. 使用容器代替原始数组
    vector<int> vec(10);
    // 自动管理内存

    // 3. 使用RAII管理资源
    {
        lock_guard<mutex> lock(mtx);  // RAII锁
        // 临界区代码
    }  // 自动解锁

    // 4. new后立即放入智能指针
    unique_ptr<int> smart_ptr(new int(10));
}

// 自定义删除器
void custom_deleter_demo() {
    // FILE*的智能指针
    unique_ptr<FILE, decltype(&fclose)> file(
        fopen("test.txt", "w"),
        &fclose
    );

    // 自定义删除器Lambda
    auto deleter = [](int* p) {
        cout << "Custom delete" << endl;
        delete p;
    };
    unique_ptr<int, decltype(deleter)> ptr(new int(42), deleter);
}
```

### 5.3 内存池与对象池

```cpp
// 简单内存池
template<typename T, size_t BlockSize = 4096>
class MemoryPool {
private:
    union Node {
        T data;
        Node* next;
    };

    Node* free_list;
    vector<char*> blocks;

public:
    MemoryPool() : free_list(nullptr) {}

    ~MemoryPool() {
        for (auto block : blocks) {
            delete[] block;
        }
    }

    T* allocate() {
        if (!free_list) {
            // 分配新块
            char* new_block = new char[BlockSize];
            blocks.push_back(new_block);

            // 将块分割成节点
            size_t num_nodes = BlockSize / sizeof(Node);
            for (size_t i = 0; i < num_nodes - 1; ++i) {
                Node* node = reinterpret_cast<Node*>(
                    new_block + i * sizeof(Node));
                node->next = reinterpret_cast<Node*>(
                    new_block + (i + 1) * sizeof(Node));
            }
            free_list = reinterpret_cast<Node*>(new_block);
        }

        Node* node = free_list;
        free_list = node->next;
        return &node->data;
    }

    void deallocate(T* ptr) {
        Node* node = reinterpret_cast<Node*>(ptr);
        node->next = free_list;
        free_list = node;
    }
};
```

---

## 第六模块：并发编程

### 6.1 多线程基础

```cpp
#include <thread>
#include <mutex>
#include <condition_variable>

// 基础线程创建
void thread_function(int id) {
    cout << "Thread " << id << " running" << endl;
    this_thread::sleep_for(chrono::seconds(1));
}

void basic_thread_demo() {
    thread t1(thread_function, 1);
    thread t2(thread_function, 2);

    t1.join();  // 等待t1完成
    t2.join();  // 等待t2完成

    // 使用Lambda
    thread t3([](){ cout << "Lambda thread" << endl; });
    t3.join();

    // 获取线程ID
    cout << "Main thread ID: " << this_thread::get_id() << endl;

    // 硬件并发数
    cout << "Hardware concurrency: "
         << thread::hardware_concurrency() << endl;
}

// 互斥锁
mutex mtx;
int shared_counter = 0;

void increment_counter() {
    for (int i = 0; i < 1000; ++i) {
        lock_guard<mutex> lock(mtx);  // RAII锁
        ++shared_counter;
    }
}

void mutex_demo() {
    thread t1(increment_counter);
    thread t2(increment_counter);

    t1.join();
    t2.join();

    cout << "Counter: " << shared_counter << endl;  // 2000
}

// unique_lock：更灵活的锁
void unique_lock_demo() {
    mutex mtx;

    unique_lock<mutex> lock(mtx);  // 自动加锁
    // 临界区
    lock.unlock();  // 手动解锁

    // 做其他事情

    lock.lock();  // 再次加锁
    // 临界区
    // 自动解锁
}

// 递归锁
void recursive_mutex_demo() {
    recursive_mutex rmtx;

    function<void(int)> recursive_func = [&](int n) {
        lock_guard<recursive_mutex> lock(rmtx);
        if (n > 0) {
            cout << n << " ";
            recursive_func(n - 1);  // 可以递归加锁
        }
    };

    recursive_func(5);
}

// 条件变量：生产者-消费者
queue<int> data_queue;
mutex queue_mutex;
condition_variable cv;
bool done = false;

void producer() {
    for (int i = 0; i < 10; ++i) {
        this_thread::sleep_for(chrono::milliseconds(100));

        lock_guard<mutex> lock(queue_mutex);
        data_queue.push(i);
        cout << "Produced: " << i << endl;
        cv.notify_one();  // 通知消费者
    }

    {
        lock_guard<mutex> lock(queue_mutex);
        done = true;
    }
    cv.notify_all();
}

void consumer(int id) {
    while (true) {
        unique_lock<mutex> lock(queue_mutex);
        cv.wait(lock, []{ return !data_queue.empty() || done; });

        while (!data_queue.empty()) {
            int value = data_queue.front();
            data_queue.pop();
            lock.unlock();

            cout << "Consumer " << id << " consumed: "
                 << value << endl;

            lock.lock();
        }

        if (done && data_queue.empty()) break;
    }
}

void producer_consumer_demo() {
    thread prod(producer);
    thread cons1(consumer, 1);
    thread cons2(consumer, 2);

    prod.join();
    cons1.join();
    cons2.join();
}
```

### 6.2 异步编程

```cpp
#include <future>

// async: 异步执行函数
int async_task(int x) {
    this_thread::sleep_for(chrono::seconds(2));
    return x * x;
}

void async_demo() {
    // 启动异步任务
    future<int> result = async(launch::async, async_task, 10);

    cout << "Doing other work..." << endl;

    // 获取结果（阻塞）
    cout << "Result: " << result.get() << endl;

    // 延迟执行
    future<int> lazy_result = async(launch::deferred, async_task, 5);
    // 直到调用get()才执行
    cout << "Lazy result: " << lazy_result.get() << endl;
}

// promise: 手动设置异步结果
void promise_demo() {
    promise<int> prom;
    future<int> fut = prom.get_future();

    thread t([](promise<int> p) {
        this_thread::sleep_for(chrono::seconds(1));
        p.set_value(42);  // 设置结果
    }, std::move(prom));

    cout << "Waiting for result..." << endl;
    cout << "Result: " << fut.get() << endl;

    t.join();
}

// packaged_task: 包装可调用对象
void packaged_task_demo() {
    packaged_task<int(int)> task([](int x) {
        return x * x;
    });

    future<int> result = task.get_future();

    thread t(std::move(task), 10);

    cout << "Result: " << result.get() << endl;

    t.join();
}

// shared_future: 多个线程共享结果
void shared_future_demo() {
    promise<int> prom;
    shared_future<int> sfut = prom.get_future().share();

    auto waiter = [](shared_future<int> sf, int id) {
        cout << "Thread " << id << " waiting..." << endl;
        cout << "Thread " << id << " got: " << sf.get() << endl;
    };

    thread t1(waiter, sfut, 1);
    thread t2(waiter, sfut, 2);

    this_thread::sleep_for(chrono::seconds(1));
    prom.set_value(42);

    t1.join();
    t2.join();
}
```

### 6.3 原子操作

```cpp
#include <atomic>

atomic<int> atomic_counter(0);

void atomic_increment() {
    for (int i = 0; i < 1000; ++i) {
        ++atomic_counter;  // 原子操作，无需锁
    }
}

void atomic_demo() {
    thread t1(atomic_increment);
    thread t2(atomic_increment);

    t1.join();
    t2.join();

    cout << "Atomic counter: " << atomic_counter << endl;  // 2000
}

// 原子操作详解
void atomic_operations() {
    atomic<int> x(0);

    // 基本操作
    x.store(10);              // 存储
    int val = x.load();       // 加载
    int old = x.exchange(20); // 交换

    // 比较并交换
    int expected = 20;
    bool success = x.compare_exchange_strong(expected, 30);

    // 算术操作
    x.fetch_add(5);   // x += 5
    x.fetch_sub(3);   // x -= 3

    // 位操作
    x.fetch_and(0xFF);
    x.fetch_or(0x10);
    x.fetch_xor(0x01);
}

// 内存序
void memory_order_demo() {
    atomic<int> x(0);
    atomic<int> y(0);

    // Relaxed: 最松散的内存序
    x.store(1, memory_order_relaxed);
    int r1 = y.load(memory_order_relaxed);

    // Acquire-Release: 同步内存序
    y.store(2, memory_order_release);
    int r2 = x.load(memory_order_acquire);

    // Sequential Consistent: 最严格的内存序（默认）
    x.store(3, memory_order_seq_cst);
    int r3 = y.load(memory_order_seq_cst);
}

// 无锁栈
template<typename T>
class LockFreeStack {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T& d) : data(d), next(nullptr) {}
    };

    atomic<Node*> head;

public:
    LockFreeStack() : head(nullptr) {}

    void push(const T& data) {
        Node* new_node = new Node(data);
        new_node->next = head.load();

        while (!head.compare_exchange_weak(new_node->next, new_node))
            ;
    }

    bool pop(T& result) {
        Node* old_head = head.load();

        while (old_head &&
               !head.compare_exchange_weak(old_head, old_head->next))
            ;

        if (old_head) {
            result = old_head->data;
            delete old_head;
            return true;
        }
        return false;
    }
};
```

---

## 第七模块：现代C++特性（C++11/14/17/20）

### 7.1 C++11核心特性

#### 7.1.1 统一初始化
```cpp
void uniform_initialization() {
    // 传统初始化
    int x = 10;
    int arr[] = {1, 2, 3};

    // C++11统一初始化
    int y{20};
    int z = {30};
    vector<int> vec{1, 2, 3, 4, 5};
    map<string, int> m{{"a", 1}, {"b", 2}};

    // 防止窄化转换
    int i{3.14};  // ❌ 错误：窄化转换
}
```

#### 7.1.2 nullptr
```cpp
void nullptr_demo() {
    int* p1 = NULL;      // C风格
    int* p2 = nullptr;   // C++11

    // nullptr类型安全
    void func(int x) {}
    void func(int* p) {}

    func(NULL);     // 可能产生歧义
    func(nullptr);  // 明确调用指针版本
}
```

#### 7.1.3 范围for循环
```cpp
void range_for() {
    vector<int> vec = {1, 2, 3, 4, 5};

    // 传统循环
    for (size_t i = 0; i < vec.size(); ++i) {
        cout << vec[i] << " ";
    }

    // C++11范围for
    for (int x : vec) {
        cout << x << " ";
    }

    // 引用避免拷贝
    for (const auto& x : vec) {
        cout << x << " ";
    }

    // 修改元素
    for (auto& x : vec) {
        x *= 2;
    }
}
```

#### 7.1.4 =default和=delete
```cpp
class MyClass {
public:
    // 显式使用默认构造函数
    MyClass() = default;

    // 显式删除拷贝构造
    MyClass(const MyClass&) = delete;
    MyClass& operator=(const MyClass&) = delete;

    // 显式使用默认移动构造
    MyClass(MyClass&&) = default;
    MyClass& operator=(MyClass&&) = default;
};
```

#### 7.1.5 override和final
```cpp
class Base {
public:
    virtual void foo() {}
    virtual void bar() final {}  // final: 禁止重写
};

class Derived : public Base {
public:
    void foo() override {}  // override: 明确重写
    // void bar() override {}  // ❌ 错误：bar是final
};

// final类：禁止继承
class FinalClass final {
public:
    void func() {}
};

// class CannotDerive : public FinalClass {};  // ❌ 错误
```

#### 7.1.6 委托构造
```cpp
class Point {
private:
    int x, y;

public:
    Point(int x_val, int y_val) : x(x_val), y(y_val) {
        cout << "Main constructor" << endl;
    }

    // 委托构造函数
    Point() : Point(0, 0) {
        cout << "Delegating constructor" << endl;
    }

    Point(int val) : Point(val, val) {}
};
```

#### 7.1.7 noexcept
```cpp
// 声明函数不抛出异常
void func() noexcept {
    // 如果抛出异常，程序会终止
}

// 条件noexcept
template<typename T>
void swap(T& a, T& b) noexcept(noexcept(T(std::move(a)))) {
    T temp(std::move(a));
    a = std::move(b);
    b = std::move(temp);
}

// 检查是否noexcept
static_assert(noexcept(func()), "func should be noexcept");
```

### 7.2 C++14新特性

#### 7.2.1 auto返回类型推导
```cpp
// C++11需要尾置返回类型
template<typename T1, typename T2>
auto add_cpp11(T1 a, T2 b) -> decltype(a + b) {
    return a + b;
}

// C++14可以自动推导
template<typename T1, typename T2>
auto add_cpp14(T1 a, T2 b) {
    return a + b;
}
```

#### 7.2.2 泛型Lambda
```cpp
void generic_lambda() {
    // C++14: auto参数
    auto lambda = [](auto a, auto b) {
        return a + b;
    };

    cout << lambda(1, 2) << endl;      // 3
    cout << lambda(1.5, 2.5) << endl;  // 4.0
    cout << lambda(string("hello"), string(" world")) << endl;
}
```

#### 7.2.3 变量模板
```cpp
template<typename T>
constexpr T pi = T(3.1415926535897932385);

void variable_template() {
    cout << pi<double> << endl;
    cout << pi<float> << endl;
}
```

### 7.3 C++17新特性

#### 7.3.1 结构化绑定
```cpp
void structured_bindings() {
    // pair
    pair<int, string> p{1, "hello"};
    auto [id, name] = p;

    // tuple
    tuple<int, double, string> t{42, 3.14, "world"};
    auto [i, d, s] = t;

    // map遍历
    map<string, int> m{{"a", 1}, {"b", 2}};
    for (const auto& [key, value] : m) {
        cout << key << ": " << value << endl;
    }
}
```

#### 7.3.2 if/switch初始化语句
```cpp
void init_statement() {
    // if with initializer
    if (auto it = m.find(key); it != m.end()) {
        // 使用it
    }

    // switch with initializer
    switch (auto val = getValue(); val) {
        case 1: /*...*/ break;
        case 2: /*...*/ break;
    }
}
```

#### 7.3.3 std::optional
```cpp
optional<int> find_value(const vector<int>& vec, int target) {
    auto it = find(vec.begin(), vec.end(), target);
    if (it != vec.end()) {
        return *it;
    }
    return nullopt;
}

void optional_demo() {
    vector<int> vec = {1, 2, 3, 4, 5};

    if (auto result = find_value(vec, 3); result.has_value()) {
        cout << "Found: " << result.value() << endl;
    } else {
        cout << "Not found" << endl;
    }

    // value_or提供默认值
    int val = find_value(vec, 10).value_or(-1);
}
```

#### 7.3.4 std::variant
```cpp
void variant_demo() {
    variant<int, double, string> v;

    v = 42;
    cout << get<int>(v) << endl;

    v = 3.14;
    cout << get<double>(v) << endl;

    v = "hello";
    cout << get<string>(v) << endl;

    // 访问variant
    visit([](auto&& arg) {
        cout << arg << endl;
    }, v);

    // 类型索引
    cout << "Index: " << v.index() << endl;
}
```

#### 7.3.5 std::any
```cpp
void any_demo() {
    any a = 10;
    cout << any_cast<int>(a) << endl;

    a = 3.14;
    cout << any_cast<double>(a) << endl;

    a = string("hello");
    cout << any_cast<string>(a) << endl;

    // 检查类型
    if (a.type() == typeid(string)) {
        cout << "It's a string" << endl;
    }
}
```

#### 7.3.6 std::string_view
```cpp
void string_view_demo() {
    string s = "hello world";

    // string_view不拷贝字符串
    string_view sv = s;
    string_view sub = sv.substr(0, 5);

    cout << sub << endl;  // "hello"

    // 高效的参数传递
    auto process = [](string_view s) {
        cout << s << endl;
    };

    process("literal");
    process(s);
    process(sv);
}
```

### 7.4 C++20新特性

#### 7.4.1 概念（Concepts）
```cpp
// 定义概念
template<typename T>
concept Integral = is_integral_v<T>;

template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> same_as<T>;
};

// 使用概念约束模板
template<Integral T>
T add(T a, T b) {
    return a + b;
}

// requires子句
template<typename T>
    requires Integral<T> && sizeof(T) >= 4
T multiply(T a, T b) {
    return a * b;
}
```

#### 7.4.2 范围（Ranges）
```cpp
#include <ranges>

void ranges_demo() {
    vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 过滤和转换
    auto result = vec
        | views::filter([](int x) { return x % 2 == 0; })
        | views::transform([](int x) { return x * x; });

    for (int x : result) {
        cout << x << " ";  // 4 16 36 64 100
    }

    // 取前N个
    auto first_three = vec | views::take(3);

    // 跳过N个
    auto skip_two = vec | views::drop(2);
}
```

#### 7.4.3 协程（Coroutines）
```cpp
#include <coroutine>

// 简单生成器
template<typename T>
struct Generator {
    struct promise_type {
        T current_value;

        auto get_return_object() {
            return Generator{
                coroutine_handle<promise_type>::from_promise(*this)
            };
        }

        auto initial_suspend() { return suspend_always{}; }
        auto final_suspend() noexcept { return suspend_always{}; }
        void return_void() {}
        void unhandled_exception() { terminate(); }

        auto yield_value(T value) {
            current_value = value;
            return suspend_always{};
        }
    };

    coroutine_handle<promise_type> coro;

    Generator(coroutine_handle<promise_type> h) : coro(h) {}
    ~Generator() { if (coro) coro.destroy(); }

    bool move_next() {
        coro.resume();
        return !coro.done();
    }

    T current_value() {
        return coro.promise().current_value;
    }
};

// 使用协程
Generator<int> fibonacci() {
    int a = 0, b = 1;
    while (true) {
        co_yield a;
        auto next = a + b;
        a = b;
        b = next;
    }
}

void coroutine_demo() {
    auto gen = fibonacci();
    for (int i = 0; i < 10; ++i) {
        gen.move_next();
        cout << gen.current_value() << " ";
    }
}
```

#### 7.4.4 三路比较运算符
```cpp
class Point {
    int x, y;

public:
    Point(int x, int y) : x(x), y(y) {}

    // C++20: 三路比较
    auto operator<=>(const Point& other) const = default;
};

void three_way_comparison() {
    Point p1(1, 2);
    Point p2(3, 4);

    // 自动生成所有比较运算符
    bool eq = (p1 == p2);
    bool ne = (p1 != p2);
    bool lt = (p1 < p2);
    bool le = (p1 <= p2);
    bool gt = (p1 > p2);
    bool ge = (p1 >= p2);
}
```

---

## 第八模块：异常处理

### 8.1 异常基础

```cpp
// 抛出异常
void throw_exception() {
    throw runtime_error("Something went wrong");
}

// 捕获异常
void catch_exception() {
    try {
        throw_exception();
    } catch (const runtime_error& e) {
        cout << "Caught: " << e.what() << endl;
    }
}

// 多个catch块
void multiple_catch() {
    try {
        // ...
    } catch (const invalid_argument& e) {
        cout << "Invalid argument: " << e.what() << endl;
    } catch (const runtime_error& e) {
        cout << "Runtime error: " << e.what() << endl;
    } catch (const exception& e) {
        cout << "Exception: " << e.what() << endl;
    } catch (...) {
        cout << "Unknown exception" << endl;
    }
}
```

### 8.2 自定义异常

```cpp
class MyException : public exception {
private:
    string message;

public:
    explicit MyException(const string& msg) : message(msg) {}

    const char* what() const noexcept override {
        return message.c_str();
    }
};

void custom_exception_demo() {
    try {
        throw MyException("Custom error occurred");
    } catch (const MyException& e) {
        cout << "Caught custom exception: " << e.what() << endl;
    }
}
```

### 8.3 异常安全性

```cpp
// 基本保证：不泄漏资源
void basic_guarantee() {
    vector<int> vec;
    vec.push_back(1);  // 如果失败，vec仍然有效
}

// 强保证：要么成功，要么保持原状
void strong_guarantee() {
    vector<int> vec = {1, 2, 3};
    vector<int> backup = vec;  // 备份

    try {
        // 修改vec
    } catch (...) {
        vec = backup;  // 恢复
        throw;
    }
}

// 不抛出保证
void nothrow_guarantee() noexcept {
    // 保证不抛出异常
}
```

### 8.4 RAII与异常安全

```cpp
class Resource {
public:
    Resource() {
        cout << "Acquire resource" << endl;
    }

    ~Resource() {
        cout << "Release resource" << endl;
    }
};

void raii_exception_safety() {
    try {
        Resource r;  // 获取资源

        // 可能抛出异常的代码
        throw runtime_error("Error");

    } catch (const exception& e) {
        // 资源自动释放
        cout << "Exception: " << e.what() << endl;
    }
}
```

---

## 第九模块：文件与流操作

### 9.1 文件I/O

```cpp
#include <fstream>

// 写文件
void write_file() {
    ofstream file("output.txt");

    if (file.is_open()) {
        file << "Hello, File!" << endl;
        file << "Line 2" << endl;
        file.close();
    }
}

// 读文件
void read_file() {
    ifstream file("input.txt");

    if (file.is_open()) {
        string line;
        while (getline(file, line)) {
            cout << line << endl;
        }
        file.close();
    }
}

// 二进制文件
void binary_file() {
    // 写二进制
    ofstream out("data.bin", ios::binary);
    int data[] = {1, 2, 3, 4, 5};
    out.write(reinterpret_cast<char*>(data), sizeof(data));
    out.close();

    // 读二进制
    ifstream in("data.bin", ios::binary);
    int buffer[5];
    in.read(reinterpret_cast<char*>(buffer), sizeof(buffer));
    in.close();
}

// 文件定位
void file_positioning() {
    fstream file("test.txt", ios::in | ios::out);

    // 移动读位置
    file.seekg(10);  // 从头开始偏移10
    file.seekg(-5, ios::end);  // 从尾部往前5

    // 获取当前位置
    streampos pos = file.tellg();

    // 移动写位置
    file.seekp(0, ios::beg);
}
```

### 9.2 字符串流

```cpp
#include <sstream>

// 字符串流
void stringstream_demo() {
    stringstream ss;

    // 写入
    ss << "Value: " << 42 << ", Pi: " << 3.14;

    // 读取
    string str = ss.str();
    cout << str << endl;

    // 解析
    ss.clear();
    ss.str("10 20 30");
    int a, b, c;
    ss >> a >> b >> c;
}

// 格式化输出
void formatting_demo() {
    stringstream ss;

    // 设置精度
    ss << fixed << setprecision(2) << 3.14159;

    // 设置宽度
    ss << setw(10) << setfill('0') << 42;

    // 十六进制
    ss << hex << 255;
}
```

---

## 第十模块：设计模式

### 10.1 单例模式

```cpp
// 饿汉式单例
class EagerSingleton {
private:
    static EagerSingleton* instance;

    EagerSingleton() {}
    EagerSingleton(const EagerSingleton&) = delete;
    EagerSingleton& operator=(const EagerSingleton&) = delete;

public:
    static EagerSingleton* getInstance() {
        return instance;
    }
};

EagerSingleton* EagerSingleton::instance = new EagerSingleton();

// 懒汉式单例（C++11线程安全）
class LazySingleton {
private:
    LazySingleton() {}
    LazySingleton(const LazySingleton&) = delete;
    LazySingleton& operator=(const LazySingleton&) = delete;

public:
    static LazySingleton& getInstance() {
        static LazySingleton instance;  // C++11保证线程安全
        return instance;
    }
};
```

### 10.2 工厂模式

```cpp
// 抽象产品
class Product {
public:
    virtual void use() = 0;
    virtual ~Product() = default;
};

// 具体产品
class ConcreteProductA : public Product {
public:
    void use() override {
        cout << "Using Product A" << endl;
    }
};

class ConcreteProductB : public Product {
public:
    void use() override {
        cout << "Using Product B" << endl;
    }
};

// 简单工厂
class SimpleFactory {
public:
    static unique_ptr<Product> createProduct(const string& type) {
        if (type == "A") {
            return make_unique<ConcreteProductA>();
        } else if (type == "B") {
            return make_unique<ConcreteProductB>();
        }
        return nullptr;
    }
};

// 抽象工厂
class AbstractFactory {
public:
    virtual unique_ptr<Product> createProduct() = 0;
    virtual ~AbstractFactory() = default;
};

class FactoryA : public AbstractFactory {
public:
    unique_ptr<Product> createProduct() override {
        return make_unique<ConcreteProductA>();
    }
};
```

### 10.3 观察者模式

```cpp
class Observer {
public:
    virtual void update(int state) = 0;
    virtual ~Observer() = default;
};

class Subject {
private:
    vector<Observer*> observers;
    int state;

public:
    void attach(Observer* observer) {
        observers.push_back(observer);
    }

    void detach(Observer* observer) {
        observers.erase(
            remove(observers.begin(), observers.end(), observer),
            observers.end()
        );
    }

    void setState(int s) {
        state = s;
        notify();
    }

    int getState() const { return state; }

private:
    void notify() {
        for (auto observer : observers) {
            observer->update(state);
        }
    }
};

class ConcreteObserver : public Observer {
private:
    int observer_state;
    Subject* subject;

public:
    ConcreteObserver(Subject* s) : subject(s) {
        subject->attach(this);
    }

    void update(int state) override {
        observer_state = state;
        cout << "Observer state updated to: " << state << endl;
    }
};
```

---

## 学习验证标准

### 基础验证（Week 1-4）
- [ ] 掌握auto、引用、Lambda表达式
- [ ] 能够设计和实现类（构造、析构、拷贝、移动）
- [ ] 理解虚函数和多态机制
- [ ] 熟练使用运算符重载
- [ ] 理解const、static关键字的各种用法

### STL验证（Week 5-6）
- [ ] 熟练使用vector、map、set等容器
- [ ] 能够使用STL算法解决实际问题
- [ ] 理解迭代器概念和类别
- [ ] 掌握容器适配器的使用

### 模板验证（Week 7-8）
- [ ] 编写函数模板和类模板
- [ ] 理解模板特化和偏特化
- [ ] 使用变参模板
- [ ] 了解SFINAE和编译期编程

### 内存验证（Week 9-10）
- [ ] 正确使用智能指针
- [ ] 理解RAII原则
- [ ] 避免内存泄漏和悬空指针
- [ ] 理解移动语义

### 并发验证（Week 11-12）
- [ ] 创建和管理多线程
- [ ] 正确使用互斥锁和条件变量
- [ ] 理解原子操作和内存序
- [ ] 使用future、promise、async

### 现代C++验证（Week 13-14）
- [ ] 掌握C++11/14/17核心特性
- [ ] 了解C++20新特性（概念、范围、协程）
- [ ] 熟练使用智能指针、Lambda、右值引用

### 综合项目验证（Week 15-16）
- [ ] 完成包含以下特性的项目：
  - OOP设计（继承、多态）
  - STL容器和算法
  - 智能指针管理资源
  - 多线程并发处理
  - 异常安全设计

---

## 常见错误与解决

### 1. 内存错误
```cpp
// ❌ 返回局部变量引用
int& bad_function() {
    int x = 10;
    return x;  // 危险！
}

// ✅ 返回值或使用static
int good_function() {
    int x = 10;
    return x;
}

// ❌ 迭代器失效
vector<int> vec = {1, 2, 3};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    vec.push_back(*it);  // ❌ 可能导致迭代器失效
}

// ✅ 正确做法
vector<int> vec = {1, 2, 3};
size_t size = vec.size();
for (size_t i = 0; i < size; ++i) {
    vec.push_back(vec[i]);
}
```

### 2. 多线程错误
```cpp
// ❌ 忘记加锁
int counter = 0;
void increment() {
    ++counter;  // 竞争条件
}

// ✅ 使用互斥锁或原子操作
mutex mtx;
void safe_increment() {
    lock_guard<mutex> lock(mtx);
    ++counter;
}
```

### 3. 异常安全错误
```cpp
// ❌ 资源泄漏
void bad_code() {
    int* ptr = new int(10);
    // 如果这里抛出异常，ptr永远不会被delete
    process();
    delete ptr;
}

// ✅ 使用RAII
void good_code() {
    unique_ptr<int> ptr = make_unique<int>(10);
    // 异常安全，自动释放
    process();
}
```

---

## 推荐学习资源

### 书籍
1. **《C++ Primer》** - Stanley Lippman（入门经典）
2. **《Effective C++》** - Scott Meyers（最佳实践）
3. **《Effective Modern C++》** - Scott Meyers（现代C++最佳实践）
4. **《深度探索C++对象模型》** - Stanley Lippman
5. **《C++并发编程实战》** - Anthony Williams
6. **《C++模板元编程》** - David Abrahams

### 在线资源
- **cppreference.com** - 权威参考文档
- **learncpp.com** - 系统教程
- **CppCon** - YouTube频道（前沿技术）
- **isocpp.org** - C++标准委员会官网

### 开源项目学习
1. **LLVM/Clang** - 编译器基础设施
2. **Boost** - C++扩展库
3. **Qt** - 跨平台应用框架
4. **Google Test** - 单元测试框架

### 实践项目
1. **命令行工具**: 文件管理、日志分析
2. **多线程下载器**: 网络编程+并发
3. **简易数据库**: STL容器+文件I/O
4. **游戏引擎**: OOP+模板+性能优化
5. **HTTP服务器**: 网络+并发+设计模式

---

## 学习建议

1. **每天编写代码，动手实践** - 理论必须结合实践
2. **阅读优秀开源项目源码** - 学习工业级代码风格
3. **参与代码审查和讨论** - 提升代码质量意识
4. **关注C++新标准发展** - 跟进语言演进
5. **重视代码质量和性能优化** - 追求卓越
6. **建立知识体系** - 从点到面，构建完整认知
7. **持续学习，保持热情** - C++是一门需要长期学习的语言

---

**祝你在C++学习之路上不断进步！**
