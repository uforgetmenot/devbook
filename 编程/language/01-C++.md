# C++完整学习笔记

## 学习目标定位
- **目标群体**: 有C语言基础或其他编程语言经验的学习者
- **学习周期**: 10-16周
- **前置要求**: C语言基础或基础编程概念
- **学习成果**: 掌握现代C++(C++11/14/17/20)并能开发实际项目

## 学习路径

```
基础强化(Week 1-2) → 面向对象(Week 3-4) → STL(Week 5-6)
→ 模板编程(Week 7-8) → 内存管理(Week 9-10) → 并发编程(Week 11-12)
→ 现代C++特性(Week 13-14) → 实战项目(Week 15-16)
```

---

## 第一模块：C++基础强化

### 1.1 数据类型与变量

#### 1.1.1 基本数据类型
```cpp
#include <iostream>
#include <limits>
using namespace std;

void type_demo() {
    // 整型
    int a = 42;
    short b = 10;
    long c = 1000000L;
    long long d = 9223372036854775807LL;

    // 无符号类型
    unsigned int ua = 100U;
    size_t size = sizeof(int);  // 返回unsigned类型

    // 浮点型
    float f = 3.14f;
    double pi = 3.14159265;
    long double ld = 3.14159265358979L;

    // 布尔型
    bool flag = true;

    // 字符型
    char ch = 'A';
    wchar_t wch = L'中';  // 宽字符

    // 类型大小
    cout << "int: " << sizeof(int) << " bytes" << endl;
    cout << "int range: " << numeric_limits<int>::min()
         << " to " << numeric_limits<int>::max() << endl;
}

// C++11: auto类型推导
void auto_demo() {
    auto x = 42;        // int
    auto y = 3.14;      // double
    auto str = "hello"; // const char*

    vector<int> vec = {1, 2, 3};
    auto it = vec.begin();  // vector<int>::iterator
}

// C++11: decltype类型推导
void decltype_demo() {
    int x = 5;
    decltype(x) y = x;  // y的类型是int

    auto func = [](int a, int b) { return a + b; };
    decltype(func) func2 = func;  // 推导Lambda类型
}
```

#### 1.1.2 引用与指针对比
```cpp
// 指针
void pointer_demo() {
    int value = 10;
    int* ptr = &value;   // 指针存储地址
    *ptr = 20;           // 通过解引用修改值

    ptr = nullptr;       // C++11: nullptr替代NULL

    // 指针可以重新赋值
    int another = 30;
    ptr = &another;
}

// 引用
void reference_demo() {
    int value = 10;
    int& ref = value;    // 引用是别名
    ref = 20;            // 直接修改value

    // 引用必须初始化，且不能重新绑定
    // int& ref2;        // ❌ 错误：必须初始化
    // ref = another;    // ✅ 这是修改value的值，不是重新绑定
}

// 常量引用：避免拷贝的高效参数传递
void print_string(const string& str) {
    // str不能被修改，但避免了拷贝
    cout << str << endl;
}

// 右值引用（C++11）
void rvalue_demo() {
    int&& rref = 42;           // 绑定到右值
    string&& str = "hello";    // 临时字符串

    vector<int> vec1 = {1, 2, 3};
    vector<int> vec2 = std::move(vec1);  // 移动语义
    // vec1现在为空
}
```

### 1.2 函数高级特性

#### 1.2.1 函数重载
```cpp
// 同名函数，不同参数列表
void print(int x) {
    cout << "Int: " << x << endl;
}

void print(double x) {
    cout << "Double: " << x << endl;
}

void print(const string& x) {
    cout << "String: " << x << endl;
}

// 使用示例
int main() {
    print(10);        // 调用print(int)
    print(3.14);      // 调用print(double)
    print("hello");   // 调用print(const string&)
}
```

#### 1.2.2 默认参数
```cpp
// 从右向左指定默认参数
void create_window(int width = 800, int height = 600,
                   bool fullscreen = false) {
    cout << "Window: " << width << "x" << height << endl;
}

// 调用示例
create_window();                    // 800x600, 非全屏
create_window(1024);                // 1024x600, 非全屏
create_window(1920, 1080);          // 1920x1080, 非全屏
create_window(1920, 1080, true);    // 1920x1080, 全屏
```

#### 1.2.3 Lambda表达式（C++11）
```cpp
void lambda_demo() {
    // 基础Lambda
    auto add = [](int a, int b) { return a + b; };
    cout << add(3, 4) << endl;  // 7

    // 捕获外部变量
    int x = 10;
    auto print_x = [x]() { cout << x << endl; };  // 值捕获
    print_x();  // 10

    auto modify_x = [&x]() { x = 20; };  // 引用捕获
    modify_x();
    cout << x << endl;  // 20

    // 捕获所有变量
    int a = 1, b = 2;
    auto lambda1 = [=]() { return a + b; };   // 值捕获所有
    auto lambda2 = [&]() { a++; b++; };       // 引用捕获所有

    // 混合捕获
    auto lambda3 = [=, &a]() { a++; return a + b; };

    // 泛型Lambda (C++14)
    auto generic = [](auto a, auto b) { return a + b; };
    cout << generic(1, 2) << endl;      // 3
    cout << generic(1.5, 2.5) << endl;  // 4.0
}

// 实战：STL算法中使用Lambda
void lambda_with_stl() {
    vector<int> nums = {1, 2, 3, 4, 5};

    // 查找第一个大于3的数
    auto it = find_if(nums.begin(), nums.end(),
                      [](int n) { return n > 3; });

    // 遍历并打印
    for_each(nums.begin(), nums.end(),
             [](int n) { cout << n << " "; });

    // 排序（自定义比较）
    sort(nums.begin(), nums.end(),
         [](int a, int b) { return a > b; });  // 降序
}
```

---

## 第二模块：面向对象编程

### 2.1 类的基础

#### 2.1.1 类的定义与使用
```cpp
class Rectangle {
private:
    double width;
    double height;

public:
    // 构造函数
    Rectangle() : width(0), height(0) {}

    Rectangle(double w, double h) : width(w), height(h) {}

    // 成员函数
    double area() const {  // const成员函数不修改对象
        return width * height;
    }

    double perimeter() const {
        return 2 * (width + height);
    }

    // Getter/Setter
    void set_width(double w) { width = w; }
    double get_width() const { return width; }

    // 析构函数
    ~Rectangle() {
        cout << "Rectangle destroyed" << endl;
    }
};

// 使用示例
void rectangle_demo() {
    Rectangle rect1;                   // 默认构造
    Rectangle rect2(10.0, 5.0);       // 参数化构造

    cout << "Area: " << rect2.area() << endl;
    cout << "Perimeter: " << rect2.perimeter() << endl;
}
```

#### 2.1.2 构造函数高级特性
```cpp
class Student {
private:
    string name;
    int age;
    vector<int> grades;

public:
    // 默认构造函数
    Student() : name(""), age(0) {}

    // 参数化构造函数
    Student(const string& n, int a) : name(n), age(a) {}

    // 初始化列表构造（C++11）
    Student(const string& n, int a, initializer_list<int> g)
        : name(n), age(a), grades(g) {}

    // 拷贝构造函数
    Student(const Student& other)
        : name(other.name), age(other.age), grades(other.grades) {
        cout << "Copy constructor called" << endl;
    }

    // 移动构造函数（C++11）
    Student(Student&& other) noexcept
        : name(std::move(other.name))
        , age(other.age)
        , grades(std::move(other.grades)) {
        cout << "Move constructor called" << endl;
    }

    // 拷贝赋值运算符
    Student& operator=(const Student& other) {
        if (this != &other) {
            name = other.name;
            age = other.age;
            grades = other.grades;
        }
        return *this;
    }

    // 移动赋值运算符（C++11）
    Student& operator=(Student&& other) noexcept {
        if (this != &other) {
            name = std::move(other.name);
            age = other.age;
            grades = std::move(other.grades);
        }
        return *this;
    }
};

// 使用示例
void student_demo() {
    Student s1("Alice", 20);
    Student s2 = s1;                           // 拷贝构造
    Student s3("Bob", 21, {85, 90, 95});      // 初始化列表
    Student s4 = std::move(s3);               // 移动构造
}
```

### 2.2 继承与多态

#### 2.2.1 继承机制
```cpp
// 基类
class Shape {
protected:
    string color;

public:
    Shape(const string& c) : color(c) {}

    virtual ~Shape() {}  // 虚析构函数

    virtual double area() const = 0;  // 纯虚函数

    virtual void draw() const {
        cout << "Drawing a " << color << " shape" << endl;
    }

    string get_color() const { return color; }
};

// 派生类：圆形
class Circle : public Shape {
private:
    double radius;

public:
    Circle(const string& c, double r)
        : Shape(c), radius(r) {}

    double area() const override {  // C++11: override关键字
        return 3.14159 * radius * radius;
    }

    void draw() const override {
        cout << "Drawing a " << color << " circle" << endl;
    }
};

// 派生类：矩形
class Rectangle : public Shape {
private:
    double width, height;

public:
    Rectangle(const string& c, double w, double h)
        : Shape(c), width(w), height(h) {}

    double area() const override {
        return width * height;
    }

    void draw() const override {
        cout << "Drawing a " << color << " rectangle" << endl;
    }
};

// 多态示例
void polymorphism_demo() {
    vector<unique_ptr<Shape>> shapes;
    shapes.push_back(make_unique<Circle>("red", 5.0));
    shapes.push_back(make_unique<Rectangle>("blue", 4.0, 6.0));

    for (const auto& shape : shapes) {
        shape->draw();
        cout << "Area: " << shape->area() << endl;
    }
}
```

#### 2.2.2 运算符重载
```cpp
class Complex {
private:
    double real, imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 算术运算符重载
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }

    Complex operator*(const Complex& other) const {
        return Complex(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }

    // 复合赋值运算符
    Complex& operator+=(const Complex& other) {
        real += other.real;
        imag += other.imag;
        return *this;
    }

    // 比较运算符
    bool operator==(const Complex& other) const {
        return real == other.real && imag == other.imag;
    }

    // 流操作符重载（友元函数）
    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << c.real;
        if (c.imag >= 0) os << "+";
        os << c.imag << "i";
        return os;
    }

    friend istream& operator>>(istream& is, Complex& c) {
        is >> c.real >> c.imag;
        return is;
    }
};

// 使用示例
void complex_demo() {
    Complex c1(3, 4);
    Complex c2(1, 2);

    Complex c3 = c1 + c2;
    cout << c1 << " + " << c2 << " = " << c3 << endl;

    c1 += c2;
    cout << "After +=: " << c1 << endl;
}
```

---

## 第三模块：STL（标准模板库）

### 3.1 容器详解

#### 3.1.1 序列容器
```cpp
void vector_demo() {
    // vector: 动态数组
    vector<int> vec = {1, 2, 3, 4, 5};

    vec.push_back(6);           // 尾部添加
    vec.pop_back();             // 尾部删除
    vec.insert(vec.begin(), 0); // 指定位置插入
    vec.erase(vec.begin());     // 删除元素

    // 访问元素
    cout << vec[0] << endl;     // 不检查边界
    cout << vec.at(0) << endl;  // 检查边界，抛出异常

    // 容量管理
    vec.reserve(100);           // 预分配容量
    vec.shrink_to_fit();        // 释放多余容量

    // 遍历
    for (int x : vec) {
        cout << x << " ";
    }
}

void list_demo() {
    // list: 双向链表
    list<int> lst = {1, 2, 3, 4, 5};

    lst.push_front(0);    // 头部添加
    lst.push_back(6);     // 尾部添加
    lst.pop_front();      // 头部删除
    lst.pop_back();       // 尾部删除

    // 排序和去重
    lst.sort();
    lst.unique();         // 删除连续重复元素

    // 合并两个有序链表
    list<int> lst2 = {10, 20, 30};
    lst.merge(lst2);
}

void deque_demo() {
    // deque: 双端队列
    deque<int> dq = {1, 2, 3};

    dq.push_front(0);     // 头部添加 O(1)
    dq.push_back(4);      // 尾部添加 O(1)
    dq.pop_front();       // 头部删除 O(1)
    dq.pop_back();        // 尾部删除 O(1)

    // 随机访问 O(1)
    cout << dq[1] << endl;
}
```

#### 3.1.2 关联容器
```cpp
void map_demo() {
    // map: 有序键值对容器（红黑树实现）
    map<string, int> age_map;

    // 插入
    age_map["Alice"] = 25;
    age_map["Bob"] = 30;
    age_map.insert({"Charlie", 28});
    age_map.emplace("David", 35);  // C++11: 直接构造

    // 查找
    if (age_map.count("Alice") > 0) {
        cout << "Alice's age: " << age_map["Alice"] << endl;
    }

    auto it = age_map.find("Bob");
    if (it != age_map.end()) {
        cout << it->first << ": " << it->second << endl;
    }

    // 遍历（按键排序）
    for (const auto& [name, age] : age_map) {  // C++17结构化绑定
        cout << name << ": " << age << endl;
    }
}

void unordered_map_demo() {
    // unordered_map: 无序键值对容器（哈希表实现）
    unordered_map<string, int> word_count;

    string text = "hello world hello";
    istringstream iss(text);
    string word;

    while (iss >> word) {
        word_count[word]++;  // 自动初始化为0
    }

    for (const auto& [word, count] : word_count) {
        cout << word << ": " << count << endl;
    }
}

void set_demo() {
    // set: 有序唯一元素集合
    set<int> s = {3, 1, 4, 1, 5, 9, 2, 6};  // 自动去重并排序

    s.insert(7);
    s.erase(1);

    // 查找
    if (s.find(4) != s.end()) {
        cout << "4 exists" << endl;
    }

    // 范围查找
    auto lower = s.lower_bound(4);  // >= 4的第一个元素
    auto upper = s.upper_bound(6);  // > 6的第一个元素
}
```

#### 3.1.3 容器适配器
```cpp
void stack_demo() {
    stack<int> stk;

    stk.push(1);
    stk.push(2);
    stk.push(3);

    while (!stk.empty()) {
        cout << stk.top() << " ";  // 访问栈顶
        stk.pop();                 // 弹出
    }
}

void queue_demo() {
    queue<int> q;

    q.push(1);
    q.push(2);
    q.push(3);

    while (!q.empty()) {
        cout << q.front() << " ";  // 访问队首
        q.pop();                   // 弹出
    }
}

void priority_queue_demo() {
    // 优先队列（默认大顶堆）
    priority_queue<int> pq;

    pq.push(3);
    pq.push(1);
    pq.push(4);
    pq.push(2);

    while (!pq.empty()) {
        cout << pq.top() << " ";  // 4 3 2 1
        pq.pop();
    }

    // 小顶堆
    priority_queue<int, vector<int>, greater<int>> min_pq;
    min_pq.push(3);
    min_pq.push(1);
    min_pq.push(4);
    // top() 返回 1
}
```

### 3.2 算法库

#### 3.2.1 常用算法
```cpp
void algorithm_demo() {
    vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6};

    // 查找
    auto it = find(vec.begin(), vec.end(), 5);
    if (it != vec.end()) {
        cout << "Found: " << *it << endl;
    }

    // 计数
    int count = count_if(vec.begin(), vec.end(),
                         [](int x) { return x > 3; });

    // 排序
    sort(vec.begin(), vec.end());               // 升序
    sort(vec.begin(), vec.end(), greater<>());  // 降序

    // 去重（需先排序）
    auto last = unique(vec.begin(), vec.end());
    vec.erase(last, vec.end());

    // 反转
    reverse(vec.begin(), vec.end());

    // 累加
    int sum = accumulate(vec.begin(), vec.end(), 0);

    // 转换
    vector<int> squared;
    transform(vec.begin(), vec.end(), back_inserter(squared),
              [](int x) { return x * x; });

    // 拷贝
    vector<int> vec_copy;
    copy(vec.begin(), vec.end(), back_inserter(vec_copy));

    // 填充
    fill(vec.begin(), vec.end(), 0);
}

// 二分查找（需要有序容器）
void binary_search_demo() {
    vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 判断是否存在
    if (binary_search(vec.begin(), vec.end(), 5)) {
        cout << "5 exists" << endl;
    }

    // 找到第一个不小于5的位置
    auto it = lower_bound(vec.begin(), vec.end(), 5);

    // 找到第一个大于5的位置
    auto it2 = upper_bound(vec.begin(), vec.end(), 5);
}
```

---

## 第四模块：模板编程

### 4.1 函数模板

```cpp
// 基础函数模板
template<typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// 多个类型参数
template<typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a + b) {  // C++11尾置返回类型
    return a + b;
}

// C++14: 自动推导返回类型
template<typename T1, typename T2>
auto multiply(T1 a, T2 b) {
    return a * b;
}

// 模板特化
template<typename T>
T max_value(T a, T b) {
    return (a > b) ? a : b;
}

// 针对const char*的特化
template<>
const char* max_value<const char*>(const char* a, const char* b) {
    return (strcmp(a, b) > 0) ? a : b;
}

// 使用示例
void template_demo() {
    cout << max_value(10, 20) << endl;           // int版本
    cout << max_value(3.14, 2.71) << endl;       // double版本
    cout << max_value("hello", "world") << endl; // 特化版本
}
```

### 4.2 类模板

```cpp
// 基础类模板
template<typename T>
class Stack {
private:
    vector<T> elements;

public:
    void push(const T& elem) {
        elements.push_back(elem);
    }

    void pop() {
        if (elements.empty()) {
            throw runtime_error("Stack is empty");
        }
        elements.pop_back();
    }

    T top() const {
        if (elements.empty()) {
            throw runtime_error("Stack is empty");
        }
        return elements.back();
    }

    bool empty() const {
        return elements.empty();
    }
};

// 使用示例
void class_template_demo() {
    Stack<int> int_stack;
    int_stack.push(1);
    int_stack.push(2);
    cout << int_stack.top() << endl;

    Stack<string> str_stack;
    str_stack.push("hello");
    str_stack.push("world");
    cout << str_stack.top() << endl;
}

// 类模板特化
template<typename T>
class Container {
    T data;
public:
    void print() { cout << data << endl; }
};

// 针对bool的特化
template<>
class Container<bool> {
    bool data;
public:
    void print() {
        cout << (data ? "true" : "false") << endl;
    }
};
```

### 4.3 变参模板（C++11）

```cpp
// 递归展开变参模板
template<typename T>
void print(const T& t) {
    cout << t << endl;  // 递归终止
}

template<typename T, typename... Args>
void print(const T& t, const Args&... args) {
    cout << t << " ";
    print(args...);     // 递归调用
}

// 使用示例
void variadic_template_demo() {
    print(1, 2, 3, 4, 5);
    print("hello", 3.14, 'A', true);
}

// C++17: 折叠表达式
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);  // 一元右折叠
}

// 使用示例
void fold_expression_demo() {
    cout << sum(1, 2, 3, 4, 5) << endl;  // 15
}
```

---

## 第五模块：内存管理

### 5.1 RAII与智能指针

#### 5.1.1 智能指针
```cpp
void unique_ptr_demo() {
    // unique_ptr: 独占所有权
    unique_ptr<int> ptr1 = make_unique<int>(42);
    cout << *ptr1 << endl;

    // unique_ptr<int> ptr2 = ptr1;  // ❌ 错误：不能拷贝
    unique_ptr<int> ptr2 = std::move(ptr1);  // ✅ 转移所有权

    // ptr1现在为空
    if (!ptr1) {
        cout << "ptr1 is null" << endl;
    }

    // 数组版本
    unique_ptr<int[]> arr = make_unique<int[]>(10);
    arr[0] = 1;
}

void shared_ptr_demo() {
    // shared_ptr: 共享所有权（引用计数）
    shared_ptr<int> ptr1 = make_shared<int>(42);
    cout << "Use count: " << ptr1.use_count() << endl;  // 1

    {
        shared_ptr<int> ptr2 = ptr1;  // 引用计数+1
        cout << "Use count: " << ptr1.use_count() << endl;  // 2
    }  // ptr2析构，引用计数-1

    cout << "Use count: " << ptr1.use_count() << endl;  // 1
}

void weak_ptr_demo() {
    // weak_ptr: 弱引用，不增加引用计数
    shared_ptr<int> shared = make_shared<int>(42);
    weak_ptr<int> weak = shared;

    cout << "Shared count: " << shared.use_count() << endl;  // 1

    // 使用weak_ptr访问对象
    if (auto locked = weak.lock()) {
        cout << *locked << endl;
    } else {
        cout << "Object has been destroyed" << endl;
    }
}

// 实战：解决循环引用
class Node {
public:
    shared_ptr<Node> next;
    weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
    int data;

    Node(int d) : data(d) {}
    ~Node() { cout << "Node " << data << " destroyed" << endl; }
};

void circular_reference_demo() {
    auto node1 = make_shared<Node>(1);
    auto node2 = make_shared<Node>(2);

    node1->next = node2;
    node2->prev = node1;  // weak_ptr不会增加引用计数

    // 正常析构，不会内存泄漏
}
```

#### 5.1.2 RAII模式
```cpp
// 资源获取即初始化
class FileHandler {
private:
    FILE* file;

public:
    FileHandler(const char* filename, const char* mode) {
        file = fopen(filename, mode);
        if (!file) {
            throw runtime_error("Failed to open file");
        }
    }

    ~FileHandler() {
        if (file) {
            fclose(file);
            cout << "File closed" << endl;
        }
    }

    // 禁止拷贝
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;

    FILE* get() { return file; }
};

// 使用示例
void raii_demo() {
    try {
        FileHandler fh("test.txt", "w");
        fprintf(fh.get(), "Hello, RAII!\n");
        // 异常安全：即使抛出异常，析构函数也会被调用
    } catch (const exception& e) {
        cerr << e.what() << endl;
    }
    // 文件自动关闭
}
```

### 5.2 内存管理最佳实践

```cpp
// ❌ 常见错误
void bad_practices() {
    // 1. 内存泄漏
    int* ptr = new int(10);
    // 忘记delete

    // 2. 野指针
    int* p = new int(10);
    delete p;
    *p = 20;  // 使用已释放的内存

    // 3. 重复释放
    int* q = new int(10);
    delete q;
    delete q;  // 重复释放
}

// ✅ 最佳实践
void good_practices() {
    // 1. 使用智能指针
    auto ptr = make_unique<int>(10);
    // 自动释放

    // 2. 使用容器代替原始数组
    vector<int> vec(10);
    // 自动管理内存

    // 3. 使用RAII管理资源
    {
        lock_guard<mutex> lock(mtx);  // RAII锁
        // 临界区代码
    }  // 自动解锁
}
```

---

## 第六模块：并发编程

### 6.1 多线程基础

```cpp
#include <thread>
#include <mutex>
#include <condition_variable>

// 基础线程创建
void thread_function(int id) {
    cout << "Thread " << id << " running" << endl;
    this_thread::sleep_for(chrono::seconds(1));
}

void basic_thread_demo() {
    thread t1(thread_function, 1);
    thread t2(thread_function, 2);

    t1.join();  // 等待t1完成
    t2.join();  // 等待t2完成

    // 使用Lambda
    thread t3([](){ cout << "Lambda thread" << endl; });
    t3.join();
}

// 互斥锁
mutex mtx;
int shared_counter = 0;

void increment_counter() {
    for (int i = 0; i < 1000; ++i) {
        lock_guard<mutex> lock(mtx);  // RAII锁
        ++shared_counter;
    }
}

void mutex_demo() {
    thread t1(increment_counter);
    thread t2(increment_counter);

    t1.join();
    t2.join();

    cout << "Counter: " << shared_counter << endl;  // 2000
}

// 条件变量：生产者-消费者
queue<int> data_queue;
mutex queue_mutex;
condition_variable cv;

void producer() {
    for (int i = 0; i < 10; ++i) {
        this_thread::sleep_for(chrono::milliseconds(100));

        lock_guard<mutex> lock(queue_mutex);
        data_queue.push(i);
        cout << "Produced: " << i << endl;
        cv.notify_one();  // 通知消费者
    }
}

void consumer() {
    while (true) {
        unique_lock<mutex> lock(queue_mutex);
        cv.wait(lock, []{ return !data_queue.empty(); });

        int value = data_queue.front();
        data_queue.pop();
        lock.unlock();

        cout << "Consumed: " << value << endl;

        if (value == 9) break;
    }
}

void producer_consumer_demo() {
    thread prod(producer);
    thread cons(consumer);

    prod.join();
    cons.join();
}
```

### 6.2 异步编程

```cpp
#include <future>

// async: 异步执行函数
int async_task(int x) {
    this_thread::sleep_for(chrono::seconds(2));
    return x * x;
}

void async_demo() {
    // 启动异步任务
    future<int> result = async(launch::async, async_task, 10);

    cout << "Doing other work..." << endl;

    // 获取结果（阻塞）
    cout << "Result: " << result.get() << endl;
}

// promise: 手动设置异步结果
void promise_demo() {
    promise<int> prom;
    future<int> fut = prom.get_future();

    thread t([](promise<int> p) {
        this_thread::sleep_for(chrono::seconds(1));
        p.set_value(42);  // 设置结果
    }, std::move(prom));

    cout << "Waiting for result..." << endl;
    cout << "Result: " << fut.get() << endl;

    t.join();
}
```

### 6.3 原子操作

```cpp
#include <atomic>

atomic<int> atomic_counter(0);

void atomic_increment() {
    for (int i = 0; i < 1000; ++i) {
        ++atomic_counter;  // 原子操作，无需锁
    }
}

void atomic_demo() {
    thread t1(atomic_increment);
    thread t2(atomic_increment);

    t1.join();
    t2.join();

    cout << "Atomic counter: " << atomic_counter << endl;  // 2000
}
```

---

## 学习验证标准

### 基础验证（Week 1-4）
- [ ] 掌握auto、引用、Lambda表达式
- [ ] 能够设计和实现类（构造、析构、拷贝、移动）
- [ ] 理解虚函数和多态机制
- [ ] 熟练使用运算符重载

### STL验证（Week 5-6）
- [ ] 熟练使用vector、map、set等容器
- [ ] 能够使用STL算法解决实际问题
- [ ] 理解迭代器概念

### 模板验证（Week 7-8）
- [ ] 编写函数模板和类模板
- [ ] 理解模板特化
- [ ] 使用变参模板

### 内存验证（Week 9-10）
- [ ] 正确使用智能指针
- [ ] 理解RAII原则
- [ ] 避免内存泄漏和悬空指针

### 并发验证（Week 11-12）
- [ ] 创建和管理多线程
- [ ] 正确使用互斥锁和条件变量
- [ ] 理解原子操作

### 综合项目验证（Week 13-16）
- [ ] 完成包含以下特性的项目：
  - OOP设计（继承、多态）
  - STL容器和算法
  - 智能指针管理资源
  - 多线程并发处理

---

## 常见错误与解决

### 1. 内存错误
```cpp
// ❌ 返回局部变量引用
int& bad_function() {
    int x = 10;
    return x;  // 危险！
}

// ✅ 返回值或使用static
int good_function() {
    int x = 10;
    return x;
}

// ❌ 迭代器失效
vector<int> vec = {1, 2, 3};
for (auto it = vec.begin(); it != vec.end(); ++it) {
    vec.push_back(*it);  // ❌ 可能导致迭代器失效
}

// ✅ 正确做法
vector<int> vec = {1, 2, 3};
size_t size = vec.size();
for (size_t i = 0; i < size; ++i) {
    vec.push_back(vec[i]);
}
```

### 2. 多线程错误
```cpp
// ❌ 忘记加锁
int counter = 0;
void increment() {
    ++counter;  // 竞争条件
}

// ✅ 使用互斥锁或原子操作
mutex mtx;
void safe_increment() {
    lock_guard<mutex> lock(mtx);
    ++counter;
}
```

---

## 推荐学习资源

### 书籍
1. **《C++ Primer》** - Stanley Lippman（入门经典）
2. **《Effective Modern C++》** - Scott Meyers（现代C++最佳实践）
3. **《深度探索C++对象模型》** - Stanley Lippman

### 在线资源
- cppreference.com（权威参考）
- learncpp.com（系统教程）
- CppCon视频（前沿技术）

### 实践项目
1. **命令行工具**: 文件管理、日志分析
2. **多线程下载器**: 网络编程+并发
3. **简易数据库**: STL容器+文件I/O
4. **游戏引擎**: OOP+模板+性能优化

---

**学习建议**:
1. 每天编写代码，动手实践
2. 阅读优秀开源项目源码
3. 参与代码审查和讨论
4. 关注C++新标准发展
5. 重视代码质量和性能优化