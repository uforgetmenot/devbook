# Qt 5.15 核心技术深度学习笔记

## 学习目标定位
- **目标群体**: 有C++基础的开发者，希望深入理解Qt核心机制
- **学习周期**: 10-14周
- **前置要求**: 扎实的C++基础、面向对象编程、模板、智能指针
- **学习成果**: 深入理解Qt元对象系统、精通信号槽机制、掌握Qt高级特性

## 学习路径图

```
Qt基础架构(Week 1-2) → 元对象系统深度剖析(Week 3-4) → 信号槽机制原理(Week 5-6)
→ 事件系统与过滤器(Week 7) → 内存管理与对象树(Week 8) → 多线程编程(Week 9-10)
→ 网络与IO(Week 11) → 数据库与SQL(Week 12) → 高级特性与性能优化(Week 13-14)
```

---

## 第一模块：Qt核心架构与环境搭建

### 1.1 Qt框架架构深度解析

#### Qt的模块化设计

Qt采用模块化设计，核心模块包括：

**Qt Core模块** - 核心非GUI功能
```cpp
// Qt Core提供的核心类
QObject          // 对象模型基类
QString          // Unicode字符串
QVariant         // 类型安全的联合体
QList/QVector    // 容器类
QFile/QIODevice  // IO抽象
QThread          // 线程支持
```

**重要模块划分：**
```
QtCore     - 核心非GUI类（本笔记重点）
QtNetwork  - 网络编程
QtSql      - 数据库集成
QtXml      - XML处理
QtTest     - 单元测试框架
QtConcurrent - 高级多线程API
```

#### Qt的设计理念

**1. 信号槽机制 (Signal-Slot)**
```cpp
// 传统回调方式的问题
class Button {
    void (*callback)(void*);  // 类型不安全，难以维护
    void* data;
};

// Qt的解决方案：类型安全的信号槽
class Button : public QObject {
    Q_OBJECT
signals:
    void clicked();  // 编译期类型检查
};
```

**2. 元对象系统 (Meta-Object System)**
```cpp
// 提供运行时类型信息(RTTI)增强
QObject *obj = new QPushButton;
QString className = obj->metaObject()->className();  // "QPushButton"
```

### 1.2 开发环境搭建

#### Linux环境完整配置

```bash
# Ubuntu/Debian系统
sudo apt-get update

# 安装Qt 5.15开发包
sudo apt-get install qt5-default
sudo apt-get install qtbase5-dev qtbase5-dev-tools
sudo apt-get install qttools5-dev qttools5-dev-tools

# 网络模块
sudo apt-get install libqt5network5 qtbase5-private-dev

# SQL模块
sudo apt-get install libqt5sql5 libqt5sql5-mysql libqt5sql5-sqlite

# 安装Qt Creator
sudo apt-get install qtcreator

# 验证安装
qmake --version
# 输出: QMake version 3.1, Using Qt version 5.15.x
```

#### 项目构建系统详解

**方法1: qmake (.pro文件)**
```pro
# myproject.pro
QT       += core network sql
QT       -= gui  # 不使用GUI模块

TARGET = myapp
TEMPLATE = app
CONFIG += c++17

SOURCES += \
    main.cpp \
    myclass.cpp

HEADERS += \
    myclass.h

# 指定输出目录
DESTDIR = bin
OBJECTS_DIR = obj
MOC_DIR = moc
```

```bash
# 构建流程
qmake myproject.pro
make
./bin/myapp
```

**方法2: CMake (推荐用于大型项目)**
```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(MyQtApp)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_AUTOMOC ON)  # 自动MOC处理

find_package(Qt5 REQUIRED COMPONENTS Core Network Sql)

add_executable(myapp
    main.cpp
    myclass.cpp
)

target_link_libraries(myapp
    Qt5::Core
    Qt5::Network
    Qt5::Sql
)
```

```bash
# 构建流程
mkdir build && cd build
cmake ..
make
./myapp
```

### 1.3 第一个Qt非GUI程序

```cpp
// main.cpp
#include <QCoreApplication>
#include <QDebug>
#include <QTimer>

int main(int argc, char *argv[]) {
    QCoreApplication app(argc, argv);

    qDebug() << "Qt Version:" << QT_VERSION_STR;
    qDebug() << "Application starting...";

    // 2秒后退出程序
    QTimer::singleShot(2000, &app, &QCoreApplication::quit);

    return app.exec();  // 进入事件循环
}
```

**编译运行：**
```bash
# 方法1: 手动编译
g++ main.cpp -o myapp \
    -I/usr/include/x86_64-linux-gnu/qt5 \
    -I/usr/include/x86_64-linux-gnu/qt5/QtCore \
    -lQt5Core -fPIC

./myapp

# 方法2: qmake
qmake -project
echo "QT -= gui" >> *.pro
qmake
make
```

**输出：**
```
Qt Version: 5.15.2
Application starting...
```

---

## 第二模块：Qt元对象系统深度剖析

### 2.1 元对象系统核心概念

Qt的元对象系统是Qt最核心的特性之一，它提供了：
1. 信号槽机制
2. 运行时类型信息(RTTI)
3. 动态属性系统
4. 对象反射能力

#### MOC (Meta-Object Compiler) 工作原理

**MOC的作用：**
```cpp
// 源代码 myclass.h
class MyClass : public QObject {
    Q_OBJECT  // 这个宏触发MOC处理
public:
    MyClass();
signals:
    void mySignal(int value);
};
```

**MOC生成的代码 (moc_myclass.cpp)：**
```cpp
// MOC自动生成，包含元对象信息
static const uint qt_meta_data_MyClass[] = {
    // 版本、类名、信号、槽等元信息
    7,       // revision
    0,       // classname
    0, 0,    // classinfo
    1, 14,   // methods (信号/槽数量)
    // ... 更多元数据
};

const QMetaObject MyClass::staticMetaObject = {
    { &QObject::staticMetaObject, qt_meta_stringdata_MyClass.data,
      qt_meta_data_MyClass, qt_static_metacall, nullptr, nullptr }
};
```

#### Q_OBJECT宏深度解析

```cpp
// Q_OBJECT宏展开后的代码（简化版）
#define Q_OBJECT \
public: \
    Q_OBJECT_CHECK \
    static const QMetaObject staticMetaObject; \
    virtual const QMetaObject *metaObject() const; \
    virtual void *qt_metacast(const char *); \
    virtual int qt_metacall(QMetaObject::Call, int, void **); \
    QT_TR_FUNCTIONS \
private: \
    Q_DECL_HIDDEN static void qt_static_metacall(QObject *, \
        QMetaObject::Call, int, void **);
```

**关键点：**
1. `staticMetaObject`: 存储类的元信息（静态成员）
2. `metaObject()`: 返回运行时元对象信息
3. `qt_metacall()`: 信号槽调用的核心函数

### 2.2 QObject深度剖析

#### QObject的核心功能

```cpp
class QObject {
public:
    // 1. 对象树（父子关系）
    QObject(QObject *parent = nullptr);
    QObject *parent() const;
    QList<QObject*> children() const;
    void setParent(QObject *parent);

    // 2. 对象名称
    QString objectName() const;
    void setObjectName(const QString &name);

    // 3. 动态属性
    void setProperty(const char *name, const QVariant &value);
    QVariant property(const char *name) const;

    // 4. 信号槽连接
    static QMetaObject::Connection connect(
        const QObject *sender, const char *signal,
        const QObject *receiver, const char *method,
        Qt::ConnectionType type = Qt::AutoConnection);

    // 5. 事件处理
    virtual bool event(QEvent *event);

    // 6. 线程亲和性
    QThread *thread() const;
    void moveToThread(QThread *thread);
};
```

#### QObject的内存布局

```cpp
// QObject内部数据结构（简化）
class QObjectPrivate {
public:
    QObject *parent;                    // 父对象指针
    QList<QObject*> children;           // 子对象列表
    QObjectConnectionListVector *connectionLists;  // 信号槽连接
    QList<QByteArray> propertyNames;    // 动态属性名
    QList<QVariant> propertyValues;     // 动态属性值
    QString objectName;                 // 对象名称
    QThread *threadData;                // 所属线程
};

class QObject {
private:
    QObjectPrivate *d_ptr;  // d指针模式
};
```

**重点：d指针（d-pointer）模式**
```cpp
// 为什么使用d指针？
// 1. 二进制兼容性：可以修改私有成员而不破坏ABI
// 2. 减少编译依赖：头文件不暴露实现细节
// 3. 更好的封装性

// 使用示例
class MyClass : public QObject {
    Q_OBJECT
    Q_DECLARE_PRIVATE(MyClass)  // 声明私有实现类
private:
    MyClassPrivate * const d_ptr;
};

class MyClassPrivate {
public:
    int value;
    QString data;
    // 所有私有成员放这里
};
```

### 2.3 运行时类型信息与反射

#### 类型信息查询

```cpp
#include <QCoreApplication>
#include <QDebug>
#include <QMetaObject>
#include <QMetaMethod>
#include <QMetaProperty>

class Person : public QObject {
    Q_OBJECT
    Q_PROPERTY(QString name READ name WRITE setName)
    Q_PROPERTY(int age READ age WRITE setAge)

private:
    QString m_name;
    int m_age;

public:
    Person(QObject *parent = nullptr) : QObject(parent), m_age(0) {}

    QString name() const { return m_name; }
    void setName(const QString &name) { m_name = name; }

    int age() const { return m_age; }
    void setAge(int age) { m_age = age; }

public slots:
    void sayHello() {
        qDebug() << "Hello, I'm" << m_name << "age" << m_age;
    }

signals:
    void nameChanged(const QString &newName);
};

void introspectionDemo() {
    Person person;
    person.setObjectName("personObject");

    // 获取元对象
    const QMetaObject *metaObj = person.metaObject();

    // 1. 类名
    qDebug() << "Class name:" << metaObj->className();

    // 2. 父类信息
    const QMetaObject *superClass = metaObj->superClass();
    qDebug() << "Super class:" << superClass->className();

    // 3. 枚举所有方法
    qDebug() << "\nMethods:";
    for (int i = metaObj->methodOffset(); i < metaObj->methodCount(); ++i) {
        QMetaMethod method = metaObj->method(i);
        qDebug() << "  " << method.methodSignature()
                 << "Type:" << method.methodType();
    }

    // 4. 枚举所有属性
    qDebug() << "\nProperties:";
    for (int i = metaObj->propertyOffset(); i < metaObj->propertyCount(); ++i) {
        QMetaProperty prop = metaObj->property(i);
        qDebug() << "  " << prop.name() << "Type:" << prop.typeName();
    }

    // 5. 动态调用方法
    QMetaObject::invokeMethod(&person, "sayHello");

    // 6. 动态设置属性
    person.setProperty("name", "张三");
    person.setProperty("age", 25);
    QMetaObject::invokeMethod(&person, "sayHello");

    // 7. 动态读取属性
    qDebug() << "\nReading properties:";
    QVariant nameValue = person.property("name");
    QVariant ageValue = person.property("age");
    qDebug() << "Name:" << nameValue.toString();
    qDebug() << "Age:" << ageValue.toInt();
}
```

**输出结果：**
```
Class name: Person
Super class: QObject

Methods:
   sayHello() Type: Slot
   nameChanged(QString) Type: Signal

Properties:
   name Type: QString
   age Type: int

Hello, I'm "" age 0
Hello, I'm "张三" age 25

Reading properties:
Name: "张三"
Age: 25
```

#### Q_PROPERTY宏详解

```cpp
// Q_PROPERTY完整语法
class MyClass : public QObject {
    Q_OBJECT

    // READ/WRITE - 必须指定至少一个
    Q_PROPERTY(QString name READ name WRITE setName)

    // NOTIFY - 属性变化时发射的信号
    Q_PROPERTY(int value READ value WRITE setValue NOTIFY valueChanged)

    // RESET - 重置到默认值
    Q_PROPERTY(QColor color READ color WRITE setColor RESET resetColor)

    // MEMBER - 直接绑定成员变量（Qt 5.0+）
    Q_PROPERTY(bool enabled MEMBER m_enabled)

    // CONSTANT - 常量属性，无需WRITE
    Q_PROPERTY(int id READ id CONSTANT)

    // FINAL - 不可在子类中重写
    Q_PROPERTY(QString type READ type FINAL)

private:
    QString m_name;
    int m_value;
    QColor m_color;
    bool m_enabled;
    const int m_id = 123;

public:
    QString name() const { return m_name; }
    void setName(const QString &n) { m_name = n; }

    int value() const { return m_value; }
    void setValue(int v) {
        if (m_value != v) {
            m_value = v;
            emit valueChanged(v);
        }
    }

    QColor color() const { return m_color; }
    void setColor(const QColor &c) { m_color = c; }
    void resetColor() { m_color = Qt::white; }

    int id() const { return m_id; }
    QString type() const { return "MyClass"; }

signals:
    void valueChanged(int newValue);
};
```

### 2.4 动态属性系统

```cpp
#include <QObject>
#include <QDebug>

void dynamicPropertyDemo() {
    QObject obj;

    // 设置各种类型的动态属性
    obj.setProperty("intValue", 42);
    obj.setProperty("stringValue", "Hello");
    obj.setProperty("doubleValue", 3.14);
    obj.setProperty("boolValue", true);

    // 读取动态属性
    int intVal = obj.property("intValue").toInt();
    QString strVal = obj.property("stringValue").toString();
    double dblVal = obj.property("doubleValue").toDouble();
    bool boolVal = obj.property("boolValue").toBool();

    qDebug() << "Int:" << intVal;
    qDebug() << "String:" << strVal;
    qDebug() << "Double:" << dblVal;
    qDebug() << "Bool:" << boolVal;

    // 检查属性是否存在
    if (obj.property("nonExistent").isValid()) {
        qDebug() << "Property exists";
    } else {
        qDebug() << "Property does not exist";
    }

    // 删除动态属性（设置为invalid QVariant）
    obj.setProperty("intValue", QVariant());

    // 列出所有动态属性
    QList<QByteArray> propNames = obj.dynamicPropertyNames();
    qDebug() << "Dynamic properties:" << propNames;
}
```

**动态属性的高级应用：**
```cpp
// 场景1：对象标记
void tagObjectsDemo() {
    QList<QObject*> objects;
    for (int i = 0; i < 10; ++i) {
        QObject *obj = new QObject();
        obj->setProperty("priority", i % 3);  // 优先级：0,1,2
        obj->setProperty("category", i < 5 ? "TypeA" : "TypeB");
        objects.append(obj);
    }

    // 筛选高优先级对象
    for (QObject *obj : objects) {
        if (obj->property("priority").toInt() == 2) {
            qDebug() << "High priority object:" << obj;
        }
    }

    qDeleteAll(objects);
}

// 场景2：配置数据存储
class Configuration : public QObject {
public:
    void loadConfig(const QString &key, const QVariant &value) {
        setProperty(key.toUtf8(), value);
    }

    QVariant getConfig(const QString &key) const {
        return property(key.toUtf8());
    }
};
```

---

## 第三模块：信号槽机制原理深度剖析

### 3.1 信号槽的本质

#### 传统观察者模式 vs Qt信号槽

```cpp
// 传统观察者模式的问题
class Subject {
    vector<Observer*> observers;  // 1. 类型耦合
public:
    void attach(Observer* obs) { observers.push_back(obs); }
    void notify() {
        for (auto obs : observers) {
            obs->update();  // 2. 方法名硬编码
        }
    }
};

// Qt信号槽的优势
class Sender : public QObject {
    Q_OBJECT
signals:
    void dataChanged(int value);  // 1. 类型安全
                                  // 2. 编译期检查
                                  // 3. 自动断开连接
                                  // 4. 支持跨线程
};
```

### 3.2 信号槽连接方式详解

#### 五种连接语法

```cpp
#include <QObject>
#include <QDebug>

class Sender : public QObject {
    Q_OBJECT
signals:
    void valueChanged(int value);
    void complexSignal(const QString &str, int num);
};

class Receiver : public QObject {
    Q_OBJECT
public slots:
    void onValueChanged(int value) {
        qDebug() << "Received value:" << value;
    }
    void handleComplex(const QString &s, int n) {
        qDebug() << "String:" << s << "Number:" << n;
    }
};

void connectionSyntaxDemo() {
    Sender sender;
    Receiver receiver;

    // 方式1: SIGNAL/SLOT宏 (Qt 4 风格，运行时检查)
    QObject::connect(&sender, SIGNAL(valueChanged(int)),
                     &receiver, SLOT(onValueChanged(int)));

    // 方式2: 函数指针 (Qt 5 推荐，编译期检查)
    QObject::connect(&sender, &Sender::valueChanged,
                     &receiver, &Receiver::onValueChanged);

    // 方式3: Lambda表达式 (Qt 5.0+)
    QObject::connect(&sender, &Sender::valueChanged,
                     [](int value) {
                         qDebug() << "Lambda received:" << value;
                     });

    // 方式4: Lambda捕获上下文
    int multiplier = 10;
    QObject::connect(&sender, &Sender::valueChanged,
                     [multiplier](int value) {
                         qDebug() << "Multiplied:" << value * multiplier;
                     });

    // 方式5: 成员函数指针（需要完整签名）
    QObject::connect(&sender, &Sender::complexSignal,
                     &receiver, &Receiver::handleComplex);

    // 测试发射信号
    emit sender.valueChanged(42);
    emit sender.complexSignal("Test", 100);
}
```

#### 连接类型详解

```cpp
enum ConnectionType {
    AutoConnection,      // 自动选择（默认）
    DirectConnection,    // 直接调用（同线程）
    QueuedConnection,    // 队列调用（跨线程）
    BlockingQueuedConnection,  // 阻塞队列调用
    UniqueConnection     // 唯一连接（避免重复）
};

void connectionTypeDemo() {
    Sender sender;
    Receiver receiver;

    // 1. DirectConnection - 同步调用，直接执行槽函数
    connect(&sender, &Sender::valueChanged,
            &receiver, &Receiver::onValueChanged,
            Qt::DirectConnection);
    // emit后立即执行槽函数，阻塞发送者

    // 2. QueuedConnection - 异步调用，通过事件队列
    connect(&sender, &Sender::valueChanged,
            &receiver, &Receiver::onValueChanged,
            Qt::QueuedConnection);
    // emit后将事件放入队列，不阻塞发送者

    // 3. BlockingQueuedConnection - 阻塞队列调用
    connect(&sender, &Sender::valueChanged,
            &receiver, &Receiver::onValueChanged,
            Qt::BlockingQueuedConnection);
    // emit后阻塞等待槽函数执行完成（禁止同线程使用）

    // 4. UniqueConnection - 避免重复连接
    connect(&sender, &Sender::valueChanged,
            &receiver, &Receiver::onValueChanged,
            Qt::UniqueConnection);
    connect(&sender, &Sender::valueChanged,
            &receiver, &Receiver::onValueChanged,
            Qt::UniqueConnection);
    // 只会建立一次连接
}
```

### 3.3 信号槽底层实现机制

#### 连接的内部数据结构

```cpp
// Qt内部的连接数据结构（简化版）
struct Connection {
    QObject *sender;        // 发送者对象
    QObject *receiver;      // 接收者对象
    int signal_index;       // 信号在元对象中的索引
    int slot_index;         // 槽在元对象中的索引
    Qt::ConnectionType type;// 连接类型
};

class QObjectPrivate {
    // 每个QObject内部维护的连接列表
    QVector<Connection*> senderConnections;    // 作为发送者的连接
    QVector<Connection*> receiverConnections;  // 作为接收者的连接
};
```

#### 信号发射的完整流程

```cpp
// 假设有这样的信号定义
class MyClass : public QObject {
    Q_OBJECT
signals:
    void mySignal(int value);
};

// MOC生成的信号实现（简化版）
void MyClass::mySignal(int value) {
    // 1. 获取信号索引
    static const int signal_index = staticMetaObject.indexOfSignal("mySignal(int)");

    // 2. 准备参数数组
    void *args[] = { nullptr, &value };

    // 3. 调用元对象系统的activate函数
    QMetaObject::activate(this, &staticMetaObject, signal_index, args);
}

// QMetaObject::activate的核心逻辑（简化）
void QMetaObject::activate(QObject *sender, const QMetaObject *m,
                           int signal_index, void **argv) {
    // 1. 获取该信号的所有连接
    QObjectPrivate *senderPrivate = sender->d_func();
    ConnectionList &connections = senderPrivate->connectionLists[signal_index];

    // 2. 遍历所有连接
    for (Connection *c : connections) {
        // 3. 根据连接类型调用槽函数
        if (c->connectionType == Qt::DirectConnection) {
            // 直接调用槽函数
            c->receiver->qt_metacall(QMetaObject::InvokeMetaMethod,
                                     c->slot_index, argv);
        }
        else if (c->connectionType == Qt::QueuedConnection) {
            // 创建事件并投递到事件队列
            QMetaCallEvent *event = new QMetaCallEvent(c->slot_index, argv);
            QCoreApplication::postEvent(c->receiver, event);
        }
        // ... 其他连接类型处理
    }
}
```

#### 自己实现一个简化版信号槽

```cpp
#include <functional>
#include <vector>
#include <algorithm>

// 简化版信号类
template<typename... Args>
class Signal {
private:
    using SlotType = std::function<void(Args...)>;
    std::vector<SlotType> slots;

public:
    // 连接槽函数
    void connect(SlotType slot) {
        slots.push_back(slot);
    }

    // 发射信号
    void emit(Args... args) {
        for (auto &slot : slots) {
            slot(args...);
        }
    }

    // 断开所有连接
    void disconnectAll() {
        slots.clear();
    }
};

// 使用示例
#include <iostream>

class Button {
public:
    Signal<int, int> clicked;  // 信号：鼠标点击(x, y)

    void simulateClick(int x, int y) {
        clicked.emit(x, y);
    }
};

void simpleSignalSlotDemo() {
    Button button;

    // 连接Lambda槽
    button.clicked.connect([](int x, int y) {
        std::cout << "Clicked at (" << x << ", " << y << ")" << std::endl;
    });

    // 连接普通函数
    button.clicked.connect([](int x, int y) {
        std::cout << "Another handler: distance = "
                  << std::sqrt(x*x + y*y) << std::endl;
    });

    // 模拟点击
    button.simulateClick(10, 20);
}
```

### 3.4 信号槽高级技巧

#### 信号转发与链式连接

```cpp
class DataProcessor : public QObject {
    Q_OBJECT
signals:
    void rawDataReceived(const QByteArray &data);
    void processedDataReady(const QString &result);

public slots:
    void processData(const QByteArray &data) {
        // 处理数据
        QString result = QString::fromUtf8(data).toUpper();
        emit processedDataReady(result);
    }
};

class DataLogger : public QObject {
    Q_OBJECT
public slots:
    void logData(const QString &data) {
        qDebug() << "Logging:" << data;
    }
};

void signalChainingDemo() {
    DataProcessor processor;
    DataLogger logger;

    // 信号到槽的链式连接
    connect(&processor, &DataProcessor::rawDataReceived,
            &processor, &DataProcessor::processData);

    connect(&processor, &DataProcessor::processedDataReady,
            &logger, &DataLogger::logData);

    // 测试
    emit processor.rawDataReceived("hello world");
    // 输出: Logging: HELLO WORLD
}
```

#### 信号重载的处理

```cpp
class Notifier : public QObject {
    Q_OBJECT
signals:
    void notify();              // 重载1
    void notify(int value);     // 重载2
    void notify(const QString &msg);  // 重载3
};

class Handler : public QObject {
    Q_OBJECT
public slots:
    void onNotify() { qDebug() << "No args"; }
    void onNotify(int v) { qDebug() << "Int:" << v; }
    void onNotify(const QString &s) { qDebug() << "String:" << s; }
};

void overloadedSignalsDemo() {
    Notifier notifier;
    Handler handler;

    // Qt 5方式：使用qOverload指定重载版本
    connect(&notifier, qOverload<>(&Notifier::notify),
            &handler, qOverload<>(&Handler::onNotify));

    connect(&notifier, qOverload<int>(&Notifier::notify),
            &handler, qOverload<int>(&Handler::onNotify));

    connect(&notifier, qOverload<const QString&>(&Notifier::notify),
            &handler, qOverload<const QString&>(&Handler::onNotify));

    // 测试
    emit notifier.notify();
    emit notifier.notify(42);
    emit notifier.notify("Hello");
}
```

#### 连接管理与自动断开

```cpp
#include <QObject>
#include <QDebug>

class Sender : public QObject {
    Q_OBJECT
signals:
    void dataReady(int value);
};

class Receiver : public QObject {
    Q_OBJECT
public slots:
    void handleData(int value) {
        qDebug() << "Received:" << value;
    }
};

void connectionManagementDemo() {
    Sender sender;
    Receiver *receiver = new Receiver();

    // 1. 保存连接对象，用于后续断开
    QMetaObject::Connection conn = connect(&sender, &Sender::dataReady,
                                           receiver, &Receiver::handleData);

    emit sender.dataReady(1);  // 输出: Received: 1

    // 2. 手动断开连接
    QObject::disconnect(conn);
    emit sender.dataReady(2);  // 无输出

    // 3. 重新连接
    conn = connect(&sender, &Sender::dataReady,
                   receiver, &Receiver::handleData);

    emit sender.dataReady(3);  // 输出: Received: 3

    // 4. 删除接收者会自动断开所有相关连接
    delete receiver;
    emit sender.dataReady(4);  // 无输出（连接已自动断开）
}
```

#### 上下文对象与生命周期管理

```cpp
// Qt 5.2+ 引入的上下文对象参数
void contextObjectDemo() {
    Sender sender;
    Receiver *receiver = new Receiver();
    QObject *context = new QObject();

    // 使用上下文对象：当context被销毁时，连接自动断开
    connect(&sender, &Sender::dataReady,
            context,  // 上下文对象
            [receiver](int value) {
                receiver->handleData(value);
            });

    emit sender.dataReady(1);  // 正常工作

    delete context;  // 删除上下文对象
    emit sender.dataReady(2);  // Lambda不再被调用

    delete receiver;
}
```

---

## 第四模块：Qt对象模型与内存管理

### 4.1 Qt对象树机制

#### 父子关系的核心原理

```cpp
// Qt对象树的核心：父对象销毁时自动删除所有子对象
class QObject {
private:
    QObject *m_parent;
    QList<QObject*> m_children;

public:
    void setParent(QObject *parent) {
        if (m_parent) {
            m_parent->m_children.removeOne(this);
        }
        m_parent = parent;
        if (m_parent) {
            m_parent->m_children.append(this);
        }
    }

    ~QObject() {
        // 1. 删除所有子对象
        qDeleteAll(m_children);

        // 2. 从父对象中移除自己
        if (m_parent) {
            m_parent->m_children.removeOne(this);
        }
    }
};
```

#### 对象树实战示例

```cpp
#include <QObject>
#include <QDebug>

class Component : public QObject {
    Q_OBJECT
public:
    Component(const QString &name, QObject *parent = nullptr)
        : QObject(parent) {
        setObjectName(name);
        qDebug() << "Component created:" << name;
    }

    ~Component() {
        qDebug() << "Component destroyed:" << objectName();
    }
};

void objectTreeDemo() {
    qDebug() << "=== Creating object tree ===";

    // 根对象
    Component *root = new Component("Root");

    // 第一层子对象
    Component *child1 = new Component("Child1", root);
    Component *child2 = new Component("Child2", root);

    // 第二层子对象
    Component *grandChild1 = new Component("GrandChild1", child1);
    Component *grandChild2 = new Component("GrandChild2", child1);
    Component *grandChild3 = new Component("GrandChild3", child2);

    qDebug() << "\n=== Object tree structure ===";
    qDebug() << "Root children:" << root->children().size();
    qDebug() << "Child1 children:" << child1->children().size();
    qDebug() << "Child2 children:" << child2->children().size();

    qDebug() << "\n=== Deleting root (all children auto-deleted) ===";
    delete root;  // 自动删除所有子对象

    // 不需要手动delete child1, child2, grandChild1等
}
```

**输出：**
```
=== Creating object tree ===
Component created: Root
Component created: Child1
Component created: Child2
Component created: GrandChild1
Component created: GrandChild2
Component created: GrandChild3

=== Object tree structure ===
Root children: 2
Child1 children: 2
Child2 children: 1

=== Deleting root (all children auto-deleted) ===
Component destroyed: GrandChild1
Component destroyed: GrandChild2
Component destroyed: Child1
Component destroyed: GrandChild3
Component destroyed: Child2
Component destroyed: Root
```

### 4.2 Qt内存管理最佳实践

#### 规则1：QObject派生类优先使用对象树

```cpp
// ❌ 错误：容易内存泄漏
void badPractice() {
    QTimer *timer = new QTimer();  // 没有父对象，必须手动delete
    // ... 使用timer
    // 忘记delete timer; // 内存泄漏！
}

// ✅ 正确：使用父对象
void goodPractice(QObject *parent) {
    QTimer *timer = new QTimer(parent);  // 父对象销毁时自动删除
    // 无需手动delete
}

// ✅ 或者使用栈对象
void stackObjectPractice() {
    QTimer timer;  // 栈对象，自动销毁
    // ...
}  // timer自动销毁
```

#### 规则2：智能指针的正确使用

```cpp
#include <QObject>
#include <QSharedPointer>
#include <QWeakPointer>
#include <QScopedPointer>

// 场景1：QScopedPointer - 独占所有权
class MyClass {
private:
    QScopedPointer<QObject> m_resource;

public:
    MyClass() : m_resource(new QObject()) {
        // QScopedPointer自动管理生命周期
    }
    // 析构时自动delete m_resource
};

// 场景2：QSharedPointer - 共享所有权
void sharedOwnershipDemo() {
    QSharedPointer<QObject> shared1(new QObject());
    qDebug() << "Ref count:" << shared1.count();  // 1

    {
        QSharedPointer<QObject> shared2 = shared1;
        qDebug() << "Ref count:" << shared1.count();  // 2
    }

    qDebug() << "Ref count:" << shared1.count();  // 1
}  // 退出作用域时自动delete

// 场景3：QWeakPointer - 弱引用，避免循环引用
class Parent;
class Child;

class Parent : public QObject {
public:
    QSharedPointer<Child> child;
};

class Child : public QObject {
public:
    QWeakPointer<Parent> parent;  // 使用弱引用避免循环
};

void weakPointerDemo() {
    QSharedPointer<Parent> p(new Parent());
    QSharedPointer<Child> c(new Child());

    p->child = c;
    c->parent = p;  // 弱引用，不增加引用计数

    // p和c都能正常销毁，无内存泄漏
}
```

#### 规则3：小心deleteLater()的使用

```cpp
class Worker : public QObject {
    Q_OBJECT
public slots:
    void doWork() {
        qDebug() << "Working...";
        // 工作完成后延迟删除自己
        deleteLater();  // 在当前事件循环迭代结束后删除
    }
};

void deleteLaterDemo() {
    Worker *worker = new Worker();

    // 连接信号
    QTimer::singleShot(1000, worker, &Worker::doWork);

    // ❌ 错误：立即删除
    // delete worker;  // worker还在使用中！

    // ✅ 正确：让doWork()槽函数调用deleteLater()
}

// deleteLater()的原理
void QObject::deleteLater() {
    // 1. 向事件队列投递DeferredDelete事件
    QCoreApplication::postEvent(this, new QEvent(QEvent::DeferredDelete));

    // 2. 事件循环处理该事件时会delete对象
}
```

### 4.3 常见内存泄漏场景

#### 场景1：忘记设置父对象

```cpp
// ❌ 内存泄漏示例
void leakExample1() {
    for (int i = 0; i < 1000; ++i) {
        QObject *obj = new QObject();  // 没有父对象，没有delete
        // 每次循环泄漏一个QObject
    }
}

// ✅ 修复方法1：使用父对象
void fixExample1(QObject *parent) {
    for (int i = 0; i < 1000; ++i) {
        QObject *obj = new QObject(parent);  // 父对象管理
    }
}

// ✅ 修复方法2：使用容器管理
void fixExample2() {
    QList<QObject*> objects;
    for (int i = 0; i < 1000; ++i) {
        objects.append(new QObject());
    }
    qDeleteAll(objects);  // 统一删除
}
```

#### 场景2：信号槽连接导致的泄漏

```cpp
// ❌ 潜在泄漏：Lambda捕获this但对象提前销毁
class MyClass : public QObject {
    Q_OBJECT
private:
    QTimer *timer;

public:
    MyClass() {
        timer = new QTimer();

        // 危险：如果MyClass被delete，但timer还存活
        connect(timer, &QTimer::timeout, [this]() {
            // this可能已经被delete了！
            doSomething();  // 未定义行为
        });

        timer->start(1000);
    }
};

// ✅ 修复：使用上下文对象
class MyClassFixed : public QObject {
    Q_OBJECT
private:
    QTimer *timer;

public:
    MyClassFixed() {
        timer = new QTimer(this);  // 设置父对象

        // 使用this作为上下文对象
        connect(timer, &QTimer::timeout, this, [this]() {
            doSomething();  // 如果this被delete，连接自动断开
        });

        timer->start(1000);
    }

    void doSomething() {
        qDebug() << "Timer fired";
    }
};
```

#### 场景3：循环引用

```cpp
// ❌ 循环引用导致内存泄漏
class NodeA;
class NodeB;

class NodeA {
public:
    QSharedPointer<NodeB> ptrB;
};

class NodeB {
public:
    QSharedPointer<NodeA> ptrA;  // 循环引用！
};

void cyclicReferenceDemo() {
    QSharedPointer<NodeA> a(new NodeA());
    QSharedPointer<NodeB> b(new NodeB());

    a->ptrB = b;  // a持有b的强引用
    b->ptrA = a;  // b持有a的强引用

    // a和b都无法释放，内存泄漏！
}

// ✅ 使用弱引用打破循环
class NodeAFixed {
public:
    QSharedPointer<NodeB> ptrB;
};

class NodeBFixed {
public:
    QWeakPointer<NodeA> ptrA;  // 使用弱引用
};

void fixedCyclicReference() {
    QSharedPointer<NodeAFixed> a(new NodeAFixed());
    QSharedPointer<NodeBFixed> b(new NodeBFixed());

    a->ptrB = b;
    b->ptrA = a;  // 弱引用，不增加引用计数

    // 正常释放
}
```

---

## 第五模块：Qt事件系统深度剖析

### 5.1 事件机制核心概念

#### Qt事件系统架构

```
用户操作/系统事件 → 事件生成 → 事件队列 → 事件分发 → 事件处理
                                ↓
                          event() → 特定事件处理器
                                ↓
                          eventFilter() 拦截
```

#### QEvent类型体系

```cpp
// Qt定义了100+种事件类型
enum QEvent::Type {
    None = 0,
    Timer = 1,                  // 定时器事件
    MouseButtonPress = 2,       // 鼠标按下
    MouseButtonRelease = 3,     // 鼠标释放
    MouseMove = 5,              // 鼠标移动
    KeyPress = 6,               // 键盘按下
    KeyRelease = 7,             // 键盘释放
    Paint = 12,                 // 绘制事件
    Close = 19,                 // 窗口关闭
    Show = 17,                  // 窗口显示
    Hide = 18,                  // 窗口隐藏
    User = 1000,                // 用户自定义事件起始
    MaxUser = 65535             // 用户事件最大值
};

// 自定义事件
class MyCustomEvent : public QEvent {
public:
    static const QEvent::Type EventType;

    MyCustomEvent(const QString &data)
        : QEvent(EventType), m_data(data) {}

    QString data() const { return m_data; }

private:
    QString m_data;
};

// 分配自定义事件类型
const QEvent::Type MyCustomEvent::EventType =
    static_cast<QEvent::Type>(QEvent::User + 1);
```

### 5.2 事件处理机制

#### event()函数重写

```cpp
#include <QObject>
#include <QEvent>
#include <QTimerEvent>
#include <QDebug>

class EventHandler : public QObject {
    Q_OBJECT

public:
    EventHandler(QObject *parent = nullptr) : QObject(parent) {
        // 启动定时器
        startTimer(1000);  // 每秒触发一次
    }

protected:
    // 核心：重写event()函数
    bool event(QEvent *e) override {
        // 根据事件类型分发处理
        switch (e->type()) {
            case QEvent::Timer: {
                QTimerEvent *timerEvent = static_cast<QTimerEvent*>(e);
                qDebug() << "Timer event, ID:" << timerEvent->timerId();
                return true;  // 事件已处理
            }

            case MyCustomEvent::EventType: {
                MyCustomEvent *customEvent = static_cast<MyCustomEvent*>(e);
                qDebug() << "Custom event:" << customEvent->data();
                return true;
            }

            default:
                // 未处理的事件传递给基类
                return QObject::event(e);
        }
    }

    // 特定事件处理器
    void timerEvent(QTimerEvent *event) override {
        qDebug() << "Timer ID:" << event->timerId();
    }
};
```

#### 事件分发流程

```cpp
// Qt事件分发的完整流程（简化）
bool QObject::event(QEvent *e) {
    switch (e->type()) {
    case QEvent::Timer:
        timerEvent((QTimerEvent*)e);
        break;

    case QEvent::ChildAdded:
    case QEvent::ChildPolished:
    case QEvent::ChildRemoved:
        childEvent((QChildEvent*)e);
        break;

    case QEvent::DeferredDelete:
        delete this;  // deleteLater()的实现
        break;

    // ... 其他事件类型

    default:
        return false;  // 未处理
    }

    return true;  // 已处理
}
```

### 5.3 事件过滤器

#### 事件过滤器原理

```cpp
// 事件过滤器接口
class QObject {
public:
    // 安装事件过滤器
    void installEventFilter(QObject *filterObj);

    // 移除事件过滤器
    void removeEventFilter(QObject *filterObj);

protected:
    // 事件过滤器函数
    virtual bool eventFilter(QObject *watched, QEvent *event);
};

// 事件传递顺序
事件产生 → eventFilter(多个，按安装顺序) → event() → 特定处理器
```

#### 事件过滤器实战

```cpp
#include <QObject>
#include <QEvent>
#include <QKeyEvent>
#include <QDebug>

// 场景1：键盘事件过滤器
class KeyPressFilter : public QObject {
    Q_OBJECT

protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        if (event->type() == QEvent::KeyPress) {
            QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);

            // 拦截ESC键
            if (keyEvent->key() == Qt::Key_Escape) {
                qDebug() << "ESC key blocked by filter";
                return true;  // 阻止事件继续传递
            }

            // 记录所有按键
            qDebug() << "Key pressed:" << keyEvent->text();
        }

        // 传递给下一个处理器
        return QObject::eventFilter(watched, event);
    }
};

// 场景2：鼠标点击统计
class ClickCounter : public QObject {
    Q_OBJECT

private:
    int m_clickCount = 0;

protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        if (event->type() == QEvent::MouseButtonPress) {
            m_clickCount++;
            qDebug() << "Total clicks:" << m_clickCount
                     << "on object:" << watched->objectName();
        }

        return false;  // 不拦截，继续传递
    }

public:
    int clickCount() const { return m_clickCount; }
    void resetCount() { m_clickCount = 0; }
};

// 使用示例
void eventFilterDemo() {
    QObject targetObject;
    targetObject.setObjectName("target");

    // 安装过滤器
    KeyPressFilter *keyFilter = new KeyPressFilter();
    ClickCounter *clickCounter = new ClickCounter();

    targetObject.installEventFilter(keyFilter);
    targetObject.installEventFilter(clickCounter);

    // 模拟事件
    QKeyEvent *keyEvent = new QKeyEvent(QEvent::KeyPress, Qt::Key_A, Qt::NoModifier, "A");
    QCoreApplication::sendEvent(&targetObject, keyEvent);

    // 移除过滤器
    targetObject.removeEventFilter(keyFilter);

    delete keyEvent;
    delete keyFilter;
    delete clickCounter;
}
```

#### 全局事件过滤器

```cpp
class GlobalEventFilter : public QObject {
    Q_OBJECT

protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        // 记录所有事件
        static int eventCount = 0;
        eventCount++;

        if (eventCount % 100 == 0) {
            qDebug() << "Total events processed:" << eventCount;
        }

        return false;  // 不拦截任何事件
    }
};

// 安装到QCoreApplication
void installGlobalFilter() {
    GlobalEventFilter *globalFilter = new GlobalEventFilter();
    qApp->installEventFilter(globalFilter);
    // 现在globalFilter会收到应用程序的所有事件
}
```

### 5.4 自定义事件

#### 完整的自定义事件示例

```cpp
#include <QCoreApplication>
#include <QObject>
#include <QEvent>
#include <QDebug>

// 1. 定义自定义事件类
class DataEvent : public QEvent {
public:
    static const QEvent::Type EventType;

    DataEvent(const QByteArray &data)
        : QEvent(EventType)
        , m_data(data)
        , m_timestamp(QDateTime::currentDateTime()) {}

    QByteArray data() const { return m_data; }
    QDateTime timestamp() const { return m_timestamp; }

private:
    QByteArray m_data;
    QDateTime m_timestamp;
};

// 分配事件类型ID
const QEvent::Type DataEvent::EventType =
    static_cast<QEvent::Type>(QEvent::registerEventType());

// 2. 事件接收者
class DataReceiver : public QObject {
    Q_OBJECT

protected:
    bool event(QEvent *e) override {
        if (e->type() == DataEvent::EventType) {
            DataEvent *dataEvent = static_cast<DataEvent*>(e);

            qDebug() << "Received data:" << dataEvent->data();
            qDebug() << "Timestamp:" << dataEvent->timestamp();

            emit dataProcessed(dataEvent->data());
            return true;
        }

        return QObject::event(e);
    }

signals:
    void dataProcessed(const QByteArray &data);
};

// 3. 事件发送者
class DataSender : public QObject {
    Q_OBJECT

private:
    DataReceiver *m_receiver;

public:
    DataSender(DataReceiver *receiver) : m_receiver(receiver) {}

public slots:
    void sendData(const QByteArray &data) {
        // 创建并发送事件
        DataEvent *event = new DataEvent(data);
        QCoreApplication::postEvent(m_receiver, event);
        // 注意：postEvent后不要delete event，Qt会自动管理
    }

    void sendDataSync(const QByteArray &data) {
        // 同步发送事件
        DataEvent event(data);
        QCoreApplication::sendEvent(m_receiver, &event);
        // sendEvent是同步的，立即返回
    }
};

// 使用示例
void customEventDemo() {
    QCoreApplication app(argc, argv);

    DataReceiver receiver;
    DataSender sender(&receiver);

    // 异步发送
    sender.sendData("Async message");

    // 同步发送
    sender.sendDataSync("Sync message");

    return app.exec();
}
```

### 5.5 事件循环机制

#### 事件循环核心原理

```cpp
// QCoreApplication::exec()的简化实现
int QCoreApplication::exec() {
    while (!qApp->shouldQuit()) {
        // 1. 处理所有待处理的事件
        processEvents(QEventLoop::AllEvents);

        // 2. 如果没有事件，等待新事件到来
        if (noMoreEvents()) {
            waitForEvents();  // 阻塞等待
        }
    }

    return qApp->exitCode();
}

// processEvents的实现
void QCoreApplication::processEvents() {
    while (!eventQueue.isEmpty()) {
        QEvent *event = eventQueue.dequeue();
        QObject *receiver = event->receiver();

        // 分发事件
        receiver->event(event);

        // 自动删除某些事件
        if (event->type() == QEvent::DeferredDelete) {
            delete receiver;
        }

        delete event;
    }
}
```

#### 局部事件循环

```cpp
#include <QEventLoop>
#include <QTimer>
#include <QDebug>

// 场景1：等待异步操作完成
class AsyncOperation : public QObject {
    Q_OBJECT

public:
    bool waitForFinished(int timeout = 30000) {
        QEventLoop loop;
        QTimer timer;

        // 操作完成时退出循环
        connect(this, &AsyncOperation::finished, &loop, &QEventLoop::quit);

        // 超时退出
        connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);
        timer.start(timeout);

        // 进入局部事件循环
        loop.exec();

        return timer.isActive();  // 如果定时器还在运行，说明没超时
    }

signals:
    void finished();
};

// 场景2：嵌套事件循环
void nestedEventLoopDemo() {
    qDebug() << "Entering main event loop";

    QTimer::singleShot(1000, []() {
        qDebug() << "Creating nested event loop";

        QEventLoop nestedLoop;
        QTimer::singleShot(2000, &nestedLoop, &QEventLoop::quit);

        qDebug() << "Nested loop started";
        nestedLoop.exec();  // 嵌套循环
        qDebug() << "Nested loop finished";
    });

    qDebug() << "Main event loop continues";
}
```

---

## 第六模块：Qt多线程编程深度剖析

### 6.1 QThread核心机制

#### QThread的两种使用方式

```cpp
#include <QThread>
#include <QDebug>

// 方式1：继承QThread（不推荐）
class WorkerThread : public QThread {
    Q_OBJECT

protected:
    void run() override {
        qDebug() << "Thread ID:" << QThread::currentThreadId();

        for (int i = 0; i < 5; ++i) {
            qDebug() << "Working..." << i;
            QThread::msleep(500);
        }

        qDebug() << "Work finished";
    }
};

// 方式2：moveToThread（推荐）
class Worker : public QObject {
    Q_OBJECT

public slots:
    void doWork() {
        qDebug() << "Worker thread ID:" << QThread::currentThreadId();

        for (int i = 0; i < 5; ++i) {
            qDebug() << "Processing..." << i;
            QThread::msleep(500);
            emit progress(i * 20);
        }

        emit finished();
    }

signals:
    void progress(int percent);
    void finished();
};

// 使用示例
void threadingDemo() {
    qDebug() << "Main thread ID:" << QThread::currentThreadId();

    // 方式1
    WorkerThread *thread1 = new WorkerThread();
    thread1->start();

    // 方式2（推荐）
    QThread *thread2 = new QThread();
    Worker *worker = new Worker();
    worker->moveToThread(thread2);

    // 连接信号槽
    QObject::connect(thread2, &QThread::started, worker, &Worker::doWork);
    QObject::connect(worker, &Worker::finished, thread2, &QThread::quit);
    QObject::connect(worker, &Worker::finished, worker, &Worker::deleteLater);
    QObject::connect(thread2, &QThread::finished, thread2, &QThread::deleteLater);

    thread2->start();
}
```

#### 为什么推荐moveToThread方式？

```cpp
// 问题：继承QThread的陷阱
class BadThread : public QThread {
    Q_OBJECT

public slots:
    // ⚠️ 警告：这个槽函数在哪个线程执行？
    void processData() {
        // 答案：在主线程！因为QThread对象在主线程创建
        qDebug() << "Thread ID:" << QThread::currentThreadId();
    }

protected:
    void run() override {
        // 只有run()在新线程执行
        qDebug() << "run() thread ID:" << QThread::currentThreadId();
    }
};

// 正确方式：Worker对象在工作线程
class GoodWorker : public QObject {
    Q_OBJECT

public slots:
    void processData() {
        // ✅ 在工作线程执行，因为Worker对象move到了工作线程
        qDebug() << "Thread ID:" << QThread::currentThreadId();
    }
};

void comparisonDemo() {
    // 错误方式
    BadThread *badThread = new BadThread();
    badThread->start();

    QMetaObject::invokeMethod(badThread, "processData");
    // processData()在主线程执行！

    // 正确方式
    QThread *goodThread = new QThread();
    GoodWorker *worker = new GoodWorker();
    worker->moveToThread(goodThread);
    goodThread->start();

    QMetaObject::invokeMethod(worker, "processData");
    // processData()在工作线程执行！
}
```

### 6.2 线程间通信

#### 信号槽的线程安全性

```cpp
// Qt的信号槽自动处理线程安全
class DataProducer : public QObject {
    Q_OBJECT

signals:
    void dataReady(const QByteArray &data);

public:
    void produceData() {
        QByteArray data = "Some data";
        // 即使在不同线程，emit也是线程安全的
        emit dataReady(data);
    }
};

class DataConsumer : public QObject {
    Q_OBJECT

public slots:
    void consumeData(const QByteArray &data) {
        qDebug() << "Consumer thread:" << QThread::currentThreadId();
        qDebug() << "Received:" << data;
    }
};

void crossThreadSignalDemo() {
    QThread *producerThread = new QThread();
    QThread *consumerThread = new QThread();

    DataProducer *producer = new DataProducer();
    DataConsumer *consumer = new DataConsumer();

    producer->moveToThread(producerThread);
    consumer->moveToThread(consumerThread);

    // 跨线程连接（Qt自动使用QueuedConnection）
    QObject::connect(producer, &DataProducer::dataReady,
                     consumer, &DataConsumer::consumeData);

    producerThread->start();
    consumerThread->start();

    // 触发数据生产
    QMetaObject::invokeMethod(producer, "produceData");
}
```

#### 线程同步机制

```cpp
#include <QMutex>
#include <QMutexLocker>
#include <QWaitCondition>
#include <QSemaphore>
#include <QReadWriteLock>

// 1. QMutex - 互斥锁
class Counter {
private:
    int m_value = 0;
    QMutex m_mutex;

public:
    void increment() {
        QMutexLocker locker(&m_mutex);  // RAII锁
        m_value++;
    }  // locker析构时自动解锁

    int value() const {
        QMutexLocker locker(&m_mutex);
        return m_value;
    }
};

// 2. QWaitCondition - 条件变量
class ProducerConsumer {
private:
    QQueue<int> m_queue;
    QMutex m_mutex;
    QWaitCondition m_dataAvailable;
    const int MAX_SIZE = 10;

public:
    void produce(int value) {
        QMutexLocker locker(&m_mutex);

        while (m_queue.size() >= MAX_SIZE) {
            m_dataAvailable.wait(&m_mutex);  // 队列满，等待消费
        }

        m_queue.enqueue(value);
        qDebug() << "Produced:" << value;

        m_dataAvailable.wakeOne();  // 唤醒一个消费者
    }

    int consume() {
        QMutexLocker locker(&m_mutex);

        while (m_queue.isEmpty()) {
            m_dataAvailable.wait(&m_mutex);  // 队列空，等待生产
        }

        int value = m_queue.dequeue();
        qDebug() << "Consumed:" << value;

        m_dataAvailable.wakeOne();  // 唤醒一个生产者
        return value;
    }
};

// 3. QSemaphore - 信号量
class ResourcePool {
private:
    QSemaphore m_semaphore;

public:
    ResourcePool(int maxResources) : m_semaphore(maxResources) {}

    bool acquire(int count = 1, int timeout = -1) {
        return m_semaphore.tryAcquire(count, timeout);
    }

    void release(int count = 1) {
        m_semaphore.release(count);
    }
};

// 4. QReadWriteLock - 读写锁
class SharedData {
private:
    QString m_data;
    mutable QReadWriteLock m_lock;

public:
    QString read() const {
        QReadLocker locker(&m_lock);  // 读锁（多个读者可并发）
        return m_data;
    }

    void write(const QString &data) {
        QWriteLocker locker(&m_lock);  // 写锁（独占）
        m_data = data;
    }
};
```

### 6.3 Qt Concurrent高级API

#### QtConcurrent::run - 简单异步执行

```cpp
#include <QtConcurrent>
#include <QFuture>
#include <QFutureWatcher>

// 耗时计算函数
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}

void qtConcurrentRunDemo() {
    // 异步执行函数
    QFuture<int> future = QtConcurrent::run(fibonacci, 40);

    // 方法1：阻塞等待结果
    int result = future.result();  // 阻塞
    qDebug() << "Fibonacci(40) =" << result;

    // 方法2：使用Watcher监听完成
    QFuture<int> future2 = QtConcurrent::run(fibonacci, 35);
    QFutureWatcher<int> *watcher = new QFutureWatcher<int>();

    QObject::connect(watcher, &QFutureWatcher<int>::finished, [watcher]() {
        int result = watcher->result();
        qDebug() << "Async result:" << result;
        watcher->deleteLater();
    });

    watcher->setFuture(future2);
}
```

#### QtConcurrent::mapped - 并行映射

```cpp
#include <QtConcurrent>

// 映射函数
int square(int x) {
    return x * x;
}

void qtConcurrentMappedDemo() {
    QList<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 并行计算每个元素的平方
    QFuture<int> future = QtConcurrent::mapped(numbers, square);

    // 等待所有任务完成
    future.waitForFinished();

    // 获取结果
    QList<int> results = future.results();
    qDebug() << "Original:" << numbers;
    qDebug() << "Squared:" << results;
}

// 使用Lambda
void qtConcurrentMappedLambda() {
    QList<QString> strings = {"hello", "world", "qt", "concurrent"};

    // 并行转换为大写
    QFuture<QString> future = QtConcurrent::mapped(strings, [](const QString &s) {
        return s.toUpper();
    });

    qDebug() << "Uppercase:" << future.results();
}
```

#### QtConcurrent::filter - 并行过滤

```cpp
// 过滤函数
bool isEven(int x) {
    return x % 2 == 0;
}

void qtConcurrentFilterDemo() {
    QList<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 方法1：filter（修改原容器）
    QList<int> numbersCopy = numbers;
    QFuture<void> future = QtConcurrent::filter(numbersCopy, isEven);
    future.waitForFinished();
    qDebug() << "Even numbers:" << numbersCopy;  // {2, 4, 6, 8, 10}

    // 方法2：filtered（返回新容器）
    QFuture<int> future2 = QtConcurrent::filtered(numbers, isEven);
    QList<int> evenNumbers = future2.results();
    qDebug() << "Filtered:" << evenNumbers;
}
```

#### QtConcurrent::reduce - 并行规约

```cpp
// 规约函数
void reduceSum(int &result, int value) {
    result += value;
}

void qtConcurrentReduceDemo() {
    QList<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Map-Reduce：计算所有平方和
    QFuture<int> future = QtConcurrent::mappedReduced(
        numbers,
        square,      // map函数
        reduceSum    // reduce函数
    );

    int sumOfSquares = future.result();
    qDebug() << "Sum of squares:" << sumOfSquares;  // 385
}
```

### 6.4 线程池

```cpp
#include <QThreadPool>
#include <QRunnable>

// 自定义任务
class Task : public QRunnable {
private:
    int m_taskId;

public:
    Task(int id) : m_taskId(id) {
        setAutoDelete(true);  // 任务完成后自动删除
    }

    void run() override {
        qDebug() << "Task" << m_taskId << "running in thread"
                 << QThread::currentThreadId();

        // 模拟耗时操作
        QThread::msleep(1000);

        qDebug() << "Task" << m_taskId << "finished";
    }
};

void threadPoolDemo() {
    QThreadPool *pool = QThreadPool::globalInstance();

    qDebug() << "Max thread count:" << pool->maxThreadCount();
    qDebug() << "Active thread count:" << pool->activeThreadCount();

    // 提交10个任务到线程池
    for (int i = 0; i < 10; ++i) {
        pool->start(new Task(i));
    }

    // 等待所有任务完成
    pool->waitForDone();
    qDebug() << "All tasks finished";
}

// 自定义线程池
void customThreadPoolDemo() {
    QThreadPool customPool;
    customPool.setMaxThreadCount(4);  // 限制为4个线程

    for (int i = 0; i < 20; ++i) {
        customPool.start(new Task(i));
    }

    customPool.waitForDone();
}
```

### 6.5 线程安全的单例模式

```cpp
// Qt提供的线程安全单例
class Singleton {
private:
    Singleton() = default;
    ~Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    static Singleton& instance() {
        static Singleton instance;  // C++11保证线程安全
        return instance;
    }

    void doSomething() {
        qDebug() << "Singleton method called";
    }
};

// 使用Q_GLOBAL_STATIC宏
class MyManager {
public:
    void manage() {
        qDebug() << "Managing...";
    }
};

Q_GLOBAL_STATIC(MyManager, manager)

void singletonDemo() {
    // 方式1：传统单例
    Singleton::instance().doSomething();

    // 方式2：Q_GLOBAL_STATIC
    manager()->manage();
}
```

---

## 第七模块：Qt网络编程

### 7.1 TCP编程

#### TCP服务器

```cpp
#include <QTcpServer>
#include <QTcpSocket>
#include <QDebug>

class TcpServer : public QObject {
    Q_OBJECT

private:
    QTcpServer *m_server;
    QList<QTcpSocket*> m_clients;

public:
    TcpServer(QObject *parent = nullptr) : QObject(parent) {
        m_server = new QTcpServer(this);

        connect(m_server, &QTcpServer::newConnection,
                this, &TcpServer::onNewConnection);
    }

    bool start(quint16 port) {
        if (!m_server->listen(QHostAddress::Any, port)) {
            qDebug() << "Failed to start server:" << m_server->errorString();
            return false;
        }

        qDebug() << "Server started on port" << port;
        return true;
    }

private slots:
    void onNewConnection() {
        QTcpSocket *client = m_server->nextPendingConnection();
        m_clients.append(client);

        qDebug() << "New client connected:" << client->peerAddress().toString();

        connect(client, &QTcpSocket::readyRead,
                this, &TcpServer::onDataReceived);

        connect(client, &QTcpSocket::disconnected,
                this, &TcpServer::onClientDisconnected);
    }

    void onDataReceived() {
        QTcpSocket *client = qobject_cast<QTcpSocket*>(sender());
        if (!client) return;

        QByteArray data = client->readAll();
        qDebug() << "Received from" << client->peerAddress().toString()
                 << ":" << data;

        // 回显数据
        client->write("Echo: " + data);
    }

    void onClientDisconnected() {
        QTcpSocket *client = qobject_cast<QTcpSocket*>(sender());
        if (!client) return;

        qDebug() << "Client disconnected:" << client->peerAddress().toString();

        m_clients.removeOne(client);
        client->deleteLater();
    }
};
```

#### TCP客户端

```cpp
class TcpClient : public QObject {
    Q_OBJECT

private:
    QTcpSocket *m_socket;

public:
    TcpClient(QObject *parent = nullptr) : QObject(parent) {
        m_socket = new QTcpSocket(this);

        connect(m_socket, &QTcpSocket::connected,
                this, &TcpClient::onConnected);

        connect(m_socket, &QTcpSocket::disconnected,
                this, &TcpClient::onDisconnected);

        connect(m_socket, &QTcpSocket::readyRead,
                this, &TcpClient::onDataReceived);

        connect(m_socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error),
                this, &TcpClient::onError);
    }

    void connectToHost(const QString &host, quint16 port) {
        qDebug() << "Connecting to" << host << ":" << port;
        m_socket->connectToHost(host, port);
    }

    void sendData(const QByteArray &data) {
        if (m_socket->state() == QAbstractSocket::ConnectedState) {
            m_socket->write(data);
        } else {
            qDebug() << "Socket not connected";
        }
    }

private slots:
    void onConnected() {
        qDebug() << "Connected to server";
    }

    void onDisconnected() {
        qDebug() << "Disconnected from server";
    }

    void onDataReceived() {
        QByteArray data = m_socket->readAll();
        qDebug() << "Received:" << data;
    }

    void onError(QAbstractSocket::SocketError error) {
        qDebug() << "Socket error:" << m_socket->errorString();
    }
};
```

### 7.2 HTTP编程

```cpp
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QJsonDocument>
#include <QJsonObject>

class HttpClient : public QObject {
    Q_OBJECT

private:
    QNetworkAccessManager *m_manager;

public:
    HttpClient(QObject *parent = nullptr) : QObject(parent) {
        m_manager = new QNetworkAccessManager(this);
    }

    // GET请求
    void get(const QString &url) {
        QNetworkRequest request(url);
        request.setHeader(QNetworkRequest::UserAgentHeader, "QtApp/1.0");

        QNetworkReply *reply = m_manager->get(request);

        connect(reply, &QNetworkReply::finished, [this, reply]() {
            handleResponse(reply);
            reply->deleteLater();
        });
    }

    // POST请求
    void post(const QString &url, const QJsonObject &json) {
        QNetworkRequest request(url);
        request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");

        QJsonDocument doc(json);
        QByteArray data = doc.toJson();

        QNetworkReply *reply = m_manager->post(request, data);

        connect(reply, &QNetworkReply::finished, [this, reply]() {
            handleResponse(reply);
            reply->deleteLater();
        });
    }

    // 文件下载
    void downloadFile(const QString &url, const QString &savePath) {
        QNetworkRequest request(url);
        QNetworkReply *reply = m_manager->get(request);

        // 监听下载进度
        connect(reply, &QNetworkReply::downloadProgress,
                [](qint64 received, qint64 total) {
                    if (total > 0) {
                        int percent = (received * 100) / total;
                        qDebug() << "Download progress:" << percent << "%";
                    }
                });

        connect(reply, &QNetworkReply::finished, [reply, savePath]() {
            if (reply->error() == QNetworkReply::NoError) {
                QFile file(savePath);
                if (file.open(QIODevice::WriteOnly)) {
                    file.write(reply->readAll());
                    file.close();
                    qDebug() << "File downloaded to" << savePath;
                }
            }
            reply->deleteLater();
        });
    }

private:
    void handleResponse(QNetworkReply *reply) {
        if (reply->error() == QNetworkReply::NoError) {
            int statusCode = reply->attribute(
                QNetworkRequest::HttpStatusCodeAttribute).toInt();

            qDebug() << "Status code:" << statusCode;

            QByteArray data = reply->readAll();
            qDebug() << "Response:" << data;

            // 解析JSON响应
            QJsonDocument doc = QJsonDocument::fromJson(data);
            if (doc.isObject()) {
                QJsonObject obj = doc.object();
                // 处理JSON数据
            }
        } else {
            qDebug() << "Error:" << reply->errorString();
        }
    }
};
```

---

## 第八模块：Qt数据库编程

### 8.1 SQL数据库操作

```cpp
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QSqlRecord>
#include <QDebug>

class DatabaseManager {
private:
    QSqlDatabase m_db;

public:
    bool initialize(const QString &dbPath) {
        m_db = QSqlDatabase::addDatabase("QSQLITE");
        m_db.setDatabaseName(dbPath);

        if (!m_db.open()) {
            qDebug() << "Database error:" << m_db.lastError().text();
            return false;
        }

        qDebug() << "Database opened successfully";
        return true;
    }

    bool createTables() {
        QSqlQuery query(m_db);

        QString createTableSQL =
            "CREATE TABLE IF NOT EXISTS users ("
            "id INTEGER PRIMARY KEY AUTOINCREMENT, "
            "username TEXT NOT NULL UNIQUE, "
            "email TEXT NOT NULL, "
            "age INTEGER, "
            "created_at DATETIME DEFAULT CURRENT_TIMESTAMP"
            ")";

        if (!query.exec(createTableSQL)) {
            qDebug() << "Create table error:" << query.lastError().text();
            return false;
        }

        return true;
    }

    bool insertUser(const QString &username, const QString &email, int age) {
        QSqlQuery query(m_db);

        // 使用预处理语句防止SQL注入
        query.prepare("INSERT INTO users (username, email, age) VALUES (:username, :email, :age)");
        query.bindValue(":username", username);
        query.bindValue(":email", email);
        query.bindValue(":age", age);

        if (!query.exec()) {
            qDebug() << "Insert error:" << query.lastError().text();
            return false;
        }

        qDebug() << "User inserted, last ID:" << query.lastInsertId().toInt();
        return true;
    }

    QList<QVariantMap> queryUsers(const QString &condition = QString()) {
        QList<QVariantMap> results;

        QString sql = "SELECT * FROM users";
        if (!condition.isEmpty()) {
            sql += " WHERE " + condition;
        }

        QSqlQuery query(m_db);
        if (!query.exec(sql)) {
            qDebug() << "Query error:" << query.lastError().text();
            return results;
        }

        while (query.next()) {
            QVariantMap row;
            QSqlRecord record = query.record();

            for (int i = 0; i < record.count(); ++i) {
                row[record.fieldName(i)] = query.value(i);
            }

            results.append(row);
        }

        return results;
    }

    bool updateUser(int id, const QString &email) {
        QSqlQuery query(m_db);
        query.prepare("UPDATE users SET email = :email WHERE id = :id");
        query.bindValue(":email", email);
        query.bindValue(":id", id);

        if (!query.exec()) {
            qDebug() << "Update error:" << query.lastError().text();
            return false;
        }

        qDebug() << "Rows affected:" << query.numRowsAffected();
        return true;
    }

    bool deleteUser(int id) {
        QSqlQuery query(m_db);
        query.prepare("DELETE FROM users WHERE id = :id");
        query.bindValue(":id", id);

        if (!query.exec()) {
            qDebug() << "Delete error:" << query.lastError().text();
            return false;
        }

        return true;
    }

    bool transaction() {
        if (!m_db.transaction()) {
            qDebug() << "Begin transaction failed";
            return false;
        }

        QSqlQuery query(m_db);

        // 批量操作
        query.prepare("INSERT INTO users (username, email, age) VALUES (?, ?, ?)");

        QVariantList usernames = {"user1", "user2", "user3"};
        QVariantList emails = {"user1@test.com", "user2@test.com", "user3@test.com"};
        QVariantList ages = {25, 30, 28};

        query.addBindValue(usernames);
        query.addBindValue(emails);
        query.addBindValue(ages);

        if (!query.execBatch()) {
            qDebug() << "Batch insert failed:" << query.lastError().text();
            m_db.rollback();
            return false;
        }

        if (!m_db.commit()) {
            qDebug() << "Commit failed";
            m_db.rollback();
            return false;
        }

        qDebug() << "Transaction committed successfully";
        return true;
    }
};

// 使用示例
void databaseDemo() {
    DatabaseManager dbManager;

    if (!dbManager.initialize("test.db")) {
        return;
    }

    dbManager.createTables();
    dbManager.insertUser("alice", "alice@example.com", 25);
    dbManager.insertUser("bob", "bob@example.com", 30);

    QList<QVariantMap> users = dbManager.queryUsers();
    for (const QVariantMap &user : users) {
        qDebug() << "User:" << user;
    }

    dbManager.updateUser(1, "newemail@example.com");
    dbManager.deleteUser(2);

    dbManager.transaction();
}
```

---

## 第九模块：Qt高级特性

### 9.1 QVariant深度解析

```cpp
#include <QVariant>
#include <QDebug>

void qvariantDemo() {
    // 基本类型
    QVariant v1 = 42;
    QVariant v2 = 3.14;
    QVariant v3 = QString("Hello");
    QVariant v4 = true;

    // 类型检查
    qDebug() << "v1 type:" << v1.typeName();  // "int"
    qDebug() << "v1 is int:" << v1.canConvert<int>();

    // 类型转换
    int intVal = v1.toInt();
    double doubleVal = v1.toDouble();  // 自动转换
    QString strVal = v1.toString();    // "42"

    // 复杂类型
    QVariant v5 = QStringList{"a", "b", "c"};
    QVariant v6 = QDateTime::currentDateTime();

    QMap<QString, QVariant> map;
    map["name"] = "Alice";
    map["age"] = 25;
    map["scores"] = QList<int>{85, 90, 95};
    QVariant v7 = map;

    // 自定义类型
    struct Person {
        QString name;
        int age;
    };

    Q_DECLARE_METATYPE(Person)  // 注册到元类型系统

    Person p{"Bob", 30};
    QVariant v8 = QVariant::fromValue(p);

    if (v8.canConvert<Person>()) {
        Person extracted = v8.value<Person>();
        qDebug() << extracted.name << extracted.age;
    }
}
```

### 9.2 QMetaType系统

```cpp
#include <QMetaType>

// 注册自定义类型
class MyClass {
public:
    QString name;
    int value;

    MyClass() : value(0) {}
    MyClass(const QString &n, int v) : name(n), value(v) {}
};

// 注册到元类型系统
Q_DECLARE_METATYPE(MyClass)

// 在使用前注册（通常在main函数开始处）
void registerMetaTypes() {
    qRegisterMetaType<MyClass>("MyClass");

    // 注册后可以用于信号槽
    qRegisterMetaType<QList<MyClass>>("QList<MyClass>");
}

// 在信号槽中使用自定义类型
class CustomSignalEmitter : public QObject {
    Q_OBJECT
signals:
    void customDataReady(const MyClass &data);
    void customListReady(const QList<MyClass> &list);
};
```

### 9.3 插件系统

```cpp
// 定义插件接口
class PluginInterface {
public:
    virtual ~PluginInterface() {}
    virtual QString name() const = 0;
    virtual void execute() = 0;
};

#define PluginInterface_iid "com.example.PluginInterface/1.0"
Q_DECLARE_INTERFACE(PluginInterface, PluginInterface_iid)

// 实现插件
class MyPlugin : public QObject, public PluginInterface {
    Q_OBJECT
    Q_PLUGIN_METADATA(IID PluginInterface_iid)
    Q_INTERFACES(PluginInterface)

public:
    QString name() const override {
        return "My Plugin";
    }

    void execute() override {
        qDebug() << "Plugin executing...";
    }
};

// 加载插件
void loadPlugin(const QString &pluginPath) {
    QPluginLoader loader(pluginPath);
    QObject *plugin = loader.instance();

    if (plugin) {
        PluginInterface *interface = qobject_cast<PluginInterface*>(plugin);
        if (interface) {
            qDebug() << "Loaded plugin:" << interface->name();
            interface->execute();
        }
    } else {
        qDebug() << "Failed to load plugin:" << loader.errorString();
    }
}
```

---

## 学习验证标准

### 核心模块验证（Week 1-4）
- [ ] 理解Qt元对象系统的实现原理
- [ ] 掌握MOC的作用和工作流程
- [ ] 能够熟练使用Q_OBJECT、Q_PROPERTY等宏
- [ ] 理解d指针模式及其应用
- [ ] 掌握Qt的RTTI和反射机制

### 信号槽验证（Week 5-6）
- [ ] 深入理解信号槽的底层实现
- [ ] 掌握5种连接语法及应用场景
- [ ] 理解不同连接类型的区别
- [ ] 能够处理信号槽的内存管理
- [ ] 掌握跨线程信号槽通信

### 内存与事件验证（Week 7-8）
- [ ] 理解Qt对象树机制
- [ ] 掌握Qt内存管理最佳实践
- [ ] 理解事件系统的完整流程
- [ ] 能够自定义事件和事件过滤器
- [ ] 掌握事件循环机制

### 多线程验证（Week 9-10）
- [ ] 掌握QThread的正确使用方式
- [ ] 理解线程间信号槽通信机制
- [ ] 熟练使用互斥锁、条件变量等同步原语
- [ ] 掌握QtConcurrent高级API
- [ ] 能够设计线程安全的类

### 网络与数据库验证（Week 11-12）
- [ ] 实现TCP服务器和客户端
- [ ] 掌握HTTP请求处理
- [ ] 熟练使用Qt SQL模块
- [ ] 理解数据库事务处理
- [ ] 掌握网络异步编程

### 综合项目验证（Week 13-14）
- [ ] 完成至少一个包含以下特性的项目：
  - 多线程架构设计
  - 网络通信功能
  - 数据库持久化
  - 自定义事件系统
  - 插件化架构

---

## 常见陷阱与最佳实践

### 1. 信号槽连接陷阱

```cpp
// ❌ 错误：忘记Q_OBJECT宏
class MyClass : public QObject {
    // 缺少Q_OBJECT
signals:
    void mySignal();
};
// 编译错误：undefined reference to vtable

// ✅ 正确
class MyClass : public QObject {
    Q_OBJECT  // 必须添加
signals:
    void mySignal();
};
```

### 2. 线程使用陷阱

```cpp
// ❌ 错误：在非UI线程更新UI
void workerThread() {
    label->setText("Updated");  // 崩溃！
}

// ✅ 正确：使用信号槽
class Worker : public QObject {
    Q_OBJECT
signals:
    void updateText(QString text);
};
// 在主线程连接
connect(worker, &Worker::updateText, label, &QLabel::setText);
```

### 3. 内存管理陷阱

```cpp
// ❌ 错误：重复删除
QObject *obj = new QObject(parent);
delete obj;  // parent析构时会再次delete，double free！

// ✅ 正确：让父对象管理
QObject *obj = new QObject(parent);
// 不手动delete，或使用deleteLater()
```

---

## 推荐学习资源

### 官方资源
- Qt官方文档: https://doc.qt.io/qt-5/
- Qt源码: https://code.qt.io/cgit/qt/qtbase.git/
- Qt示例代码: Qt Creator → Examples

### 深度学习
1. **《C++ GUI Programming with Qt 5》** - 官方教程
2. **《Advanced Qt Programming》** - 高级主题
3. **《Qt5 Cadaques》** - 在线免费教程

### 源码阅读建议
1. 从QObject开始，理解对象模型
2. 研究信号槽的MOC生成代码
3. 阅读QThread和QEventLoop实现
4. 学习Qt容器类的实现技巧

---

**核心学习建议**:
1. 重点理解Qt的元对象系统，这是Qt的灵魂
2. 深入研究信号槽机制的实现原理
3. 掌握Qt的内存管理和对象生命周期
4. 重视多线程编程的正确使用方式
5. 阅读Qt源码，学习优秀的C++编程实践
6. 多做实战项目，理论结合实践

---

## 附录：Qt 5.15新特性

### Qt 5.15重要改进

1. **CMake构建系统成为默认**
2. **QCalendar API改进**
3. **QColorSpace支持**
4. **改进的正则表达式引擎（QRegularExpression）**
5. **更好的HiDPI支持**

### Qt 5.15性能优化技巧

```cpp
// 1. 使用QStringLiteral避免动态分配
QString s1 = "Hello";  // 运行时分配
QString s2 = QStringLiteral("Hello");  // 编译期常量

// 2. 使用reserve()预分配容器内存
QList<int> list;
list.reserve(1000);  // 避免多次重新分配

// 3. 使用move语义
QString createString() {
    QString s = "Large string data...";
    return s;  // 自动move，无拷贝
}

// 4. 避免隐式共享的分离
const QString &getString();  // 返回const引用避免分离
```

本笔记将持续更新，欢迎反馈和建议！
