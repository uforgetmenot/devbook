# 数据结构完整学习笔记

## 学习目标定位
- **目标群体**: 计算机专业学生、准备技术面试的开发者
- **学习周期**: 8-12周
- **前置要求**: 基础编程能力（Python/Java/C++）
- **学习成果**: 掌握常用数据结构，能够分析算法复杂度，解决实际问题

## 学习路径

```
基础数据结构(Week 1-2) → 线性结构(Week 3-4) → 树结构(Week 5-6)
→ 图结构(Week 7-8) → 高级数据结构(Week 9-10) → 算法综合(Week 11-12)
```

---

## 第一模块：基础数据结构

### 1.1 数组(Array)

#### 概念与特点
- **定义**: 存储相同类型元素的连续内存空间
- **特点**: 随机访问O(1)，插入删除O(n)
- **优势**: 访问速度快，缓存友好
- **劣势**: 大小固定，插入删除效率低

#### Python实现

```python
# 一维数组基础操作
class Array:
    def __init__(self, capacity=10):
        self.data = [None] * capacity
        self.size = 0
        self.capacity = capacity

    def __len__(self):
        return self.size

    def __getitem__(self, index):
        if not 0 <= index < self.size:
            raise IndexError("Index out of range")
        return self.data[index]

    def __setitem__(self, index, value):
        if not 0 <= index < self.size:
            raise IndexError("Index out of range")
        self.data[index] = value

    def append(self, value):
        """尾部添加元素 - O(1)"""
        if self.size == self.capacity:
            self._resize(self.capacity * 2)
        self.data[self.size] = value
        self.size += 1

    def insert(self, index, value):
        """指定位置插入 - O(n)"""
        if not 0 <= index <= self.size:
            raise IndexError("Index out of range")

        if self.size == self.capacity:
            self._resize(self.capacity * 2)

        # 移动元素
        for i in range(self.size, index, -1):
            self.data[i] = self.data[i-1]

        self.data[index] = value
        self.size += 1

    def remove(self, index):
        """删除指定位置元素 - O(n)"""
        if not 0 <= index < self.size:
            raise IndexError("Index out of range")

        value = self.data[index]

        # 移动元素
        for i in range(index, self.size - 1):
            self.data[i] = self.data[i+1]

        self.size -= 1
        self.data[self.size] = None

        # 缩容
        if self.size < self.capacity // 4 and self.capacity > 10:
            self._resize(self.capacity // 2)

        return value

    def _resize(self, new_capacity):
        """动态扩容/缩容"""
        new_data = [None] * new_capacity
        for i in range(self.size):
            new_data[i] = self.data[i]
        self.data = new_data
        self.capacity = new_capacity

    def find(self, value):
        """查找元素 - O(n)"""
        for i in range(self.size):
            if self.data[i] == value:
                return i
        return -1

# 使用示例
arr = Array()
arr.append(1)
arr.append(2)
arr.append(3)
arr.insert(1, 10)  # [1, 10, 2, 3]
print(arr[1])  # 10
arr.remove(1)  # [1, 2, 3]
```

#### 多维数组

```python
# 二维数组（矩阵）操作
def create_matrix(rows, cols, default=0):
    """创建矩阵"""
    return [[default for _ in range(cols)] for _ in range(rows)]

def transpose(matrix):
    """矩阵转置"""
    rows = len(matrix)
    cols = len(matrix[0])
    result = create_matrix(cols, rows)

    for i in range(rows):
        for j in range(cols):
            result[j][i] = matrix[i][j]

    return result

def matrix_multiply(A, B):
    """矩阵乘法"""
    rows_a, cols_a = len(A), len(A[0])
    rows_b, cols_b = len(B), len(B[0])

    if cols_a != rows_b:
        raise ValueError("矩阵维度不匹配")

    result = create_matrix(rows_a, cols_b)

    for i in range(rows_a):
        for j in range(cols_b):
            for k in range(cols_a):
                result[i][j] += A[i][k] * B[k][j]

    return result

# 使用示例
matrix = [[1, 2, 3],
          [4, 5, 6]]

transposed = transpose(matrix)
# [[1, 4],
#  [2, 5],
#  [3, 6]]
```

### 1.2 字符串(String)

#### 常用字符串算法

```python
# 1. KMP字符串匹配算法
def kmp_search(text, pattern):
    """KMP算法 - O(n+m)"""
    if not pattern:
        return 0

    # 构建next数组（部分匹配表）
    def build_next(pattern):
        m = len(pattern)
        next_arr = [0] * m
        j = 0

        for i in range(1, m):
            while j > 0 and pattern[i] != pattern[j]:
                j = next_arr[j-1]

            if pattern[i] == pattern[j]:
                j += 1

            next_arr[i] = j

        return next_arr

    next_arr = build_next(pattern)
    n, m = len(text), len(pattern)
    j = 0

    for i in range(n):
        while j > 0 and text[i] != pattern[j]:
            j = next_arr[j-1]

        if text[i] == pattern[j]:
            j += 1

        if j == m:
            return i - m + 1  # 找到匹配

    return -1  # 未找到

# 2. 最长公共子串
def longest_common_substring(s1, s2):
    """动态规划 - O(mn)"""
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_pos = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i

    return s1[end_pos - max_len:end_pos]

# 3. 字符串反转（各种方式）
def reverse_string(s):
    # 方式1: Python切片
    return s[::-1]

    # 方式2: 双指针
    chars = list(s)
    left, right = 0, len(chars) - 1
    while left < right:
        chars[left], chars[right] = chars[right], chars[left]
        left += 1
        right -= 1
    return ''.join(chars)

# 4. 回文串判断
def is_palindrome(s):
    """双指针 - O(n)"""
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

# 使用示例
print(kmp_search("hello world", "world"))  # 6
print(longest_common_substring("abcde", "ace"))  # "a" 或 "c" 或 "e"
print(is_palindrome("racecar"))  # True
```

### 1.3 链表(Linked List)

#### 单链表实现

```python
class ListNode:
    """链表节点"""
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    """单链表"""
    def __init__(self):
        self.head = None
        self.size = 0

    def __len__(self):
        return self.size

    def is_empty(self):
        return self.size == 0

    def append(self, val):
        """尾部添加 - O(n)"""
        new_node = ListNode(val)

        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

        self.size += 1

    def prepend(self, val):
        """头部添加 - O(1)"""
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
        self.size += 1

    def insert(self, index, val):
        """指定位置插入 - O(n)"""
        if index < 0 or index > self.size:
            raise IndexError("Index out of range")

        if index == 0:
            self.prepend(val)
            return

        new_node = ListNode(val)
        current = self.head

        for _ in range(index - 1):
            current = current.next

        new_node.next = current.next
        current.next = new_node
        self.size += 1

    def remove(self, val):
        """删除首个匹配值 - O(n)"""
        if not self.head:
            return False

        if self.head.val == val:
            self.head = self.head.next
            self.size -= 1
            return True

        current = self.head
        while current.next:
            if current.next.val == val:
                current.next = current.next.next
                self.size -= 1
                return True
            current = current.next

        return False

    def reverse(self):
        """反转链表 - O(n)"""
        prev = None
        current = self.head

        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node

        self.head = prev

    def get_middle(self):
        """获取中间节点（快慢指针）- O(n)"""
        if not self.head:
            return None

        slow = fast = self.head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        return slow.val

    def has_cycle(self):
        """检测环（Floyd判圈算法）- O(n)"""
        if not self.head:
            return False

        slow = fast = self.head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True

        return False

    def to_list(self):
        """转换为Python列表"""
        result = []
        current = self.head
        while current:
            result.append(current.val)
            current = current.next
        return result

# 使用示例
ll = LinkedList()
ll.append(1)
ll.append(2)
ll.append(3)
ll.prepend(0)  # [0, 1, 2, 3]
ll.insert(2, 99)  # [0, 1, 99, 2, 3]
ll.reverse()  # [3, 2, 99, 1, 0]
print(ll.to_list())
```

#### 双链表实现

```python
class DNode:
    """双向链表节点"""
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next

class DoublyLinkedList:
    """双向链表"""
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def append(self, val):
        """尾部添加 - O(1)"""
        new_node = DNode(val)

        if not self.head:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

        self.size += 1

    def prepend(self, val):
        """头部添加 - O(1)"""
        new_node = DNode(val)

        if not self.head:
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

        self.size += 1

    def remove(self, val):
        """删除节点 - O(n)"""
        current = self.head

        while current:
            if current.val == val:
                if current.prev:
                    current.prev.next = current.next
                else:
                    self.head = current.next

                if current.next:
                    current.next.prev = current.prev
                else:
                    self.tail = current.prev

                self.size -= 1
                return True

            current = current.next

        return False
```

---

## 第二模块：线性数据结构

### 2.1 栈(Stack)

#### 栈的概念
- **特点**: 后进先出(LIFO - Last In First Out)
- **操作**: push(入栈), pop(出栈), peek(查看栈顶), is_empty(判空)
- **应用**: 函数调用栈、表达式求值、括号匹配、浏览器历史

#### Python实现

```python
# 方式1: 基于列表
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        """入栈 - O(1)"""
        self.items.append(item)

    def pop(self):
        """出栈 - O(1)"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items.pop()

    def peek(self):
        """查看栈顶 - O(1)"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items[-1]

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# 方式2: 基于链表
class StackNode:
    def __init__(self, val, next=None):
        self.val = val
        self.next = next

class LinkedStack:
    def __init__(self):
        self.top = None
        self._size = 0

    def push(self, val):
        """入栈 - O(1)"""
        self.top = StackNode(val, self.top)
        self._size += 1

    def pop(self):
        """出栈 - O(1)"""
        if self.is_empty():
            raise IndexError("Stack is empty")
        val = self.top.val
        self.top = self.top.next
        self._size -= 1
        return val

    def peek(self):
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.top.val

    def is_empty(self):
        return self.top is None

    def size(self):
        return self._size
```

#### 栈的经典应用

```python
# 1. 括号匹配
def is_valid_parentheses(s):
    """检查括号是否匹配 - O(n)"""
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}

    for char in s:
        if char in pairs:
            stack.append(char)
        elif char in pairs.values():
            if not stack or pairs[stack.pop()] != char:
                return False

    return len(stack) == 0

# 2. 逆波兰表达式求值
def eval_rpn(tokens):
    """后缀表达式求值 - O(n)"""
    stack = []

    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()

            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))

    return stack[0]

# 3. 简化路径（Unix风格）
def simplify_path(path):
    """简化文件路径 - O(n)"""
    stack = []

    for part in path.split('/'):
        if part == '..':
            if stack:
                stack.pop()
        elif part and part != '.':
            stack.append(part)

    return '/' + '/'.join(stack)

# 使用示例
print(is_valid_parentheses("()[]{}"))  # True
print(eval_rpn(["2", "1", "+", "3", "*"]))  # 9 ((2+1)*3)
print(simplify_path("/a/./b/../../c/"))  # "/c"
```

### 2.2 队列(Queue)

#### 队列的概念
- **特点**: 先进先出(FIFO - First In First Out)
- **操作**: enqueue(入队), dequeue(出队), front(查看队首)
- **应用**: BFS遍历、任务调度、消息队列

#### Python实现

```python
# 1. 普通队列（基于列表）
class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        """入队 - O(1)"""
        self.items.append(item)

    def dequeue(self):
        """出队 - O(n)"""
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items.pop(0)

    def front(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items[0]

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

# 2. 循环队列（高效实现）
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.items = [None] * capacity
        self.front_idx = 0
        self.rear_idx = -1
        self.count = 0

    def enqueue(self, item):
        """入队 - O(1)"""
        if self.is_full():
            raise OverflowError("Queue is full")

        self.rear_idx = (self.rear_idx + 1) % self.capacity
        self.items[self.rear_idx] = item
        self.count += 1

    def dequeue(self):
        """出队 - O(1)"""
        if self.is_empty():
            raise IndexError("Queue is empty")

        item = self.items[self.front_idx]
        self.front_idx = (self.front_idx + 1) % self.capacity
        self.count -= 1
        return item

    def is_empty(self):
        return self.count == 0

    def is_full(self):
        return self.count == self.capacity

# 3. 双端队列（使用collections.deque）
from collections import deque

class Deque:
    def __init__(self):
        self.items = deque()

    def add_front(self, item):
        """前端添加 - O(1)"""
        self.items.appendleft(item)

    def add_rear(self, item):
        """后端添加 - O(1)"""
        self.items.append(item)

    def remove_front(self):
        """前端移除 - O(1)"""
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self.items.popleft()

    def remove_rear(self):
        """后端移除 - O(1)"""
        if self.is_empty():
            raise IndexError("Deque is empty")
        return self.items.pop()

    def is_empty(self):
        return len(self.items) == 0

# 4. 优先队列（基于堆）
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []
        self.count = 0

    def push(self, item, priority):
        """入队（优先级越小越优先）- O(log n)"""
        heapq.heappush(self.heap, (priority, self.count, item))
        self.count += 1

    def pop(self):
        """出队 - O(log n)"""
        if self.is_empty():
            raise IndexError("PriorityQueue is empty")
        return heapq.heappop(self.heap)[2]

    def is_empty(self):
        return len(self.heap) == 0

# 使用示例
pq = PriorityQueue()
pq.push("task1", priority=3)
pq.push("task2", priority=1)
pq.push("task3", priority=2)
print(pq.pop())  # task2 (优先级最高)
print(pq.pop())  # task3
```

#### 队列的经典应用

```python
# 1. 滑动窗口最大值
def max_sliding_window(nums, k):
    """单调队列 - O(n)"""
    from collections import deque

    dq = deque()  # 存储下标
    result = []

    for i, num in enumerate(nums):
        # 移除超出窗口的元素
        if dq and dq[0] < i - k + 1:
            dq.popleft()

        # 移除比当前元素小的元素
        while dq and nums[dq[-1]] < num:
            dq.pop()

        dq.append(i)

        # 窗口形成后记录最大值
        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

# 使用示例
print(max_sliding_window([1,3,-1,-3,5,3,6,7], 3))  # [3,3,5,5,6,7]
```

---

## 第三模块：树结构

### 3.1 二叉树(Binary Tree)

#### 二叉树节点定义

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

#### 二叉树遍历

```python
# 1. 前序遍历（根-左-右）
def preorder_traversal(root):
    """递归 - O(n)"""
    result = []

    def traverse(node):
        if not node:
            return
        result.append(node.val)
        traverse(node.left)
        traverse(node.right)

    traverse(root)
    return result

def preorder_iterative(root):
    """迭代（使用栈）- O(n)"""
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)

        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result

# 2. 中序遍历（左-根-右）
def inorder_traversal(root):
    """递归 - O(n)"""
    result = []

    def traverse(node):
        if not node:
            return
        traverse(node.left)
        result.append(node.val)
        traverse(node.right)

    traverse(root)
    return result

def inorder_iterative(root):
    """迭代 - O(n)"""
    result = []
    stack = []
    current = root

    while current or stack:
        while current:
            stack.append(current)
            current = current.left

        current = stack.pop()
        result.append(current.val)
        current = current.right

    return result

# 3. 后序遍历（左-右-根）
def postorder_traversal(root):
    """递归 - O(n)"""
    result = []

    def traverse(node):
        if not node:
            return
        traverse(node.left)
        traverse(node.right)
        result.append(node.val)

    traverse(root)
    return result

# 4. 层序遍历（BFS）
def level_order_traversal(root):
    """广度优先 - O(n)"""
    if not root:
        return []

    from collections import deque
    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        level = []

        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(level)

    return result
```

#### 二叉树常见操作

```python
# 1. 计算树的深度
def max_depth(root):
    """递归 - O(n)"""
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

# 2. 判断是否为平衡二叉树
def is_balanced(root):
    """O(n)"""
    def height(node):
        if not node:
            return 0

        left_height = height(node.left)
        right_height = height(node.right)

        if left_height == -1 or right_height == -1:
            return -1

        if abs(left_height - right_height) > 1:
            return -1

        return 1 + max(left_height, right_height)

    return height(root) != -1

# 3. 翻转二叉树
def invert_tree(root):
    """递归 - O(n)"""
    if not root:
        return None

    root.left, root.right = root.right, root.left
    invert_tree(root.left)
    invert_tree(root.right)

    return root

# 4. 二叉树的直径
def diameter_of_binary_tree(root):
    """O(n)"""
    diameter = 0

    def depth(node):
        nonlocal diameter
        if not node:
            return 0

        left = depth(node.left)
        right = depth(node.right)

        diameter = max(diameter, left + right)

        return 1 + max(left, right)

    depth(root)
    return diameter

# 5. 最近公共祖先
def lowest_common_ancestor(root, p, q):
    """O(n)"""
    if not root or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left and right:
        return root

    return left if left else right
```

### 3.2 二叉搜索树(BST)

#### BST实现

```python
class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        """插入节点 - 平均O(log n), 最坏O(n)"""
        def _insert(node, val):
            if not node:
                return TreeNode(val)

            if val < node.val:
                node.left = _insert(node.left, val)
            elif val > node.val:
                node.right = _insert(node.right, val)

            return node

        self.root = _insert(self.root, val)

    def search(self, val):
        """查找节点 - 平均O(log n), 最坏O(n)"""
        def _search(node, val):
            if not node or node.val == val:
                return node

            if val < node.val:
                return _search(node.left, val)
            return _search(node.right, val)

        return _search(self.root, val)

    def delete(self, val):
        """删除节点 - 平均O(log n), 最坏O(n)"""
        def _min_node(node):
            current = node
            while current.left:
                current = current.left
            return current

        def _delete(node, val):
            if not node:
                return None

            if val < node.val:
                node.left = _delete(node.left, val)
            elif val > node.val:
                node.right = _delete(node.right, val)
            else:
                # 找到要删除的节点
                if not node.left:
                    return node.right
                elif not node.right:
                    return node.left

                # 节点有两个子节点
                min_node = _min_node(node.right)
                node.val = min_node.val
                node.right = _delete(node.right, min_node.val)

            return node

        self.root = _delete(self.root, val)

    def inorder(self):
        """中序遍历（有序）"""
        result = []

        def _inorder(node):
            if node:
                _inorder(node.left)
                result.append(node.val)
                _inorder(node.right)

        _inorder(self.root)
        return result

# 使用示例
bst = BST()
for val in [5, 3, 7, 2, 4, 6, 8]:
    bst.insert(val)

print(bst.inorder())  # [2, 3, 4, 5, 6, 7, 8]
print(bst.search(4) is not None)  # True
bst.delete(3)
print(bst.inorder())  # [2, 4, 5, 6, 7, 8]
```

#### BST经典问题

```python
# 1. 验证二叉搜索树
def is_valid_bst(root):
    """O(n)"""
    def validate(node, min_val, max_val):
        if not node:
            return True

        if node.val <= min_val or node.val >= max_val:
            return False

        return (validate(node.left, min_val, node.val) and
                validate(node.right, node.val, max_val))

    return validate(root, float('-inf'), float('inf'))

# 2. BST中第K小的元素
def kth_smallest(root, k):
    """中序遍历 - O(n)"""
    result = []

    def inorder(node):
        if not node or len(result) >= k:
            return

        inorder(node.left)
        result.append(node.val)
        inorder(node.right)

    inorder(root)
    return result[k-1] if k <= len(result) else None
```

### 3.3 堆(Heap)

#### 最小堆实现

```python
class MinHeap:
    def __init__(self):
        self.heap = []

    def parent(self, i):
        return (i - 1) // 2

    def left_child(self, i):
        return 2 * i + 1

    def right_child(self, i):
        return 2 * i + 2

    def push(self, val):
        """插入元素 - O(log n)"""
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)

    def pop(self):
        """弹出最小元素 - O(log n)"""
        if not self.heap:
            raise IndexError("Heap is empty")

        if len(self.heap) == 1:
            return self.heap.pop()

        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)

        return root

    def peek(self):
        """查看最小元素 - O(1)"""
        if not self.heap:
            raise IndexError("Heap is empty")
        return self.heap[0]

    def _heapify_up(self, i):
        """向上调整"""
        parent = self.parent(i)

        if i > 0 and self.heap[i] < self.heap[parent]:
            self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]
            self._heapify_up(parent)

    def _heapify_down(self, i):
        """向下调整"""
        min_idx = i
        left = self.left_child(i)
        right = self.right_child(i)

        if left < len(self.heap) and self.heap[left] < self.heap[min_idx]:
            min_idx = left

        if right < len(self.heap) and self.heap[right] < self.heap[min_idx]:
            min_idx = right

        if min_idx != i:
            self.heap[i], self.heap[min_idx] = self.heap[min_idx], self.heap[i]
            self._heapify_down(min_idx)

# 使用Python的heapq模块
import heapq

# 最小堆
min_heap = []
heapq.heappush(min_heap, 3)
heapq.heappush(min_heap, 1)
heapq.heappush(min_heap, 2)
print(heapq.heappop(min_heap))  # 1

# 最大堆（取负数）
max_heap = []
heapq.heappush(max_heap, -3)
heapq.heappush(max_heap, -1)
heapq.heappush(max_heap, -2)
print(-heapq.heappop(max_heap))  # 3
```

#### 堆的经典应用

```python
# 1. Top K问题
def find_kth_largest(nums, k):
    """找第K大的元素 - O(n log k)"""
    import heapq
    min_heap = []

    for num in nums:
        heapq.heappush(min_heap, num)
        if len(min_heap) > k:
            heapq.heappop(min_heap)

    return min_heap[0]

# 2. 合并K个有序链表
def merge_k_lists(lists):
    """O(N log k), N为所有节点总数"""
    import heapq

    heap = []
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst.val, i, lst))

    dummy = TreeNode(0)
    current = dummy

    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next

        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))

    return dummy.next

# 3. 数据流的中位数
class MedianFinder:
    def __init__(self):
        self.small = []  # 最大堆（存较小的一半）
        self.large = []  # 最小堆（存较大的一半）

    def add_num(self, num):
        """添加数字 - O(log n)"""
        import heapq

        heapq.heappush(self.small, -num)

        # 平衡两个堆
        if (self.small and self.large and
            -self.small[0] > self.large[0]):
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)

        # 保持大小差不超过1
        if len(self.small) > len(self.large) + 1:
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)

        if len(self.large) > len(self.small):
            val = heapq.heappop(self.large)
            heapq.heappush(self.small, -val)

    def find_median(self):
        """获取中位数 - O(1)"""
        if len(self.small) > len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
```

---

## 第四模块：图结构

### 4.1 图的表示

```python
# 1. 邻接矩阵
class GraphMatrix:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.matrix = [[0] * num_vertices for _ in range(num_vertices)]

    def add_edge(self, u, v, weight=1):
        """添加边"""
        self.matrix[u][v] = weight
        self.matrix[v][u] = weight  # 无向图

# 2. 邻接表
class GraphList:
    def __init__(self):
        self.graph = {}

    def add_vertex(self, vertex):
        """添加顶点"""
        if vertex not in self.graph:
            self.graph[vertex] = []

    def add_edge(self, u, v, weight=1):
        """添加边"""
        if u not in self.graph:
            self.add_vertex(u)
        if v not in self.graph:
            self.add_vertex(v)

        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))  # 无向图

    def get_neighbors(self, vertex):
        """获取邻居"""
        return self.graph.get(vertex, [])
```

### 4.2 图的遍历

```python
# 1. 深度优先搜索(DFS)
def dfs(graph, start):
    """递归DFS - O(V+E)"""
    visited = set()
    result = []

    def dfs_helper(vertex):
        visited.add(vertex)
        result.append(vertex)

        for neighbor, _ in graph.get_neighbors(vertex):
            if neighbor not in visited:
                dfs_helper(neighbor)

    dfs_helper(start)
    return result

def dfs_iterative(graph, start):
    """迭代DFS - O(V+E)"""
    visited = set()
    result = []
    stack = [start]

    while stack:
        vertex = stack.pop()

        if vertex not in visited:
            visited.add(vertex)
            result.append(vertex)

            for neighbor, _ in graph.get_neighbors(vertex):
                if neighbor not in visited:
                    stack.append(neighbor)

    return result

# 2. 广度优先搜索(BFS)
def bfs(graph, start):
    """BFS - O(V+E)"""
    from collections import deque

    visited = set([start])
    result = []
    queue = deque([start])

    while queue:
        vertex = queue.popleft()
        result.append(vertex)

        for neighbor, _ in graph.get_neighbors(vertex):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return result
```

### 4.3 最短路径算法

```python
# 1. Dijkstra算法（单源最短路径）
def dijkstra(graph, start):
    """Dijkstra算法 - O((V+E) log V)"""
    import heapq

    distances = {vertex: float('inf') for vertex in graph.graph}
    distances[start] = 0

    pq = [(0, start)]
    visited = set()

    while pq:
        current_dist, current = heapq.heappop(pq)

        if current in visited:
            continue

        visited.add(current)

        for neighbor, weight in graph.get_neighbors(current):
            distance = current_dist + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances

# 2. Floyd-Warshall算法（所有点对最短路径）
def floyd_warshall(graph, num_vertices):
    """Floyd-Warshall算法 - O(V^3)"""
    # 初始化距离矩阵
    dist = [[float('inf')] * num_vertices for _ in range(num_vertices)]

    for i in range(num_vertices):
        dist[i][i] = 0

    # 填充已知边
    for u in graph.graph:
        for v, weight in graph.graph[u]:
            dist[u][v] = weight

    # 动态规划
    for k in range(num_vertices):
        for i in range(num_vertices):
            for j in range(num_vertices):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist

# 3. Bellman-Ford算法（允许负权边）
def bellman_ford(graph, start, num_vertices):
    """Bellman-Ford算法 - O(VE)"""
    distances = {i: float('inf') for i in range(num_vertices)}
    distances[start] = 0

    # 松弛V-1次
    for _ in range(num_vertices - 1):
        for u in graph.graph:
            for v, weight in graph.graph[u]:
                if distances[u] + weight < distances[v]:
                    distances[v] = distances[u] + weight

    # 检测负权环
    for u in graph.graph:
        for v, weight in graph.graph[u]:
            if distances[u] + weight < distances[v]:
                return None  # 存在负权环

    return distances
```

### 4.4 拓扑排序

```python
def topological_sort(graph):
    """拓扑排序（Kahn算法）- O(V+E)"""
    from collections import deque

    # 计算入度
    in_degree = {vertex: 0 for vertex in graph.graph}

    for vertex in graph.graph:
        for neighbor, _ in graph.graph[vertex]:
            in_degree[neighbor] += 1

    # 将入度为0的顶点加入队列
    queue = deque([v for v in in_degree if in_degree[v] == 0])
    result = []

    while queue:
        vertex = queue.popleft()
        result.append(vertex)

        for neighbor, _ in graph.graph[vertex]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    # 检测环
    if len(result) != len(graph.graph):
        return None  # 存在环

    return result
```

---

## 第五模块：高级数据结构

### 5.1 并查集(Union-Find)

```python
class UnionFind:
    """并查集（路径压缩 + 按秩合并）"""

    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n  # 连通分量数

    def find(self, x):
        """查找根节点（路径压缩）- 平均O(α(n))"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        """合并两个集合（按秩合并）- 平均O(α(n))"""
        root_x = self.find(x)
        root_y = self.find(y)

        if root_x == root_y:
            return False

        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1

        self.count -= 1
        return True

    def connected(self, x, y):
        """判断是否连通 - 平均O(α(n))"""
        return self.find(x) == self.find(y)

# 应用：求连通分量数
def count_components(n, edges):
    """O(Eα(n))"""
    uf = UnionFind(n)

    for u, v in edges:
        uf.union(u, v)

    return uf.count
```

### 5.2 字典树(Trie)

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    """前缀树"""

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """插入单词 - O(m), m为单词长度"""
        node = self.root

        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]

        node.is_end = True

    def search(self, word):
        """搜索单词 - O(m)"""
        node = self.root

        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]

        return node.is_end

    def starts_with(self, prefix):
        """搜索前缀 - O(m)"""
        node = self.root

        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]

        return True

# 使用示例
trie = Trie()
trie.insert("apple")
print(trie.search("apple"))    # True
print(trie.search("app"))      # False
print(trie.starts_with("app")) # True
```

### 5.3 LRU缓存

```python
class LRUCache:
    """最近最少使用缓存"""

    class Node:
        def __init__(self, key=0, val=0):
            self.key = key
            self.val = val
            self.prev = None
            self.next = None

    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> Node

        # 虚拟头尾节点
        self.head = self.Node()
        self.tail = self.Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        """获取值 - O(1)"""
        if key not in self.cache:
            return -1

        node = self.cache[key]
        self._move_to_head(node)
        return node.val

    def put(self, key, value):
        """放入键值对 - O(1)"""
        if key in self.cache:
            node = self.cache[key]
            node.val = value
            self._move_to_head(node)
        else:
            node = self.Node(key, value)
            self.cache[key] = node
            self._add_to_head(node)

            if len(self.cache) > self.capacity:
                removed = self._remove_tail()
                del self.cache[removed.key]

    def _add_to_head(self, node):
        """添加节点到头部"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def _remove_node(self, node):
        """移除节点"""
        node.prev.next = node.next
        node.next.prev = node.prev

    def _move_to_head(self, node):
        """移动节点到头部"""
        self._remove_node(node)
        self._add_to_head(node)

    def _remove_tail(self):
        """移除尾部节点"""
        node = self.tail.prev
        self._remove_node(node)
        return node

# 使用示例
cache = LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # 1
cache.put(3, 3)      # 移除key=2
print(cache.get(2))  # -1
```

---

## 第六模块：算法复杂度分析

### 6.1 时间复杂度对比

| 复杂度 | 名称 | 示例算法 |
|--------|------|----------|
| O(1) | 常数 | 数组访问、哈希表查找 |
| O(log n) | 对数 | 二分查找、平衡树操作 |
| O(n) | 线性 | 线性搜索、遍历 |
| O(n log n) | 线性对数 | 归并排序、快速排序 |
| O(n²) | 平方 | 冒泡排序、选择排序 |
| O(2^n) | 指数 | 递归斐波那契 |
| O(n!) | 阶乘 | 全排列 |

### 6.2 空间复杂度分析

```python
# O(1) 空间
def reverse_array_inplace(arr):
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1

# O(n) 空间
def reverse_array_new(arr):
    return arr[::-1]

# O(n) 递归空间（调用栈）
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

---

## 学习验证标准

### 基础验证（Week 1-4）
- [ ] 能够手写数组、链表、栈、队列的实现
- [ ] 理解各数据结构的时间空间复杂度
- [ ] 熟练使用Python内置数据结构

### 中级验证（Week 5-8）
- [ ] 掌握二叉树的各种遍历方式
- [ ] 能够实现BST的增删查改
- [ ] 理解图的表示和遍历算法
- [ ] 掌握Dijkstra和BFS最短路径

### 高级验证（Week 9-12）
- [ ] 实现并查集、Trie、LRU缓存
- [ ] 能够分析算法的复杂度
- [ ] 解决LeetCode中等难度题目
- [ ] 完成至少一个综合项目

---

## 常见面试题精选

### 1. 数组与字符串
- 两数之和、三数之和
- 最长回文子串
- 字符串匹配（KMP）
- 最大子数组和

### 2. 链表
- 反转链表
- 链表环检测
- 合并两个有序链表
- 两数相加（链表表示）

### 3. 树
- 二叉树的层序遍历
- 验证二叉搜索树
- 最近公共祖先
- 序列化与反序列化二叉树

### 4. 图
- 岛屿数量
- 课程表（拓扑排序）
- 最短路径（Dijkstra/BFS）
- 连通分量

---

## 推荐学习资源

### 在线平台
- **LeetCode**: https://leetcode.com/
- **HackerRank**: https://www.hackerrank.com/
- **Codeforces**: https://codeforces.com/

### 推荐书籍
1. **《算法导论》** - CLRS（权威教材）
2. **《数据结构与算法分析》** - Mark Allen Weiss
3. **《剑指Offer》** - 何海涛（面试必备）
4. **《编程珠玑》** - Jon Bentley

### 学习建议
1. 每天至少做1-2道算法题
2. 注重理解原理，不要死记硬背
3. 复杂度分析要成为习惯
4. 多做总结，归纳题型
5. 参与算法竞赛和讨论

---

**最后总结**：

数据结构是编程的基础，掌握数据结构能够：
- **提升编码能力**: 选择合适的数据结构解决问题
- **优化程序性能**: 理解复杂度，写出高效代码
- **通过技术面试**: 大厂面试必考内容
- **深入理解原理**: 了解计算机底层实现

通过系统学习和大量练习，你将能够：
1. 快速识别问题类型
2. 选择最优数据结构
3. 分析算法复杂度
4. 实现高效解决方案

坚持练习，祝你学习进步！
