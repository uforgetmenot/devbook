# æ•°å­—ç”µè·¯å­¦ä¹ ç¬”è®°

## ğŸ“‹ ç›®å½•å¯¼èˆª

1. [å­¦ä¹ æŒ‡å—](#å­¦ä¹ æŒ‡å—)
2. [æ¨¡å—ä¸€ï¼šæ•°å­—ç”µè·¯åŸºç¡€ä¸é€»è¾‘ä»£æ•°](#æ¨¡å—ä¸€æ•°å­—ç”µè·¯åŸºç¡€ä¸é€»è¾‘ä»£æ•°)
3. [æ¨¡å—äºŒï¼šç»„åˆé€»è¾‘ç”µè·¯](#æ¨¡å—äºŒç»„åˆé€»è¾‘ç”µè·¯)
4. [æ¨¡å—ä¸‰ï¼šæ—¶åºé€»è¾‘ç”µè·¯](#æ¨¡å—ä¸‰æ—¶åºé€»è¾‘ç”µè·¯)
5. [æ¨¡å—å››ï¼šç¡¬ä»¶æè¿°è¯­è¨€ä¸ä»¿çœŸ](#æ¨¡å—å››ç¡¬ä»¶æè¿°è¯­è¨€ä¸ä»¿çœŸ)
6. [æ¨¡å—äº”ï¼šFPGAè®¾è®¡å®æˆ˜](#æ¨¡å—äº”fpgaè®¾è®¡å®æˆ˜)
7. [æ¨¡å—å…­ï¼šé«˜çº§ä¸»é¢˜ä¸ç³»ç»Ÿè®¾è®¡](#æ¨¡å—å…­é«˜çº§ä¸»é¢˜ä¸ç³»ç»Ÿè®¾è®¡)
8. [æ¨¡å—ä¸ƒï¼šæ•°å­—ç³»ç»Ÿè®¾è®¡è¿›é˜¶](#æ¨¡å—ä¸ƒæ•°å­—ç³»ç»Ÿè®¾è®¡è¿›é˜¶)
9. [å­¦ä¹ æˆæœéªŒè¯](#å­¦ä¹ æˆæœéªŒè¯)
10. [å¸¸è§é—®é¢˜ä¸è°ƒè¯•æŠ€å·§](#å¸¸è§é—®é¢˜ä¸è°ƒè¯•æŠ€å·§)
11. [æ‰©å±•èµ„æºä¸è¿›é˜¶å»ºè®®](#æ‰©å±•èµ„æºä¸è¿›é˜¶å»ºè®®)

---

## å­¦ä¹ æŒ‡å—

### ğŸ“Œ å…³äºæœ¬ç¬”è®°

æœ¬ç¬”è®°æ˜¯ä¸€ä»½ç³»ç»ŸåŒ–çš„æ•°å­—ç”µè·¯å­¦ä¹ èµ„æº,é¢å‘æœ‰0-5å¹´å¼€å‘ç»éªŒçš„ç¡¬ä»¶å·¥ç¨‹å¸ˆã€åµŒå…¥å¼å¼€å‘è€…åŠå¸Œæœ›æ·±å…¥ç†è§£è®¡ç®—æœºåº•å±‚åŸç†çš„å­¦ä¹ è€…ã€‚ç¬”è®°éµå¾ªä»ç†è®ºåˆ°å®è·µã€ä»åŸºç¡€åˆ°è¿›é˜¶çš„å­¦ä¹ è·¯å¾„,æ¯ä¸ªæ¨¡å—éƒ½é…å¤‡äº†å®Œæ•´çš„ç†è®ºè®²è§£ã€å®æˆ˜ä»£ç ç¤ºä¾‹å’ŒéªŒè¯æ–¹æ¡ˆã€‚

### ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬ç¬”è®°çš„å­¦ä¹ å,ä½ å°†èƒ½å¤Ÿ:

| å­¦ä¹ ç›®æ ‡ | å…·ä½“æè¿° |
|---------|--------|
| **ç†è®ºåŸºç¡€** | æ·±å…¥ç†è§£æ•°å­—é€»è¾‘ã€å¸ƒå°”ä»£æ•°ã€ç»„åˆé€»è¾‘å’Œæ—¶åºé€»è¾‘çš„åŸç† |
| **å·¥å…·æŒæ¡** | ç†Ÿç»ƒä½¿ç”¨Verilog/VHDLè¿›è¡Œæ•°å­—ç”µè·¯è®¾è®¡å’Œä»¿çœŸ |
| **å·¥ç¨‹å®è·µ** | èƒ½å¤Ÿåœ¨FPGAæˆ–ASICå·¥å…·é“¾ä¸­å®Œæˆå®Œæ•´çš„è®¾è®¡æµç¨‹ |
| **ç³»ç»Ÿè®¾è®¡** | èƒ½å¤Ÿè®¾è®¡ä¸­ç­‰å¤æ‚åº¦çš„æ•°å­—ç³»ç»Ÿ,å¦‚æ§åˆ¶å™¨ã€æ•°æ®é€šè·¯ç­‰ |
| **æ•…éšœæ’æŸ¥** | èƒ½å¤Ÿç‹¬ç«‹è°ƒè¯•æ•°å­—ç”µè·¯è®¾è®¡ä¸­çš„é€»è¾‘å’Œæ—¶åºé—®é¢˜ |

### ğŸ“š å­¦ä¹ è·¯å¾„

```
ç¬¬1å‘¨ï¼šåŸºç¡€ç†è®ºï¼ˆ30-40å°æ—¶ï¼‰
  â”œâ”€ æ•°å­—ä¿¡å·åŸºç¡€ä¸é€»è¾‘é—¨
  â”œâ”€ å¸ƒå°”ä»£æ•°ä¸é€»è¾‘åŒ–ç®€
  â””â”€ çœŸå€¼è¡¨ä¸é€»è¾‘è¡¨è¾¾å¼

ç¬¬2-3å‘¨ï¼šç»„åˆé€»è¾‘ï¼ˆ40-50å°æ—¶ï¼‰
  â”œâ”€ åŠ æ³•å™¨ã€ä¹˜æ³•å™¨è®¾è®¡
  â”œâ”€ å¤šè·¯é€‰æ‹©å™¨ã€è¯‘ç å™¨
  â””â”€ ç®—æœ¯é€»è¾‘å•å…ƒ(ALU)è®¾è®¡

ç¬¬4-5å‘¨ï¼šæ—¶åºé€»è¾‘ï¼ˆ40-50å°æ—¶ï¼‰
  â”œâ”€ é”å­˜å™¨ä¸è§¦å‘å™¨
  â”œâ”€ è®¡æ•°å™¨ä¸å¯„å­˜å™¨
  â””â”€ æœ‰é™çŠ¶æ€æœº(FSM)

ç¬¬6-7å‘¨ï¼šHDLå·¥å…·é“¾ï¼ˆ50-60å°æ—¶ï¼‰
  â”œâ”€ Verilogè¯­è¨€ä¸RTLè®¾è®¡
  â”œâ”€ ä»¿çœŸä¸éªŒè¯
  â””â”€ ç»¼åˆä¸ä¼˜åŒ–

ç¬¬8-10å‘¨ï¼šFPGAè®¾è®¡ï¼ˆ60-80å°æ—¶ï¼‰
  â”œâ”€ FPGAæ¶æ„ä¸è®¾è®¡å·¥å…·
  â”œâ”€ å®Œæ•´è®¾è®¡æµç¨‹
  â””â”€ ç»¼åˆå¸ƒå±€å¸ƒçº¿

ç¬¬11-12å‘¨ï¼šç³»ç»Ÿè®¾è®¡ä¸ä¼˜åŒ–ï¼ˆ50-70å°æ—¶ï¼‰
  â”œâ”€ ç³»ç»Ÿçº§è®¾è®¡æ–¹æ³•
  â”œâ”€ æ€§èƒ½ä¼˜åŒ–ä¸åˆ†æ
  â””â”€ å®Œæ•´é¡¹ç›®å®æˆ˜
```

### ğŸ› ï¸ ç¯å¢ƒæ­å»º

#### å¿…å¤‡å·¥å…·

| å·¥å…·ç±»å‹ | æ¨èäº§å“ | ç”¨é€” | å¼€æºæ›¿ä»£ |
|---------|--------|------|--------|
| **ä»¿çœŸå·¥å…·** | ModelSimã€VCS | Verilog/VHDLä»¿çœŸã€åŠŸèƒ½éªŒè¯ | iverilog+gtkwave |
| **ç»¼åˆå·¥å…·** | Vivadoã€ISEã€Quartus | RTLç»¼åˆã€ä¼˜åŒ– | Yosys |
| **FPGAå·¥å…·** | Vivado(Xilinx)ã€Quartus(Intel) | FPGAè®¾è®¡å®Œæ•´æµç¨‹ | - |
| **æ³¢å½¢æŸ¥çœ‹** | GTKWave | ä»¿çœŸç»“æœæ³¢å½¢åˆ†æ | å¼€æº |
| **ç¼–è¾‘å™¨** | VS Code+Verilogæ’ä»¶ | ä»£ç ç¼–å†™ | - |

#### å®‰è£…æ­¥éª¤ï¼ˆä»¥å¼€æºå·¥å…·ä¸ºä¾‹ï¼‰

**1. å®‰è£…iverilogå’Œgtkwaveï¼ˆLinux/Ubuntuï¼‰ï¼š**

```bash
# æ›´æ–°åŒ…ç®¡ç†å™¨
sudo apt-get update

# å®‰è£…iverilogï¼ˆVerilogç¼–è¯‘å™¨ï¼‰
sudo apt-get install -y iverilog

# å®‰è£…gtkwaveï¼ˆæ³¢å½¢æŸ¥çœ‹å·¥å…·ï¼‰
sudo apt-get install -y gtkwave

# éªŒè¯å®‰è£…
iverilog -v
gtkwave --version
```

**2. å®‰è£…VS Code Verilogæ’ä»¶ï¼š**

```
æ‰“å¼€VS Code â†’ æ‰©å±•(Extensions) â†’ æœç´¢"Verilog" â†’
å®‰è£…"Verilog-HDL/SystemVerilog" (ä½œè€…: mshr-h)
```

**3. åˆ›å»ºé¡¹ç›®ç›®å½•ç»“æ„ï¼š**

```bash
mkdir -p ~/digital-circuit-learning
cd ~/digital-circuit-learning
mkdir -p {source,testbench,simulation,build}

# åˆ›å»ºåˆå§‹é…ç½®æ–‡ä»¶
cat > Makefile << 'EOF'
VERILOG_FILES = $(wildcard source/*.v)
TB_FILES = $(wildcard testbench/*_tb.v)
BUILD_DIR = build
SIMULATION_DIR = simulation

.PHONY: all clean simulate

all: compile

compile:
	@echo "Compiling Verilog files..."
	iverilog -o $(BUILD_DIR)/design.vvp $(VERILOG_FILES) $(TB_FILES)

simulate: compile
	@echo "Running simulation..."
	vvp $(BUILD_DIR)/design.vvp -vcd
	gtkwave $(SIMULATION_DIR)/waveform.vcd &

clean:
	rm -rf $(BUILD_DIR)/*.vvp
	rm -rf $(SIMULATION_DIR)/*.vcd

help:
	@echo "Available targets:"
	@echo "  make compile   - Compile Verilog files"
	@echo "  make simulate  - Run simulation and view waveform"
	@echo "  make clean     - Clean generated files"
EOF

chmod +x Makefile
```

---

## æ¨¡å—ä¸€ï¼šæ•°å­—ç”µè·¯åŸºç¡€ä¸é€»è¾‘ä»£æ•°

### 1.1 æ•°å­—ä¿¡å·ä¸æ•°åˆ¶åŸºç¡€

#### æ•°å­—ä¿¡å·çš„æœ¬è´¨

æ•°å­—ç”µè·¯å¤„ç†çš„æ˜¯ç¦»æ•£å€¼ä¿¡å·,ä¸æ¨¡æ‹Ÿä¿¡å·çš„è¿ç»­æ€§ç›¸åã€‚åœ¨å®é™…ç”µå­ç³»ç»Ÿä¸­,æ•°å­—ä¿¡å·é€šå¸¸ç”¨ä¸¤ä¸ªç”µå‹çº§æ¥è¡¨ç¤ºé€»è¾‘å€¼:

| é€»è¾‘å€¼ | ç”µå‹èŒƒå›´ï¼ˆTTLï¼‰ | ç”µå‹èŒƒå›´ï¼ˆCMOS 3.3Vï¼‰ | å«ä¹‰ |
|------|--------------|------------------|------|
| é€»è¾‘1ï¼ˆHIGHï¼‰ | â‰¥2.4V | â‰¥2.4V | é«˜ç”µå¹³ã€çœŸã€æ˜¯ |
| é€»è¾‘0ï¼ˆLOWï¼‰ | â‰¤0.4V | â‰¤0.8V | ä½ç”µå¹³ã€å‡ã€å¦ |
| ä¸ç¡®å®šï¼ˆXï¼‰ | 0.4V~2.4V | 0.8V~2.4V | ä¸ç¡®å®šæ€ï¼ˆä»¿çœŸç”¨ï¼‰ |

**ä¸ºä»€ä¹ˆéœ€è¦æ•°å­—ä¿¡å·ï¼Ÿ**

1. **æŠ—å¹²æ‰°èƒ½åŠ›å¼º**ï¼šåœ¨ä¸€å®šèŒƒå›´å†…çš„å™ªå£°ä¸ä¼šå½±å“é€»è¾‘å€¼è¯†åˆ«
2. **æ˜“äºé›†æˆ**ï¼šæ•°å­—ç”µè·¯ä¾¿äºé›†æˆåˆ°èŠ¯ç‰‡ä¸Š,æé«˜é›†æˆåº¦
3. **ä¾¿äºå¤„ç†**ï¼šæ˜“äºè¿›è¡Œå¤æ‚çš„é€»è¾‘è¿ç®—å’Œæ§åˆ¶
4. **æ˜“äºå­˜å‚¨**ï¼šå¯ä»¥é•¿æœŸç¨³å®šä¿å­˜ä¿¡æ¯

#### æ•°åˆ¶ä¸è½¬æ¢

**åè¿›åˆ¶åˆ°äºŒè¿›åˆ¶çš„è½¬æ¢æ–¹æ³•ï¼š**

æ•´æ•°éƒ¨åˆ†ï¼šé™¤2å–ä½™æ³•ï¼ˆä»ä¸‹å¾€ä¸Šè¯»ï¼‰
```
10è¿›åˆ¶ï¼š45
45 Ã· 2 = 22 ... 1
22 Ã· 2 = 11 ... 0
11 Ã· 2 = 5  ... 1
5  Ã· 2 = 2  ... 1
2  Ã· 2 = 1  ... 0
1  Ã· 2 = 0  ... 1
ç»“æœï¼š101101(äºŒè¿›åˆ¶) = 32+8+4+1 = 45
```

å°æ•°éƒ¨åˆ†ï¼šä¹˜2å–æ•´æ³•ï¼ˆä»ä¸Šå¾€ä¸‹è¯»ï¼‰
```
0.625 Ã— 2 = 1.25 â†’ å–1
0.25 Ã— 2 = 0.5  â†’ å–0
0.5 Ã— 2 = 1.0   â†’ å–1
ç»“æœï¼š0.101(äºŒè¿›åˆ¶) = 1/2 + 1/8 = 0.625
```

**åå…­è¿›åˆ¶çš„åº”ç”¨**ï¼š

ç”±äºäºŒè¿›åˆ¶ä¹¦å†™å†—é•¿,åœ¨ç”µè·¯è®¾è®¡ä¸­å¹¿æ³›ä½¿ç”¨åå…­è¿›åˆ¶:
- 1å­—èŠ‚ = 8ä½äºŒè¿›åˆ¶ = 2ä½åå…­è¿›åˆ¶
- ä¾¿äºæè¿°æ€»çº¿å®½åº¦ã€åœ°å€ã€æ•°æ®

```
äºŒè¿›åˆ¶ï¼š1111_0101_1010_0011
åå…­è¿›åˆ¶ï¼šF5A3
```

#### å®æˆ˜ï¼šæ•°åˆ¶è½¬æ¢éªŒè¯å·¥å…·

**Pythonè„šæœ¬å®ç°æ•°åˆ¶è½¬æ¢ï¼ˆdigital_convert.pyï¼‰ï¼š**

```python
#!/usr/bin/env python3
"""
æ•°å­—ç”µè·¯æ•°åˆ¶è½¬æ¢å·¥å…·
æ”¯æŒ 2/8/10/16 è¿›åˆ¶è½¬æ¢
"""

class DigitalConvert:
    @staticmethod
    def dec_to_bin(num, bits=8):
        """åè¿›åˆ¶è½¬äºŒè¿›åˆ¶"""
        if num < 0:
            # ä½¿ç”¨è¡¥ç è¡¨ç¤ºè´Ÿæ•°
            num = (1 << bits) + num
        return format(num, f'0{bits}b')

    @staticmethod
    def bin_to_dec(binary_str):
        """äºŒè¿›åˆ¶è½¬åè¿›åˆ¶"""
        return int(binary_str, 2)

    @staticmethod
    def hex_to_bin(hex_str):
        """åå…­è¿›åˆ¶è½¬äºŒè¿›åˆ¶"""
        hex_str = hex_str.replace('0x', '').replace('0X', '')
        return bin(int(hex_str, 16))[2:].zfill(len(hex_str) * 4)

    @staticmethod
    def bin_to_hex(binary_str):
        """äºŒè¿›åˆ¶è½¬åå…­è¿›åˆ¶"""
        decimal = int(binary_str, 2)
        return hex(decimal)[2:].upper()

    @staticmethod
    def print_conversion(value, source_base=10, target_bases=[2, 8, 10, 16]):
        """æ‰“å°å„è¿›åˆ¶è½¬æ¢ç»“æœ"""
        # å…ˆè½¬ä¸ºåè¿›åˆ¶
        if source_base == 10:
            decimal = value
        elif source_base == 2:
            decimal = int(str(value), 2)
        elif source_base == 16:
            decimal = int(str(value), 16)
        else:
            decimal = int(value, source_base)

        print(f"\nåŸå€¼: {value} (åŸºæ•°: {source_base})")
        print(f"åè¿›åˆ¶: {decimal}")

        for base in target_bases:
            if base == 2:
                print(f"äºŒè¿›åˆ¶: {bin(decimal)[2:]}")
            elif base == 8:
                print(f"å…«è¿›åˆ¶: {oct(decimal)[2:]}")
            elif base == 10:
                print(f"åè¿›åˆ¶: {decimal}")
            elif base == 16:
                print(f"åå…­è¿›åˆ¶: {hex(decimal)[2:].upper()}")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    conv = DigitalConvert()

    # ç¤ºä¾‹1: åè¿›åˆ¶åˆ°å…¶ä»–è¿›åˆ¶
    print("=" * 40)
    print("ç¤ºä¾‹1: åè¿›åˆ¶45è½¬æ¢")
    conv.print_conversion(45, source_base=10)

    # ç¤ºä¾‹2: åå…­è¿›åˆ¶åˆ°å…¶ä»–è¿›åˆ¶
    print("\n" + "=" * 40)
    print("ç¤ºä¾‹2: åå…­è¿›åˆ¶0xFFè½¬æ¢")
    conv.print_conversion("FF", source_base=16)

    # ç¤ºä¾‹3: äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºè´Ÿæ•°
    print("\n" + "=" * 40)
    print("ç¤ºä¾‹3: 8ä½äºŒè¿›åˆ¶è¡¨ç¤º")
    print(f"åè¿›åˆ¶ 45: {conv.dec_to_bin(45, bits=8)}")
    print(f"åè¿›åˆ¶ -45: {conv.dec_to_bin(-45, bits=8)}")
    print(f"è¡¥ç  11010011 è½¬åè¿›åˆ¶: {conv.bin_to_dec('11010011') - 256}")
```

### 1.2 é€»è¾‘é—¨ä¸åŸºæœ¬è¿ç®—

#### åŸºæœ¬é€»è¾‘é—¨

æ•°å­—ç”µè·¯ä¸­çš„æ‰€æœ‰å¤æ‚é€»è¾‘éƒ½ç”±åŸºæœ¬é€»è¾‘é—¨ç»„åˆè€Œæˆã€‚ç†è§£è¿™äº›é—¨ç”µè·¯çš„å·¥ä½œåŸç†æ˜¯æŒæ¡æ•°å­—ç”µè·¯çš„åŸºç¡€ã€‚

**ANDï¼ˆä¸ï¼‰é—¨**

| A | B | Y = AÂ·B |
|---|---|---------|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

ç‰¹æ€§ï¼šåªæœ‰å½“æ‰€æœ‰è¾“å…¥éƒ½ä¸º1æ—¶,è¾“å‡ºæ‰ä¸º1

åº”ç”¨åœºæ™¯ï¼š
- æ¡ä»¶æ§åˆ¶ï¼šä¸¤ä¸ªæ¡ä»¶éƒ½æ»¡è¶³æ‰æ‰§è¡Œæ“ä½œ
- ä½¿èƒ½ä¿¡å·ï¼šéœ€è¦å¤šä¸ªä½¿èƒ½æ¡ä»¶éƒ½æœ‰æ•ˆæ‰èƒ½å·¥ä½œ

**ORï¼ˆæˆ–ï¼‰é—¨**

| A | B | Y = A+B |
|---|---|---------|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

ç‰¹æ€§ï¼šåªè¦æœ‰ä¸€ä¸ªè¾“å…¥ä¸º1,è¾“å‡ºå°±ä¸º1

åº”ç”¨åœºæ™¯ï¼š
- ä¸­æ–­ä¿¡å·åˆå¹¶ï¼šä»»ä½•ä¸­æ–­æºéƒ½å¯ä»¥è§¦å‘ä¸­æ–­
- æŠ¥è­¦ç³»ç»Ÿï¼šä»»ä½•ä¼ æ„Ÿå™¨æŠ¥è­¦éƒ½å‘å‡ºè­¦æŠ¥

**XORï¼ˆå¼‚æˆ–ï¼‰é—¨**

| A | B | Y = AâŠ•B |
|---|---|----------|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

ç‰¹æ€§ï¼šè¾“å…¥ä¸åŒæ—¶è¾“å‡ºä¸º1ã€‚è¡¨è¾¾å¼ï¼šY = AÂ·BÌ„ + Ä€Â·B

åº”ç”¨åœºæ™¯ï¼š
- æ¯”è¾ƒï¼šåˆ¤æ–­ä¸¤ä¸ªä¿¡å·æ˜¯å¦ç›¸åŒ
- åŠ æ³•å™¨è®¾è®¡ï¼šä½œä¸ºåŠåŠ æ³•å™¨çš„æ ¸å¿ƒ
- å¥‡å¶æ ¡éªŒï¼šæ£€æµ‹æ•°æ®ä½æ˜¯å¦å‡ºç°ç¿»è½¬

#### å®æˆ˜ï¼šç”¨Verilogæè¿°åŸºæœ¬é€»è¾‘é—¨

**æ–‡ä»¶ï¼šsource/logic_gates.v**

```verilog
// æ•°å­—ç”µè·¯ - åŸºæœ¬é€»è¾‘é—¨æ¨¡å—
// æè¿°æ‰€æœ‰åŸºæœ¬é€»è¾‘é—¨çš„è¡Œä¸º

module logic_gates (
    input  wire a,
    input  wire b,
    output wire and_out,    // ANDè¾“å‡º
    output wire or_out,     // ORè¾“å‡º
    output wire not_a,      // NOT(A)
    output wire not_b,      // NOT(B)
    output wire nand_out,   // NANDè¾“å‡º
    output wire nor_out,    // NORè¾“å‡º
    output wire xor_out,    // XORè¾“å‡º
    output wire xnor_out    // XNORè¾“å‡º
);

    // åŸºæœ¬é—¨ç”µè·¯æè¿°
    assign and_out  = a & b;           // ä¸é—¨
    assign or_out   = a | b;           // æˆ–é—¨
    assign not_a    = ~a;              // éé—¨A
    assign not_b    = ~b;              // éé—¨B
    assign nand_out = ~(a & b);        // ä¸éé—¨
    assign nor_out  = ~(a | b);        // æˆ–éé—¨
    assign xor_out  = a ^ b;           // å¼‚æˆ–é—¨
    assign xnor_out = ~(a ^ b);        // åŒæˆ–é—¨

endmodule
```

### 1.3 å¸ƒå°”ä»£æ•°ä¸é€»è¾‘åŒ–ç®€

#### å¸ƒå°”ä»£æ•°çš„åŸºæœ¬å®šå¾‹

å¸ƒå°”ä»£æ•°æ˜¯æ•°å­—ç”µè·¯è®¾è®¡çš„æ•°å­¦åŸºç¡€,æŒæ¡è¿™äº›å®šå¾‹èƒ½å¤ŸåŒ–ç®€å¤æ‚çš„é€»è¾‘è¡¨è¾¾å¼,å‡å°‘æ‰€éœ€çš„é€»è¾‘é—¨æ•°é‡ã€‚

**åŸºæœ¬å®šå¾‹**

| å®šå¾‹åç§° | è¡¨è¾¾å¼ | éªŒè¯ä¾‹å­ |
|---------|--------|--------|
| äº¤æ¢å¾‹ | A+B = B+A; AÂ·B = BÂ·A | 3+5 = 5+3 |
| ç»“åˆå¾‹ | (A+B)+C = A+(B+C); (AÂ·B)Â·C = AÂ·(BÂ·C) | (1+2)+3 = 1+(2+3) |
| åˆ†é…å¾‹ | AÂ·(B+C) = AÂ·B + AÂ·C | 2Ã—(3+4) = 2Ã—3 + 2Ã—4 |
| å¸æ”¶å¾‹ | A + AÂ·B = A; AÂ·(A+B) = A | Aå·²ç»åŒ…å«AÂ·Bçš„æ‰€æœ‰æƒ…å†µ |
| ç›¸é‚»é¡¹æ¶ˆå» | AÂ·B + AÂ·BÌ„ = A | ä¸¤é¡¹ä»…ä¸€ä¸ªå˜é‡ä¸åŒ |
| å¹‚ç­‰å¾‹ | A+A = A; AÂ·A = A | 1+1 = 1, 2Ã—2 = 2 |
| äº’è¡¥å¾‹ | A + Ä€ = 1; AÂ·Ä€ = 0 | çœŸ+å‡ = çœŸ |
| å¯¹åˆå¾‹ | Ä€Ì„ = A | éé = æ’ç­‰ |
| å¾·æ‘©æ ¹å®šå¾‹ | (A+B)Ì„ = Ä€Â·BÌ„; (AÂ·B)Ì„ = Ä€+BÌ„ | é‡è¦ï¼ç”¨äºå˜æ¢ |

**å¾·æ‘©æ ¹å®šå¾‹è¯¦è§£**

å¾·æ‘©æ ¹å®šå¾‹æ˜¯é€»è¾‘åŒ–ç®€ä¸­æœ€é‡è¦çš„å®šå¾‹,å®ƒæä¾›äº†åœ¨ANDå’ŒORä¹‹é—´è½¬æ¢çš„æ–¹æ³•ã€‚

**ç¬¬ä¸€å½¢å¼ï¼š** (A+B)Ì„ = Ä€Â·BÌ„
å«ä¹‰ï¼šæ±‚å’Œçš„åç­‰äºå„é¡¹åçš„ç§¯

**ç¬¬äºŒå½¢å¼ï¼š** (AÂ·B)Ì„ = Ä€+BÌ„
å«ä¹‰ï¼šä¹˜ç§¯çš„åç­‰äºå„é¡¹åçš„å’Œ

---

## æ¨¡å—äºŒï¼šç»„åˆé€»è¾‘ç”µè·¯

### 2.1 åŠ æ³•å™¨è®¾è®¡

#### åŠåŠ æ³•å™¨ï¼ˆHalf Adderï¼‰

åŠåŠ æ³•å™¨æ˜¯æœ€åŸºæœ¬çš„ç®—æœ¯ç»„ä»¶,ç”¨äºä¸¤ä¸ªå•ä½äºŒè¿›åˆ¶æ•°ç›¸åŠ ã€‚

**å·¥ä½œåŸç†åˆ†æ**

| A | B | S(Sum) | Cy(Carry) |
|---|---|--------|-----------|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

**é€»è¾‘è¡¨è¾¾å¼**
- S = A âŠ• B = ABÌ„ + Ä€B
- Cy = AÂ·B

#### å…¨åŠ æ³•å™¨ï¼ˆFull Adderï¼‰

å…¨åŠ æ³•å™¨åœ¨åŠåŠ æ³•å™¨åŸºç¡€ä¸Šå¢åŠ äº†è¿›ä½è¾“å…¥ï¼ˆCinï¼‰,ä½¿å…¶å¯ä»¥çº§è”å¤„ç†å¤šä½åŠ æ³•ã€‚

**é€»è¾‘è¡¨è¾¾å¼**
- S = A âŠ• B âŠ• Cin
- Cout = AB + (A âŠ• B)Â·Cin = AB + ACin + BCin

#### å®æˆ˜ï¼šVerilogå®ç°å¤šä½åŠ æ³•å™¨

**æ–‡ä»¶ï¼šsource/adder.v**

```verilog
// æ•°å­—ç”µè·¯ - åŠ æ³•å™¨è®¾è®¡æ¨¡å—

// åŠåŠ æ³•å™¨ (Half Adder)
module half_adder (
    input  wire a,      // è¾“å…¥A
    input  wire b,      // è¾“å…¥B
    output wire sum,    // å’Œ
    output wire carry   // è¿›ä½
);

    assign sum   = a ^ b;      // å¼‚æˆ–ï¼šå’Œçš„ä½
    assign carry = a & b;      // ä¸ï¼šè¿›ä½

endmodule

// å…¨åŠ æ³•å™¨ (Full Adder)
module full_adder (
    input  wire a,      // è¾“å…¥A
    input  wire b,      // è¾“å…¥B
    input  wire cin,    // è¿›ä½è¾“å…¥
    output wire sum,    // å’Œ
    output wire cout    // è¿›ä½è¾“å‡º
);

    assign sum  = a ^ b ^ cin;
    assign cout = (a & b) | ((a ^ b) & cin);

endmodule

// Nä½è¡Œæ³¢è¿›ä½åŠ æ³•å™¨
module ripple_carry_adder #(
    parameter WIDTH = 8  // ä½å®½,é»˜è®¤8ä½
) (
    input  wire [WIDTH-1:0] a,      // ç¬¬ä¸€ä¸ªåŠ æ•°
    input  wire [WIDTH-1:0] b,      // ç¬¬äºŒä¸ªåŠ æ•°
    input  wire            cin,     // è¿›ä½è¾“å…¥
    output wire [WIDTH-1:0] sum,    // æ±‚å’Œç»“æœ
    output wire            cout     // è¿›ä½è¾“å‡º
);

    wire [WIDTH:0] carry;
    assign carry[0] = cin;

    genvar i;
    generate
        for (i = 0; i < WIDTH; i = i + 1) begin : adder_bits
            full_adder fa_i (
                .a(a[i]),
                .b(b[i]),
                .cin(carry[i]),
                .sum(sum[i]),
                .cout(carry[i+1])
            );
        end
    endgenerate

    assign cout = carry[WIDTH];

endmodule
```

### 2.2 å¤šè·¯é€‰æ‹©å™¨ä¸è¯‘ç å™¨

#### å¤šè·¯é€‰æ‹©å™¨ï¼ˆMultiplexerï¼‰

å¤šè·¯é€‰æ‹©å™¨æ˜¯ä¸€ä¸ªç»„åˆç”µè·¯,æ ¹æ®æ§åˆ¶ä¿¡å·é€‰æ‹©å¤šä¸ªè¾“å…¥ä¸­çš„ä¸€ä¸ªè¿›è¡Œè¾“å‡ºã€‚

**2é€‰1å¤šè·¯é€‰æ‹©å™¨**

| S | Y |
|---|---|
| 0 | I0 |
| 1 | I1 |

è¡¨è¾¾å¼ï¼šY = SÌ„Â·I0 + SÂ·I1

**4é€‰1å¤šè·¯é€‰æ‹©å™¨**

| S1 | S0 | Y |
|----|----|----|
| 0 | 0 | I0 |
| 0 | 1 | I1 |
| 1 | 0 | I2 |
| 1 | 1 | I3 |

#### è¯‘ç å™¨ï¼ˆDecoderï¼‰

è¯‘ç å™¨æ˜¯å¤šè·¯é€‰æ‹©å™¨çš„å¯¹å¶,ä¸€ä¸ªè¾“å…¥è¢«è¯‘ç ä¸ºå¤šä¸ªè¾“å‡ºä¸­çš„ä¸€ä¸ªæ¿€æ´»ã€‚

**3-8è¯‘ç å™¨**

è¾“å…¥ä¸º3ä½åœ°å€ç ,è¾“å‡ºä¸º8æ¡è¾“å‡ºçº¿,å…¶ä¸­ä¸€æ¡è¢«é€‰ä¸­ä¸º1,å…¶ä½™ä¸º0ã€‚

#### å®æˆ˜ï¼šVerilogå®ç°

**æ–‡ä»¶ï¼šsource/mux_decoder.v**

```verilog
// æ•°å­—ç”µè·¯ - å¤šè·¯é€‰æ‹©å™¨ä¸è¯‘ç å™¨

// 2é€‰1å¤šè·¯é€‰æ‹©å™¨
module mux2to1 (
    input  wire in0,
    input  wire in1,
    input  wire sel,
    output wire out
);

    assign out = sel ? in1 : in0;

endmodule

// 4é€‰1å¤šè·¯é€‰æ‹©å™¨
module mux4to1 (
    input  wire [3:0] in,
    input  wire [1:0] sel,
    output wire       out
);

    assign out = in[sel];

endmodule

// 3-8è¯‘ç å™¨
module decoder3to8 (
    input  wire [2:0] a,
    input  wire       enable,
    output wire [7:0] y
);

    assign y[0] = enable & ~a[2] & ~a[1] & ~a[0];
    assign y[1] = enable & ~a[2] & ~a[1] &  a[0];
    assign y[2] = enable & ~a[2] &  a[1] & ~a[0];
    assign y[3] = enable & ~a[2] &  a[1] &  a[0];
    assign y[4] = enable &  a[2] & ~a[1] & ~a[0];
    assign y[5] = enable &  a[2] & ~a[1] &  a[0];
    assign y[6] = enable &  a[2] &  a[1] & ~a[0];
    assign y[7] = enable &  a[2] &  a[1] &  a[0];

endmodule
```

### 2.3 ç®—æœ¯é€»è¾‘å•å…ƒï¼ˆALUï¼‰

#### ALUçš„åŸºæœ¬ç»“æ„

ç®—æœ¯é€»è¾‘å•å…ƒæ˜¯æ•°å­—ç³»ç»Ÿï¼ˆå°¤å…¶æ˜¯CPUï¼‰çš„æ ¸å¿ƒéƒ¨ä»¶,è´Ÿè´£æ‰§è¡Œç®—æœ¯è¿ç®—å’Œé€»è¾‘è¿ç®—ã€‚

**ç®—æœ¯è¿ç®—**ï¼šåŠ æ³•ã€å‡æ³•ã€ä¹˜æ³•ã€é™¤æ³•
**é€»è¾‘è¿ç®—**ï¼šANDã€ORã€XORã€NOT
**ç§»ä½è¿ç®—**ï¼šå·¦ç§»ã€å³ç§»ã€æ—‹è½¬

#### å®æˆ˜ï¼š8ä½ç®€åŒ–ALUè®¾è®¡

**æ–‡ä»¶ï¼šsource/alu.v**

```verilog
// æ•°å­—ç”µè·¯ - ç®—æœ¯é€»è¾‘å•å…ƒ(ALU)

// 8ä½ç®€åŒ–ALU
module alu_8bit (
    input  wire [7:0] a,
    input  wire [7:0] b,
    input  wire [3:0] operation,
    output reg  [7:0] result,
    output wire       zero_flag,
    output wire       carry_flag,
    output wire       overflow_flag
);

    wire [8:0] adder_result;
    wire [8:0] sub_result;

    assign adder_result = a + b;
    assign sub_result = a - b;

    always @(*) begin
        case(operation)
            4'b0000: result = adder_result[7:0];         // åŠ æ³•
            4'b0001: result = sub_result[7:0];           // å‡æ³•
            4'b0010: result = a & b;                     // ä¸
            4'b0011: result = a | b;                     // æˆ–
            4'b0100: result = a ^ b;                     // å¼‚æˆ–
            4'b0101: result = ~a;                        // Açš„å
            4'b0110: result = ~b;                        // Bçš„å
            4'b0111: result = {a[6:0], 1'b0};            // å·¦ç§»1ä½
            4'b1000: result = {1'b0, a[7:1]};            // å³ç§»1ä½
            4'b1001: result = {a[6:0], a[7]};            // å¾ªç¯å·¦ç§»
            4'b1010: result = {a[0], a[7:1]};            // å¾ªç¯å³ç§»
            default: result = 8'h00;
        endcase
    end

    assign zero_flag = (result == 8'h00) ? 1'b1 : 1'b0;
    assign carry_flag = adder_result[8];
    assign overflow_flag = (operation == 4'b0000) ?
                          ((a[7] == b[7]) && (a[7] != result[7])) :
                          1'b0;

endmodule
```

---

## æ¨¡å—ä¸‰ï¼šæ—¶åºé€»è¾‘ç”µè·¯

### 3.1 é”å­˜å™¨ä¸è§¦å‘å™¨

#### é”å­˜å™¨ï¼ˆLatchï¼‰

é”å­˜å™¨æ˜¯å…·æœ‰è®°å¿†åŠŸèƒ½çš„ç»„åˆé€»è¾‘,èƒ½å¤Ÿä¿æŒè¾“å…¥ä¿¡å·çš„çŠ¶æ€ã€‚

**SRé”å­˜å™¨ï¼ˆç”¨NORé—¨æ„æˆï¼‰**

| S(Set) | R(Reset) | Qn+1 | QÌ„n+1 | è¯´æ˜ |
|--------|----------|------|------|------|
| 0 | 0 | Qn | QÌ„n | ä¿æŒçŠ¶æ€ |
| 0 | 1 | 0 | 1 | å¤ä½ |
| 1 | 0 | 1 | 0 | ç½®ä½ |
| 1 | 1 | 0 | 0 | **ç¦æ­¢æ€** |

#### è§¦å‘å™¨ï¼ˆFlip-Flopï¼‰

è§¦å‘å™¨æ˜¯æ—¶é’Ÿæ§åˆ¶çš„å­˜å‚¨å…ƒä»¶,åªåœ¨æ—¶é’Ÿçš„ç‰¹å®šè¾¹æ²¿ï¼ˆä¸Šå‡æ²¿æˆ–ä¸‹é™æ²¿ï¼‰å¯¹è¾“å…¥è¿›è¡Œé‡‡æ ·ã€‚

**Dè§¦å‘å™¨**

æœ€å¸¸ç”¨çš„è§¦å‘å™¨ç±»å‹,é€šå¸¸é‡‡ç”¨ä¸»ä»ç»“æ„å®ç°ã€‚

çœŸå€¼è¡¨ï¼ˆä¸Šå‡æ²¿è§¦å‘ï¼‰ï¼š

| æ—¶åˆ» | D | Qn+1 |
|------|---|------|
| ä¸Šå‡æ²¿ | 0 | 0 |
| ä¸Šå‡æ²¿ | 1 | 1 |
| å…¶ä»–æ—¶åˆ» | - | Qn |

#### å®æˆ˜ï¼šVerilogå®ç°è§¦å‘å™¨

**æ–‡ä»¶ï¼šsource/flip_flops.v**

```verilog
// æ•°å­—ç”µè·¯ - è§¦å‘å™¨è®¾è®¡

// Dé”å­˜å™¨ï¼ˆå¸¦ä½¿èƒ½ä¿¡å·ï¼‰
module d_latch (
    input  wire d,
    input  wire enable,
    output reg  q,
    output wire qb
);

    assign qb = ~q;

    always @(*) begin
        if (enable)
            q = d;
    end

endmodule

// Dè§¦å‘å™¨ï¼ˆä¸Šå‡æ²¿è§¦å‘ï¼‰
module d_flip_flop (
    input  wire d,
    input  wire clock,
    input  wire reset_n,
    output reg  q,
    output wire qb
);

    assign qb = ~q;

    always @(posedge clock or negedge reset_n) begin
        if (!reset_n)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule

// JKè§¦å‘å™¨
module jk_flip_flop (
    input  wire j,
    input  wire k,
    input  wire clock,
    input  wire reset_n,
    output reg  q,
    output wire qb
);

    assign qb = ~q;

    always @(posedge clock or negedge reset_n) begin
        if (!reset_n)
            q <= 1'b0;
        else begin
            case ({j, k})
                2'b00: q <= q;
                2'b01: q <= 1'b0;
                2'b10: q <= 1'b1;
                2'b11: q <= ~q;
            endcase
        end
    end

endmodule

// Tè§¦å‘å™¨ï¼ˆè®¡æ•°è§¦å‘å™¨ï¼‰
module t_flip_flop (
    input  wire t,
    input  wire clock,
    input  wire reset_n,
    output reg  q,
    output wire qb
);

    assign qb = ~q;

    always @(posedge clock or negedge reset_n) begin
        if (!reset_n)
            q <= 1'b0;
        else if (t)
            q <= ~q;
        else
            q <= q;
    end

endmodule
```

### 3.2 è®¡æ•°å™¨è®¾è®¡

#### äºŒè¿›åˆ¶è®¡æ•°å™¨

æœ€åŸºæœ¬çš„è®¡æ•°å™¨æ˜¯ç”¨Tè§¦å‘å™¨çº§è”æ„æˆçš„äºŒè¿›åˆ¶å¢è®¡æ•°å™¨ã€‚

**4ä½äºŒè¿›åˆ¶è®¡æ•°å™¨å·¥ä½œåŸç†**

```
åˆå§‹å€¼ï¼šQ3 Q2 Q1 Q0 = 0000
ç¬¬1ä¸ªæ—¶é’Ÿè„‰å†²ï¼š0001
ç¬¬2ä¸ªæ—¶é’Ÿè„‰å†²ï¼š0010
ç¬¬3ä¸ªæ—¶é’Ÿè„‰å†²ï¼š0011
...
ç¬¬16ä¸ªæ—¶é’Ÿè„‰å†²ï¼š0000ï¼ˆæº¢å‡º,å›åˆ°0ï¼‰
```

#### å®æˆ˜ï¼šè®¾è®¡å¯é…ç½®çš„è®¡æ•°å™¨

**æ–‡ä»¶ï¼šsource/counter.v**

```verilog
// æ•°å­—ç”µè·¯ - è®¡æ•°å™¨è®¾è®¡

// Nä½äºŒè¿›åˆ¶å¢è®¡æ•°å™¨
module binary_counter #(
    parameter WIDTH = 4,
    parameter MAX = 15
) (
    input  wire                 clock,
    input  wire                 reset_n,
    input  wire                 enable,
    output wire [WIDTH-1:0]     count,
    output wire                 overflow
);

    reg [WIDTH-1:0] counter;

    assign count = counter;
    assign overflow = (counter == MAX) ? 1'b1 : 1'b0;

    always @(posedge clock or negedge reset_n) begin
        if (!reset_n)
            counter <= {WIDTH{1'b0}};
        else if (enable) begin
            if (counter == MAX)
                counter <= {WIDTH{1'b0}};
            else
                counter <= counter + 1;
        end
    end

endmodule

// åè¿›åˆ¶è®¡æ•°å™¨ï¼ˆ0-9ï¼‰
module decimal_counter (
    input  wire         clock,
    input  wire         reset_n,
    input  wire         enable,
    output wire [3:0]   count,
    output wire         overflow
);

    reg [3:0] counter;

    assign count = counter;
    assign overflow = enable & (counter == 4'b1001);

    always @(posedge clock or negedge reset_n) begin
        if (!reset_n)
            counter <= 4'b0000;
        else if (enable) begin
            if (counter == 4'b1001)
                counter <= 4'b0000;
            else
                counter <= counter + 1;
        end
    end

endmodule

// å¯é…ç½®çš„æ¨¡Nè®¡æ•°å™¨
module modulo_n_counter #(
    parameter WIDTH = 4,
    parameter MODULUS = 10
) (
    input  wire                     clock,
    input  wire                     reset_n,
    input  wire                     enable,
    output wire [WIDTH-1:0]         count,
    output wire                     terminal_count
);

    reg [WIDTH-1:0] counter;

    assign count = counter;
    assign terminal_count = (counter == (MODULUS - 1));

    always @(posedge clock or negedge reset_n) begin
        if (!reset_n)
            counter <= {WIDTH{1'b0}};
        else if (enable) begin
            if (counter == (MODULUS - 1))
                counter <= {WIDTH{1'b0}};
            else
                counter <= counter + 1;
        end
    end

endmodule
```

### 3.3 æœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰

#### çŠ¶æ€æœºåŸºç¡€

æœ‰é™çŠ¶æ€æœºæ˜¯æ—¶åºé€»è¾‘ç”µè·¯çš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼,å¹¿æ³›åº”ç”¨äºæ§åˆ¶ç³»ç»Ÿã€é€šä¿¡åè®®ã€æ•°å­—ä¿¡å·å¤„ç†ç­‰é¢†åŸŸã€‚

**çŠ¶æ€æœºçš„ä¸‰è¦ç´ ï¼š**
1. **çŠ¶æ€é›†åˆ**ï¼šç³»ç»Ÿå¯èƒ½å¤„äºçš„æ‰€æœ‰çŠ¶æ€
2. **è¾“å…¥é›†åˆ**ï¼šå½±å“çŠ¶æ€è½¬æ¢çš„è¾“å…¥ä¿¡å·
3. **è½¬ç§»å‡½æ•°**ï¼šå®šä¹‰çŠ¶æ€å¦‚ä½•æ ¹æ®è¾“å…¥è½¬æ¢

**çŠ¶æ€æœºåˆ†ç±»ï¼š**

| ç±»å‹ | æè¿° | è¾“å‡ºç‰¹ç‚¹ |
|------|------|---------|
| **Mooreå‹** | è¾“å‡ºåªä¾èµ–äºå½“å‰çŠ¶æ€ | è¾“å‡ºç¨³å®š,æ— æ¯›åˆº |
| **Mealyå‹** | è¾“å‡ºä¾èµ–äºå½“å‰çŠ¶æ€å’Œè¾“å…¥ | å“åº”å¿«,å¯èƒ½æœ‰æ¯›åˆº |

#### çŠ¶æ€æœºè®¾è®¡æ–¹æ³•

**ä¸‰æ®µå¼çŠ¶æ€æœºï¼ˆæ¨èï¼‰ï¼š**

```verilog
// ç¬¬ä¸€æ®µï¼šçŠ¶æ€å¯„å­˜å™¨ï¼ˆæ—¶åºé€»è¾‘ï¼‰
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        current_state <= IDLE;
    else
        current_state <= next_state;
end

// ç¬¬äºŒæ®µï¼šä¸‹ä¸€çŠ¶æ€é€»è¾‘ï¼ˆç»„åˆé€»è¾‘ï¼‰
always @(*) begin
    case(current_state)
        IDLE: begin
            if (start)
                next_state = PROCESS;
            else
                next_state = IDLE;
        end
        PROCESS: begin
            if (done)
                next_state = FINISH;
            else
                next_state = PROCESS;
        end
        FINISH: begin
            next_state = IDLE;
        end
        default: next_state = IDLE;
    endcase
end

// ç¬¬ä¸‰æ®µï¼šè¾“å‡ºé€»è¾‘ï¼ˆç»„åˆæˆ–æ—¶åºï¼‰
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        output_signal <= 1'b0;
    else begin
        case(current_state)
            IDLE: output_signal <= 1'b0;
            PROCESS: output_signal <= 1'b1;
            FINISH: output_signal <= 1'b0;
            default: output_signal <= 1'b0;
        endcase
    end
end
```

#### å®æˆ˜ï¼šè‡ªåŠ¨å”®è´§æœºæ§åˆ¶å™¨

**è®¾è®¡éœ€æ±‚ï¼š**
- å•†å“ä»·æ ¼ï¼š50åˆ†
- æ¥å—ç¡¬å¸ï¼š10åˆ†ã€25åˆ†
- æ‰¾é›¶åŠŸèƒ½ï¼šé€€è¿˜å¤šä½™ç¡¬å¸

**çŠ¶æ€å®šä¹‰ï¼š**
- IDLEï¼šç­‰å¾…æŠ•å¸ï¼ˆç´¯è®¡é‡‘é¢=0ï¼‰
- AMOUNT_10ï¼šå·²æŠ•10åˆ†
- AMOUNT_20ï¼šå·²æŠ•20åˆ†
- AMOUNT_25ï¼šå·²æŠ•25åˆ†
- AMOUNT_35ï¼šå·²æŠ•35åˆ†
- AMOUNT_45ï¼šå·²æŠ•45åˆ†
- DISPENSEï¼šå‡ºè´§å¹¶æ‰¾é›¶

**æ–‡ä»¶ï¼šsource/vending_machine.v**

```verilog
// è‡ªåŠ¨å”®è´§æœºçŠ¶æ€æœºè®¾è®¡

module vending_machine (
    input  wire       clk,
    input  wire       rst_n,
    input  wire       coin_10,    // æŠ•å…¥10åˆ†ç¡¬å¸
    input  wire       coin_25,    // æŠ•å…¥25åˆ†ç¡¬å¸
    output reg        dispense,   // å‡ºè´§ä¿¡å·
    output reg  [1:0] change,     // æ‰¾é›¶ï¼ˆ00=0åˆ†, 01=10åˆ†, 10=20åˆ†ï¼‰
    output reg  [5:0] amount      // å½“å‰ç´¯è®¡é‡‘é¢
);

    // çŠ¶æ€å®šä¹‰
    localparam IDLE       = 3'd0;
    localparam AMOUNT_10  = 3'd1;
    localparam AMOUNT_20  = 3'd2;
    localparam AMOUNT_25  = 3'd3;
    localparam AMOUNT_35  = 3'd4;
    localparam AMOUNT_45  = 3'd5;
    localparam DISPENSE   = 3'd6;

    reg [2:0] current_state, next_state;

    // çŠ¶æ€å¯„å­˜å™¨
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= IDLE;
        else
            current_state <= next_state;
    end

    // ä¸‹ä¸€çŠ¶æ€é€»è¾‘
    always @(*) begin
        case(current_state)
            IDLE: begin
                if (coin_10)
                    next_state = AMOUNT_10;
                else if (coin_25)
                    next_state = AMOUNT_25;
                else
                    next_state = IDLE;
            end

            AMOUNT_10: begin
                if (coin_10)
                    next_state = AMOUNT_20;
                else if (coin_25)
                    next_state = AMOUNT_35;
                else
                    next_state = AMOUNT_10;
            end

            AMOUNT_20: begin
                if (coin_10)
                    next_state = AMOUNT_35;  // ä¿®æ­£ï¼š20+10=30,ä½†è·³åˆ°35çŠ¶æ€ä¾¿äºç®¡ç†
                else if (coin_25)
                    next_state = AMOUNT_45;
                else
                    next_state = AMOUNT_20;
            end

            AMOUNT_25: begin
                if (coin_10)
                    next_state = AMOUNT_35;
                else if (coin_25)
                    next_state = DISPENSE;  // 50åˆ†,ç›´æ¥å‡ºè´§
                else
                    next_state = AMOUNT_25;
            end

            AMOUNT_35: begin
                if (coin_10)
                    next_state = AMOUNT_45;
                else if (coin_25)
                    next_state = DISPENSE;  // 60åˆ†,å‡ºè´§å¹¶æ‰¾é›¶
                else
                    next_state = AMOUNT_35;
            end

            AMOUNT_45: begin
                if (coin_10 || coin_25)
                    next_state = DISPENSE;  // è¾¾åˆ°50åˆ†ä»¥ä¸Š
                else
                    next_state = AMOUNT_45;
            end

            DISPENSE: begin
                next_state = IDLE;  // å‡ºè´§åå›åˆ°åˆå§‹çŠ¶æ€
            end

            default: next_state = IDLE;
        endcase
    end

    // è¾“å‡ºé€»è¾‘
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            dispense <= 1'b0;
            change <= 2'b00;
            amount <= 6'd0;
        end else begin
            case(current_state)
                IDLE: begin
                    dispense <= 1'b0;
                    change <= 2'b00;
                    amount <= 6'd0;
                end

                AMOUNT_10: begin
                    dispense <= 1'b0;
                    amount <= 6'd10;
                end

                AMOUNT_20: begin
                    dispense <= 1'b0;
                    amount <= 6'd20;
                end

                AMOUNT_25: begin
                    dispense <= 1'b0;
                    amount <= 6'd25;
                end

                AMOUNT_35: begin
                    dispense <= 1'b0;
                    amount <= 6'd35;
                end

                AMOUNT_45: begin
                    dispense <= 1'b0;
                    amount <= 6'd45;
                end

                DISPENSE: begin
                    dispense <= 1'b1;
                    // è®¡ç®—æ‰¾é›¶
                    if (amount == 6'd50)
                        change <= 2'b00;  // ä¸æ‰¾é›¶
                    else if (amount == 6'd55 || amount == 6'd60)
                        change <= 2'b01;  // æ‰¾10åˆ†
                    else if (amount >= 6'd65)
                        change <= 2'b10;  // æ‰¾20åˆ†
                    else
                        change <= 2'b00;
                end

                default: begin
                    dispense <= 1'b0;
                    change <= 2'b00;
                    amount <= 6'd0;
                end
            endcase
        end
    end

endmodule
```

**æ–‡ä»¶ï¼štestbench/vending_machine_tb.v**

```verilog
// è‡ªåŠ¨å”®è´§æœºæµ‹è¯•å¹³å°

module vending_machine_tb;

    reg clk, rst_n;
    reg coin_10, coin_25;
    wire dispense;
    wire [1:0] change;
    wire [5:0] amount;

    // æ—¶é’Ÿç”Ÿæˆ
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    // å®ä¾‹åŒ–å”®è´§æœº
    vending_machine vm (
        .clk(clk),
        .rst_n(rst_n),
        .coin_10(coin_10),
        .coin_25(coin_25),
        .dispense(dispense),
        .change(change),
        .amount(amount)
    );

    initial begin
        $dumpfile("simulation/vending_machine.vcd");
        $dumpvars(0, vending_machine_tb);

        $display("\n========== è‡ªåŠ¨å”®è´§æœºæµ‹è¯• ==========");

        // åˆå§‹åŒ–
        rst_n = 0;
        coin_10 = 0;
        coin_25 = 0;
        #20;
        rst_n = 1;

        // æµ‹è¯•åœºæ™¯1ï¼šæŠ•å…¥2ä¸ª25åˆ†ç¡¬å¸ï¼ˆæ­£å¥½50åˆ†ï¼‰
        $display("\nåœºæ™¯1ï¼šæŠ•å…¥2ä¸ª25åˆ†ç¡¬å¸");
        #10; coin_25 = 1;
        #10; coin_25 = 0;
        #10; coin_25 = 1;
        #10; coin_25 = 0;
        #20;
        $display("å‡ºè´§ï¼š%b, æ‰¾é›¶ï¼š%dåˆ†, ç´¯è®¡ï¼š%dåˆ†", dispense, change*10, amount);

        // æµ‹è¯•åœºæ™¯2ï¼šæŠ•å…¥5ä¸ª10åˆ†ç¡¬å¸ï¼ˆæ­£å¥½50åˆ†ï¼‰
        $display("\nåœºæ™¯2ï¼šæŠ•å…¥5ä¸ª10åˆ†ç¡¬å¸");
        #20;
        repeat(5) begin
            coin_10 = 1;
            #10;
            coin_10 = 0;
            #10;
        end
        #20;
        $display("å‡ºè´§ï¼š%b, æ‰¾é›¶ï¼š%dåˆ†", dispense, change*10);

        // æµ‹è¯•åœºæ™¯3ï¼šæŠ•å…¥60åˆ†ï¼ˆéœ€è¦æ‰¾é›¶10åˆ†ï¼‰
        $display("\nåœºæ™¯3ï¼šæŠ•å…¥60åˆ†ï¼ˆéœ€æ‰¾é›¶ï¼‰");
        #20;
        coin_25 = 1; #10; coin_25 = 0;
        #10;
        coin_10 = 1; #10; coin_10 = 0;
        #10;
        coin_25 = 1; #10; coin_25 = 0;
        #20;
        $display("å‡ºè´§ï¼š%b, æ‰¾é›¶ï¼š%dåˆ†", dispense, change*10);

        #50;
        $finish;
    end

endmodule
```

---

## æ¨¡å—å››ï¼šç¡¬ä»¶æè¿°è¯­è¨€ä¸ä»¿çœŸ

### 4.1 VerilogåŸºç¡€è¯­æ³•

#### Verilogçš„è®¾è®¡ç»“æ„

Verilogä»£ç çš„åŸºæœ¬æ¡†æ¶åŒ…æ‹¬ä¸‰ä¸ªä¸»è¦éƒ¨åˆ†ï¼šæ¨¡å—å®šä¹‰ã€ç«¯å£å£°æ˜å’Œå†…éƒ¨é€»è¾‘å®ç°ã€‚

```verilog
module module_name (
    // ç«¯å£å£°æ˜
    input   wire    clk,
    output  reg     data_out
);

    // å†…éƒ¨ä¿¡å·å’Œå‚æ•°å£°æ˜
    reg    [7:0]    internal_reg;
    wire   [3:0]    internal_wire;

    // åˆå§‹å—ï¼ˆä»¿çœŸç”¨ï¼‰
    initial begin
        // åˆå§‹åŒ–æ“ä½œ
    end

    // æ—¶é’Ÿæ•æ„Ÿå—
    always @(posedge clk) begin
        // æ—¶åºé€»è¾‘
    end

    // ç»„åˆé€»è¾‘ï¼ˆè¿ç»­èµ‹å€¼ï¼‰
    assign internal_wire = internal_reg[3:0];

endmodule
```

#### æ•°æ®ç±»å‹

| ç±»å‹ | è¯´æ˜ | ç”¨é€” |
|------|------|------|
| **wire** | ç»„åˆé€»è¾‘è¿æ¥,ä¸ä¿å­˜å€¼ | ç»„åˆé€»è¾‘çš„è¾“å…¥ã€è¾“å‡ºã€å†…éƒ¨è¿æ¥ |
| **reg** | é¡ºåºé€»è¾‘å­˜å‚¨,å¯åœ¨alwayså—ä¸­èµ‹å€¼ | æ—¶åºé€»è¾‘ã€è®¡æ•°å™¨ã€å¯„å­˜å™¨ |
| **input** | æ¨¡å—è¾“å…¥ç«¯å£ | æ¥æ”¶å¤–éƒ¨ä¿¡å· |
| **output** | æ¨¡å—è¾“å‡ºç«¯å£ | è¾“å‡ºå†…éƒ¨ä¿¡å· |
| **parameter** | å‚æ•°å¸¸é‡ | å‚æ•°åŒ–æ¨¡å— |
| **localparam** | å±€éƒ¨å‚æ•°å¸¸é‡ | ä»…åœ¨æ¨¡å—å†…ä½¿ç”¨ |

#### è¿ç®—ç¬¦

| è¿ç®—ç¬¦ | è¯´æ˜ | ä¾‹å­ |
|--------|------|------|
| `+, -, *, /` | ç®—æœ¯è¿ç®— | `a + b` |
| `&, \|, ^, ~` | æŒ‰ä½è¿ç®— | `a & b` |
| `&&, \|\|, !` | é€»è¾‘è¿ç®— | `(a > b) && (c < d)` |
| `<<, >>` | ç§»ä½è¿ç®— | `data << 1` |
| `==, !=, <, >` | æ¯”è¾ƒè¿ç®— | `count == 10` |
| `?:` | ä¸‰å…ƒè¿ç®—ç¬¦ | `sel ? in1 : in0` |
| `{,}` | æ‹¼æ¥è¿ç®—ç¬¦ | `{high_byte, low_byte}` |

#### èµ‹å€¼æ–¹å¼

**1. è¿ç»­èµ‹å€¼ï¼ˆç”¨äºç»„åˆé€»è¾‘ï¼‰**

```verilog
assign output_signal = input_a & input_b;
```

**2. å—èµ‹å€¼ï¼ˆç”¨äºæ—¶åºé€»è¾‘ï¼‰**

```verilog
always @(posedge clk) begin
    q <= d;             // éé˜»å¡èµ‹å€¼ï¼ˆæ—¶åºé€»è¾‘æ¨èï¼‰
end

always @(*) begin
    out = in1 | in2;    // é˜»å¡èµ‹å€¼ï¼ˆç»„åˆé€»è¾‘æ¨èï¼‰
end
```

### 4.2 Testbenchç¼–å†™ä¸ä»¿çœŸéªŒè¯

#### Testbenchçš„åŸºæœ¬ç»“æ„

```verilog
module stimulus_module_testbench;

    // å®šä¹‰ä»¿çœŸä¿¡å·
    reg  input_signal;
    wire output_signal;

    // å®ä¾‹åŒ–è¢«æµ‹è¯•æ¨¡å—
    module_under_test dut (
        .input(input_signal),
        .output(output_signal)
    );

    // ç”Ÿæˆæ¿€åŠ±ä¿¡å·
    initial begin
        // VCDæ³¢å½¢æ–‡ä»¶
        $dumpfile("waveform.vcd");
        $dumpvars(0, stimulus_module_testbench);

        // æµ‹è¯•æ¿€åŠ±åºåˆ—
        input_signal = 1'b0;
        #10;
        input_signal = 1'b1;
        #10;

        $display("ä»¿çœŸå®Œæˆ");
        $finish;
    end

endmodule
```

#### ç³»ç»Ÿä»»åŠ¡ä¸å‡½æ•°

| ç³»ç»Ÿä»»åŠ¡ | åŠŸèƒ½ | ç¤ºä¾‹ |
|---------|------|------|
| `$display` | æ˜¾ç¤ºä¿¡æ¯ | `$display("Value = %d", var);` |
| `$monitor` | ç›‘æ§å˜é‡å˜åŒ– | `$monitor("Time=%t, data=%h", $time, data);` |
| `$dumpfile` | æŒ‡å®šæ³¢å½¢æ–‡ä»¶ | `$dumpfile("wave.vcd");` |
| `$dumpvars` | æŒ‡å®šè®°å½•å˜é‡ | `$dumpvars(0, testbench);` |
| `$time` | å½“å‰ä»¿çœŸæ—¶é—´ | `$display("Time=%t", $time);` |
| `$random` | ç”Ÿæˆéšæœºæ•° | `data = $random % 256;` |
| `$finish` | ç»“æŸä»¿çœŸ | `$finish;` |
| `$stop` | æš‚åœä»¿çœŸ | `$stop;` |

---

## æ¨¡å—äº”ï¼šFPGAè®¾è®¡å®æˆ˜

### 5.1 FPGAå¼€å‘æµç¨‹

#### å…¸å‹çš„FPGAè®¾è®¡æµç¨‹

```
1. è®¾è®¡è§„æ ¼   â†’ ç¡®å®šåŠŸèƒ½éœ€æ±‚ã€æ€§èƒ½æŒ‡æ ‡ã€æ¥å£å®šä¹‰
                â†“
2. RTLè®¾è®¡    â†’ ç”¨Verilog/VHDLæè¿°ç¡¬ä»¶é€»è¾‘
                â†“
3. åŠŸèƒ½ä»¿çœŸ   â†’ éªŒè¯é€»è¾‘æ­£ç¡®æ€§
                â†“
4. ç»¼åˆ       â†’ å°†RTLè½¬æ¢ä¸ºé—¨çº§ç”µè·¯
                â†“
5. å¸ƒå±€å¸ƒçº¿   â†’ å°†é—¨çº§ç”µè·¯æ˜ å°„åˆ°FPGAç‰©ç†èµ„æº
                â†“
6. æ—¶åºåˆ†æ   â†’ æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ—¶åºçº¦æŸ
                â†“
7. ç”Ÿæˆé…ç½®æ–‡ä»¶ â†’ ç”Ÿæˆæ¯”ç‰¹æµæ–‡ä»¶
                â†“
8. ä¸‹è½½é…ç½®    â†’ å°†æ¯”ç‰¹æµä¸‹è½½åˆ°FPGA
                â†“
9. ç¡¬ä»¶æµ‹è¯•    â†’ åœ¨å®é™…ç¡¬ä»¶ä¸ŠéªŒè¯åŠŸèƒ½
```

#### çº¦æŸæ–‡ä»¶ï¼ˆXDCï¼‰

çº¦æŸæ–‡ä»¶å®šä¹‰äº†é€»è¾‘ä¿¡å·ä¸FPGAç‰©ç†å¼•è„šçš„å¯¹åº”å…³ç³»ä»¥åŠæ—¶åºè¦æ±‚ã€‚

**XDCçº¦æŸæ–‡ä»¶ç¤ºä¾‹ï¼ˆXilinxï¼‰ï¼š**

```tcl
# æ—¶é’Ÿçº¦æŸ
create_clock -period 10 -name clk [get_ports clk]

# ç«¯å£ä½ç½®çº¦æŸ
set_property PACKAGE_PIN P13 [get_ports clk]
set_property PACKAGE_PIN D19 [get_ports rst]
set_property PACKAGE_PIN G19 [get_ports led0]
set_property PACKAGE_PIN J19 [get_ports led1]

# IOç”µå‹æ ‡å‡†
set_property IOSTANDARD LVCMOS33 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports rst]
set_property IOSTANDARD LVCMOS33 [get_ports led*]

# æ—¶åºçº¦æŸ
set_false_path -from [get_ports rst]
```

### 5.2 å®æˆ˜é¡¹ç›®ï¼šLEDé—ªçƒæ§åˆ¶ç³»ç»Ÿ

#### é¡¹ç›®éœ€æ±‚

è®¾è®¡ä¸€ä¸ªLEDé—ªçƒæ§åˆ¶ç³»ç»Ÿ,èƒ½å¤Ÿäº§ç”Ÿå¯é…ç½®çš„é—ªçƒé¢‘ç‡å’Œå ç©ºæ¯”ã€‚

**åŠŸèƒ½è§„æ ¼**
- è¾“å…¥æ—¶é’Ÿï¼š100MHz
- è¾“å‡ºï¼šæ§åˆ¶LEDçš„ä¿¡å·
- é—ªçƒé¢‘ç‡èŒƒå›´ï¼š1Hz ~ 10Hzï¼ˆå¯é…ç½®ï¼‰
- å ç©ºæ¯”ï¼šå¯è°ƒï¼ˆé»˜è®¤50%ï¼‰

**æ–‡ä»¶ï¼šsource/led_blinker.v**

```verilog
// LEDé—ªçƒæ§åˆ¶å™¨

module led_blinker #(
    parameter CLK_FREQ = 100_000_000,
    parameter BLINK_FREQ = 1
) (
    input  wire         clk,
    input  wire         rst_n,
    output wire         led_out
);

    localparam HALF_PERIOD = CLK_FREQ / (2 * BLINK_FREQ);
    localparam COUNTER_WIDTH = $clog2(HALF_PERIOD);

    reg [COUNTER_WIDTH:0] counter;
    reg led_state;

    assign led_out = led_state;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            counter <= 0;
            led_state <= 1'b0;
        end else begin
            if (counter == (HALF_PERIOD - 1)) begin
                counter <= 0;
                led_state <= ~led_state;
            end else begin
                counter <= counter + 1;
            end
        end
    end

endmodule
```

### 5.3 FPGAè®¾è®¡æœ€ä½³å®è·µ

#### æ—¶åºè®¾è®¡åŸåˆ™

1. **åŒæ­¥è®¾è®¡**
   - æ‰€æœ‰å¯„å­˜å™¨åœ¨åŒä¸€æ—¶é’ŸåŸŸä¸­
   - é¿å…å¼‚æ­¥ä¿¡å·ç›´æ¥è¿›å…¥å…³é”®é€»è¾‘

2. **æ—¶é’Ÿçº¦æŸ**
   ```tcl
   create_clock -period 10 -name sys_clk [get_ports clk]
   set_false_path -from [get_ports async_reset]
   ```

3. **ç®¡é“è®¾è®¡**
   ```verilog
   always @(posedge clk) begin
       result1 <= input1 + input2;
       result2 <= result1 * coefficient;
   end
   ```

#### åŠŸè€—ä¼˜åŒ–

1. **æ—¶é’Ÿé—¨æ§**
   ```verilog
   wire gated_clock;
   assign gated_clock = clock & enable;
   ```

2. **ä½åŠŸè€—è®¾è®¡æ¨¡å¼**
   ```verilog
   always @(posedge clk) begin
       if (idle_counter == MAX_IDLE) begin
           power_mode <= LOW_POWER;
       end
   end
   ```

---

## æ¨¡å—å…­ï¼šé«˜çº§ä¸»é¢˜ä¸ç³»ç»Ÿè®¾è®¡

### 6.1 æ€»çº¿è®¾è®¡ä¸æ¥å£åè®®

#### APBæ€»çº¿ï¼ˆAdvanced Peripheral Busï¼‰

APBæ˜¯ARMå…¬å¸å®šä¹‰çš„ä½é€Ÿå¤–è®¾æ€»çº¿,å¹¿æ³›ç”¨äºSoCè®¾è®¡ä¸­çš„å¤–è®¾æ¥å£ã€‚

**APBæ€»çº¿ä¿¡å·**

| ä¿¡å· | æ–¹å‘ | è¯´æ˜ |
|------|------|------|
| pclk | è¾“å…¥ | æ—¶é’Ÿ |
| preset_n | è¾“å…¥ | å¤ä½ï¼ˆä½æœ‰æ•ˆï¼‰ |
| paddr[31:0] | è¾“å‡º | åœ°å€æ€»çº¿ |
| pwrite | è¾“å‡º | å†™ä½¿èƒ½ï¼ˆ1=å†™,0=è¯»ï¼‰ |
| pwdata[31:0] | è¾“å‡º | å†™æ•°æ® |
| prdata[31:0] | è¾“å…¥ | è¯»æ•°æ® |
| psel | è¾“å‡º | ä»æœºé€‰æ‹©ï¼ˆé«˜æœ‰æ•ˆï¼‰ |
| penable | è¾“å‡º | ä½¿èƒ½ä¿¡å·ï¼ˆé«˜æœ‰æ•ˆï¼‰ |
| pready | è¾“å…¥ | ä»æœºå°±ç»ªï¼ˆé«˜æœ‰æ•ˆï¼‰ |

**æ–‡ä»¶ï¼šsource/apb_slave.v**

```verilog
// APBä»æœºæ¥å£å®ç°

module apb_slave #(
    parameter ADDR_WIDTH = 12,
    parameter DATA_WIDTH = 32,
    parameter NUM_REGS = 16
) (
    input  wire                         pclk,
    input  wire                         preset_n,
    input  wire [ADDR_WIDTH-1:0]        paddr,
    input  wire                         pwrite,
    input  wire [DATA_WIDTH-1:0]        pwdata,
    output wire [DATA_WIDTH-1:0]        prdata,
    input  wire                         psel,
    input  wire                         penable,
    output wire                         pready,
    output wire                         pslverr
);

    reg [NUM_REGS-1:0][DATA_WIDTH-1:0] registers;

    assign pready = 1'b1;
    assign pslverr = 1'b0;

    assign prdata = psel ? registers[paddr[$clog2(NUM_REGS)-1:0]] : {DATA_WIDTH{1'b0}};

    always @(posedge pclk or negedge preset_n) begin
        if (!preset_n) begin
            registers <= '{default:0};
        end else if (psel && penable && pwrite) begin
            registers[paddr[$clog2(NUM_REGS)-1:0]] <= pwdata;
        end
    end

endmodule
```

### 6.2 è·¨æ—¶é’ŸåŸŸè®¾è®¡

#### è·¨æ—¶é’ŸåŸŸé—®é¢˜

å½“ä¿¡å·ä»ä¸€ä¸ªæ—¶é’ŸåŸŸä¼ é€’åˆ°å¦ä¸€ä¸ªæ—¶é’ŸåŸŸæ—¶,å¯èƒ½ä¼šå‡ºç°äºšç¨³æ€ã€æ•°æ®ä¸¢å¤±ç­‰é—®é¢˜ã€‚

**å¸¸è§é—®é¢˜ï¼š**
1. **äºšç¨³æ€**ï¼šè§¦å‘å™¨çš„å»ºç«‹æ—¶é—´å’Œä¿æŒæ—¶é—´ä¸æ»¡è¶³
2. **æ•°æ®ä¸¢å¤±**ï¼šå¿«æ—¶é’ŸåŸŸåˆ°æ…¢æ—¶é’ŸåŸŸçš„æ•°æ®ä¼ é€’
3. **æ•°æ®ç›¸å…³æ€§**ï¼šå¤šä½æ•°æ®çš„ä¸€è‡´æ€§

#### è§£å†³æ–¹æ¡ˆ

**1. å•bitä¿¡å·åŒæ­¥ï¼ˆåŒå¯„å­˜å™¨åŒæ­¥ï¼‰**

```verilog
module sync_2ff (
    input  wire clk_dst,
    input  wire rst_n,
    input  wire signal_in,
    output wire signal_out
);

    reg sync_ff1, sync_ff2;

    always @(posedge clk_dst or negedge rst_n) begin
        if (!rst_n) begin
            sync_ff1 <= 1'b0;
            sync_ff2 <= 1'b0;
        end else begin
            sync_ff1 <= signal_in;
            sync_ff2 <= sync_ff1;
        end
    end

    assign signal_out = sync_ff2;

endmodule
```

**2. å¤šbitä¿¡å·åŒæ­¥ï¼ˆGrayç è½¬æ¢ï¼‰**

```verilog
// äºŒè¿›åˆ¶è½¬Grayç 
module bin2gray #(parameter WIDTH = 4) (
    input  wire [WIDTH-1:0] bin,
    output wire [WIDTH-1:0] gray
);

    assign gray = bin ^ (bin >> 1);

endmodule

// Grayç è½¬äºŒè¿›åˆ¶
module gray2bin #(parameter WIDTH = 4) (
    input  wire [WIDTH-1:0] gray,
    output wire [WIDTH-1:0] bin
);

    genvar i;
    generate
        for (i = 0; i < WIDTH; i = i + 1) begin : gray_decode
            assign bin[i] = ^(gray >> i);
        end
    endgenerate

endmodule
```

**3. å¼‚æ­¥FIFO**

å¼‚æ­¥FIFOæ˜¯è§£å†³è·¨æ—¶é’ŸåŸŸæ•°æ®ä¼ è¾“çš„ç»å…¸æ–¹æ¡ˆã€‚

```verilog
module async_fifo #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 4
) (
    // å†™æ—¶é’ŸåŸŸ
    input  wire                     wr_clk,
    input  wire                     wr_rst_n,
    input  wire                     wr_en,
    input  wire [DATA_WIDTH-1:0]    wr_data,
    output wire                     wr_full,

    // è¯»æ—¶é’ŸåŸŸ
    input  wire                     rd_clk,
    input  wire                     rd_rst_n,
    input  wire                     rd_en,
    output wire [DATA_WIDTH-1:0]    rd_data,
    output wire                     rd_empty
);

    localparam DEPTH = 1 << ADDR_WIDTH;

    // åŒå£RAM
    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];

    // è¯»å†™æŒ‡é’ˆï¼ˆGrayç ï¼‰
    reg [ADDR_WIDTH:0] wr_ptr_gray, rd_ptr_gray;
    reg [ADDR_WIDTH:0] wr_ptr_bin, rd_ptr_bin;

    // åŒæ­¥åçš„æŒ‡é’ˆ
    reg [ADDR_WIDTH:0] wr_ptr_gray_sync1, wr_ptr_gray_sync2;
    reg [ADDR_WIDTH:0] rd_ptr_gray_sync1, rd_ptr_gray_sync2;

    // å†™æ“ä½œ
    always @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n)
            wr_ptr_bin <= 0;
        else if (wr_en && !wr_full) begin
            mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= wr_data;
            wr_ptr_bin <= wr_ptr_bin + 1;
        end
    end

    // è¯»æ“ä½œ
    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n)
            rd_ptr_bin <= 0;
        else if (rd_en && !rd_empty)
            rd_ptr_bin <= rd_ptr_bin + 1;
    end

    assign rd_data = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];

    // äºŒè¿›åˆ¶è½¬Grayç 
    always @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n)
            wr_ptr_gray <= 0;
        else
            wr_ptr_gray <= wr_ptr_bin ^ (wr_ptr_bin >> 1);
    end

    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n)
            rd_ptr_gray <= 0;
        else
            rd_ptr_gray <= rd_ptr_bin ^ (rd_ptr_bin >> 1);
    end

    // åŒæ­¥å†™æŒ‡é’ˆåˆ°è¯»æ—¶é’ŸåŸŸ
    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            wr_ptr_gray_sync1 <= 0;
            wr_ptr_gray_sync2 <= 0;
        end else begin
            wr_ptr_gray_sync1 <= wr_ptr_gray;
            wr_ptr_gray_sync2 <= wr_ptr_gray_sync1;
        end
    end

    // åŒæ­¥è¯»æŒ‡é’ˆåˆ°å†™æ—¶é’ŸåŸŸ
    always @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n) begin
            rd_ptr_gray_sync1 <= 0;
            rd_ptr_gray_sync2 <= 0;
        end else begin
            rd_ptr_gray_sync1 <= rd_ptr_gray;
            rd_ptr_gray_sync2 <= rd_ptr_gray_sync1;
        end
    end

    // ç©ºæ»¡æ ‡å¿—
    assign wr_full = (wr_ptr_gray == {~rd_ptr_gray_sync2[ADDR_WIDTH:ADDR_WIDTH-1],
                                      rd_ptr_gray_sync2[ADDR_WIDTH-2:0]});
    assign rd_empty = (rd_ptr_gray == wr_ptr_gray_sync2);

endmodule
```

---

## æ¨¡å—ä¸ƒï¼šæ•°å­—ç³»ç»Ÿè®¾è®¡è¿›é˜¶

### 7.1 æµæ°´çº¿è®¾è®¡æŠ€æœ¯

#### æµæ°´çº¿çš„åŸºæœ¬æ¦‚å¿µ

æµæ°´çº¿æ˜¯æé«˜æ•°å­—ç³»ç»Ÿååé‡çš„é‡è¦æŠ€æœ¯ã€‚é€šè¿‡å°†å¤æ‚æ“ä½œåˆ†è§£ä¸ºå¤šä¸ªé˜¶æ®µ,æ¯ä¸ªé˜¶æ®µåœ¨ä¸åŒæ—¶é’Ÿå‘¨æœŸæ‰§è¡Œ,å¯ä»¥æ˜¾è‘—æé«˜ç³»ç»Ÿæ€§èƒ½ã€‚

**æµæ°´çº¿çš„å…³é”®æŒ‡æ ‡ï¼š**

| æŒ‡æ ‡ | å®šä¹‰ | è®¡ç®—æ–¹æ³• |
|------|------|---------|
| **ååé‡** | å•ä½æ—¶é—´å†…å®Œæˆçš„æ“ä½œæ•° | 1 / æ—¶é’Ÿå‘¨æœŸ |
| **å»¶è¿Ÿ** | å•ä¸ªæ“ä½œå®Œæˆæ‰€éœ€æ—¶é—´ | æµæ°´çº¿çº§æ•° Ã— æ—¶é’Ÿå‘¨æœŸ |
| **åŠ é€Ÿæ¯”** | ç›¸å¯¹äºéæµæ°´çº¿çš„æ€§èƒ½æå‡ | ç†æƒ³æƒ…å†µä¸‹ç­‰äºæµæ°´çº¿çº§æ•° |

#### å®æˆ˜ï¼šæµæ°´çº¿ä¹˜æ³•å™¨

**æ–‡ä»¶ï¼šsource/pipeline_multiplier.v**

```verilog
// æµæ°´çº¿ä¹˜æ³•å™¨ï¼ˆ3çº§æµæ°´çº¿ï¼‰

module pipeline_multiplier #(
    parameter WIDTH = 8
) (
    input  wire                     clk,
    input  wire                     rst_n,
    input  wire [WIDTH-1:0]         a_in,
    input  wire [WIDTH-1:0]         b_in,
    input  wire                     valid_in,
    output reg  [2*WIDTH-1:0]       result,
    output reg                      valid_out
);

    // æµæ°´çº¿é˜¶æ®µ1ï¼šè¾“å…¥å¯„å­˜
    reg [WIDTH-1:0] a_stage1, b_stage1;
    reg valid_stage1;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            a_stage1 <= 0;
            b_stage1 <= 0;
            valid_stage1 <= 0;
        end else begin
            a_stage1 <= a_in;
            b_stage1 <= b_in;
            valid_stage1 <= valid_in;
        end
    end

    // æµæ°´çº¿é˜¶æ®µ2ï¼šéƒ¨åˆ†ç§¯è®¡ç®—
    reg [2*WIDTH-1:0] partial_product;
    reg valid_stage2;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            partial_product <= 0;
            valid_stage2 <= 0;
        end else begin
            partial_product <= a_stage1 * b_stage1;
            valid_stage2 <= valid_stage1;
        end
    end

    // æµæ°´çº¿é˜¶æ®µ3ï¼šç»“æœè¾“å‡º
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            result <= 0;
            valid_out <= 0;
        end else begin
            result <= partial_product;
            valid_out <= valid_stage2;
        end
    end

endmodule
```

### 7.2 å†…å­˜è®¾è®¡

#### å•å£RAM

```verilog
module single_port_ram #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 10
) (
    input  wire                     clk,
    input  wire                     we,
    input  wire [ADDR_WIDTH-1:0]    addr,
    input  wire [DATA_WIDTH-1:0]    din,
    output reg  [DATA_WIDTH-1:0]    dout
);

    localparam DEPTH = 1 << ADDR_WIDTH;
    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];

    always @(posedge clk) begin
        if (we)
            mem[addr] <= din;
        dout <= mem[addr];
    end

endmodule
```

#### åŒå£RAM

```verilog
module dual_port_ram #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 10
) (
    input  wire                     clk,

    // ç«¯å£A
    input  wire                     we_a,
    input  wire [ADDR_WIDTH-1:0]    addr_a,
    input  wire [DATA_WIDTH-1:0]    din_a,
    output reg  [DATA_WIDTH-1:0]    dout_a,

    // ç«¯å£B
    input  wire                     we_b,
    input  wire [ADDR_WIDTH-1:0]    addr_b,
    input  wire [DATA_WIDTH-1:0]    din_b,
    output reg  [DATA_WIDTH-1:0]    dout_b
);

    localparam DEPTH = 1 << ADDR_WIDTH;
    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];

    // ç«¯å£Aæ“ä½œ
    always @(posedge clk) begin
        if (we_a)
            mem[addr_a] <= din_a;
        dout_a <= mem[addr_a];
    end

    // ç«¯å£Bæ“ä½œ
    always @(posedge clk) begin
        if (we_b)
            mem[addr_b] <= din_b;
        dout_b <= mem[addr_b];
    end

endmodule
```

### 7.3 UARTé€šä¿¡åè®®å®ç°

UARTï¼ˆUniversal Asynchronous Receiver/Transmitterï¼‰æ˜¯æœ€å¸¸ç”¨çš„ä¸²è¡Œé€šä¿¡åè®®ã€‚

#### UARTåè®®åŸºç¡€

**å¸§æ ¼å¼ï¼š**
```
èµ·å§‹ä½(1bit) + æ•°æ®ä½(5-9bit) + å¥‡å¶æ ¡éªŒä½(å¯é€‰) + åœæ­¢ä½(1-2bit)

æ ‡å‡†é…ç½®ï¼š8N1ï¼ˆ8ä½æ•°æ®,æ— æ ¡éªŒ,1ä½åœæ­¢ä½ï¼‰
```

**æ³¢ç‰¹ç‡ï¼š**
å¸¸è§æ³¢ç‰¹ç‡ï¼š9600, 19200, 38400, 57600, 115200

#### UARTå‘é€å™¨å®ç°

**æ–‡ä»¶ï¼šsource/uart_tx.v**

```verilog
// UARTå‘é€å™¨

module uart_tx #(
    parameter CLK_FREQ = 50_000_000,
    parameter BAUD_RATE = 115200
) (
    input  wire       clk,
    input  wire       rst_n,
    input  wire [7:0] tx_data,
    input  wire       tx_start,
    output reg        tx,
    output wire       tx_busy
);

    localparam BAUD_DIV = CLK_FREQ / BAUD_RATE;
    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    reg [1:0] state;
    reg [$clog2(BAUD_DIV)-1:0] baud_counter;
    reg [2:0] bit_index;
    reg [7:0] tx_shift_reg;

    assign tx_busy = (state != IDLE);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            tx <= 1'b1;
            baud_counter <= 0;
            bit_index <= 0;
            tx_shift_reg <= 0;
        end else begin
            case(state)
                IDLE: begin
                    tx <= 1'b1;
                    if (tx_start) begin
                        tx_shift_reg <= tx_data;
                        state <= START;
                        baud_counter <= 0;
                    end
                end

                START: begin
                    tx <= 1'b0;  // èµ·å§‹ä½
                    if (baud_counter == BAUD_DIV - 1) begin
                        baud_counter <= 0;
                        state <= DATA;
                        bit_index <= 0;
                    end else begin
                        baud_counter <= baud_counter + 1;
                    end
                end

                DATA: begin
                    tx <= tx_shift_reg[bit_index];
                    if (baud_counter == BAUD_DIV - 1) begin
                        baud_counter <= 0;
                        if (bit_index == 7)
                            state <= STOP;
                        else
                            bit_index <= bit_index + 1;
                    end else begin
                        baud_counter <= baud_counter + 1;
                    end
                end

                STOP: begin
                    tx <= 1'b1;  // åœæ­¢ä½
                    if (baud_counter == BAUD_DIV - 1) begin
                        baud_counter <= 0;
                        state <= IDLE;
                    end else begin
                        baud_counter <= baud_counter + 1;
                    end
                end

                default: state <= IDLE;
            endcase
        end
    end

endmodule
```

#### UARTæ¥æ”¶å™¨å®ç°

**æ–‡ä»¶ï¼šsource/uart_rx.v**

```verilog
// UARTæ¥æ”¶å™¨

module uart_rx #(
    parameter CLK_FREQ = 50_000_000,
    parameter BAUD_RATE = 115200
) (
    input  wire       clk,
    input  wire       rst_n,
    input  wire       rx,
    output reg  [7:0] rx_data,
    output reg        rx_valid
);

    localparam BAUD_DIV = CLK_FREQ / BAUD_RATE;
    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    reg [1:0] state;
    reg [$clog2(BAUD_DIV)-1:0] baud_counter;
    reg [2:0] bit_index;
    reg [7:0] rx_shift_reg;
    reg [1:0] rx_sync;

    // RXä¿¡å·åŒæ­¥
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            rx_sync <= 2'b11;
        else
            rx_sync <= {rx_sync[0], rx};
    end

    wire rx_synced = rx_sync[1];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            baud_counter <= 0;
            bit_index <= 0;
            rx_shift_reg <= 0;
            rx_data <= 0;
            rx_valid <= 0;
        end else begin
            rx_valid <= 0;

            case(state)
                IDLE: begin
                    if (rx_synced == 0) begin  // æ£€æµ‹åˆ°èµ·å§‹ä½
                        state <= START;
                        baud_counter <= 0;
                    end
                end

                START: begin
                    if (baud_counter == BAUD_DIV / 2) begin
                        if (rx_synced == 0) begin  // ç¡®è®¤èµ·å§‹ä½
                            state <= DATA;
                            baud_counter <= 0;
                            bit_index <= 0;
                        end else begin
                            state <= IDLE;  // å‡èµ·å§‹ä½
                        end
                    end else begin
                        baud_counter <= baud_counter + 1;
                    end
                end

                DATA: begin
                    if (baud_counter == BAUD_DIV - 1) begin
                        baud_counter <= 0;
                        rx_shift_reg[bit_index] <= rx_synced;
                        if (bit_index == 7)
                            state <= STOP;
                        else
                            bit_index <= bit_index + 1;
                    end else begin
                        baud_counter <= baud_counter + 1;
                    end
                end

                STOP: begin
                    if (baud_counter == BAUD_DIV - 1) begin
                        if (rx_synced == 1) begin  // ç¡®è®¤åœæ­¢ä½
                            rx_data <= rx_shift_reg;
                            rx_valid <= 1;
                        end
                        state <= IDLE;
                    end else begin
                        baud_counter <= baud_counter + 1;
                    end
                end

                default: state <= IDLE;
            endcase
        end
    end

endmodule
```

---

## å­¦ä¹ æˆæœéªŒè¯

### æ£€éªŒæ ‡å‡†

å®Œæˆæœ¬æ¨¡å—å­¦ä¹ å,ä½ åº”è¯¥èƒ½å¤Ÿè¾¾åˆ°ä»¥ä¸‹æ£€éªŒæ ‡å‡†:

#### æ ‡å‡†1ï¼šç†è®ºåŸºç¡€æŒæ¡

**è¯„ä¼°æ–¹å¼**ï¼šé€šè¿‡ä»¥ä¸‹é—®é¢˜çš„å›ç­”

- èƒ½æ­£ç¡®è§£é‡Šå¸ƒå°”ä»£æ•°ä¸­çš„åŸºæœ¬å®šå¾‹,å¹¶è¿ç”¨å…¶åŒ–ç®€é€»è¾‘è¡¨è¾¾å¼
- èƒ½å¤ŸåŒºåˆ†ç»„åˆé€»è¾‘å’Œæ—¶åºé€»è¾‘,è¯´æ˜å®ƒä»¬çš„åº”ç”¨åœºæ™¯
- èƒ½å¤Ÿç†è§£è§¦å‘å™¨çš„å·¥ä½œåŸç†,è¯´æ˜å¼‚æ­¥å’ŒåŒæ­¥çš„åŒºåˆ«
- èƒ½å¤Ÿåˆ†æä¸€ä¸ªä¸­ç­‰å¤æ‚åº¦çš„çŠ¶æ€æœº,æ¨å¯¼å‡ºå…¶æ—¶åºè¡¨

#### æ ‡å‡†2ï¼šHDLç¼–ç¨‹èƒ½åŠ›

**è¯„ä¼°æ–¹å¼**ï¼šå®Œæˆä»¥ä¸‹ç¼–ç¨‹ä»»åŠ¡

- èƒ½ç”¨Verilogæè¿°ç»™å®šçš„ç»„åˆé€»è¾‘ç”µè·¯
- èƒ½ç”¨Verilogè®¾è®¡æ—¶åºé€»è¾‘æ¨¡å—,åŒ…å«æ­£ç¡®çš„æ—¶é’Ÿæ•æ„Ÿæ€§
- èƒ½ç¼–å†™å®Œæ•´çš„Testbenchå¹¶è¿›è¡Œä»¿çœŸ
- èƒ½è¿›è¡Œæ³¢å½¢åˆ†æå¹¶è°ƒè¯•è®¾è®¡

**éªŒè¯é¡¹ç›®**
```
ä»»åŠ¡1ï¼šå®ç°ä¸€ä¸ª4ä½åŠ æ³•å™¨,åŒ…å«å®Œæ•´çš„Testbench
ä»»åŠ¡2ï¼šè®¾è®¡ä¸€ä¸ªè‡ªåŠ¨å”®è´§æœºçš„çŠ¶æ€æœº,æ”¯æŒå¤šç§ç¡¬å¸
ä»»åŠ¡3ï¼šè®¾è®¡ä¸€ä¸ª16Ã—8çš„RAMè¯»å†™æ§åˆ¶å™¨
```

#### æ ‡å‡†3ï¼šå·¥ç¨‹è®¾è®¡èƒ½åŠ›

**è¯„ä¼°æ–¹å¼**ï¼šç‹¬ç«‹å®Œæˆä¸€ä¸ªå®Œæ•´çš„è®¾è®¡é¡¹ç›®

- èƒ½å¤Ÿç†è§£è®¾è®¡è§„æ ¼å¹¶è½¬åŒ–ä¸ºæŠ€æœ¯æ–¹æ¡ˆ
- èƒ½å¤Ÿè¿›è¡Œæ¨¡å—åˆ’åˆ†,æ˜ç¡®æ¨¡å—é—´çš„æ¥å£
- èƒ½å¤Ÿè€ƒè™‘æ—¶åºã€åŠŸè€—ã€é¢ç§¯ç­‰å¤šä¸ªå› ç´ 
- èƒ½å¤Ÿè¿›è¡Œç³»ç»Ÿé›†æˆå’ŒéªŒè¯

#### æ ‡å‡†4ï¼šæ•…éšœè¯Šæ–­èƒ½åŠ›

**è¯„ä¼°æ–¹å¼**ï¼šèƒ½å¤Ÿå¿«é€Ÿå®šä½å’Œè§£å†³è®¾è®¡é—®é¢˜

- èƒ½æ ¹æ®ä»¿çœŸæ³¢å½¢åˆ¤æ–­é—®é¢˜æ‰€åœ¨
- èƒ½ä½¿ç”¨è°ƒè¯•å·¥å…·è¿›è¡Œä¿¡å·è¿½è¸ª
- èƒ½åˆ†ææ—¶åºè¿è§„å¹¶æå‡ºè§£å†³æ–¹æ¡ˆ
- èƒ½å¤„ç†ç»¼åˆå’Œå¸ƒå±€å¸ƒçº¿ä¸­çš„é”™è¯¯

---

## å¸¸è§é—®é¢˜ä¸è°ƒè¯•æŠ€å·§

### Q1ï¼šä»¿çœŸè¿è¡Œåæ— ä»»ä½•è¾“å‡º

**é—®é¢˜åŸå› **
- Testbenchä¸­æ²¡æœ‰ç”ŸæˆVCDæ³¢å½¢æ–‡ä»¶
- ä»¿çœŸæå‰ç»“æŸï¼ˆ$finishè¢«æå‰è°ƒç”¨ï¼‰
- æ¨¡å—æ²¡æœ‰æ­£ç¡®å®ä¾‹åŒ–

**è§£å†³æ–¹æ¡ˆ**
```verilog
initial begin
    $dumpfile("waveform.vcd");
    $dumpvars(0, testbench_name);

    // æµ‹è¯•æ¿€åŠ±
    ...

    #1000;
    $finish;
end
```

### Q2ï¼šå¤ä½ä¿¡å·ä¸èµ·ä½œç”¨

**è§£å†³æ–¹æ¡ˆ**
```verilog
always @(posedge clk or negedge reset_n) begin
    if (!reset_n) begin
        register <= 8'h00;
        state <= IDLE;
    end else begin
        // æ­£å¸¸æ“ä½œ
    end
end
```

### Q3ï¼šæ—¶åºä¸æ»¡è¶³

**è§£å†³æ–¹æ¡ˆ**
```tcl
# æŸ¥çœ‹å…³é”®è·¯å¾„
report_timing -delay_type max

# ä½¿ç”¨ç®¡é“æŠ€æœ¯
# åœ¨é«˜é¢‘è·¯å¾„ä¸Šæ·»åŠ å¯„å­˜å™¨
```

### Q4ï¼šç»¼åˆå¤±è´¥

**æ£€æŸ¥æ¸…å•**
```verilog
// å¯ç»¼åˆ
always @(posedge clk) begin
    // åªæœ‰åŒæ­¥æ“ä½œ
    // æ˜ç¡®çš„çŠ¶æ€è½¬ç§»
end
```

---

## æ‰©å±•èµ„æºä¸è¿›é˜¶å»ºè®®

### æ¨èå­¦ä¹ èµ„æº

#### å‚è€ƒä¹¦ç±

1. **ã€ŠVerilog HDL é«˜çº§æ•°å­—è®¾è®¡ã€‹** - Michael D. Ciletti
2. **ã€Šæ•°å­—é›†æˆç”µè·¯ - ç”µè·¯ã€é€»è¾‘å’Œè®¾è®¡ã€‹** - Rabaey & Chandrakasan
3. **ã€ŠFPGAè®¾è®¡å®æˆ˜ã€‹** - åˆ˜å† æ­¦
4. **ã€ŠThe Art of FPGA Designã€‹** - Ken Coffman

#### å¼€æºå·¥å…·å’Œé¡¹ç›®

1. **å¼€æºFPGAå·¥å…·é“¾**
   ```bash
   git clone https://github.com/YosysHQ/yosys.git
   git clone https://github.com/YosysHQ/nextpnr.git
   ```

2. **Verilogæ¨¡æ‹Ÿå™¨**
   ```bash
   sudo apt-get install iverilog gtkwave
   ```

3. **å­¦ä¹ é¡¹ç›®**
   - **CV32E40P** (RISC-Vå¤„ç†å™¨)
   - **OpenTitan** (å®‰å…¨èŠ¯ç‰‡)
   - **LiteX** - æ„å»ºå®šåˆ¶SoCçš„æ¡†æ¶

### è¿›é˜¶å­¦ä¹ è·¯å¾„

#### ç¬¬ä¸€é˜¶æ®µï¼šç³»ç»Ÿçº§è®¾è®¡ï¼ˆ3-6ä¸ªæœˆï¼‰

**å­¦ä¹ å†…å®¹**
- å¾®æ¶æ„è®¾è®¡ï¼ˆæŒ‡ä»¤é›†ã€æµæ°´çº¿ã€ç¼“å­˜ï¼‰
- ç³»ç»Ÿçº§æ€»çº¿è®¾è®¡ï¼ˆAXI, Wishboneï¼‰
- å†…å­˜å­ç³»ç»Ÿè®¾è®¡
- äº’è¿ç½‘ç»œ

#### ç¬¬äºŒé˜¶æ®µï¼šç¡¬ä»¶è®¾è®¡æµç¨‹ï¼ˆ3-6ä¸ªæœˆï¼‰

**å­¦ä¹ å†…å®¹**
- RTLç»¼åˆä¼˜åŒ–æŠ€æœ¯
- é™æ€æ—¶åºåˆ†æï¼ˆSTAï¼‰
- åŠŸè€—åˆ†æå’Œä¼˜åŒ–
- å½¢å¼åŒ–éªŒè¯åŸºç¡€

#### ç¬¬ä¸‰é˜¶æ®µï¼šèŠ¯ç‰‡è®¾è®¡ï¼ˆ6-12ä¸ªæœˆï¼‰

**å­¦ä¹ å†…å®¹**
- ç‰©ç†è®¾è®¡ï¼ˆLayoutï¼‰
- æ—¶é’Ÿæ ‘ç»¼åˆï¼ˆCTSï¼‰
- åŠŸè€—å®Œæ•´æ€§ï¼ˆPIï¼‰åˆ†æ
- ç”µç£å…¼å®¹æ€§ï¼ˆEMCï¼‰è€ƒè™‘
- æµç‰‡å‰çš„å®Œæ•´éªŒè¯

---

## æ€»ç»“ä¸åç»­è¡ŒåŠ¨

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **æ•°å­—ç”µè·¯æ˜¯è®¡ç®—æœºçš„åŸºç¡€**
   - ä»é€»è¾‘é—¨åˆ°å¤æ‚ç³»ç»Ÿçš„é€’è¿›è¿‡ç¨‹
   - ç†è®ºä¸å®è·µç›¸ç»“åˆçš„é‡è¦æ€§

2. **ç³»ç»ŸåŒ–å­¦ä¹ çš„é‡è¦æ€§**
   - ä»åŸºç¡€ç†è®ºåˆ°å·¥ç¨‹å®è·µ
   - å¾ªåºæ¸è¿›åœ°æŒæ¡æ¯ä¸ªæ¨¡å—

3. **åŠ¨æ‰‹å®è·µä¸å¯æ›¿ä»£**
   - é€šè¿‡ç¼–å†™Verilogä»£ç åŠ æ·±ç†è§£
   - é€šè¿‡ä»¿çœŸå’Œç¡¬ä»¶éªŒè¯æŒæ¡è®¾è®¡

4. **æŒç»­ä¼˜åŒ–çš„è®¾è®¡ç†å¿µ**
   - æ€§èƒ½ã€åŠŸè€—ã€é¢ç§¯çš„æƒè¡¡
   - éµå¾ªè®¾è®¡æœ€ä½³å®è·µ

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨è®¡åˆ’

**ç¬¬1-2å‘¨ï¼šå·©å›ºåŸºç¡€**
- [ ] å®Œæˆæ‰€æœ‰æ¨¡å—çš„ç†è®ºå­¦ä¹ 
- [ ] è¿è¡Œæ‰€æœ‰æä¾›çš„ä»£ç ç¤ºä¾‹
- [ ] å°è¯•ä¿®æ”¹ä»£ç å‚æ•°è§‚å¯Ÿç»“æœ

**ç¬¬3-4å‘¨ï¼šåŠ¨æ‰‹å®è·µ**
- [ ] è®¾è®¡3ä¸ªç‹¬ç«‹çš„å°é¡¹ç›®
- [ ] ç¼–å†™å®Œæ•´çš„Testbench
- [ ] å­¦ä¼šä½¿ç”¨è°ƒè¯•å·¥å…·

**ç¬¬5-8å‘¨ï¼šæ·±åŒ–ç†è§£**
- [ ] å®Œæˆç»¼åˆè®¾è®¡é¡¹ç›®
- [ ] å­¦ä¹ FPGAè®¾è®¡æµç¨‹
- [ ] ç ”ç©¶ä¼˜åŒ–æŠ€æœ¯

**ç¬¬9-12å‘¨ï¼šç³»ç»Ÿé›†æˆ**
- [ ] å®Œæˆç³»ç»Ÿçº§è®¾è®¡
- [ ] å­¦ä¹ èŠ¯ç‰‡è®¾è®¡åŸºç¡€
- [ ] å‚åŠ å®é™…é¡¹ç›®

ç¥ä½ å­¦ä¹ è¿›æ­¥,æ—©æ—¥æˆä¸ºæ•°å­—ç”µè·¯è®¾è®¡çš„é«˜æ‰‹ï¼
